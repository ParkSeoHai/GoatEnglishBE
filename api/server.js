// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);

// node_modules/lodash/lodash.js
var require_lodash = __commonJS((exports, module) => {
  (function() {
    var undefined2;
    var VERSION = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined2 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined2 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index = -1, length = array.length;
      while (++index < length) {
        var current = iteratee(array[index]);
        if (current !== undefined2) {
          result = result === undefined2 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1, length = strSymbols.length;
      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;
      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object, key) {
      return object == null ? undefined2 : object[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
      var data, result = [];
      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index = -1, length = array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    function setToPairs(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index = fromIndex + 1;
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return index;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext(context) {
      context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
      var { Array: Array2, Date: Date2, Error: Error2, Function: Function2, Math: Math2, Object: Object2, RegExp: RegExp2, String: String2, TypeError: TypeError2 } = context;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root._;
      var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
      var defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
      var { ceil: nativeCeil, floor: nativeFloor } = Math2, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2;
      var realNames = {};
      var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
      function lodash(value) {
        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result2 = new object;
          object.prototype = undefined2;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined2;
      }
      lodash.templateSettings = {
        escape: reEscape,
        evaluate: reEvaluate,
        interpolate: reInterpolate,
        variable: "",
        imports: {
          _: lodash
        }
      };
      lodash.prototype = baseLodash.prototype;
      lodash.prototype.constructor = lodash;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1, value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED ? undefined2 : result2;
        }
        return hasOwnProperty.call(data, key) ? data[key] : undefined2;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? undefined2 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          hash: new Hash,
          map: new (Map2 || ListCache),
          string: new Hash
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache;
        while (++index < length) {
          this.add(values2[index]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache;
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result2 = data["delete"](key);
        this.size = data.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined2;
      }
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index < length) {
          result2[index] = skip ? undefined2 : get(object, paths[index]);
        }
        return result2;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined2) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined2) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result2 !== undefined2) {
          return result2;
        }
        if (!isObject(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack);
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? undefined2 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source[key], value = object[key];
          if (value === undefined2 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined2, args);
        }, wait);
      }
      function baseDifference(array, values2, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index, collection2) {
          result2 = !!predicate(value, index, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator) {
        var index = -1, length = array.length;
        while (++index < length) {
          var value = array[index], current = iteratee2(value);
          if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
            var computed = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array, value, start, end) {
        var length = array.length;
        start = toInteger(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined2 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array[start++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index, collection2) {
          if (predicate(value, index, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction(object[key]);
        });
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : undefined2;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined2 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number, start, end) {
        return number >= nativeMin(start, end) && number < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
        }
        array = arrays[0];
        var index = -1, seen = caches[0];
        outer:
          while (++index < length && result2.length < maxLength) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last(path))];
        return func == null ? undefined2 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack);
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack);
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack);
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined2 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack;
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result2[++index] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack);
          if (isObject(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
            if (newValue === undefined2) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
        var isCommon = newValue === undefined2;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n) {
        var length = array.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array[n] : undefined2;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { criteria, index: ++index, value };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index = -1, length = paths.length, result2 = {};
        while (++index < length) {
          var path = paths[index], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result2, castPath(path, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
        if (array === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index < length) {
          var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index = indexes[length];
          if (length == lastIndex || index !== previous) {
            var previous = index;
            if (isIndex(index)) {
              splice.call(array, index, 1);
            } else {
              baseUnset(array, index);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index] = start;
          start += step;
        }
        return result2;
      }
      function baseRepeat(string, n) {
        var result2 = "";
        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n % 2) {
            result2 += string;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string += string;
          }
        } while (n);
        return result2;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject(object)) {
          return object;
        }
        path = castPath(path, object);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined2;
            if (newValue === undefined2) {
              newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          configurable: true,
          enumerable: false,
          value: constant(string),
          writable: true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array2(length);
        while (++index < length) {
          result2[index] = array[index + start];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index, collection2) {
          result2 = predicate(value, index, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array[mid];
            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value : computed < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
          if (!index || !eq(computed, seen)) {
            var seen = computed;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set2 = iteratee2 ? null : createSet(array);
          if (set2) {
            return setToArray(set2);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache;
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result2.push(value);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result2) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index = -1, result2 = Array2(length);
        while (++index < length) {
          var array = arrays[index], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index) {
              result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index = -1, length = props.length, valsLength = values2.length, result2 = {};
        while (++index < length) {
          var value = index < valsLength ? values2[index] : undefined2;
          assignFunc(result2, props[index], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function castPath(value, object) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString(value));
      }
      var castRest = baseRest;
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === undefined2 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root.clearTimeout(id);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index < length) {
          var result2 = compareAscending(objCriteria[index], othCriteria[index]);
          if (result2) {
            if (index >= ordersLength) {
              return result2;
            }
            var order = orders[index];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array2(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
          if (newValue === undefined2) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined2 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee2(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor;
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
          while (index--) {
            args[index] = arguments[index];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined2, args, holders, undefined2, undefined2, arity - length);
          }
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index--) {
            var func = funcs[index];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index = wrapper ? index : length;
          while (++index < length) {
            func = funcs[index];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray(value)) {
              return wrapper.plant(value).value();
            }
            var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
            while (++index2 < length) {
              result2 = funcs[index2].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length;
          while (index--) {
            args[index] = arguments[index];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined2 && other === undefined2) {
            return defaultValue;
          }
          if (value !== undefined2) {
            result2 = value;
          }
          if (other !== undefined2) {
            if (result2 === undefined2) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined2 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined2;
          }
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined2, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber(number);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined2;
        }
        ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined2 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined2;
        }
        var data = isBindKey ? undefined2 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined2, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject(objValue) && isObject(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject(value) ? undefined2 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache : undefined2;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== undefined2) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && (("constructor" in object) && ("constructor" in other)) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined2, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data = array[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object) {
        var result2 = keys(object), length = result2.length;
        while (length--) {
          var key = result2[length], value = object[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined2;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined2;
          var unmasked = true;
        } catch (e) {
        }
        var result2 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2) != setTag || WeakMap2 && getTag(new WeakMap2) != weakMapTag) {
        getTag = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start, end, transforms) {
        var index = -1, length = transforms.length;
        while (++index < length) {
          var data = transforms[index], size2 = data.size;
          switch (data.type) {
            case "drop":
              start += size2;
              break;
            case "dropRight":
              end -= size2;
              break;
            case "take":
              end = nativeMin(end, start + size2);
              break;
            case "takeRight":
              start = nativeMax(start, end - size2);
              break;
          }
        }
        return { start, end };
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index = -1, length = path.length, result2 = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor;
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor;
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject(object)) {
          return false;
        }
        var type = typeof index;
        if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && (index in object)) {
          return eq(object[index], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined2 || (key in Object2(object)));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result2.cache;
        return result2;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start, transform2) {
        start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array2(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform2(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index = indexes[length];
          array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
        }
        return array;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined2, arguments);
        };
      }
      function shuffleSelf(array, size2) {
        var index = -1, length = array.length, lastIndex = length - 1;
        size2 = size2 === undefined2 ? length : size2;
        while (++index < size2) {
          var rand = baseRandom(index, lastIndex), value = array[rand];
          array[rand] = array[index];
          array[index] = value;
        }
        array.length = size2;
        return array;
      }
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array, size2, guard) {
        if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
          size2 = 1;
        } else {
          size2 = nativeMax(toInteger(size2), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
        while (index < length) {
          result2[resIndex++] = baseSlice(array, index, index += size2);
        }
        return result2;
      }
      function compact(array) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index = length;
        while (index--) {
          args[index - 1] = arguments[index];
        }
        return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined2;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
      });
      function drop(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function dropRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array, value, start, end);
      }
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== undefined2) {
          index = toInteger(fromIndex);
          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined2 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index < length) {
          var pair = pairs[index];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined2;
      }
      function indexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseIndexOf(array, value, index);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined2;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
      });
      function join(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined2;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length;
        if (fromIndex !== undefined2) {
          index = toInteger(fromIndex);
          index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
      }
      function nth(array, n) {
        return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index) {
          return isIndex(index, length) ? +index : index;
        }).sort(compareAscending));
        return result2;
      });
      function remove(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result2.push(value);
            indexes.push(index);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice(array, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger(start);
          end = end === undefined2 ? length : toInteger(end);
        }
        return baseSlice(array, start, end);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value);
          if (index < length && eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take(array, n, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function takeRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return array && array.length ? baseUniq(array, undefined2, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index) {
          return arrayMap(array, baseProperty(index));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, undefined2, group);
        });
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({
          func: thru,
          args: [interceptor],
          thisArg: undefined2
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined2);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined2) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
        return { done, value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone2 = wrapperClone(parent2);
          clone2.__index__ = 0;
          clone2.__values__ = undefined2;
          if (result2) {
            previous.__wrapped__ = clone2;
          } else {
            result2 = clone2;
          }
          var previous = clone2;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            func: thru,
            args: [reverse],
            thisArg: undefined2
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined2;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined2 ? 1 : toInteger(depth);
        return baseFlatten(map(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue(result2, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map(collection, iteratee2) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined2 : orders;
        if (!isArray(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n, guard) {
        if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        var func = isArray(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      function shuffle(collection) {
        var func = isArray(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined2;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n, guard) {
        n = guard ? undefined2 : n;
        n = func && n == null ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
      }
      function before(n, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined2;
          }
          return result2;
        };
      }
      var bind = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined2 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined2 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time2) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined2;
          lastInvokeTime = time2;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time2) {
          lastInvokeTime = time2;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time2) : result2;
        }
        function remainingWait(time2) {
          var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time2) {
          var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
          return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time2 = now();
          if (shouldInvoke(time2)) {
            return trailingEdge(time2);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time2));
        }
        function trailingEdge(time2) {
          timerId = undefined2;
          if (trailing && lastArgs) {
            return invokeFunc(time2);
          }
          lastArgs = lastThis = undefined2;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined2) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined2;
        }
        function flush() {
          return timerId === undefined2 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time2 = now(), isInvoking = shouldInvoke(time2);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time2;
          if (isInvoking) {
            if (timerId === undefined2) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined2) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache.set(key, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache);
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index = -1, length = nativeMin(args.length, funcsLength);
          while (++index < length) {
            args[index] = transforms[index].call(this, args[index]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined2 ? start : toInteger(start);
        return baseRest(func, start);
      }
      function spread(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger(start), 0);
        return baseRest(function(args) {
          var array = args[start], otherArgs = castSlice(args, 0, start);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          leading,
          maxWait: wait,
          trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray(value) ? value : [value];
      }
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys(source));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray = Array2.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isBoolean(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
      }
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        var result2 = customizer ? customizer(value, other) : undefined2;
        return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString(value) {
        return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value) {
        return value === undefined2;
      }
      function isWeakMap(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys(source), object, customizer);
      });
      var at = flatRest(baseAt);
      function create(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults = baseRest(function(object, sources) {
        object = Object2(object);
        var index = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined2;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined2, customDefaultsMerge);
        return apply(mergeWith, undefined2, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get(object, path, defaultValue) {
        var result2 = object == null ? undefined2 : baseGet(object, path);
        return result2 === undefined2 ? defaultValue : result2;
      }
      function has(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result2[value] = key;
      }, constant(identity));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, iteratee2(value, key, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, key, iteratee2(value, key, object2));
        });
        return result2;
      }
      var merge = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index = -1, length = path.length;
        if (!length) {
          length = 1;
          object = undefined2;
        }
        while (++index < length) {
          var value = object == null ? undefined2 : object[toKey(path[index])];
          if (value === undefined2) {
            index = length;
            value = defaultValue;
          }
          object = isFunction(value) ? value.call(object) : value;
        }
        return object;
      }
      function set(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return object == null ? object : baseSet(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform(object, iteratee2, accumulator) {
        var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor : [];
          } else if (isObject(object)) {
            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
          return iteratee2(accumulator, value, index, object2);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp(number, lower, upper) {
        if (upper === undefined2) {
          upper = lower;
          lower = undefined2;
        }
        if (upper !== undefined2) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined2) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number), lower, upper);
      }
      function inRange(number, start, end) {
        start = toFinite(start);
        if (end === undefined2) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number = toNumber(number);
        return baseInRange(number, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined2;
        }
        if (floating === undefined2) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined2;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined2;
          }
        }
        if (lower === undefined2 && upper === undefined2) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined2) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index) {
        word = word.toLowerCase();
        return result2 + (index ? capitalize(word) : word);
      });
      function capitalize(string) {
        return upperFirst(toString(string).toLowerCase());
      }
      function deburr(string) {
        string = toString(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target, position) {
        string = toString(string);
        target = baseToString(target);
        var length = string.length;
        position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end) == target;
      }
      function escape(string) {
        string = toString(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string, n, guard) {
        if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        return baseRepeat(toString(string), n);
      }
      function replace() {
        var args = arguments, string = toString(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined2;
        }
        limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position) {
        string = toString(string);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }
      function template(string, options, guard) {
        var settings = lodash.templateSettings;
        if (guard && isIterateeCall(string, options, guard)) {
          options = undefined2;
        }
        string = toString(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index = offset + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString(value).toLowerCase();
      }
      function toUpper(value) {
        return toString(value).toUpperCase();
      }
      function trim(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined2)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined2)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined2)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string = toString(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (separator === undefined2) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp(separator)) {
          if (string.slice(end).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end) != end) {
          var index = result2.lastIndexOf(separator);
          if (index > -1) {
            result2 = result2.slice(0, index);
          }
        }
        return result2 + omission;
      }
      function unescape(string) {
        string = toString(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString(string);
        pattern = guard ? undefined2 : pattern;
        if (pattern === undefined2) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined2, args);
        } catch (e) {
          return isError(e) ? e : new Error2(e);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index = -1;
          while (++index < length) {
            var pair = pairs[index];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source, options) {
        var props = keys(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain2 = !(isObject(options) && ("chain" in options)) || !!options.chain, isFunc = isFunction(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({ func, args: arguments, thisArg: object });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop() {
      }
      function nthArg(n) {
        n = toInteger(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined2 : baseGet(object, path);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n, iteratee2) {
        n = toInteger(n);
        if (n < 1 || n > MAX_SAFE_INTEGER) {
          return [];
        }
        var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index < n) {
          iteratee2(index);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString(prefix) + id;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
      }
      function mean(array) {
        return baseMean(array, identity);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash.after = after;
      lodash.ary = ary;
      lodash.assign = assign;
      lodash.assignIn = assignIn;
      lodash.assignInWith = assignInWith;
      lodash.assignWith = assignWith;
      lodash.at = at;
      lodash.before = before;
      lodash.bind = bind;
      lodash.bindAll = bindAll;
      lodash.bindKey = bindKey;
      lodash.castArray = castArray;
      lodash.chain = chain;
      lodash.chunk = chunk;
      lodash.compact = compact;
      lodash.concat = concat;
      lodash.cond = cond;
      lodash.conforms = conforms;
      lodash.constant = constant;
      lodash.countBy = countBy;
      lodash.create = create;
      lodash.curry = curry;
      lodash.curryRight = curryRight;
      lodash.debounce = debounce;
      lodash.defaults = defaults;
      lodash.defaultsDeep = defaultsDeep;
      lodash.defer = defer;
      lodash.delay = delay;
      lodash.difference = difference;
      lodash.differenceBy = differenceBy;
      lodash.differenceWith = differenceWith;
      lodash.drop = drop;
      lodash.dropRight = dropRight;
      lodash.dropRightWhile = dropRightWhile;
      lodash.dropWhile = dropWhile;
      lodash.fill = fill;
      lodash.filter = filter;
      lodash.flatMap = flatMap;
      lodash.flatMapDeep = flatMapDeep;
      lodash.flatMapDepth = flatMapDepth;
      lodash.flatten = flatten;
      lodash.flattenDeep = flattenDeep;
      lodash.flattenDepth = flattenDepth;
      lodash.flip = flip;
      lodash.flow = flow;
      lodash.flowRight = flowRight;
      lodash.fromPairs = fromPairs;
      lodash.functions = functions;
      lodash.functionsIn = functionsIn;
      lodash.groupBy = groupBy;
      lodash.initial = initial;
      lodash.intersection = intersection;
      lodash.intersectionBy = intersectionBy;
      lodash.intersectionWith = intersectionWith;
      lodash.invert = invert;
      lodash.invertBy = invertBy;
      lodash.invokeMap = invokeMap;
      lodash.iteratee = iteratee;
      lodash.keyBy = keyBy;
      lodash.keys = keys;
      lodash.keysIn = keysIn;
      lodash.map = map;
      lodash.mapKeys = mapKeys;
      lodash.mapValues = mapValues;
      lodash.matches = matches;
      lodash.matchesProperty = matchesProperty;
      lodash.memoize = memoize;
      lodash.merge = merge;
      lodash.mergeWith = mergeWith;
      lodash.method = method;
      lodash.methodOf = methodOf;
      lodash.mixin = mixin;
      lodash.negate = negate;
      lodash.nthArg = nthArg;
      lodash.omit = omit;
      lodash.omitBy = omitBy;
      lodash.once = once;
      lodash.orderBy = orderBy;
      lodash.over = over;
      lodash.overArgs = overArgs;
      lodash.overEvery = overEvery;
      lodash.overSome = overSome;
      lodash.partial = partial;
      lodash.partialRight = partialRight;
      lodash.partition = partition;
      lodash.pick = pick;
      lodash.pickBy = pickBy;
      lodash.property = property;
      lodash.propertyOf = propertyOf;
      lodash.pull = pull;
      lodash.pullAll = pullAll;
      lodash.pullAllBy = pullAllBy;
      lodash.pullAllWith = pullAllWith;
      lodash.pullAt = pullAt;
      lodash.range = range;
      lodash.rangeRight = rangeRight;
      lodash.rearg = rearg;
      lodash.reject = reject;
      lodash.remove = remove;
      lodash.rest = rest;
      lodash.reverse = reverse;
      lodash.sampleSize = sampleSize;
      lodash.set = set;
      lodash.setWith = setWith;
      lodash.shuffle = shuffle;
      lodash.slice = slice;
      lodash.sortBy = sortBy;
      lodash.sortedUniq = sortedUniq;
      lodash.sortedUniqBy = sortedUniqBy;
      lodash.split = split;
      lodash.spread = spread;
      lodash.tail = tail;
      lodash.take = take;
      lodash.takeRight = takeRight;
      lodash.takeRightWhile = takeRightWhile;
      lodash.takeWhile = takeWhile;
      lodash.tap = tap;
      lodash.throttle = throttle;
      lodash.thru = thru;
      lodash.toArray = toArray;
      lodash.toPairs = toPairs;
      lodash.toPairsIn = toPairsIn;
      lodash.toPath = toPath;
      lodash.toPlainObject = toPlainObject;
      lodash.transform = transform;
      lodash.unary = unary;
      lodash.union = union;
      lodash.unionBy = unionBy;
      lodash.unionWith = unionWith;
      lodash.uniq = uniq;
      lodash.uniqBy = uniqBy;
      lodash.uniqWith = uniqWith;
      lodash.unset = unset;
      lodash.unzip = unzip;
      lodash.unzipWith = unzipWith;
      lodash.update = update;
      lodash.updateWith = updateWith;
      lodash.values = values;
      lodash.valuesIn = valuesIn;
      lodash.without = without;
      lodash.words = words;
      lodash.wrap = wrap;
      lodash.xor = xor;
      lodash.xorBy = xorBy;
      lodash.xorWith = xorWith;
      lodash.zip = zip;
      lodash.zipObject = zipObject;
      lodash.zipObjectDeep = zipObjectDeep;
      lodash.zipWith = zipWith;
      lodash.entries = toPairs;
      lodash.entriesIn = toPairsIn;
      lodash.extend = assignIn;
      lodash.extendWith = assignInWith;
      mixin(lodash, lodash);
      lodash.add = add;
      lodash.attempt = attempt;
      lodash.camelCase = camelCase;
      lodash.capitalize = capitalize;
      lodash.ceil = ceil;
      lodash.clamp = clamp;
      lodash.clone = clone;
      lodash.cloneDeep = cloneDeep;
      lodash.cloneDeepWith = cloneDeepWith;
      lodash.cloneWith = cloneWith;
      lodash.conformsTo = conformsTo;
      lodash.deburr = deburr;
      lodash.defaultTo = defaultTo;
      lodash.divide = divide;
      lodash.endsWith = endsWith;
      lodash.eq = eq;
      lodash.escape = escape;
      lodash.escapeRegExp = escapeRegExp;
      lodash.every = every;
      lodash.find = find;
      lodash.findIndex = findIndex;
      lodash.findKey = findKey;
      lodash.findLast = findLast;
      lodash.findLastIndex = findLastIndex;
      lodash.findLastKey = findLastKey;
      lodash.floor = floor;
      lodash.forEach = forEach;
      lodash.forEachRight = forEachRight;
      lodash.forIn = forIn;
      lodash.forInRight = forInRight;
      lodash.forOwn = forOwn;
      lodash.forOwnRight = forOwnRight;
      lodash.get = get;
      lodash.gt = gt;
      lodash.gte = gte;
      lodash.has = has;
      lodash.hasIn = hasIn;
      lodash.head = head;
      lodash.identity = identity;
      lodash.includes = includes;
      lodash.indexOf = indexOf;
      lodash.inRange = inRange;
      lodash.invoke = invoke;
      lodash.isArguments = isArguments;
      lodash.isArray = isArray;
      lodash.isArrayBuffer = isArrayBuffer;
      lodash.isArrayLike = isArrayLike;
      lodash.isArrayLikeObject = isArrayLikeObject;
      lodash.isBoolean = isBoolean;
      lodash.isBuffer = isBuffer;
      lodash.isDate = isDate;
      lodash.isElement = isElement;
      lodash.isEmpty = isEmpty;
      lodash.isEqual = isEqual;
      lodash.isEqualWith = isEqualWith;
      lodash.isError = isError;
      lodash.isFinite = isFinite2;
      lodash.isFunction = isFunction;
      lodash.isInteger = isInteger;
      lodash.isLength = isLength;
      lodash.isMap = isMap;
      lodash.isMatch = isMatch;
      lodash.isMatchWith = isMatchWith;
      lodash.isNaN = isNaN2;
      lodash.isNative = isNative;
      lodash.isNil = isNil;
      lodash.isNull = isNull;
      lodash.isNumber = isNumber;
      lodash.isObject = isObject;
      lodash.isObjectLike = isObjectLike;
      lodash.isPlainObject = isPlainObject;
      lodash.isRegExp = isRegExp;
      lodash.isSafeInteger = isSafeInteger;
      lodash.isSet = isSet;
      lodash.isString = isString;
      lodash.isSymbol = isSymbol;
      lodash.isTypedArray = isTypedArray;
      lodash.isUndefined = isUndefined;
      lodash.isWeakMap = isWeakMap;
      lodash.isWeakSet = isWeakSet;
      lodash.join = join;
      lodash.kebabCase = kebabCase;
      lodash.last = last;
      lodash.lastIndexOf = lastIndexOf;
      lodash.lowerCase = lowerCase;
      lodash.lowerFirst = lowerFirst;
      lodash.lt = lt;
      lodash.lte = lte;
      lodash.max = max;
      lodash.maxBy = maxBy;
      lodash.mean = mean;
      lodash.meanBy = meanBy;
      lodash.min = min;
      lodash.minBy = minBy;
      lodash.stubArray = stubArray;
      lodash.stubFalse = stubFalse;
      lodash.stubObject = stubObject;
      lodash.stubString = stubString;
      lodash.stubTrue = stubTrue;
      lodash.multiply = multiply;
      lodash.nth = nth;
      lodash.noConflict = noConflict;
      lodash.noop = noop;
      lodash.now = now;
      lodash.pad = pad;
      lodash.padEnd = padEnd;
      lodash.padStart = padStart;
      lodash.parseInt = parseInt2;
      lodash.random = random;
      lodash.reduce = reduce;
      lodash.reduceRight = reduceRight;
      lodash.repeat = repeat;
      lodash.replace = replace;
      lodash.result = result;
      lodash.round = round;
      lodash.runInContext = runInContext;
      lodash.sample = sample;
      lodash.size = size;
      lodash.snakeCase = snakeCase;
      lodash.some = some;
      lodash.sortedIndex = sortedIndex;
      lodash.sortedIndexBy = sortedIndexBy;
      lodash.sortedIndexOf = sortedIndexOf;
      lodash.sortedLastIndex = sortedLastIndex;
      lodash.sortedLastIndexBy = sortedLastIndexBy;
      lodash.sortedLastIndexOf = sortedLastIndexOf;
      lodash.startCase = startCase;
      lodash.startsWith = startsWith;
      lodash.subtract = subtract;
      lodash.sum = sum;
      lodash.sumBy = sumBy;
      lodash.template = template;
      lodash.times = times;
      lodash.toFinite = toFinite;
      lodash.toInteger = toInteger;
      lodash.toLength = toLength;
      lodash.toLower = toLower;
      lodash.toNumber = toNumber;
      lodash.toSafeInteger = toSafeInteger;
      lodash.toString = toString;
      lodash.toUpper = toUpper;
      lodash.trim = trim;
      lodash.trimEnd = trimEnd;
      lodash.trimStart = trimStart;
      lodash.truncate = truncate;
      lodash.unescape = unescape;
      lodash.uniqueId = uniqueId;
      lodash.upperCase = upperCase;
      lodash.upperFirst = upperFirst;
      lodash.each = forEach;
      lodash.eachRight = forEachRight;
      lodash.first = head;
      mixin(lodash, function() {
        var source = {};
        baseForOwn(lodash, function(func, methodName) {
          if (!hasOwnProperty.call(lodash.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { chain: false });
      lodash.VERSION = VERSION;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash[methodName].placeholder = lodash;
      });
      arrayEach(["drop", "take"], function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
          var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
          } else {
            result2.__views__.push({
              size: nativeMin(n, MAX_ARRAY_LENGTH),
              type: methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
        var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            iteratee: getIteratee(iteratee2, 3),
            type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index) {
        var takeName = "take" + (index ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index) {
        var dropName = "drop" + (index ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);
        var result2 = this;
        if (result2.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start < 0) {
          result2 = result2.takeRight(-start);
        } else if (start) {
          result2 = result2.drop(start);
        }
        if (end !== undefined2) {
          end = toInteger(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({ func: thru, args: [interceptor], thisArg: undefined2 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ name: methodName, func: lodashFunc });
        }
      });
      realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
        name: "wrapper",
        func: undefined2
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash.prototype.at = wrapperAt;
      lodash.prototype.chain = wrapperChain;
      lodash.prototype.commit = wrapperCommit;
      lodash.prototype.next = wrapperNext;
      lodash.prototype.plant = wrapperPlant;
      lodash.prototype.reverse = wrapperReverse;
      lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
      lodash.prototype.first = lodash.prototype.head;
      if (symIterator) {
        lodash.prototype[symIterator] = wrapperToIterator;
      }
      return lodash;
    };
    var _ = runInContext();
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
      root._ = _;
      define(function() {
        return _;
      });
    } else if (freeModule) {
      (freeModule.exports = _)._ = _;
      freeExports._ = _;
    } else {
      root._ = _;
    }
  }).call(exports);
});

// node_modules/lodash/_freeGlobal.js
var require__freeGlobal = __commonJS((exports, module) => {
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  module.exports = freeGlobal;
});

// node_modules/lodash/_root.js
var require__root = __commonJS((exports, module) => {
  var freeGlobal = require__freeGlobal();
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  module.exports = root;
});

// node_modules/lodash/_Symbol.js
var require__Symbol = __commonJS((exports, module) => {
  var root = require__root();
  var Symbol2 = root.Symbol;
  module.exports = Symbol2;
});

// node_modules/lodash/_getRawTag.js
var require__getRawTag = __commonJS((exports, module) => {
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  var Symbol2 = require__Symbol();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined;
  module.exports = getRawTag;
});

// node_modules/lodash/_objectToString.js
var require__objectToString = __commonJS((exports, module) => {
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;
  module.exports = objectToString;
});

// node_modules/lodash/_baseGetTag.js
var require__baseGetTag = __commonJS((exports, module) => {
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  var Symbol2 = require__Symbol();
  var getRawTag = require__getRawTag();
  var objectToString = require__objectToString();
  var nullTag = "[object Null]";
  var undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined;
  module.exports = baseGetTag;
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS((exports, module) => {
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  module.exports = isObject;
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS((exports, module) => {
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  var baseGetTag = require__baseGetTag();
  var isObject = require_isObject();
  var asyncTag = "[object AsyncFunction]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var proxyTag = "[object Proxy]";
  module.exports = isFunction;
});

// node_modules/lodash/_coreJsData.js
var require__coreJsData = __commonJS((exports, module) => {
  var root = require__root();
  var coreJsData = root["__core-js_shared__"];
  module.exports = coreJsData;
});

// node_modules/lodash/_isMasked.js
var require__isMasked = __commonJS((exports, module) => {
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  var coreJsData = require__coreJsData();
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  module.exports = isMasked;
});

// node_modules/lodash/_toSource.js
var require__toSource = __commonJS((exports, module) => {
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  module.exports = toSource;
});

// node_modules/lodash/_baseIsNative.js
var require__baseIsNative = __commonJS((exports, module) => {
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  var isFunction = require_isFunction();
  var isMasked = require__isMasked();
  var isObject = require_isObject();
  var toSource = require__toSource();
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  module.exports = baseIsNative;
});

// node_modules/lodash/_getValue.js
var require__getValue = __commonJS((exports, module) => {
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }
  module.exports = getValue;
});

// node_modules/lodash/_getNative.js
var require__getNative = __commonJS((exports, module) => {
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }
  var baseIsNative = require__baseIsNative();
  var getValue = require__getValue();
  module.exports = getNative;
});

// node_modules/lodash/_defineProperty.js
var require__defineProperty = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var defineProperty = function() {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  }();
  module.exports = defineProperty;
});

// node_modules/lodash/_baseAssignValue.js
var require__baseAssignValue = __commonJS((exports, module) => {
  function baseAssignValue(object, key, value) {
    if (key == "__proto__" && defineProperty) {
      defineProperty(object, key, {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      });
    } else {
      object[key] = value;
    }
  }
  var defineProperty = require__defineProperty();
  module.exports = baseAssignValue;
});

// node_modules/lodash/eq.js
var require_eq = __commonJS((exports, module) => {
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  module.exports = eq;
});

// node_modules/lodash/_assignValue.js
var require__assignValue = __commonJS((exports, module) => {
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  var baseAssignValue = require__baseAssignValue();
  var eq = require_eq();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = assignValue;
});

// node_modules/lodash/_copyObject.js
var require__copyObject = __commonJS((exports, module) => {
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
      if (newValue === undefined) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }
  var assignValue = require__assignValue();
  var baseAssignValue = require__baseAssignValue();
  module.exports = copyObject;
});

// node_modules/lodash/identity.js
var require_identity = __commonJS((exports, module) => {
  function identity(value) {
    return value;
  }
  module.exports = identity;
});

// node_modules/lodash/_apply.js
var require__apply = __commonJS((exports, module) => {
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  module.exports = apply;
});

// node_modules/lodash/_overRest.js
var require__overRest = __commonJS((exports, module) => {
  function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }
  var apply = require__apply();
  var nativeMax = Math.max;
  module.exports = overRest;
});

// node_modules/lodash/constant.js
var require_constant = __commonJS((exports, module) => {
  function constant(value) {
    return function() {
      return value;
    };
  }
  module.exports = constant;
});

// node_modules/lodash/_baseSetToString.js
var require__baseSetToString = __commonJS((exports, module) => {
  var constant = require_constant();
  var defineProperty = require__defineProperty();
  var identity = require_identity();
  var baseSetToString = !defineProperty ? identity : function(func, string) {
    return defineProperty(func, "toString", {
      configurable: true,
      enumerable: false,
      value: constant(string),
      writable: true
    });
  };
  module.exports = baseSetToString;
});

// node_modules/lodash/_shortOut.js
var require__shortOut = __commonJS((exports, module) => {
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(undefined, arguments);
    };
  }
  var HOT_COUNT = 800;
  var HOT_SPAN = 16;
  var nativeNow = Date.now;
  module.exports = shortOut;
});

// node_modules/lodash/_setToString.js
var require__setToString = __commonJS((exports, module) => {
  var baseSetToString = require__baseSetToString();
  var shortOut = require__shortOut();
  var setToString = shortOut(baseSetToString);
  module.exports = setToString;
});

// node_modules/lodash/_baseRest.js
var require__baseRest = __commonJS((exports, module) => {
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity), func + "");
  }
  var identity = require_identity();
  var overRest = require__overRest();
  var setToString = require__setToString();
  module.exports = baseRest;
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS((exports, module) => {
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  var MAX_SAFE_INTEGER = 9007199254740991;
  module.exports = isLength;
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS((exports, module) => {
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  var isFunction = require_isFunction();
  var isLength = require_isLength();
  module.exports = isArrayLike;
});

// node_modules/lodash/_isIndex.js
var require__isIndex = __commonJS((exports, module) => {
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  module.exports = isIndex;
});

// node_modules/lodash/_isIterateeCall.js
var require__isIterateeCall = __commonJS((exports, module) => {
  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index;
    if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && (index in object)) {
      return eq(object[index], value);
    }
    return false;
  }
  var eq = require_eq();
  var isArrayLike = require_isArrayLike();
  var isIndex = require__isIndex();
  var isObject = require_isObject();
  module.exports = isIterateeCall;
});

// node_modules/lodash/_createAssigner.js
var require__createAssigner = __commonJS((exports, module) => {
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  }
  var baseRest = require__baseRest();
  var isIterateeCall = require__isIterateeCall();
  module.exports = createAssigner;
});

// node_modules/lodash/_baseTimes.js
var require__baseTimes = __commonJS((exports, module) => {
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  module.exports = baseTimes;
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS((exports, module) => {
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  module.exports = isObjectLike;
});

// node_modules/lodash/_baseIsArguments.js
var require__baseIsArguments = __commonJS((exports, module) => {
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }
  var baseGetTag = require__baseGetTag();
  var isObjectLike = require_isObjectLike();
  var argsTag = "[object Arguments]";
  module.exports = baseIsArguments;
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS((exports, module) => {
  var baseIsArguments = require__baseIsArguments();
  var isObjectLike = require_isObjectLike();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  module.exports = isArguments;
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS((exports, module) => {
  var isArray = Array.isArray;
  module.exports = isArray;
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS((exports, module) => {
  function stubFalse() {
    return false;
  }
  module.exports = stubFalse;
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS((exports, module) => {
  var root = require__root();
  var stubFalse = require_stubFalse();
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root.Buffer : undefined;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined;
  var isBuffer = nativeIsBuffer || stubFalse;
  module.exports = isBuffer;
});

// node_modules/lodash/_baseIsTypedArray.js
var require__baseIsTypedArray = __commonJS((exports, module) => {
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  var baseGetTag = require__baseGetTag();
  var isLength = require_isLength();
  var isObjectLike = require_isObjectLike();
  var argsTag = "[object Arguments]";
  var arrayTag = "[object Array]";
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var errorTag = "[object Error]";
  var funcTag = "[object Function]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var objectTag = "[object Object]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  module.exports = baseIsTypedArray;
});

// node_modules/lodash/_baseUnary.js
var require__baseUnary = __commonJS((exports, module) => {
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  module.exports = baseUnary;
});

// node_modules/lodash/_nodeUtil.js
var require__nodeUtil = __commonJS((exports, module) => {
  var freeGlobal = require__freeGlobal();
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal.process;
  var nodeUtil = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  module.exports = nodeUtil;
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS((exports, module) => {
  var baseIsTypedArray = require__baseIsTypedArray();
  var baseUnary = require__baseUnary();
  var nodeUtil = require__nodeUtil();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  module.exports = isTypedArray;
});

// node_modules/lodash/_arrayLikeKeys.js
var require__arrayLikeKeys = __commonJS((exports, module) => {
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  var baseTimes = require__baseTimes();
  var isArguments = require_isArguments();
  var isArray = require_isArray();
  var isBuffer = require_isBuffer();
  var isIndex = require__isIndex();
  var isTypedArray = require_isTypedArray();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = arrayLikeKeys;
});

// node_modules/lodash/_isPrototype.js
var require__isPrototype = __commonJS((exports, module) => {
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  }
  var objectProto = Object.prototype;
  module.exports = isPrototype;
});

// node_modules/lodash/_nativeKeysIn.js
var require__nativeKeysIn = __commonJS((exports, module) => {
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }
  module.exports = nativeKeysIn;
});

// node_modules/lodash/_baseKeysIn.js
var require__baseKeysIn = __commonJS((exports, module) => {
  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  var isObject = require_isObject();
  var isPrototype = require__isPrototype();
  var nativeKeysIn = require__nativeKeysIn();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = baseKeysIn;
});

// node_modules/lodash/keysIn.js
var require_keysIn = __commonJS((exports, module) => {
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  var arrayLikeKeys = require__arrayLikeKeys();
  var baseKeysIn = require__baseKeysIn();
  var isArrayLike = require_isArrayLike();
  module.exports = keysIn;
});

// node_modules/lodash/assignIn.js
var require_assignIn = __commonJS((exports, module) => {
  var copyObject = require__copyObject();
  var createAssigner = require__createAssigner();
  var keysIn = require_keysIn();
  var assignIn = createAssigner(function(object, source) {
    copyObject(source, keysIn(source), object);
  });
  module.exports = assignIn;
});

// node_modules/lodash/isString.js
var require_isString = __commonJS((exports, module) => {
  function isString(value) {
    return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
  }
  var baseGetTag = require__baseGetTag();
  var isArray = require_isArray();
  var isObjectLike = require_isObjectLike();
  var stringTag = "[object String]";
  module.exports = isString;
});

// node_modules/lodash/isUndefined.js
var require_isUndefined = __commonJS((exports, module) => {
  function isUndefined(value) {
    return value === undefined;
  }
  module.exports = isUndefined;
});

// node_modules/lodash/_overArg.js
var require__overArg = __commonJS((exports, module) => {
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  module.exports = overArg;
});

// node_modules/lodash/_nativeKeys.js
var require__nativeKeys = __commonJS((exports, module) => {
  var overArg = require__overArg();
  var nativeKeys = overArg(Object.keys, Object);
  module.exports = nativeKeys;
});

// node_modules/lodash/_baseKeys.js
var require__baseKeys = __commonJS((exports, module) => {
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  var isPrototype = require__isPrototype();
  var nativeKeys = require__nativeKeys();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = baseKeys;
});

// node_modules/lodash/_DataView.js
var require__DataView = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var root = require__root();
  var DataView2 = getNative(root, "DataView");
  module.exports = DataView2;
});

// node_modules/lodash/_Map.js
var require__Map = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var root = require__root();
  var Map2 = getNative(root, "Map");
  module.exports = Map2;
});

// node_modules/lodash/_Promise.js
var require__Promise = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var root = require__root();
  var Promise2 = getNative(root, "Promise");
  module.exports = Promise2;
});

// node_modules/lodash/_Set.js
var require__Set = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var root = require__root();
  var Set2 = getNative(root, "Set");
  module.exports = Set2;
});

// node_modules/lodash/_WeakMap.js
var require__WeakMap = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var root = require__root();
  var WeakMap2 = getNative(root, "WeakMap");
  module.exports = WeakMap2;
});

// node_modules/lodash/_getTag.js
var require__getTag = __commonJS((exports, module) => {
  var DataView2 = require__DataView();
  var Map2 = require__Map();
  var Promise2 = require__Promise();
  var Set2 = require__Set();
  var WeakMap2 = require__WeakMap();
  var baseGetTag = require__baseGetTag();
  var toSource = require__toSource();
  var mapTag = "[object Map]";
  var objectTag = "[object Object]";
  var promiseTag = "[object Promise]";
  var setTag = "[object Set]";
  var weakMapTag = "[object WeakMap]";
  var dataViewTag = "[object DataView]";
  var dataViewCtorString = toSource(DataView2);
  var mapCtorString = toSource(Map2);
  var promiseCtorString = toSource(Promise2);
  var setCtorString = toSource(Set2);
  var weakMapCtorString = toSource(WeakMap2);
  var getTag = baseGetTag;
  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2) != setTag || WeakMap2 && getTag(new WeakMap2) != weakMapTag) {
    getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  module.exports = getTag;
});

// node_modules/lodash/isEmpty.js
var require_isEmpty = __commonJS((exports, module) => {
  function isEmpty(value) {
    if (value == null) {
      return true;
    }
    if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
      return !value.length;
    }
    var tag = getTag(value);
    if (tag == mapTag || tag == setTag) {
      return !value.size;
    }
    if (isPrototype(value)) {
      return !baseKeys(value).length;
    }
    for (var key in value) {
      if (hasOwnProperty.call(value, key)) {
        return false;
      }
    }
    return true;
  }
  var baseKeys = require__baseKeys();
  var getTag = require__getTag();
  var isArguments = require_isArguments();
  var isArray = require_isArray();
  var isArrayLike = require_isArrayLike();
  var isBuffer = require_isBuffer();
  var isPrototype = require__isPrototype();
  var isTypedArray = require_isTypedArray();
  var mapTag = "[object Map]";
  var setTag = "[object Set]";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = isEmpty;
});

// node_modules/cloudinary/lib/utils/entries.js
var require_entries = __commonJS((exports, module) => {
  module.exports = Object.entries ? Object.entries : function(obj) {
    let ownProps = Object.keys(obj), i = ownProps.length, resArray = new Array(i);
    while (i--) {
      resArray[i] = [ownProps[i], obj[ownProps[i]]];
    }
    return resArray;
  };
});

// node_modules/cloudinary/lib/config.js
var require_config = __commonJS((exports, module) => {
  function putNestedValue(params, key, value) {
    let chain = key.split(/[\[\]]+/).filter((i) => i.length);
    let outer = params;
    let lastKey = chain.pop();
    for (let j = 0;j < chain.length; j++) {
      let innerKey = chain[j];
      let inner = outer[innerKey];
      if (inner == null) {
        inner = {};
        outer[innerKey] = inner;
      }
      outer = inner;
    }
    outer[lastKey] = value;
    return params;
  }
  function parseCloudinaryConfigFromEnvURL(ENV_STR) {
    let conf = {};
    let uri = url.parse(ENV_STR, true);
    if (uri.protocol === "cloudinary:") {
      conf = Object.assign({}, conf, {
        cloud_name: uri.host,
        api_key: uri.auth && uri.auth.split(":")[0],
        api_secret: uri.auth && uri.auth.split(":")[1],
        private_cdn: uri.pathname != null,
        secure_distribution: uri.pathname && uri.pathname.substring(1)
      });
    } else if (uri.protocol === "account:") {
      conf = Object.assign({}, conf, {
        account_id: uri.host,
        provisioning_api_key: uri.auth && uri.auth.split(":")[0],
        provisioning_api_secret: uri.auth && uri.auth.split(":")[1]
      });
    }
    return conf;
  }
  function extendCloudinaryConfigFromQuery(ENV_URL, confToExtend = {}) {
    let uri = url.parse(ENV_URL, true);
    if (uri.query != null) {
      entries(uri.query).forEach(([key, value]) => putNestedValue(confToExtend, key, value));
    }
  }
  function extendCloudinaryConfig(parsedConfig, confToExtend = {}) {
    entries(parsedConfig).forEach(([key, value]) => {
      if (value !== undefined) {
        confToExtend[key] = value;
      }
    });
    return confToExtend;
  }
  var url = import.meta.require("url");
  var extend = require_assignIn();
  var isObject = require_isObject();
  var isString = require_isString();
  var isUndefined = require_isUndefined();
  var isEmpty = require_isEmpty();
  var entries = require_entries();
  var cloudinary_config = undefined;
  module.exports = function(new_config, new_value) {
    if (cloudinary_config == null || new_config === true) {
      if (cloudinary_config == null) {
        cloudinary_config = {};
      } else {
        Object.keys(cloudinary_config).forEach((key) => delete cloudinary_config[key]);
      }
      let CLOUDINARY_ENV_URL = process.env.CLOUDINARY_URL;
      let CLOUDINARY_ENV_ACCOUNT_URL = process.env.CLOUDINARY_ACCOUNT_URL;
      let CLOUDINARY_API_PROXY = process.env.CLOUDINARY_API_PROXY;
      if (CLOUDINARY_ENV_URL && !CLOUDINARY_ENV_URL.toLowerCase().startsWith("cloudinary://")) {
        throw new Error("Invalid CLOUDINARY_URL protocol. URL should begin with 'cloudinary://'");
      }
      if (CLOUDINARY_ENV_ACCOUNT_URL && !CLOUDINARY_ENV_ACCOUNT_URL.toLowerCase().startsWith("account://")) {
        throw new Error("Invalid CLOUDINARY_ACCOUNT_URL protocol. URL should begin with 'account://'");
      }
      if (!isEmpty(CLOUDINARY_API_PROXY)) {
        extendCloudinaryConfig({ api_proxy: CLOUDINARY_API_PROXY }, cloudinary_config);
      }
      [CLOUDINARY_ENV_URL, CLOUDINARY_ENV_ACCOUNT_URL].forEach((ENV_URL) => {
        if (ENV_URL) {
          let parsedConfig = parseCloudinaryConfigFromEnvURL(ENV_URL);
          extendCloudinaryConfig(parsedConfig, cloudinary_config);
          extendCloudinaryConfigFromQuery(ENV_URL, cloudinary_config);
        }
      });
    }
    if (!isUndefined(new_value)) {
      cloudinary_config[new_config] = new_value;
    } else if (isString(new_config)) {
      return cloudinary_config[new_config];
    } else if (isObject(new_config)) {
      extend(cloudinary_config, new_config);
    }
    return cloudinary_config;
  };
});

// node_modules/lodash/compact.js
var require_compact = __commonJS((exports, module) => {
  function compact(array) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index < length) {
      var value = array[index];
      if (value) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  module.exports = compact;
});

// node_modules/lodash/head.js
var require_head = __commonJS((exports, module) => {
  function head(array) {
    return array && array.length ? array[0] : undefined;
  }
  module.exports = head;
});

// node_modules/lodash/_getPrototype.js
var require__getPrototype = __commonJS((exports, module) => {
  var overArg = require__overArg();
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  module.exports = getPrototype;
});

// node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS((exports, module) => {
  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  var baseGetTag = require__baseGetTag();
  var getPrototype = require__getPrototype();
  var isObjectLike = require_isObjectLike();
  var objectTag = "[object Object]";
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  module.exports = isPlainObject;
});

// node_modules/lodash/last.js
var require_last = __commonJS((exports, module) => {
  function last(array) {
    var length = array == null ? 0 : array.length;
    return length ? array[length - 1] : undefined;
  }
  module.exports = last;
});

// node_modules/lodash/_arrayMap.js
var require__arrayMap = __commonJS((exports, module) => {
  function arrayMap(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }
  module.exports = arrayMap;
});

// node_modules/lodash/_listCacheClear.js
var require__listCacheClear = __commonJS((exports, module) => {
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  module.exports = listCacheClear;
});

// node_modules/lodash/_assocIndexOf.js
var require__assocIndexOf = __commonJS((exports, module) => {
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  var eq = require_eq();
  module.exports = assocIndexOf;
});

// node_modules/lodash/_listCacheDelete.js
var require__listCacheDelete = __commonJS((exports, module) => {
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  var assocIndexOf = require__assocIndexOf();
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  module.exports = listCacheDelete;
});

// node_modules/lodash/_listCacheGet.js
var require__listCacheGet = __commonJS((exports, module) => {
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }
  var assocIndexOf = require__assocIndexOf();
  module.exports = listCacheGet;
});

// node_modules/lodash/_listCacheHas.js
var require__listCacheHas = __commonJS((exports, module) => {
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  var assocIndexOf = require__assocIndexOf();
  module.exports = listCacheHas;
});

// node_modules/lodash/_listCacheSet.js
var require__listCacheSet = __commonJS((exports, module) => {
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  var assocIndexOf = require__assocIndexOf();
  module.exports = listCacheSet;
});

// node_modules/lodash/_ListCache.js
var require__ListCache = __commonJS((exports, module) => {
  function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  var listCacheClear = require__listCacheClear();
  var listCacheDelete = require__listCacheDelete();
  var listCacheGet = require__listCacheGet();
  var listCacheHas = require__listCacheHas();
  var listCacheSet = require__listCacheSet();
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  module.exports = ListCache;
});

// node_modules/lodash/_stackClear.js
var require__stackClear = __commonJS((exports, module) => {
  function stackClear() {
    this.__data__ = new ListCache;
    this.size = 0;
  }
  var ListCache = require__ListCache();
  module.exports = stackClear;
});

// node_modules/lodash/_stackDelete.js
var require__stackDelete = __commonJS((exports, module) => {
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  module.exports = stackDelete;
});

// node_modules/lodash/_stackGet.js
var require__stackGet = __commonJS((exports, module) => {
  function stackGet(key) {
    return this.__data__.get(key);
  }
  module.exports = stackGet;
});

// node_modules/lodash/_stackHas.js
var require__stackHas = __commonJS((exports, module) => {
  function stackHas(key) {
    return this.__data__.has(key);
  }
  module.exports = stackHas;
});

// node_modules/lodash/_nativeCreate.js
var require__nativeCreate = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var nativeCreate = getNative(Object, "create");
  module.exports = nativeCreate;
});

// node_modules/lodash/_hashClear.js
var require__hashClear = __commonJS((exports, module) => {
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  var nativeCreate = require__nativeCreate();
  module.exports = hashClear;
});

// node_modules/lodash/_hashDelete.js
var require__hashDelete = __commonJS((exports, module) => {
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  module.exports = hashDelete;
});

// node_modules/lodash/_hashGet.js
var require__hashGet = __commonJS((exports, module) => {
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }
  var nativeCreate = require__nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = hashGet;
});

// node_modules/lodash/_hashHas.js
var require__hashHas = __commonJS((exports, module) => {
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }
  var nativeCreate = require__nativeCreate();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = hashHas;
});

// node_modules/lodash/_hashSet.js
var require__hashSet = __commonJS((exports, module) => {
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  }
  var nativeCreate = require__nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  module.exports = hashSet;
});

// node_modules/lodash/_Hash.js
var require__Hash = __commonJS((exports, module) => {
  function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  var hashClear = require__hashClear();
  var hashDelete = require__hashDelete();
  var hashGet = require__hashGet();
  var hashHas = require__hashHas();
  var hashSet = require__hashSet();
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  module.exports = Hash;
});

// node_modules/lodash/_mapCacheClear.js
var require__mapCacheClear = __commonJS((exports, module) => {
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      hash: new Hash,
      map: new (Map2 || ListCache),
      string: new Hash
    };
  }
  var Hash = require__Hash();
  var ListCache = require__ListCache();
  var Map2 = require__Map();
  module.exports = mapCacheClear;
});

// node_modules/lodash/_isKeyable.js
var require__isKeyable = __commonJS((exports, module) => {
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  module.exports = isKeyable;
});

// node_modules/lodash/_getMapData.js
var require__getMapData = __commonJS((exports, module) => {
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  var isKeyable = require__isKeyable();
  module.exports = getMapData;
});

// node_modules/lodash/_mapCacheDelete.js
var require__mapCacheDelete = __commonJS((exports, module) => {
  function mapCacheDelete(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  var getMapData = require__getMapData();
  module.exports = mapCacheDelete;
});

// node_modules/lodash/_mapCacheGet.js
var require__mapCacheGet = __commonJS((exports, module) => {
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  var getMapData = require__getMapData();
  module.exports = mapCacheGet;
});

// node_modules/lodash/_mapCacheHas.js
var require__mapCacheHas = __commonJS((exports, module) => {
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  var getMapData = require__getMapData();
  module.exports = mapCacheHas;
});

// node_modules/lodash/_mapCacheSet.js
var require__mapCacheSet = __commonJS((exports, module) => {
  function mapCacheSet(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  var getMapData = require__getMapData();
  module.exports = mapCacheSet;
});

// node_modules/lodash/_MapCache.js
var require__MapCache = __commonJS((exports, module) => {
  function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  var mapCacheClear = require__mapCacheClear();
  var mapCacheDelete = require__mapCacheDelete();
  var mapCacheGet = require__mapCacheGet();
  var mapCacheHas = require__mapCacheHas();
  var mapCacheSet = require__mapCacheSet();
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  module.exports = MapCache;
});

// node_modules/lodash/_stackSet.js
var require__stackSet = __commonJS((exports, module) => {
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  var ListCache = require__ListCache();
  var Map2 = require__Map();
  var MapCache = require__MapCache();
  var LARGE_ARRAY_SIZE = 200;
  module.exports = stackSet;
});

// node_modules/lodash/_Stack.js
var require__Stack = __commonJS((exports, module) => {
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  var ListCache = require__ListCache();
  var stackClear = require__stackClear();
  var stackDelete = require__stackDelete();
  var stackGet = require__stackGet();
  var stackHas = require__stackHas();
  var stackSet = require__stackSet();
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  module.exports = Stack;
});

// node_modules/lodash/_setCacheAdd.js
var require__setCacheAdd = __commonJS((exports, module) => {
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  module.exports = setCacheAdd;
});

// node_modules/lodash/_setCacheHas.js
var require__setCacheHas = __commonJS((exports, module) => {
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  module.exports = setCacheHas;
});

// node_modules/lodash/_SetCache.js
var require__SetCache = __commonJS((exports, module) => {
  function SetCache(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache;
    while (++index < length) {
      this.add(values[index]);
    }
  }
  var MapCache = require__MapCache();
  var setCacheAdd = require__setCacheAdd();
  var setCacheHas = require__setCacheHas();
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  module.exports = SetCache;
});

// node_modules/lodash/_arraySome.js
var require__arraySome = __commonJS((exports, module) => {
  function arraySome(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }
  module.exports = arraySome;
});

// node_modules/lodash/_cacheHas.js
var require__cacheHas = __commonJS((exports, module) => {
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  module.exports = cacheHas;
});

// node_modules/lodash/_equalArrays.js
var require__equalArrays = __commonJS((exports, module) => {
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }
    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache : undefined;
    stack.set(array, other);
    stack.set(other, array);
    while (++index < arrLength) {
      var arrValue = array[index], othValue = other[index];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== undefined) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }
  var SetCache = require__SetCache();
  var arraySome = require__arraySome();
  var cacheHas = require__cacheHas();
  var COMPARE_PARTIAL_FLAG = 1;
  var COMPARE_UNORDERED_FLAG = 2;
  module.exports = equalArrays;
});

// node_modules/lodash/_Uint8Array.js
var require__Uint8Array = __commonJS((exports, module) => {
  var root = require__root();
  var Uint8Array2 = root.Uint8Array;
  module.exports = Uint8Array2;
});

// node_modules/lodash/_mapToArray.js
var require__mapToArray = __commonJS((exports, module) => {
  function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  module.exports = mapToArray;
});

// node_modules/lodash/_setToArray.js
var require__setToArray = __commonJS((exports, module) => {
  function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  module.exports = setToArray;
});

// node_modules/lodash/_equalByTag.js
var require__equalByTag = __commonJS((exports, module) => {
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq(+object, +other);
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case regexpTag:
      case stringTag:
        return object == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  var Symbol2 = require__Symbol();
  var Uint8Array2 = require__Uint8Array();
  var eq = require_eq();
  var equalArrays = require__equalArrays();
  var mapToArray = require__mapToArray();
  var setToArray = require__setToArray();
  var COMPARE_PARTIAL_FLAG = 1;
  var COMPARE_UNORDERED_FLAG = 2;
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var errorTag = "[object Error]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var symbolTag = "[object Symbol]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var symbolProto = Symbol2 ? Symbol2.prototype : undefined;
  var symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
  module.exports = equalByTag;
});

// node_modules/lodash/_arrayPush.js
var require__arrayPush = __commonJS((exports, module) => {
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  module.exports = arrayPush;
});

// node_modules/lodash/_baseGetAllKeys.js
var require__baseGetAllKeys = __commonJS((exports, module) => {
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  var arrayPush = require__arrayPush();
  var isArray = require_isArray();
  module.exports = baseGetAllKeys;
});

// node_modules/lodash/_arrayFilter.js
var require__arrayFilter = __commonJS((exports, module) => {
  function arrayFilter(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  module.exports = arrayFilter;
});

// node_modules/lodash/stubArray.js
var require_stubArray = __commonJS((exports, module) => {
  function stubArray() {
    return [];
  }
  module.exports = stubArray;
});

// node_modules/lodash/_getSymbols.js
var require__getSymbols = __commonJS((exports, module) => {
  var arrayFilter = require__arrayFilter();
  var stubArray = require_stubArray();
  var objectProto = Object.prototype;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  module.exports = getSymbols;
});

// node_modules/lodash/keys.js
var require_keys = __commonJS((exports, module) => {
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  var arrayLikeKeys = require__arrayLikeKeys();
  var baseKeys = require__baseKeys();
  var isArrayLike = require_isArrayLike();
  module.exports = keys;
});

// node_modules/lodash/_getAllKeys.js
var require__getAllKeys = __commonJS((exports, module) => {
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }
  var baseGetAllKeys = require__baseGetAllKeys();
  var getSymbols = require__getSymbols();
  var keys = require_keys();
  module.exports = getAllKeys;
});

// node_modules/lodash/_equalObjects.js
var require__equalObjects = __commonJS((exports, module) => {
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }
    var objStacked = stack.get(object);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }
      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && (("constructor" in object) && ("constructor" in other)) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }
  var getAllKeys = require__getAllKeys();
  var COMPARE_PARTIAL_FLAG = 1;
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = equalObjects;
});

// node_modules/lodash/_baseIsEqualDeep.js
var require__baseIsEqualDeep = __commonJS((exports, module) => {
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack);
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack);
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack);
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }
  var Stack = require__Stack();
  var equalArrays = require__equalArrays();
  var equalByTag = require__equalByTag();
  var equalObjects = require__equalObjects();
  var getTag = require__getTag();
  var isArray = require_isArray();
  var isBuffer = require_isBuffer();
  var isTypedArray = require_isTypedArray();
  var COMPARE_PARTIAL_FLAG = 1;
  var argsTag = "[object Arguments]";
  var arrayTag = "[object Array]";
  var objectTag = "[object Object]";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = baseIsEqualDeep;
});

// node_modules/lodash/_baseIsEqual.js
var require__baseIsEqual = __commonJS((exports, module) => {
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  var baseIsEqualDeep = require__baseIsEqualDeep();
  var isObjectLike = require_isObjectLike();
  module.exports = baseIsEqual;
});

// node_modules/lodash/_baseIsMatch.js
var require__baseIsMatch = __commonJS((exports, module) => {
  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length, length = index, noCustomizer = !customizer;
    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index--) {
      var data = matchData[index];
      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
        return false;
      }
    }
    while (++index < length) {
      data = matchData[index];
      var key = data[0], objValue = object[key], srcValue = data[1];
      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object)) {
          return false;
        }
      } else {
        var stack = new Stack;
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }
        if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  var Stack = require__Stack();
  var baseIsEqual = require__baseIsEqual();
  var COMPARE_PARTIAL_FLAG = 1;
  var COMPARE_UNORDERED_FLAG = 2;
  module.exports = baseIsMatch;
});

// node_modules/lodash/_isStrictComparable.js
var require__isStrictComparable = __commonJS((exports, module) => {
  function isStrictComparable(value) {
    return value === value && !isObject(value);
  }
  var isObject = require_isObject();
  module.exports = isStrictComparable;
});

// node_modules/lodash/_getMatchData.js
var require__getMatchData = __commonJS((exports, module) => {
  function getMatchData(object) {
    var result = keys(object), length = result.length;
    while (length--) {
      var key = result[length], value = object[key];
      result[length] = [key, value, isStrictComparable(value)];
    }
    return result;
  }
  var isStrictComparable = require__isStrictComparable();
  var keys = require_keys();
  module.exports = getMatchData;
});

// node_modules/lodash/_matchesStrictComparable.js
var require__matchesStrictComparable = __commonJS((exports, module) => {
  function matchesStrictComparable(key, srcValue) {
    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue && (srcValue !== undefined || (key in Object(object)));
    };
  }
  module.exports = matchesStrictComparable;
});

// node_modules/lodash/_baseMatches.js
var require__baseMatches = __commonJS((exports, module) => {
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }
  var baseIsMatch = require__baseIsMatch();
  var getMatchData = require__getMatchData();
  var matchesStrictComparable = require__matchesStrictComparable();
  module.exports = baseMatches;
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS((exports, module) => {
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
  }
  var baseGetTag = require__baseGetTag();
  var isObjectLike = require_isObjectLike();
  var symbolTag = "[object Symbol]";
  module.exports = isSymbol;
});

// node_modules/lodash/_isKey.js
var require__isKey = __commonJS((exports, module) => {
  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }
  var isArray = require_isArray();
  var isSymbol = require_isSymbol();
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
  var reIsPlainProp = /^\w*$/;
  module.exports = isKey;
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS((exports, module) => {
  function memoize(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache);
    return memoized;
  }
  var MapCache = require__MapCache();
  var FUNC_ERROR_TEXT = "Expected a function";
  memoize.Cache = MapCache;
  module.exports = memoize;
});

// node_modules/lodash/_memoizeCapped.js
var require__memoizeCapped = __commonJS((exports, module) => {
  function memoizeCapped(func) {
    var result = memoize(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });
    var cache = result.cache;
    return result;
  }
  var memoize = require_memoize();
  var MAX_MEMOIZE_SIZE = 500;
  module.exports = memoizeCapped;
});

// node_modules/lodash/_stringToPath.js
var require__stringToPath = __commonJS((exports, module) => {
  var memoizeCapped = require__memoizeCapped();
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46) {
      result.push("");
    }
    string.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
    });
    return result;
  });
  module.exports = stringToPath;
});

// node_modules/lodash/_baseToString.js
var require__baseToString = __commonJS((exports, module) => {
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  var Symbol2 = require__Symbol();
  var arrayMap = require__arrayMap();
  var isArray = require_isArray();
  var isSymbol = require_isSymbol();
  var INFINITY = 1 / 0;
  var symbolProto = Symbol2 ? Symbol2.prototype : undefined;
  var symbolToString = symbolProto ? symbolProto.toString : undefined;
  module.exports = baseToString;
});

// node_modules/lodash/toString.js
var require_toString = __commonJS((exports, module) => {
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  var baseToString = require__baseToString();
  module.exports = toString;
});

// node_modules/lodash/_castPath.js
var require__castPath = __commonJS((exports, module) => {
  function castPath(value, object) {
    if (isArray(value)) {
      return value;
    }
    return isKey(value, object) ? [value] : stringToPath(toString(value));
  }
  var isArray = require_isArray();
  var isKey = require__isKey();
  var stringToPath = require__stringToPath();
  var toString = require_toString();
  module.exports = castPath;
});

// node_modules/lodash/_toKey.js
var require__toKey = __commonJS((exports, module) => {
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  var isSymbol = require_isSymbol();
  var INFINITY = 1 / 0;
  module.exports = toKey;
});

// node_modules/lodash/_baseGet.js
var require__baseGet = __commonJS((exports, module) => {
  function baseGet(object, path) {
    path = castPath(path, object);
    var index = 0, length = path.length;
    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }
    return index && index == length ? object : undefined;
  }
  var castPath = require__castPath();
  var toKey = require__toKey();
  module.exports = baseGet;
});

// node_modules/lodash/get.js
var require_get = __commonJS((exports, module) => {
  function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }
  var baseGet = require__baseGet();
  module.exports = get;
});

// node_modules/lodash/_baseHasIn.js
var require__baseHasIn = __commonJS((exports, module) => {
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }
  module.exports = baseHasIn;
});

// node_modules/lodash/_hasPath.js
var require__hasPath = __commonJS((exports, module) => {
  function hasPath(object, path, hasFunc) {
    path = castPath(path, object);
    var index = -1, length = path.length, result = false;
    while (++index < length) {
      var key = toKey(path[index]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index != length) {
      return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
  }
  var castPath = require__castPath();
  var isArguments = require_isArguments();
  var isArray = require_isArray();
  var isIndex = require__isIndex();
  var isLength = require_isLength();
  var toKey = require__toKey();
  module.exports = hasPath;
});

// node_modules/lodash/hasIn.js
var require_hasIn = __commonJS((exports, module) => {
  function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }
  var baseHasIn = require__baseHasIn();
  var hasPath = require__hasPath();
  module.exports = hasIn;
});

// node_modules/lodash/_baseMatchesProperty.js
var require__baseMatchesProperty = __commonJS((exports, module) => {
  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }
    return function(object) {
      var objValue = get(object, path);
      return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }
  var baseIsEqual = require__baseIsEqual();
  var get = require_get();
  var hasIn = require_hasIn();
  var isKey = require__isKey();
  var isStrictComparable = require__isStrictComparable();
  var matchesStrictComparable = require__matchesStrictComparable();
  var toKey = require__toKey();
  var COMPARE_PARTIAL_FLAG = 1;
  var COMPARE_UNORDERED_FLAG = 2;
  module.exports = baseMatchesProperty;
});

// node_modules/lodash/_baseProperty.js
var require__baseProperty = __commonJS((exports, module) => {
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }
  module.exports = baseProperty;
});

// node_modules/lodash/_basePropertyDeep.js
var require__basePropertyDeep = __commonJS((exports, module) => {
  function basePropertyDeep(path) {
    return function(object) {
      return baseGet(object, path);
    };
  }
  var baseGet = require__baseGet();
  module.exports = basePropertyDeep;
});

// node_modules/lodash/property.js
var require_property = __commonJS((exports, module) => {
  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }
  var baseProperty = require__baseProperty();
  var basePropertyDeep = require__basePropertyDeep();
  var isKey = require__isKey();
  var toKey = require__toKey();
  module.exports = property;
});

// node_modules/lodash/_baseIteratee.js
var require__baseIteratee = __commonJS((exports, module) => {
  function baseIteratee(value) {
    if (typeof value == "function") {
      return value;
    }
    if (value == null) {
      return identity;
    }
    if (typeof value == "object") {
      return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
  }
  var baseMatches = require__baseMatches();
  var baseMatchesProperty = require__baseMatchesProperty();
  var identity = require_identity();
  var isArray = require_isArray();
  var property = require_property();
  module.exports = baseIteratee;
});

// node_modules/lodash/_createBaseFor.js
var require__createBaseFor = __commonJS((exports, module) => {
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  module.exports = createBaseFor;
});

// node_modules/lodash/_baseFor.js
var require__baseFor = __commonJS((exports, module) => {
  var createBaseFor = require__createBaseFor();
  var baseFor = createBaseFor();
  module.exports = baseFor;
});

// node_modules/lodash/_baseForOwn.js
var require__baseForOwn = __commonJS((exports, module) => {
  function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
  }
  var baseFor = require__baseFor();
  var keys = require_keys();
  module.exports = baseForOwn;
});

// node_modules/lodash/_createBaseEach.js
var require__createBaseEach = __commonJS((exports, module) => {
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
      while (fromRight ? index-- : ++index < length) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }
  var isArrayLike = require_isArrayLike();
  module.exports = createBaseEach;
});

// node_modules/lodash/_baseEach.js
var require__baseEach = __commonJS((exports, module) => {
  var baseForOwn = require__baseForOwn();
  var createBaseEach = require__createBaseEach();
  var baseEach = createBaseEach(baseForOwn);
  module.exports = baseEach;
});

// node_modules/lodash/_baseMap.js
var require__baseMap = __commonJS((exports, module) => {
  function baseMap(collection, iteratee) {
    var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
    baseEach(collection, function(value, key, collection2) {
      result[++index] = iteratee(value, key, collection2);
    });
    return result;
  }
  var baseEach = require__baseEach();
  var isArrayLike = require_isArrayLike();
  module.exports = baseMap;
});

// node_modules/lodash/map.js
var require_map = __commonJS((exports, module) => {
  function map(collection, iteratee) {
    var func = isArray(collection) ? arrayMap : baseMap;
    return func(collection, baseIteratee(iteratee, 3));
  }
  var arrayMap = require__arrayMap();
  var baseIteratee = require__baseIteratee();
  var baseMap = require__baseMap();
  var isArray = require_isArray();
  module.exports = map;
});

// node_modules/lodash/_baseSlice.js
var require__baseSlice = __commonJS((exports, module) => {
  function baseSlice(array, start, end) {
    var index = -1, length = array.length;
    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }
  module.exports = baseSlice;
});

// node_modules/lodash/_trimmedEndIndex.js
var require__trimmedEndIndex = __commonJS((exports, module) => {
  function trimmedEndIndex(string) {
    var index = string.length;
    while (index-- && reWhitespace.test(string.charAt(index))) {
    }
    return index;
  }
  var reWhitespace = /\s/;
  module.exports = trimmedEndIndex;
});

// node_modules/lodash/_baseTrim.js
var require__baseTrim = __commonJS((exports, module) => {
  function baseTrim(string) {
    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
  }
  var trimmedEndIndex = require__trimmedEndIndex();
  var reTrimStart = /^\s+/;
  module.exports = baseTrim;
});

// node_modules/lodash/toNumber.js
var require_toNumber = __commonJS((exports, module) => {
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  var baseTrim = require__baseTrim();
  var isObject = require_isObject();
  var isSymbol = require_isSymbol();
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  module.exports = toNumber;
});

// node_modules/lodash/toFinite.js
var require_toFinite = __commonJS((exports, module) => {
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  var toNumber = require_toNumber();
  var INFINITY = 1 / 0;
  var MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
  module.exports = toFinite;
});

// node_modules/lodash/toInteger.js
var require_toInteger = __commonJS((exports, module) => {
  function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  var toFinite = require_toFinite();
  module.exports = toInteger;
});

// node_modules/lodash/take.js
var require_take = __commonJS((exports, module) => {
  function take(array, n, guard) {
    if (!(array && array.length)) {
      return [];
    }
    n = guard || n === undefined ? 1 : toInteger(n);
    return baseSlice(array, 0, n < 0 ? 0 : n);
  }
  var baseSlice = require__baseSlice();
  var toInteger = require_toInteger();
  module.exports = take;
});

// node_modules/lodash/_baseAt.js
var require__baseAt = __commonJS((exports, module) => {
  function baseAt(object, paths) {
    var index = -1, length = paths.length, result = Array(length), skip = object == null;
    while (++index < length) {
      result[index] = skip ? undefined : get(object, paths[index]);
    }
    return result;
  }
  var get = require_get();
  module.exports = baseAt;
});

// node_modules/lodash/_isFlattenable.js
var require__isFlattenable = __commonJS((exports, module) => {
  function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  var Symbol2 = require__Symbol();
  var isArguments = require_isArguments();
  var isArray = require_isArray();
  var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined;
  module.exports = isFlattenable;
});

// node_modules/lodash/_baseFlatten.js
var require__baseFlatten = __commonJS((exports, module) => {
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  var arrayPush = require__arrayPush();
  var isFlattenable = require__isFlattenable();
  module.exports = baseFlatten;
});

// node_modules/lodash/flatten.js
var require_flatten = __commonJS((exports, module) => {
  function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseFlatten(array, 1) : [];
  }
  var baseFlatten = require__baseFlatten();
  module.exports = flatten;
});

// node_modules/lodash/_flatRest.js
var require__flatRest = __commonJS((exports, module) => {
  function flatRest(func) {
    return setToString(overRest(func, undefined, flatten), func + "");
  }
  var flatten = require_flatten();
  var overRest = require__overRest();
  var setToString = require__setToString();
  module.exports = flatRest;
});

// node_modules/lodash/at.js
var require_at = __commonJS((exports, module) => {
  var baseAt = require__baseAt();
  var flatRest = require__flatRest();
  var at = flatRest(baseAt);
  module.exports = at;
});

// node_modules/lodash/_arrayEach.js
var require__arrayEach = __commonJS((exports, module) => {
  function arrayEach(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }
  module.exports = arrayEach;
});

// node_modules/lodash/_baseAssign.js
var require__baseAssign = __commonJS((exports, module) => {
  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }
  var copyObject = require__copyObject();
  var keys = require_keys();
  module.exports = baseAssign;
});

// node_modules/lodash/_baseAssignIn.js
var require__baseAssignIn = __commonJS((exports, module) => {
  function baseAssignIn(object, source) {
    return object && copyObject(source, keysIn(source), object);
  }
  var copyObject = require__copyObject();
  var keysIn = require_keysIn();
  module.exports = baseAssignIn;
});

// node_modules/lodash/_cloneBuffer.js
var require__cloneBuffer = __commonJS((exports, module) => {
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  var root = require__root();
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root.Buffer : undefined;
  var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined;
  module.exports = cloneBuffer;
});

// node_modules/lodash/_copyArray.js
var require__copyArray = __commonJS((exports, module) => {
  function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }
  module.exports = copyArray;
});

// node_modules/lodash/_copySymbols.js
var require__copySymbols = __commonJS((exports, module) => {
  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }
  var copyObject = require__copyObject();
  var getSymbols = require__getSymbols();
  module.exports = copySymbols;
});

// node_modules/lodash/_getSymbolsIn.js
var require__getSymbolsIn = __commonJS((exports, module) => {
  var arrayPush = require__arrayPush();
  var getPrototype = require__getPrototype();
  var getSymbols = require__getSymbols();
  var stubArray = require_stubArray();
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
    var result = [];
    while (object) {
      arrayPush(result, getSymbols(object));
      object = getPrototype(object);
    }
    return result;
  };
  module.exports = getSymbolsIn;
});

// node_modules/lodash/_copySymbolsIn.js
var require__copySymbolsIn = __commonJS((exports, module) => {
  function copySymbolsIn(source, object) {
    return copyObject(source, getSymbolsIn(source), object);
  }
  var copyObject = require__copyObject();
  var getSymbolsIn = require__getSymbolsIn();
  module.exports = copySymbolsIn;
});

// node_modules/lodash/_getAllKeysIn.js
var require__getAllKeysIn = __commonJS((exports, module) => {
  function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
  }
  var baseGetAllKeys = require__baseGetAllKeys();
  var getSymbolsIn = require__getSymbolsIn();
  var keysIn = require_keysIn();
  module.exports = getAllKeysIn;
});

// node_modules/lodash/_initCloneArray.js
var require__initCloneArray = __commonJS((exports, module) => {
  function initCloneArray(array) {
    var length = array.length, result = new array.constructor(length);
    if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = initCloneArray;
});

// node_modules/lodash/_cloneArrayBuffer.js
var require__cloneArrayBuffer = __commonJS((exports, module) => {
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
    return result;
  }
  var Uint8Array2 = require__Uint8Array();
  module.exports = cloneArrayBuffer;
});

// node_modules/lodash/_cloneDataView.js
var require__cloneDataView = __commonJS((exports, module) => {
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  var cloneArrayBuffer = require__cloneArrayBuffer();
  module.exports = cloneDataView;
});

// node_modules/lodash/_cloneRegExp.js
var require__cloneRegExp = __commonJS((exports, module) => {
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }
  var reFlags = /\w*$/;
  module.exports = cloneRegExp;
});

// node_modules/lodash/_cloneSymbol.js
var require__cloneSymbol = __commonJS((exports, module) => {
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  var Symbol2 = require__Symbol();
  var symbolProto = Symbol2 ? Symbol2.prototype : undefined;
  var symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
  module.exports = cloneSymbol;
});

// node_modules/lodash/_cloneTypedArray.js
var require__cloneTypedArray = __commonJS((exports, module) => {
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  var cloneArrayBuffer = require__cloneArrayBuffer();
  module.exports = cloneTypedArray;
});

// node_modules/lodash/_initCloneByTag.js
var require__initCloneByTag = __commonJS((exports, module) => {
  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);
      case boolTag:
      case dateTag:
        return new Ctor(+object);
      case dataViewTag:
        return cloneDataView(object, isDeep);
      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object, isDeep);
      case mapTag:
        return new Ctor;
      case numberTag:
      case stringTag:
        return new Ctor(object);
      case regexpTag:
        return cloneRegExp(object);
      case setTag:
        return new Ctor;
      case symbolTag:
        return cloneSymbol(object);
    }
  }
  var cloneArrayBuffer = require__cloneArrayBuffer();
  var cloneDataView = require__cloneDataView();
  var cloneRegExp = require__cloneRegExp();
  var cloneSymbol = require__cloneSymbol();
  var cloneTypedArray = require__cloneTypedArray();
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var symbolTag = "[object Symbol]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  module.exports = initCloneByTag;
});

// node_modules/lodash/_baseCreate.js
var require__baseCreate = __commonJS((exports, module) => {
  var isObject = require_isObject();
  var objectCreate = Object.create;
  var baseCreate = function() {
    function object() {
    }
    return function(proto) {
      if (!isObject(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object;
      object.prototype = undefined;
      return result;
    };
  }();
  module.exports = baseCreate;
});

// node_modules/lodash/_initCloneObject.js
var require__initCloneObject = __commonJS((exports, module) => {
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  var baseCreate = require__baseCreate();
  var getPrototype = require__getPrototype();
  var isPrototype = require__isPrototype();
  module.exports = initCloneObject;
});

// node_modules/lodash/_baseIsMap.js
var require__baseIsMap = __commonJS((exports, module) => {
  function baseIsMap(value) {
    return isObjectLike(value) && getTag(value) == mapTag;
  }
  var getTag = require__getTag();
  var isObjectLike = require_isObjectLike();
  var mapTag = "[object Map]";
  module.exports = baseIsMap;
});

// node_modules/lodash/isMap.js
var require_isMap = __commonJS((exports, module) => {
  var baseIsMap = require__baseIsMap();
  var baseUnary = require__baseUnary();
  var nodeUtil = require__nodeUtil();
  var nodeIsMap = nodeUtil && nodeUtil.isMap;
  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
  module.exports = isMap;
});

// node_modules/lodash/_baseIsSet.js
var require__baseIsSet = __commonJS((exports, module) => {
  function baseIsSet(value) {
    return isObjectLike(value) && getTag(value) == setTag;
  }
  var getTag = require__getTag();
  var isObjectLike = require_isObjectLike();
  var setTag = "[object Set]";
  module.exports = baseIsSet;
});

// node_modules/lodash/isSet.js
var require_isSet = __commonJS((exports, module) => {
  var baseIsSet = require__baseIsSet();
  var baseUnary = require__baseUnary();
  var nodeUtil = require__nodeUtil();
  var nodeIsSet = nodeUtil && nodeUtil.isSet;
  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
  module.exports = isSet;
});

// node_modules/lodash/_baseClone.js
var require__baseClone = __commonJS((exports, module) => {
  function baseClone(value, bitmask, customizer, key, object, stack) {
    var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== undefined) {
      return result;
    }
    if (!isObject(value)) {
      return value;
    }
    var isArr = isArray(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag || tag == argsTag || isFunc && !object) {
        result = isFlat || isFunc ? {} : initCloneObject(value);
        if (!isDeep) {
          return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag, isDeep);
      }
    }
    stack || (stack = new Stack);
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);
    if (isSet(value)) {
      value.forEach(function(subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });
    } else if (isMap(value)) {
      value.forEach(function(subValue, key2) {
        result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
    }
    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
    var props = isArr ? undefined : keysFunc(value);
    arrayEach(props || value, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value[key2];
      }
      assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
    return result;
  }
  var Stack = require__Stack();
  var arrayEach = require__arrayEach();
  var assignValue = require__assignValue();
  var baseAssign = require__baseAssign();
  var baseAssignIn = require__baseAssignIn();
  var cloneBuffer = require__cloneBuffer();
  var copyArray = require__copyArray();
  var copySymbols = require__copySymbols();
  var copySymbolsIn = require__copySymbolsIn();
  var getAllKeys = require__getAllKeys();
  var getAllKeysIn = require__getAllKeysIn();
  var getTag = require__getTag();
  var initCloneArray = require__initCloneArray();
  var initCloneByTag = require__initCloneByTag();
  var initCloneObject = require__initCloneObject();
  var isArray = require_isArray();
  var isBuffer = require_isBuffer();
  var isMap = require_isMap();
  var isObject = require_isObject();
  var isSet = require_isSet();
  var keys = require_keys();
  var keysIn = require_keysIn();
  var CLONE_DEEP_FLAG = 1;
  var CLONE_FLAT_FLAG = 2;
  var CLONE_SYMBOLS_FLAG = 4;
  var argsTag = "[object Arguments]";
  var arrayTag = "[object Array]";
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var errorTag = "[object Error]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var objectTag = "[object Object]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var symbolTag = "[object Symbol]";
  var weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  module.exports = baseClone;
});

// node_modules/lodash/clone.js
var require_clone = __commonJS((exports, module) => {
  function clone(value) {
    return baseClone(value, CLONE_SYMBOLS_FLAG);
  }
  var baseClone = require__baseClone();
  var CLONE_SYMBOLS_FLAG = 4;
  module.exports = clone;
});

// node_modules/lodash/_baseFilter.js
var require__baseFilter = __commonJS((exports, module) => {
  function baseFilter(collection, predicate) {
    var result = [];
    baseEach(collection, function(value, index, collection2) {
      if (predicate(value, index, collection2)) {
        result.push(value);
      }
    });
    return result;
  }
  var baseEach = require__baseEach();
  module.exports = baseFilter;
});

// node_modules/lodash/filter.js
var require_filter = __commonJS((exports, module) => {
  function filter(collection, predicate) {
    var func = isArray(collection) ? arrayFilter : baseFilter;
    return func(collection, baseIteratee(predicate, 3));
  }
  var arrayFilter = require__arrayFilter();
  var baseFilter = require__baseFilter();
  var baseIteratee = require__baseIteratee();
  var isArray = require_isArray();
  module.exports = filter;
});

// node_modules/lodash/_baseFindIndex.js
var require__baseFindIndex = __commonJS((exports, module) => {
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }
  module.exports = baseFindIndex;
});

// node_modules/lodash/_baseIsNaN.js
var require__baseIsNaN = __commonJS((exports, module) => {
  function baseIsNaN(value) {
    return value !== value;
  }
  module.exports = baseIsNaN;
});

// node_modules/lodash/_strictIndexOf.js
var require__strictIndexOf = __commonJS((exports, module) => {
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }
  module.exports = strictIndexOf;
});

// node_modules/lodash/_baseIndexOf.js
var require__baseIndexOf = __commonJS((exports, module) => {
  function baseIndexOf(array, value, fromIndex) {
    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var baseFindIndex = require__baseFindIndex();
  var baseIsNaN = require__baseIsNaN();
  var strictIndexOf = require__strictIndexOf();
  module.exports = baseIndexOf;
});

// node_modules/lodash/_baseValues.js
var require__baseValues = __commonJS((exports, module) => {
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }
  var arrayMap = require__arrayMap();
  module.exports = baseValues;
});

// node_modules/lodash/values.js
var require_values = __commonJS((exports, module) => {
  function values(object) {
    return object == null ? [] : baseValues(object, keys(object));
  }
  var baseValues = require__baseValues();
  var keys = require_keys();
  module.exports = values;
});

// node_modules/lodash/includes.js
var require_includes = __commonJS((exports, module) => {
  function includes(collection, value, fromIndex, guard) {
    collection = isArrayLike(collection) ? collection : values(collection);
    fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
    var length = collection.length;
    if (fromIndex < 0) {
      fromIndex = nativeMax(length + fromIndex, 0);
    }
    return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
  }
  var baseIndexOf = require__baseIndexOf();
  var isArrayLike = require_isArrayLike();
  var isString = require_isString();
  var toInteger = require_toInteger();
  var values = require_values();
  var nativeMax = Math.max;
  module.exports = includes;
});

// node_modules/lodash/isNumber.js
var require_isNumber = __commonJS((exports, module) => {
  function isNumber(value) {
    return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
  }
  var baseGetTag = require__baseGetTag();
  var isObjectLike = require_isObjectLike();
  var numberTag = "[object Number]";
  module.exports = isNumber;
});

// node_modules/cloudinary/lib/utils/encoding/smart_escape.js
var require_smart_escape = __commonJS((exports, module) => {
  function smart_escape(string, unsafe = /([^a-zA-Z0-9_.\-\/:]+)/g) {
    return string.replace(unsafe, function(match) {
      return match.split("").map(function(c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
      }).join("");
    });
  }
  module.exports = smart_escape;
});

// node_modules/cloudinary/lib/utils/parsing/consumeOption.js
var require_consumeOption = __commonJS((exports, module) => {
  function consumeOption(options, option_name, default_value) {
    let result = options[option_name];
    delete options[option_name];
    return result != null ? result : default_value;
  }
  module.exports = consumeOption;
});

// node_modules/cloudinary/lib/utils/parsing/toArray.js
var require_toArray = __commonJS((exports, module) => {
  function toArray(arg) {
    switch (true) {
      case arg == null:
        return [];
      case isArray(arg):
        return arg;
      default:
        return [arg];
    }
  }
  var isArray = require_isArray();
  module.exports = toArray;
});

// node_modules/cloudinary/lib/utils/encoding/base64Encode.js
var require_base64Encode = __commonJS((exports, module) => {
  function base64Encode(input) {
    if (!(input instanceof Buffer)) {
      input = Buffer.from(String(input), "binary");
    }
    return input.toString("base64");
  }
  exports.base64Encode = base64Encode;
});

// node_modules/cloudinary/lib/utils/encoding/base64EncodeURL.js
var require_base64EncodeURL = __commonJS((exports, module) => {
  function base64EncodeURL(sourceUrl) {
    try {
      sourceUrl = decodeURI(sourceUrl);
    } catch (error) {
    }
    sourceUrl = encodeURI(sourceUrl);
    return base64Encode(sourceUrl).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  }
  var { base64Encode } = require_base64Encode();
  exports.base64EncodeURL = base64EncodeURL;
});

// node_modules/cloudinary/lib/utils/encoding/encodeDoubleArray.js
var require_encodeDoubleArray = __commonJS((exports, module) => {
  function encodeDoubleArray(array) {
    array = toArray(array);
    if (!isArray(array[0])) {
      array = [array];
    }
    return array.map((e) => toArray(e).join(",")).join("|");
  }
  var isArray = require_isArray();
  var toArray = require_toArray();
  module.exports = encodeDoubleArray;
});

// node_modules/cloudinary/lib/auth_token.js
var require_auth_token = __commonJS((exports, module) => {
  function digest(message, key) {
    return crypto3.createHmac("sha256", Buffer.from(key, "hex")).update(message).digest("hex");
  }
  function escapeToLower(url) {
    const safeUrl = smart_escape(url, unsafe);
    return safeUrl.replace(/%../g, function(match) {
      return match.toLowerCase();
    });
  }
  var crypto3 = import.meta.require("crypto");
  var smart_escape = require_smart_escape();
  var unsafe = /([ "#%&'/:;<=>?@[\]^`{|}~]+)/g;
  module.exports = function(options) {
    const tokenName = options.token_name ? options.token_name : "__cld_token__";
    const tokenSeparator = "~";
    if (options.expiration == null) {
      if (options.duration != null) {
        let start = options.start_time != null ? options.start_time : Math.round(Date.now() / 1000);
        options.expiration = start + options.duration;
      } else {
        throw new Error("Must provide either expiration or duration");
      }
    }
    let tokenParts = [];
    if (options.ip != null) {
      tokenParts.push(`ip=${options.ip}`);
    }
    if (options.start_time != null) {
      tokenParts.push(`st=${options.start_time}`);
    }
    tokenParts.push(`exp=${options.expiration}`);
    if (options.acl != null) {
      if (Array.isArray(options.acl) === true) {
        options.acl = options.acl.join("!");
      }
      tokenParts.push(`acl=${escapeToLower(options.acl)}`);
    }
    let toSign = [...tokenParts];
    if (options.url != null && options.acl == null) {
      let url = escapeToLower(options.url);
      toSign.push(`url=${url}`);
    }
    let auth = digest(toSign.join(tokenSeparator), options.key);
    tokenParts.push(`hmac=${auth}`);
    if (!options.url && !options.acl) {
      throw "authToken must contain either an acl or a url property";
    }
    return `${tokenName}=${tokenParts.join(tokenSeparator)}`;
  };
});

// node_modules/cloudinary/lib/utils/utf8_encode.js
var require_utf8_encode = __commonJS((exports, module) => {
  module.exports = function utf8_encode(argString) {
    let c1, enc, n;
    if (argString == null) {
      return "";
    }
    let string = argString + "";
    let utftext = "";
    let start = 0;
    let end = 0;
    let stringl = string.length;
    n = 0;
    while (n < stringl) {
      c1 = string.charCodeAt(n);
      enc = null;
      if (c1 < 128) {
        end++;
      } else if (c1 > 127 && c1 < 2048) {
        enc = String.fromCharCode(c1 >> 6 | 192, c1 & 63 | 128);
      } else {
        enc = String.fromCharCode(c1 >> 12 | 224, c1 >> 6 & 63 | 128, c1 & 63 | 128);
      }
      if (enc !== null) {
        if (end > start) {
          utftext += string.slice(start, end);
        }
        utftext += enc;
        start = n + 1;
        end = start;
      }
      n++;
    }
    if (end > start) {
      utftext += string.slice(start, stringl);
    }
    return utftext;
  };
});

// node_modules/cloudinary/lib/utils/crc32.js
var require_crc32 = __commonJS((exports, module) => {
  function crc32(str) {
    let crc, i, iTop, table, x, y;
    str = utf8_encode(str);
    table = "00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D";
    crc = 0;
    x = 0;
    y = 0;
    crc = crc ^ -1;
    i = 0;
    iTop = str.length;
    while (i < iTop) {
      y = (crc ^ str.charCodeAt(i)) & 255;
      x = "0x" + table.substr(y * 9, 8);
      crc = crc >>> 8 ^ x;
      i++;
    }
    crc = crc ^ -1;
    if (crc < 0) {
      crc += 4294967296;
    }
    return crc;
  }
  var utf8_encode = require_utf8_encode();
  module.exports = crc32;
});

// node_modules/cloudinary/lib/utils/ensurePresenceOf.js
var require_ensurePresenceOf = __commonJS((exports, module) => {
  function ensurePresenceOf(parameters) {
    let missing = Object.keys(parameters).filter((key) => parameters[key] === undefined);
    if (missing.length) {
      console.error(missing.join(",") + " cannot be undefined");
    }
  }
  module.exports = ensurePresenceOf;
});

// node_modules/cloudinary/lib/utils/ensureOption.js
var require_ensureOption = __commonJS((exports, module) => {
  function defaults(defaultOptions) {
    return function ensureOption(options, name, defaultValue) {
      let value;
      if (typeof options[name] !== "undefined") {
        value = options[name];
      } else if (typeof defaultOptions[name] !== "undefined") {
        value = defaultOptions[name];
      } else if (typeof defaultValue !== "undefined") {
        value = defaultValue;
      } else {
        throw new Error(`Must supply ${name}`);
      }
      return value;
    };
  }
  module.exports = defaults({});
  module.exports.defaults = defaults;
});

// node_modules/cloudinary/lib/utils/isRemoteUrl.js
var require_isRemoteUrl = __commonJS((exports, module) => {
  function isRemoteUrl(url) {
    const SUBSTRING_LENGTH = 120;
    const urlSubstring = isString(url) && url.substring(0, SUBSTRING_LENGTH);
    return isString(url) && /^ftp:|^https?:|^gs:|^s3:|^data:([\w-.]+\/[\w-.]+(\+[\w-.]+)?)?(;[\w-.]+=[\w-.]+)*;base64,([a-zA-Z0-9\/+\n=]+)$/.test(urlSubstring);
  }
  var isString = require_isString();
  module.exports = isRemoteUrl;
});

// node_modules/cloudinary/lib/utils/analytics/getSDKVersions.js
var require_getSDKVersions = __commonJS((exports, module) => {
  function readSdkSemver() {
    const pkgJsonPath = path.join(__dirname, "../../../package.json");
    try {
      const pkgJSONFile = fs.readFileSync(pkgJsonPath, "utf-8");
      return JSON.parse(pkgJSONFile).version;
    } catch (e) {
      if (e.code === "ENOENT") {
        return "0.0.0";
      }
      return "n/a";
    }
  }
  function getSDKVersions(useSDKVersion = "default", useNodeVersion = "default") {
    const sdkSemver = useSDKVersion === "default" ? readSdkSemver() : useSDKVersion;
    const techVersion = useNodeVersion === "default" ? process.versions.node : useNodeVersion;
    const product = "A";
    return {
      sdkSemver,
      techVersion,
      sdkCode,
      product
    };
  }
  var __dirname = "D:\\Workspace\\DoAnTotNghiep\\GoatEnglishApi\\node_modules\\cloudinary\\lib\\utils\\analytics";
  var fs = import.meta.require("fs");
  var path = import.meta.require("path");
  var sdkCode = "M";
  module.exports = getSDKVersions;
});

// node_modules/cloudinary/lib/utils/analytics/removePatchFromSemver.js
var require_removePatchFromSemver = __commonJS((exports, module) => {
  module.exports = (semVerStr) => {
    let parts = semVerStr.split(".");
    return `${parts[0]}.${parts[1]}`;
  };
});

// node_modules/cloudinary/lib/utils/analytics/stringPad.js
var require_stringPad = __commonJS((exports, module) => {
  function repeatStringNumTimes(string, times) {
    let repeatedString = "";
    while (times > 0) {
      repeatedString += string;
      times--;
    }
    return repeatedString;
  }
  module.exports = (value, targetLength, padString) => {
    targetLength = targetLength >> 0;
    padString = String(typeof padString !== "undefined" ? padString : " ");
    if (value.length > targetLength) {
      return String(value);
    } else {
      targetLength = targetLength - value.length;
      if (targetLength > padString.length) {
        padString += repeatStringNumTimes(padString, targetLength / padString.length);
      }
      return padString.slice(0, targetLength) + String(value);
    }
  };
});

// node_modules/cloudinary/lib/utils/analytics/reverseVersion.js
var require_reverseVersion = __commonJS((exports, module) => {
  var stringPad = require_stringPad();
  module.exports = (semVer) => {
    if (semVer.split(".").length < 2) {
      throw new Error("invalid semVer, must have at least two segments");
    }
    return semVer.split(".").reverse().map((segment) => {
      return stringPad(segment, 2, "0");
    }).join(".");
  };
});

// node_modules/cloudinary/lib/utils/encoding/base64Map.js
var require_base64Map = __commonJS((exports, module) => {
  var stringPad = require_stringPad();
  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var num = 0;
  var base64Map = {};
  [...chars].forEach((char) => {
    let key = num.toString(2);
    key = stringPad(key, 6, "0");
    base64Map[key] = char;
    num++;
  });
  module.exports = base64Map;
});

// node_modules/cloudinary/lib/utils/analytics/encodeVersion.js
var require_encodeVersion = __commonJS((exports, module) => {
  var reverseVersion = require_reverseVersion();
  var stringPad = require_stringPad();
  var base64Map = require_base64Map();
  module.exports = (semVer) => {
    let strResult = "";
    let parts = semVer.split(".").length;
    let paddedStringLength = parts * 6;
    let paddedReversedSemver = reverseVersion(semVer);
    let num = parseInt(paddedReversedSemver.split(".").join(""));
    let paddedBinary = num.toString(2);
    paddedBinary = stringPad(paddedBinary, paddedStringLength, "0");
    if (paddedBinary.length % 6 !== 0) {
      throw "Version must be smaller than 43.21.26)";
    }
    paddedBinary.match(/.{1,6}/g).forEach((bitString) => {
      strResult += base64Map[bitString];
    });
    return strResult;
  };
});

// node_modules/cloudinary/lib/utils/analytics/index.js
var require_analytics = __commonJS((exports, module) => {
  function getSDKAnalyticsSignature(analyticsOptions = {}) {
    try {
      const twoPartVersion = removePatchFromSemver(analyticsOptions.techVersion);
      const encodedSDKVersion = encodeVersion(analyticsOptions.sdkSemver);
      const encodedTechVersion = encodeVersion(twoPartVersion);
      const featureCode = analyticsOptions.feature;
      const SDKCode = analyticsOptions.sdkCode;
      const product = analyticsOptions.product;
      const algoVersion = "B";
      return `${algoVersion}${product}${SDKCode}${encodedSDKVersion}${encodedTechVersion}${featureCode}`;
    } catch (e) {
      return "E";
    }
  }
  function getAnalyticsOptions(options) {
    let analyticsOptions = {
      sdkSemver: options.sdkSemver,
      techVersion: options.techVersion,
      sdkCode: options.sdkCode,
      product: options.product,
      feature: "0"
    };
    if (options.urlAnalytics) {
      if (options.accessibility) {
        analyticsOptions.feature = "D";
      }
      if (options.loading === "lazy") {
        analyticsOptions.feature = "C";
      }
      if (options.responsive) {
        analyticsOptions.feature = "A";
      }
      if (options.placeholder) {
        analyticsOptions.feature = "B";
      }
      return analyticsOptions;
    } else {
      return {};
    }
  }
  var removePatchFromSemver = require_removePatchFromSemver();
  var encodeVersion = require_encodeVersion();
  module.exports = {
    getSDKAnalyticsSignature,
    getAnalyticsOptions
  };
});

// node_modules/cloudinary/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    author: "Cloudinary <info@cloudinary.com>",
    name: "cloudinary",
    description: "Cloudinary NPM for node.js integration",
    version: "2.5.1",
    homepage: "https://cloudinary.com",
    license: "MIT",
    repository: {
      type: "git",
      url: "https://github.com/cloudinary/cloudinary_npm.git"
    },
    main: "cloudinary.js",
    dependencies: {
      lodash: "^4.17.21",
      q: "^1.5.1"
    },
    devDependencies: {
      "@types/mocha": "^7.0.2",
      "@types/node": "^13.5.0",
      "@types/expect.js": "^0.3.29",
      "date-fns": "^2.16.1",
      dotenv: "4.x",
      dtslint: "^0.9.1",
      eslint: "^6.8.0",
      "eslint-config-airbnb-base": "^14.2.1",
      "eslint-plugin-import": "^2.20.2",
      "expect.js": "0.3.x",
      glob: "^7.1.6",
      jsdoc: "3.5.5",
      jsdom: "^9.12.0",
      "jsdom-global": "2.1.1",
      mocha: "^6.2.3",
      "mock-fs": "^4.12.0",
      nyc: "^13.3.0",
      rimraf: "^3.0.0",
      sinon: "^6.1.4",
      typescript: "^3.7.5",
      "webpack-cli": "^3.2.1"
    },
    files: [
      "lib/**/*",
      "cloudinary.js",
      "babel.config.js",
      "package.json",
      "types/index.d.ts"
    ],
    types: "types",
    scripts: {
      test: "tools/scripts/test.sh",
      "test:unit": "tools/scripts/test.es6.unit.sh",
      "test-with-temp-cloud": "tools/scripts/tests-with-temp-cloud.sh",
      dtslint: "tools/scripts/ditslint.sh",
      lint: "tools/scripts/lint.sh",
      coverage: "tools/scripts/test.es6.sh --coverage",
      "test-es6": "tools/scripts/test.es6.sh",
      docs: "tools/scripts/docs.sh"
    },
    engines: {
      node: ">=9"
    }
  };
});

// node_modules/cloudinary/lib/utils/consts.js
var require_consts = __commonJS((exports, module) => {
  var DEFAULT_RESPONSIVE_WIDTH_TRANSFORMATION = {
    width: "auto",
    crop: "limit"
  };
  var DEFAULT_POSTER_OPTIONS = {
    format: "jpg",
    resource_type: "video"
  };
  var DEFAULT_VIDEO_SOURCE_TYPES = ["webm", "mp4", "ogv"];
  var CONDITIONAL_OPERATORS = {
    "=": "eq",
    "!=": "ne",
    "<": "lt",
    ">": "gt",
    "<=": "lte",
    ">=": "gte",
    "&&": "and",
    "||": "or",
    "*": "mul",
    "/": "div",
    "+": "add",
    "-": "sub",
    "^": "pow"
  };
  var SIMPLE_PARAMS = [
    ["audio_codec", "ac"],
    ["audio_frequency", "af"],
    ["bit_rate", "br"],
    ["color_space", "cs"],
    ["default_image", "d"],
    ["delay", "dl"],
    ["density", "dn"],
    ["duration", "du"],
    ["end_offset", "eo"],
    ["fetch_format", "f"],
    ["gravity", "g"],
    ["page", "pg"],
    ["prefix", "p"],
    ["start_offset", "so"],
    ["streaming_profile", "sp"],
    ["video_codec", "vc"],
    ["video_sampling", "vs"]
  ];
  var PREDEFINED_VARS = {
    aspect_ratio: "ar",
    aspectRatio: "ar",
    current_page: "cp",
    currentPage: "cp",
    duration: "du",
    face_count: "fc",
    faceCount: "fc",
    height: "h",
    initial_aspect_ratio: "iar",
    initial_height: "ih",
    initial_width: "iw",
    initialAspectRatio: "iar",
    initialHeight: "ih",
    initialWidth: "iw",
    initial_duration: "idu",
    initialDuration: "idu",
    page_count: "pc",
    page_x: "px",
    page_y: "py",
    pageCount: "pc",
    pageX: "px",
    pageY: "py",
    tags: "tags",
    width: "w"
  };
  var TRANSFORMATION_PARAMS = [
    "angle",
    "aspect_ratio",
    "audio_codec",
    "audio_frequency",
    "background",
    "bit_rate",
    "border",
    "color",
    "color_space",
    "crop",
    "default_image",
    "delay",
    "density",
    "dpr",
    "duration",
    "effect",
    "end_offset",
    "fetch_format",
    "flags",
    "fps",
    "gravity",
    "height",
    "if",
    "keyframe_interval",
    "offset",
    "opacity",
    "overlay",
    "page",
    "prefix",
    "quality",
    "radius",
    "raw_transformation",
    "responsive_width",
    "size",
    "start_offset",
    "streaming_profile",
    "transformation",
    "underlay",
    "variables",
    "video_codec",
    "video_sampling",
    "width",
    "x",
    "y",
    "zoom"
  ];
  var LAYER_KEYWORD_PARAMS = {
    font_weight: "normal",
    font_style: "normal",
    text_decoration: "none",
    text_align: null,
    stroke: "none"
  };
  var UPLOAD_PREFIX = "https://api.cloudinary.com";
  var SUPPORTED_SIGNATURE_ALGORITHMS = ["sha1", "sha256"];
  var DEFAULT_SIGNATURE_ALGORITHM = "sha1";
  module.exports = {
    DEFAULT_RESPONSIVE_WIDTH_TRANSFORMATION,
    DEFAULT_POSTER_OPTIONS,
    DEFAULT_VIDEO_SOURCE_TYPES,
    CONDITIONAL_OPERATORS,
    PREDEFINED_VARS,
    LAYER_KEYWORD_PARAMS,
    TRANSFORMATION_PARAMS,
    SIMPLE_PARAMS,
    UPLOAD_PREFIX,
    SUPPORTED_SIGNATURE_ALGORITHMS,
    DEFAULT_SIGNATURE_ALGORITHM
  };
});

// node_modules/cloudinary/lib/utils/index.js
var require_utils = __commonJS((exports, module) => {
  function generate_auth_token(options) {
    let token_options = Object.assign({}, config().auth_token, options);
    return generate_token(token_options);
  }
  function getUserAgent() {
    return isEmpty(utils.userPlatform) ? `${utils.USER_AGENT}` : `${utils.userPlatform} ${utils.USER_AGENT}`;
  }
  function textStyle(layer) {
    let keywords = [];
    let style = "";
    if (!isEmpty(layer.text_style)) {
      return layer.text_style;
    }
    Object.keys(LAYER_KEYWORD_PARAMS).forEach((attr) => {
      let default_value = LAYER_KEYWORD_PARAMS[attr];
      let attr_value = layer[attr] || default_value;
      if (attr_value !== default_value) {
        keywords.push(attr_value);
      }
    });
    Object.keys(layer).forEach((attr) => {
      if (attr === "letter_spacing" || attr === "line_spacing") {
        keywords.push(`${attr}_${layer[attr]}`);
      }
      if (attr === "font_hinting") {
        keywords.push(`${attr.split("_").pop()}_${layer[attr]}`);
      }
      if (attr === "font_antialiasing") {
        keywords.push(`antialias_${layer[attr]}`);
      }
    });
    if (layer.hasOwnProperty("font_size") || !isEmpty(keywords)) {
      if (!layer.font_size)
        throw new Error("Must supply font_size for text in overlay/underlay");
      if (!layer.font_family)
        throw new Error("Must supply font_family for text in overlay/underlay");
      keywords.unshift(layer.font_size);
      keywords.unshift(layer.font_family);
      style = compact(keywords).join("_");
    }
    return style;
  }
  function normalize_expression(expression) {
    if (!isString(expression) || expression.length === 0 || expression.match(/^!.+!$/)) {
      return expression;
    }
    const operators = "\\|\\||>=|<=|&&|!=|>|=|<|/|-|\\^|\\+|\\*";
    const operatorsPattern = "((" + operators + ")(?=[ _]))";
    const operatorsReplaceRE = new RegExp(operatorsPattern, "g");
    expression = expression.replace(operatorsReplaceRE, (match) => CONDITIONAL_OPERATORS[match]);
    const predefinedVarsPattern = "(" + Object.keys(PREDEFINED_VARS).map((v) => `:${v}|${v}`).join("|") + ")";
    const userVariablePattern = "(\\$_*[^_ ]+)";
    const variablesReplaceRE = new RegExp(`${userVariablePattern}|${predefinedVarsPattern}`, "g");
    expression = expression.replace(variablesReplaceRE, (match) => PREDEFINED_VARS[match] || match);
    return expression.replace(/[ _]+/g, "_");
  }
  function process_custom_function(customFunction) {
    if (!isObject(customFunction)) {
      return customFunction;
    }
    if (customFunction.function_type === "remote") {
      const encodedSource = base64EncodeURL(customFunction.source);
      return [customFunction.function_type, encodedSource].join(":");
    }
    return [customFunction.function_type, customFunction.source].join(":");
  }
  function process_custom_pre_function(customPreFunction) {
    let result = process_custom_function(customPreFunction);
    return utils.isString(result) ? `pre:${result}` : null;
  }
  function process_if(ifValue) {
    return ifValue ? "if_" + normalize_expression(ifValue) : ifValue;
  }
  function process_layer(layer) {
    if (isString(layer)) {
      let resourceType = null;
      let layerUrl = "";
      let fetchLayerBegin = "fetch:";
      if (layer.startsWith(fetchLayerBegin)) {
        layerUrl = layer.substring(fetchLayerBegin.length);
      } else if (layer.indexOf(":fetch:", 0) !== -1) {
        const parts = layer.split(":", 3);
        resourceType = parts[0];
        layerUrl = parts[2];
      } else {
        return layer;
      }
      layer = {
        url: layerUrl,
        type: "fetch"
      };
      if (resourceType) {
        layer.resource_type = resourceType;
      }
    }
    if (typeof layer !== "object") {
      return layer;
    }
    let {
      resource_type,
      text,
      type,
      public_id,
      format,
      url: fetchUrl
    } = layer;
    const components = [];
    if (!isEmpty(text) && isEmpty(resource_type)) {
      resource_type = "text";
    }
    if (!isEmpty(fetchUrl) && isEmpty(type)) {
      type = "fetch";
    }
    if (!isEmpty(public_id) && !isEmpty(format)) {
      public_id = `${public_id}.${format}`;
    }
    if (isEmpty(public_id) && resource_type !== "text" && type !== "fetch") {
      throw new Error("Must supply public_id for non-text overlay");
    }
    if (!isEmpty(resource_type) && resource_type !== "image") {
      components.push(resource_type);
    }
    if (!isEmpty(type) && type !== "upload") {
      components.push(type);
    }
    if (resource_type === "text" || resource_type === "subtitles") {
      if (isEmpty(public_id) && isEmpty(text)) {
        throw new Error("Must supply either text or public_in in overlay");
      }
      const textOptions = textStyle(layer);
      if (!isEmpty(textOptions)) {
        components.push(textOptions);
      }
      if (!isEmpty(public_id)) {
        public_id = public_id.replace("/", ":");
        components.push(public_id);
      }
      if (!isEmpty(text)) {
        const variablesRegex = new RegExp(/(\$\([a-zA-Z]\w+\))/g);
        const textDividedByVariables = text.split(variablesRegex).filter((x) => x);
        const encodedParts = textDividedByVariables.map((subText) => {
          const matches = variablesRegex[Symbol.match](subText);
          const isVariable = matches ? matches.length > 0 : false;
          if (isVariable) {
            return subText;
          }
          return encodeCurlyBraces(encodeURIComponent(smart_escape(subText, new RegExp(/([,\/])/g))));
        });
        components.push(encodedParts.join(""));
      }
    } else if (type === "fetch") {
      const encodedUrl = base64EncodeURL(fetchUrl);
      components.push(encodedUrl);
    } else {
      public_id = public_id.replace("/", ":");
      components.push(public_id);
    }
    return components.join(":");
  }
  function replaceAllSubstrings(string, search, replacement = "") {
    return string.split(search).join(replacement);
  }
  function encodeCurlyBraces(input) {
    return replaceAllSubstrings(replaceAllSubstrings(input, "(", "%28"), ")", "%29");
  }
  function process_radius(radius) {
    if (!radius) {
      return radius;
    }
    if (!isArray(radius)) {
      radius = [radius];
    }
    if (radius.length === 0 || radius.length > 4) {
      throw new Error("Radius array should contain between 1 and 4 values");
    }
    if (radius.findIndex((x) => x === null) >= 0) {
      throw new Error("Corner: Cannot be null");
    }
    return radius.map(normalize_expression).join(":");
  }
  function build_multi_and_sprite_params(tagOrOptions, options) {
    let tag = null;
    if (typeof tagOrOptions === "string") {
      tag = tagOrOptions;
    } else {
      if (isEmpty(options)) {
        options = tagOrOptions;
      } else {
        throw new Error("First argument must be a tag when additional options are passed");
      }
      tag = null;
    }
    if (!options && !tag) {
      throw new Error("Either tag or urls are required");
    }
    if (!options) {
      options = {};
    }
    const urls = options.urls;
    const transformation = generate_transformation_string(extend({}, options, {
      fetch_format: options.format
    }));
    return {
      tag,
      transformation,
      urls,
      timestamp: utils.timestamp(),
      async: options.async,
      notification_url: options.notification_url
    };
  }
  function build_upload_params(options) {
    let params = {
      access_mode: options.access_mode,
      allowed_formats: options.allowed_formats && toArray(options.allowed_formats).join(","),
      asset_folder: options.asset_folder,
      async: utils.as_safe_bool(options.async),
      backup: utils.as_safe_bool(options.backup),
      callback: options.callback,
      cinemagraph_analysis: utils.as_safe_bool(options.cinemagraph_analysis),
      colors: utils.as_safe_bool(options.colors),
      display_name: options.display_name,
      discard_original_filename: utils.as_safe_bool(options.discard_original_filename),
      eager: utils.build_eager(options.eager),
      eager_async: utils.as_safe_bool(options.eager_async),
      eager_notification_url: options.eager_notification_url,
      eval: options.eval,
      exif: utils.as_safe_bool(options.exif),
      faces: utils.as_safe_bool(options.faces),
      folder: options.folder,
      format: options.format,
      filename_override: options.filename_override,
      image_metadata: utils.as_safe_bool(options.image_metadata),
      media_metadata: utils.as_safe_bool(options.media_metadata),
      invalidate: utils.as_safe_bool(options.invalidate),
      moderation: options.moderation,
      notification_url: options.notification_url,
      overwrite: utils.as_safe_bool(options.overwrite),
      phash: utils.as_safe_bool(options.phash),
      proxy: options.proxy,
      public_id: options.public_id,
      public_id_prefix: options.public_id_prefix,
      quality_analysis: utils.as_safe_bool(options.quality_analysis),
      responsive_breakpoints: utils.generate_responsive_breakpoints_string(options.responsive_breakpoints),
      return_delete_token: utils.as_safe_bool(options.return_delete_token),
      timestamp: options.timestamp || exports.timestamp(),
      transformation: decodeURIComponent(utils.generate_transformation_string(clone(options))),
      type: options.type,
      unique_filename: utils.as_safe_bool(options.unique_filename),
      upload_preset: options.upload_preset,
      use_filename: utils.as_safe_bool(options.use_filename),
      use_filename_as_display_name: utils.as_safe_bool(options.use_filename_as_display_name),
      quality_override: options.quality_override,
      accessibility_analysis: utils.as_safe_bool(options.accessibility_analysis),
      use_asset_folder_as_public_id_prefix: utils.as_safe_bool(options.use_asset_folder_as_public_id_prefix),
      visual_search: utils.as_safe_bool(options.visual_search),
      on_success: options.on_success,
      auto_transcription: options.auto_transcription,
      auto_chaptering: utils.as_safe_bool(options.auto_chaptering)
    };
    return utils.updateable_resource_params(options, params);
  }
  function encode_key_value(arg) {
    if (!isObject(arg)) {
      return arg;
    }
    return entries(arg).map(([k, v]) => `${k}=${v}`).join("|");
  }
  function escapeMetadataValue(value) {
    return value.toString().replace(/([=|])/g, "\\$&");
  }
  function encode_context(metadataObj) {
    if (!isObject(metadataObj)) {
      return metadataObj;
    }
    return entries(metadataObj).map(([key, value]) => {
      if (isString(value)) {
        return `${key}=${escapeMetadataValue(value)}`;
      } else if (isArray(value)) {
        let values = value.map((innerVal) => {
          return `\"${escapeMetadataValue(innerVal)}\"`;
        }).join(",");
        return `${key}=[${values}]`;
      } else if (Number.isInteger(value)) {
        return `${key}=${escapeMetadataValue(String(value))}`;
      } else {
        return value.toString();
      }
    }).join("|");
  }
  function build_eager(transformations) {
    return toArray(transformations).map((transformation) => {
      const transformationString = utils.generate_transformation_string(clone(transformation));
      const format = transformation.format;
      return format == null ? transformationString : `${transformationString}/${format}`;
    }).join("|");
  }
  function build_custom_headers(headers) {
    switch (true) {
      case headers == null:
        return;
      case isArray(headers):
        return headers.join("\n");
      case isObject(headers):
        return entries(headers).map(([k, v]) => `${k}:${v}`).join("\n");
      default:
        return headers;
    }
  }
  function generate_transformation_string(options) {
    if (utils.isString(options)) {
      return options;
    }
    if (isArray(options)) {
      return options.map((t) => utils.generate_transformation_string(clone(t))).filter(utils.present).join("/");
    }
    let responsive_width = consumeOption(options, "responsive_width", config().responsive_width);
    let width = options.width;
    let height = options.height;
    let size = consumeOption(options, "size");
    if (size) {
      [width, height] = size.split("x");
      [options.width, options.height] = [width, height];
    }
    let has_layer = options.overlay || options.underlay;
    let crop = consumeOption(options, "crop");
    let angle = toArray(consumeOption(options, "angle")).join(".");
    let no_html_sizes = has_layer || utils.present(angle) || crop === "fit" || crop === "limit" || responsive_width;
    if (width && (width.toString().indexOf("auto") === 0 || no_html_sizes || parseFloat(width) < 1)) {
      delete options.width;
    }
    if (height && (no_html_sizes || parseFloat(height) < 1)) {
      delete options.height;
    }
    let background = consumeOption(options, "background");
    background = background && background.replace(/^#/, "rgb:");
    let color = consumeOption(options, "color");
    color = color && color.replace(/^#/, "rgb:");
    let base_transformations = toArray(consumeOption(options, "transformation", []));
    let named_transformation = [];
    if (base_transformations.some(isObject)) {
      base_transformations = base_transformations.map((tr) => utils.generate_transformation_string(isObject(tr) ? clone(tr) : { transformation: tr }));
    } else {
      named_transformation = base_transformations.join(".");
      base_transformations = [];
    }
    let effect = consumeOption(options, "effect");
    if (isArray(effect)) {
      effect = effect.join(":");
    } else if (isObject(effect)) {
      effect = entries(effect).map(([key, value]) => `${key}:${value}`);
    }
    let border = consumeOption(options, "border");
    if (isObject(border)) {
      border = `${border.width != null ? border.width : 2}px_solid_${(border.color != null ? border.color : "black").replace(/^#/, "rgb:")}`;
    } else if (/^\d+$/.exec(border)) {
      options.border = border;
      border = undefined;
    }
    let flags = toArray(consumeOption(options, "flags")).join(".");
    let dpr = consumeOption(options, "dpr", config().dpr);
    if (options.offset != null) {
      [options.start_offset, options.end_offset] = split_range(consumeOption(options, "offset"));
    }
    if (options.start_offset) {
      options.start_offset = normalize_expression(options.start_offset);
    }
    if (options.end_offset) {
      options.end_offset = normalize_expression(options.end_offset);
    }
    let overlay = process_layer(consumeOption(options, "overlay"));
    let radius = process_radius(consumeOption(options, "radius"));
    let underlay = process_layer(consumeOption(options, "underlay"));
    let ifValue = process_if(consumeOption(options, "if"));
    let custom_function = process_custom_function(consumeOption(options, "custom_function"));
    let custom_pre_function = process_custom_pre_function(consumeOption(options, "custom_pre_function"));
    let fps = consumeOption(options, "fps");
    if (isArray(fps)) {
      fps = fps.join("-");
    }
    let params = {
      a: normalize_expression(angle),
      ar: normalize_expression(consumeOption(options, "aspect_ratio")),
      b: background,
      bo: border,
      c: crop,
      co: color,
      dpr: normalize_expression(dpr),
      e: normalize_expression(effect),
      fl: flags,
      fn: custom_function || custom_pre_function,
      fps,
      h: normalize_expression(height),
      ki: normalize_expression(consumeOption(options, "keyframe_interval")),
      l: overlay,
      o: normalize_expression(consumeOption(options, "opacity")),
      q: normalize_expression(consumeOption(options, "quality")),
      r: radius,
      t: named_transformation,
      u: underlay,
      w: normalize_expression(width),
      x: normalize_expression(consumeOption(options, "x")),
      y: normalize_expression(consumeOption(options, "y")),
      z: normalize_expression(consumeOption(options, "zoom"))
    };
    SIMPLE_PARAMS.forEach(([name, short]) => {
      let value = consumeOption(options, name);
      if (value !== undefined) {
        params[short] = value;
      }
    });
    if (params.vc != null) {
      params.vc = process_video_params(params.vc);
    }
    ["so", "eo", "du"].forEach((short) => {
      if (params[short] !== undefined) {
        params[short] = norm_range_value(params[short]);
      }
    });
    let variablesParam = consumeOption(options, "variables", []);
    let variables = entries(options).filter(([key, value]) => key.startsWith("$")).map(([key, value]) => {
      delete options[key];
      return `${key}_${normalize_expression(value)}`;
    }).sort().concat(variablesParam.map(([name, value]) => `${name}_${normalize_expression(value)}`)).join(",");
    let transformations = entries(params).filter(([key, value]) => utils.present(value)).map(([key, value]) => key + "_" + value).sort().join(",");
    let raw_transformation = consumeOption(options, "raw_transformation");
    transformations = compact([ifValue, variables, transformations, raw_transformation]).join(",");
    base_transformations.push(transformations);
    transformations = base_transformations;
    if (responsive_width) {
      let responsive_width_transformation = config().responsive_width_transformation || DEFAULT_RESPONSIVE_WIDTH_TRANSFORMATION;
      transformations.push(utils.generate_transformation_string(clone(responsive_width_transformation)));
    }
    if (String(width).startsWith("auto") || responsive_width) {
      options.responsive = true;
    }
    if (dpr === "auto") {
      options.hidpi = true;
    }
    return filter(transformations, utils.present).join("/");
  }
  function updateable_resource_params(options, params = {}) {
    if (options.access_control != null) {
      params.access_control = utils.jsonArrayParam(options.access_control);
    }
    if (options.auto_tagging != null) {
      params.auto_tagging = options.auto_tagging;
    }
    if (options.background_removal != null) {
      params.background_removal = options.background_removal;
    }
    if (options.categorization != null) {
      params.categorization = options.categorization;
    }
    if (options.context != null) {
      params.context = utils.encode_context(options.context);
    }
    if (options.metadata != null) {
      params.metadata = utils.encode_context(options.metadata);
    }
    if (options.custom_coordinates != null) {
      params.custom_coordinates = encodeDoubleArray(options.custom_coordinates);
    }
    if (options.detection != null) {
      params.detection = options.detection;
    }
    if (options.face_coordinates != null) {
      params.face_coordinates = encodeDoubleArray(options.face_coordinates);
    }
    if (options.headers != null) {
      params.headers = utils.build_custom_headers(options.headers);
    }
    if (options.notification_url != null) {
      params.notification_url = options.notification_url;
    }
    if (options.ocr != null) {
      params.ocr = options.ocr;
    }
    if (options.raw_convert != null) {
      params.raw_convert = options.raw_convert;
    }
    if (options.similarity_search != null) {
      params.similarity_search = options.similarity_search;
    }
    if (options.tags != null) {
      params.tags = toArray(options.tags).join(",");
    }
    if (options.quality_override != null) {
      params.quality_override = options.quality_override;
    }
    if (options.asset_folder != null) {
      params.asset_folder = options.asset_folder;
    }
    if (options.display_name != null) {
      params.display_name = options.display_name;
    }
    if (options.unique_display_name != null) {
      params.unique_display_name = options.unique_display_name;
    }
    if (options.visual_search != null) {
      params.visual_search = options.visual_search;
    }
    if (options.regions != null) {
      params.regions = JSON.stringify(options.regions);
    }
    const autoTranscription = options.auto_transcription;
    if (autoTranscription != null) {
      if (typeof autoTranscription === "boolean") {
        params.auto_transcription = utils.as_safe_bool(autoTranscription);
      } else {
        const isAutoTranscriptionObject = typeof autoTranscription === "object" && !Array.isArray(autoTranscription);
        if (isAutoTranscriptionObject && Object.keys(autoTranscription).includes("translate")) {
          params.auto_transcription = JSON.stringify(autoTranscription);
        }
      }
    }
    return params;
  }
  function extractUrlParams(options) {
    return pickOnlyExistingValues(options, ...URL_KEYS);
  }
  function extractTransformationParams(options) {
    return pickOnlyExistingValues(options, ...TRANSFORMATION_PARAMS);
  }
  function patchFetchFormat(options = {}) {
    if (options.type === "fetch") {
      if (options.fetch_format == null) {
        options.fetch_format = consumeOption(options, "format");
      }
    }
  }
  function build_distribution_domain(source, options) {
    const cloud_name = consumeOption(options, "cloud_name", config().cloud_name);
    if (!cloud_name) {
      throw new Error("Must supply cloud_name in tag or in configuration");
    }
    let secure = consumeOption(options, "secure", true);
    const ssl_detected = consumeOption(options, "ssl_detected", config().ssl_detected);
    if (secure === null) {
      secure = ssl_detected || config().secure;
    }
    const private_cdn = consumeOption(options, "private_cdn", config().private_cdn);
    const cname = consumeOption(options, "cname", config().cname);
    const secure_distribution = consumeOption(options, "secure_distribution", config().secure_distribution);
    const cdn_subdomain = consumeOption(options, "cdn_subdomain", config().cdn_subdomain);
    const secure_cdn_subdomain = consumeOption(options, "secure_cdn_subdomain", config().secure_cdn_subdomain);
    return unsigned_url_prefix(source, cloud_name, private_cdn, cdn_subdomain, secure_cdn_subdomain, cname, secure, secure_distribution);
  }
  function url(public_id, options = {}) {
    let signature, source_to_sign;
    utils.patchFetchFormat(options);
    let type = consumeOption(options, "type", null);
    let transformation = utils.generate_transformation_string(options);
    let resource_type = consumeOption(options, "resource_type", "image");
    let version = consumeOption(options, "version");
    let force_version = consumeOption(options, "force_version", config().force_version);
    if (force_version == null) {
      force_version = true;
    }
    let long_url_signature = !!consumeOption(options, "long_url_signature", config().long_url_signature);
    let format = consumeOption(options, "format");
    let shorten = consumeOption(options, "shorten", config().shorten);
    let sign_url = consumeOption(options, "sign_url", config().sign_url);
    let api_secret = consumeOption(options, "api_secret", config().api_secret);
    let url_suffix = consumeOption(options, "url_suffix");
    let use_root_path = consumeOption(options, "use_root_path", config().use_root_path);
    let signature_algorithm = consumeOption(options, "signature_algorithm", config().signature_algorithm || DEFAULT_SIGNATURE_ALGORITHM);
    if (long_url_signature) {
      signature_algorithm = "sha256";
    }
    let auth_token = consumeOption(options, "auth_token");
    if (auth_token !== false) {
      auth_token = exports.merge(config().auth_token, auth_token);
    }
    let preloaded = /^(image|raw)\/([a-z0-9_]+)\/v(\d+)\/([^#]+)$/.exec(public_id);
    if (preloaded) {
      resource_type = preloaded[1];
      type = preloaded[2];
      version = preloaded[3];
      public_id = preloaded[4];
    }
    let original_source = public_id;
    if (public_id == null) {
      return original_source;
    }
    public_id = public_id.toString();
    if (type === null && public_id.match(/^https?:\//i)) {
      return original_source;
    }
    [resource_type, type] = finalize_resource_type(resource_type, type, url_suffix, use_root_path, shorten);
    [public_id, source_to_sign] = finalize_source(public_id, format, url_suffix);
    if (version == null && force_version && source_to_sign.indexOf("/") >= 0 && !source_to_sign.match(/^v[0-9]+/) && !source_to_sign.match(/^https?:\//)) {
      version = 1;
    }
    if (version != null) {
      version = `v${version}`;
    } else {
      version = null;
    }
    transformation = transformation.replace(/([^:])\/\//g, "$1/");
    if (sign_url && isEmpty(auth_token)) {
      let to_sign = [transformation, source_to_sign].filter(function(part) {
        return part != null && part !== "";
      }).join("/");
      const signatureConfig = {};
      if (long_url_signature) {
        signatureConfig.algorithm = "sha256";
        signatureConfig.signatureLength = 32;
      } else {
        signatureConfig.algorithm = signature_algorithm;
        signatureConfig.signatureLength = 8;
      }
      const truncated = compute_hash(to_sign + api_secret, signatureConfig.algorithm, "base64").slice(0, signatureConfig.signatureLength).replace(/\//g, "_").replace(/\+/g, "-");
      signature = `s--${truncated}--`;
    }
    let prefix = build_distribution_domain(public_id, options);
    let resultUrl = [prefix, resource_type, type, signature, transformation, version, public_id].filter(function(part) {
      return part != null && part !== "";
    }).join("/").replace(/ /g, "%20");
    if (sign_url && !isEmpty(auth_token)) {
      auth_token.url = urlParse(resultUrl).path;
      let token = generate_token(auth_token);
      resultUrl += `?${token}`;
    }
    const urlAnalytics = ensureOption(options, "urlAnalytics", ensureOption(options, "analytics", true));
    if (urlAnalytics === true) {
      let {
        sdkCode: sdkCodeDefault,
        sdkSemver: sdkSemverDefault,
        techVersion: techVersionDefault,
        product: productDefault
      } = getSDKVersions();
      const sdkCode = ensureOption(options, "sdkCode", ensureOption(options, "sdk_code", sdkCodeDefault));
      const sdkSemver = ensureOption(options, "sdkSemver", ensureOption(options, "sdk_semver", sdkSemverDefault));
      const techVersion = ensureOption(options, "techVersion", ensureOption(options, "tech_version", techVersionDefault));
      const product = ensureOption(options, "product", productDefault);
      let sdkVersions = {
        sdkCode,
        sdkSemver,
        techVersion,
        product,
        urlAnalytics
      };
      let analyticsOptions = getAnalyticsOptions(Object.assign({}, options, sdkVersions));
      let sdkAnalyticsSignature = getSDKAnalyticsSignature(analyticsOptions);
      let appender = "?";
      if (resultUrl.indexOf("?") >= 0) {
        appender = "&";
      }
      resultUrl = `${resultUrl}${appender}_a=${sdkAnalyticsSignature}`;
    }
    return resultUrl;
  }
  function video_url(public_id, options) {
    options = extend({
      resource_type: "video"
    }, options);
    return utils.url(public_id, options);
  }
  function finalize_source(source, format, url_suffix) {
    let source_to_sign;
    source = source.replace(/([^:])\/\//g, "$1/");
    if (source.match(/^https?:\//i)) {
      source = smart_escape(source);
      source_to_sign = source;
    } else {
      source = encodeURIComponent(decodeURIComponent(source)).replace(/%3A/g, ":").replace(/%2F/g, "/");
      source_to_sign = source;
      if (url_suffix) {
        if (url_suffix.match(/[\.\/]/)) {
          throw new Error("url_suffix should not include . or /");
        }
        source = source + "/" + url_suffix;
      }
      if (format != null) {
        source = source + "." + format;
        source_to_sign = source_to_sign + "." + format;
      }
    }
    return [source, source_to_sign];
  }
  function video_thumbnail_url(public_id, options) {
    options = extend({}, DEFAULT_POSTER_OPTIONS, options);
    return utils.url(public_id, options);
  }
  function finalize_resource_type(resource_type, type, url_suffix, use_root_path, shorten) {
    if (type == null) {
      type = "upload";
    }
    if (url_suffix != null) {
      if (resource_type === "image" && type === "upload") {
        resource_type = "images";
        type = null;
      } else if (resource_type === "image" && type === "private") {
        resource_type = "private_images";
        type = null;
      } else if (resource_type === "image" && type === "authenticated") {
        resource_type = "authenticated_images";
        type = null;
      } else if (resource_type === "raw" && type === "upload") {
        resource_type = "files";
        type = null;
      } else if (resource_type === "video" && type === "upload") {
        resource_type = "videos";
        type = null;
      } else {
        throw new Error("URL Suffix only supported for image/upload, image/private, image/authenticated, video/upload and raw/upload");
      }
    }
    if (use_root_path) {
      if (resource_type === "image" && type === "upload" || resource_type === "images" && type == null) {
        resource_type = null;
        type = null;
      } else {
        throw new Error("Root path only supported for image/upload");
      }
    }
    if (shorten && resource_type === "image" && type === "upload") {
      resource_type = "iu";
      type = null;
    }
    return [resource_type, type];
  }
  function unsigned_url_prefix(source, cloud_name, private_cdn, cdn_subdomain, secure_cdn_subdomain, cname, secure, secure_distribution) {
    let prefix;
    if (cloud_name.indexOf("/") === 0) {
      return "/res" + cloud_name;
    }
    let shared_domain = !private_cdn;
    if (secure) {
      if (secure_distribution == null || secure_distribution === exports.OLD_AKAMAI_SHARED_CDN) {
        secure_distribution = private_cdn ? cloud_name + "-res.cloudinary.com" : exports.SHARED_CDN;
      }
      if (shared_domain == null) {
        shared_domain = secure_distribution === exports.SHARED_CDN;
      }
      if (secure_cdn_subdomain == null && shared_domain) {
        secure_cdn_subdomain = cdn_subdomain;
      }
      if (secure_cdn_subdomain) {
        secure_distribution = secure_distribution.replace("res.cloudinary.com", "res-" + (crc32(source) % 5 + 1 + ".cloudinary.com"));
      }
      prefix = "https://" + secure_distribution;
    } else if (cname) {
      let subdomain = cdn_subdomain ? "a" + (crc32(source) % 5 + 1) + "." : "";
      prefix = "http://" + subdomain + cname;
    } else {
      let cdn_part = private_cdn ? cloud_name + "-" : "";
      let subdomain_part = cdn_subdomain ? "-" + (crc32(source) % 5 + 1) : "";
      let host = [cdn_part, "res", subdomain_part, ".cloudinary.com"].join("");
      prefix = "http://" + host;
    }
    if (shared_domain) {
      prefix += "/" + cloud_name;
    }
    return prefix;
  }
  function base_api_url_v1_1() {
    return base_api_url("v1_1");
  }
  function base_api_url_v2() {
    return base_api_url("v2");
  }
  function base_api_url(api_version) {
    if (!api_version || api_version.length === 0) {
      throw new Error("api_version needs to be a non-empty string");
    }
    return (path = [], options = []) => {
      let cloudinary = ensureOption(options, "upload_prefix", UPLOAD_PREFIX);
      let cloud_name = ensureOption(options, "cloud_name");
      let encode_path = (unencoded_path) => encodeURIComponent(unencoded_path).replace("'", "%27");
      let encoded_path = Array.isArray(path) ? path.map(encode_path) : encode_path(path);
      return [cloudinary, api_version, cloud_name].concat(encoded_path).join("/");
    };
  }
  function api_url(action = "upload", options = {}) {
    let resource_type = options.resource_type || "image";
    return base_api_url_v1_1()([resource_type, action], options);
  }
  function random_public_id() {
    return crypto3.randomBytes(12).toString("base64").replace(/[^a-z0-9]/g, "");
  }
  function signed_preloaded_image(result) {
    return `${result.resource_type}/upload/v${result.version}/${filter([result.public_id, result.format], utils.present).join(".")}#${result.signature}`;
  }
  function api_sign_request(params_to_sign, api_secret) {
    let to_sign = entries(params_to_sign).filter(([k, v]) => utils.present(v)).map(([k, v]) => `${k}=${toArray(v).join(",")}`).sort().join("&");
    return compute_hash(to_sign + api_secret, config().signature_algorithm || DEFAULT_SIGNATURE_ALGORITHM, "hex");
  }
  function compute_hash(input, signature_algorithm, encoding) {
    if (!SUPPORTED_SIGNATURE_ALGORITHMS.includes(signature_algorithm)) {
      throw new Error(`Signature algorithm ${signature_algorithm} is not supported. Supported algorithms: ${SUPPORTED_SIGNATURE_ALGORITHMS.join(", ")}`);
    }
    const hash = crypto3.createHash(signature_algorithm).update(input).digest();
    return Buffer.from(hash).toString(encoding);
  }
  function clear_blank(hash) {
    let filtered_hash = {};
    entries(hash).filter(([k, v]) => utils.present(v)).forEach(([k, v]) => {
      filtered_hash[k] = v.filter ? v.filter((x) => x) : v;
    });
    return filtered_hash;
  }
  function sort_object_by_key(object) {
    return Object.keys(object).sort().reduce((obj, key) => {
      obj[key] = object[key];
      return obj;
    }, {});
  }
  function merge(hash1, hash2) {
    return { ...hash1, ...hash2 };
  }
  function sign_request(params, options = {}) {
    let apiKey = ensureOption(options, "api_key");
    let apiSecret = ensureOption(options, "api_secret");
    params = exports.clear_blank(params);
    params.signature = exports.api_sign_request(params, apiSecret);
    params.api_key = apiKey;
    return params;
  }
  function webhook_signature(data, timestamp, options = {}) {
    ensurePresenceOf({
      data,
      timestamp
    });
    let api_secret = ensureOption(options, "api_secret");
    let signature_algorithm = ensureOption(options, "signature_algorithm", DEFAULT_SIGNATURE_ALGORITHM);
    return compute_hash(data + timestamp + api_secret, signature_algorithm, "hex");
  }
  function verifyNotificationSignature(body, timestamp, signature, valid_for = 7200) {
    if (timestamp < Math.round(Date.now() / 1000) - valid_for) {
      return false;
    }
    const payload_hash = utils.webhook_signature(body, timestamp, {
      api_secret: config().api_secret,
      signature_algorithm: config().signature_algorithm
    });
    return signature === payload_hash;
  }
  function process_request_params(params, options) {
    if (options.unsigned != null && options.unsigned) {
      params = exports.clear_blank(params);
      delete params.timestamp;
    } else if (options.oauth_token || config().oauth_token) {
      params = exports.clear_blank(params);
    } else if (options.signature) {
      params = exports.clear_blank(options);
    } else {
      params = exports.sign_request(params, options);
    }
    return params;
  }
  function private_download_url(public_id, format, options = {}) {
    let params = exports.sign_request({
      timestamp: options.timestamp || exports.timestamp(),
      public_id,
      format,
      type: options.type,
      attachment: options.attachment,
      expires_at: options.expires_at
    }, options);
    return exports.api_url("download", options) + "?" + querystring.stringify(params);
  }
  function zip_download_url(tag, options = {}) {
    let params = exports.sign_request({
      timestamp: options.timestamp || exports.timestamp(),
      tag,
      transformation: utils.generate_transformation_string(options)
    }, options);
    return exports.api_url("download_tag.zip", options) + "?" + hashToQuery(params);
  }
  function download_backedup_asset(asset_id, version_id, options = {}) {
    let params = exports.sign_request({
      timestamp: options.timestamp || exports.timestamp(),
      asset_id,
      version_id
    }, options);
    return exports.base_api_url_v1()(["download_backup"], options) + "?" + hashToQuery(params);
  }
  function api_download_url(action, params, options) {
    const download_params = {
      ...params,
      mode: "download"
    };
    let cloudinary_params = exports.sign_request(download_params, options);
    return exports.api_url(action, options) + "?" + hashToQuery(cloudinary_params);
  }
  function download_archive_url(options = {}) {
    const params = exports.archive_params(merge(options, {
      mode: "download"
    }));
    return api_download_url("generate_archive", params, options);
  }
  function download_zip_url(options = {}) {
    return exports.download_archive_url(merge(options, {
      target_format: "zip"
    }));
  }
  function download_folder(folder_path, options = {}) {
    options.resource_type = options.resource_type || "all";
    options.prefixes = folder_path;
    let cloudinary_params = exports.sign_request(exports.archive_params(merge(options, {
      mode: "download"
    })), options);
    return exports.api_url("generate_archive", options) + "?" + hashToQuery(cloudinary_params);
  }
  function join_pair(key, value) {
    if (!value) {
      return;
    }
    return value === true ? key : key + "='" + value + "'";
  }
  function escapeQuotes(value) {
    return isString(value) ? value.replace(/\"/g, "&#34;").replace(/\'/g, "&#39;") : value;
  }
  function cloudinary_js_config() {
    let params = pickOnlyExistingValues(config(), ...CLOUDINARY_JS_CONFIG_PARAMS);
    return `<script type='text/javascript'>\n\$.cloudinary.config(${JSON.stringify(params)});\n</script>`;
  }
  function v1_result_adapter(callback) {
    if (callback == null) {
      return;
    }
    return function(result) {
      if (result.error != null) {
        return callback(result.error);
      }
      return callback(undefined, result);
    };
  }
  function v1_adapter(name, num_pass_args, v1) {
    return function(...args) {
      let pass_args = take(args, num_pass_args);
      let options = args[num_pass_args];
      let callback = args[num_pass_args + 1];
      if (callback == null && isFunction(options)) {
        callback = options;
        options = {};
      }
      callback = v1_result_adapter(callback);
      args = pass_args.concat([callback, options]);
      return v1[name].apply(this, args);
    };
  }
  function v1_adapters(exports2, v1, mapping) {
    return Object.keys(mapping).map((name) => {
      let num_pass_args = mapping[name];
      exports2[name] = v1_adapter(name, num_pass_args, v1);
      return exports2[name];
    });
  }
  function as_safe_bool(value) {
    if (value == null) {
      return;
    }
    if (value === true || value === "true" || value === "1") {
      value = 1;
    }
    if (value === false || value === "false" || value === "0") {
      value = 0;
    }
    return value;
  }
  function split_range(range) {
    switch (range.constructor) {
      case String:
        if (!OFFSET_ANY_PATTERN_RE.test(range)) {
          return range;
        }
        return range.split("..");
      case Array:
        return [first(range), last(range)];
      default:
        return [null, null];
    }
  }
  function norm_range_value(value) {
    let offset = String(value).match(RANGE_VALUE_RE);
    if (offset) {
      let modifier = offset[5] ? "p" : "";
      value = `${offset[1] || offset[4]}${modifier}`;
    }
    return value;
  }
  function process_video_params(param) {
    switch (param.constructor) {
      case Object: {
        let video = "";
        if ("codec" in param) {
          video = param.codec;
          if ("profile" in param) {
            video += ":" + param.profile;
            if ("level" in param) {
              video += ":" + param.level;
            }
          }
        }
        return video;
      }
      case String:
        return param;
      default:
        return null;
    }
  }
  function archive_params(options = {}) {
    return {
      allow_missing: exports.as_safe_bool(options.allow_missing),
      async: exports.as_safe_bool(options.async),
      expires_at: options.expires_at,
      flatten_folders: exports.as_safe_bool(options.flatten_folders),
      flatten_transformations: exports.as_safe_bool(options.flatten_transformations),
      keep_derived: exports.as_safe_bool(options.keep_derived),
      mode: options.mode,
      notification_url: options.notification_url,
      prefixes: options.prefixes && toArray(options.prefixes),
      fully_qualified_public_ids: options.fully_qualified_public_ids && toArray(options.fully_qualified_public_ids),
      public_ids: options.public_ids && toArray(options.public_ids),
      skip_transformation_name: exports.as_safe_bool(options.skip_transformation_name),
      tags: options.tags && toArray(options.tags),
      target_format: options.target_format,
      target_public_id: options.target_public_id,
      target_tags: options.target_tags && toArray(options.target_tags),
      timestamp: options.timestamp || exports.timestamp(),
      transformations: utils.build_eager(options.transformations),
      type: options.type,
      use_original_filename: exports.as_safe_bool(options.use_original_filename)
    };
  }
  function build_explicit_api_params(public_id, options = {}) {
    return [exports.build_upload_params(extend({}, { public_id }, options))];
  }
  function generate_responsive_breakpoints_string(breakpoints) {
    if (breakpoints == null) {
      return null;
    }
    breakpoints = clone(breakpoints);
    if (!isArray(breakpoints)) {
      breakpoints = [breakpoints];
    }
    for (let j = 0;j < breakpoints.length; j++) {
      let breakpoint_settings = breakpoints[j];
      if (breakpoint_settings != null) {
        if (breakpoint_settings.transformation) {
          breakpoint_settings.transformation = utils.generate_transformation_string(clone(breakpoint_settings.transformation));
        }
      }
    }
    return JSON.stringify(breakpoints);
  }
  function build_streaming_profiles_param(options = {}) {
    let params = pickOnlyExistingValues(options, "display_name", "representations");
    if (isArray(params.representations)) {
      params.representations = JSON.stringify(params.representations.map((r) => ({
        transformation: utils.generate_transformation_string(r.transformation)
      })));
    }
    return params;
  }
  function hashToParameters(hash) {
    return entries(hash).reduce((parameters, [key, value]) => {
      if (isArray(value)) {
        key = key.endsWith("[]") ? key : key + "[]";
        const items = value.map((v) => [key, v]);
        parameters = parameters.concat(items);
      } else {
        parameters.push([key, value]);
      }
      return parameters;
    }, []);
  }
  function hashToQuery(hash) {
    return hashToParameters(hash).map(([key, value]) => `${querystring.escape(key)}=${querystring.escape(value)}`).join("&");
  }
  function present(value) {
    return value != null && ("" + value).length > 0;
  }
  function pickOnlyExistingValues(source, ...keys) {
    let result = {};
    if (source) {
      keys.forEach((key) => {
        if (source[key] != null) {
          result[key] = source[key];
        }
      });
    }
    return result;
  }
  function jsonArrayParam(data, modifier) {
    if (!data) {
      return null;
    }
    if (isString(data)) {
      data = JSON.parse(data);
    }
    if (!isArray(data)) {
      data = [data];
    }
    if (isFunction(modifier)) {
      data = modifier(data);
    }
    return JSON.stringify(data);
  }
  var crypto3 = import.meta.require("crypto");
  var querystring = import.meta.require("querystring");
  var urlParse = import.meta.require("url").parse;
  var compact = require_compact();
  var first = require_head();
  var isFunction = require_isFunction();
  var isPlainObject = require_isPlainObject();
  var last = require_last();
  var map = require_map();
  var take = require_take();
  var at = require_at();
  var clone = require_clone();
  var extend = require_assignIn();
  var filter = require_filter();
  var includes = require_includes();
  var isArray = require_isArray();
  var isEmpty = require_isEmpty();
  var isNumber = require_isNumber();
  var isObject = require_isObject();
  var isString = require_isString();
  var isUndefined = require_isUndefined();
  var smart_escape = require_smart_escape();
  var consumeOption = require_consumeOption();
  var toArray = require_toArray();
  var { base64EncodeURL } = require_base64EncodeURL();
  var encodeDoubleArray = require_encodeDoubleArray();
  var config = require_config();
  var generate_token = require_auth_token();
  var crc32 = require_crc32();
  var ensurePresenceOf = require_ensurePresenceOf();
  var ensureOption = require_ensureOption().defaults(config());
  var entries = require_entries();
  var isRemoteUrl = require_isRemoteUrl();
  var getSDKVersions = require_getSDKVersions();
  var {
    getAnalyticsOptions,
    getSDKAnalyticsSignature
  } = require_analytics();
  exports = module.exports;
  var utils = module.exports;
  try {
    utils.VERSION = require_package().version;
  } catch (error) {
    utils.VERSION = "";
  }
  exports.CF_SHARED_CDN = "d3jpl91pxevbkh.cloudfront.net";
  exports.OLD_AKAMAI_SHARED_CDN = "cloudinary-a.akamaihd.net";
  exports.AKAMAI_SHARED_CDN = "res.cloudinary.com";
  exports.SHARED_CDN = exports.AKAMAI_SHARED_CDN;
  exports.USER_AGENT = `CloudinaryNodeJS/${exports.VERSION} (Node ${process.versions.node})`;
  exports.userPlatform = "";
  var {
    DEFAULT_RESPONSIVE_WIDTH_TRANSFORMATION,
    DEFAULT_POSTER_OPTIONS,
    DEFAULT_VIDEO_SOURCE_TYPES,
    CONDITIONAL_OPERATORS,
    PREDEFINED_VARS,
    LAYER_KEYWORD_PARAMS,
    TRANSFORMATION_PARAMS,
    SIMPLE_PARAMS,
    UPLOAD_PREFIX,
    SUPPORTED_SIGNATURE_ALGORITHMS,
    DEFAULT_SIGNATURE_ALGORITHM
  } = require_consts();
  var URL_KEYS = [
    "api_secret",
    "auth_token",
    "cdn_subdomain",
    "cloud_name",
    "cname",
    "format",
    "long_url_signature",
    "private_cdn",
    "resource_type",
    "secure",
    "secure_cdn_subdomain",
    "secure_distribution",
    "shorten",
    "sign_url",
    "ssl_detected",
    "type",
    "url_suffix",
    "use_root_path",
    "version"
  ];
  exports.html_attrs = function html_attrs(attrs) {
    return filter(map(attrs, function(value, key) {
      return join_pair(key, escapeQuotes(value));
    })).sort().join(" ");
  };
  var CLOUDINARY_JS_CONFIG_PARAMS = ["api_key", "cloud_name", "private_cdn", "secure_distribution", "cdn_subdomain"];
  var NUMBER_PATTERN = "([0-9]*)\\.([0-9]+)|([0-9]+)";
  var OFFSET_ANY_PATTERN = `(${NUMBER_PATTERN})([%pP])?`;
  var RANGE_VALUE_RE = RegExp(`^${OFFSET_ANY_PATTERN}\$`);
  var OFFSET_ANY_PATTERN_RE = RegExp(`(${OFFSET_ANY_PATTERN})\\.\\.(${OFFSET_ANY_PATTERN})`);
  exports.process_layer = process_layer;
  exports.create_source_tag = function create_source_tag(src, source_type, codecs = null) {
    let video_type = source_type === "ogv" ? "ogg" : source_type;
    let mime_type = `video/${video_type}`;
    if (!isEmpty(codecs)) {
      let codecs_str = isArray(codecs) ? codecs.join(", ") : codecs;
      mime_type += `; codecs=${codecs_str}`;
    }
    return `<source ${utils.html_attrs({
      src,
      type: mime_type
    })}>`;
  };
  exports.NOP = function() {
  };
  exports.generate_auth_token = generate_auth_token;
  exports.getUserAgent = getUserAgent;
  exports.build_upload_params = build_upload_params;
  exports.build_multi_and_sprite_params = build_multi_and_sprite_params;
  exports.api_download_url = api_download_url;
  exports.timestamp = () => Math.floor(new Date().getTime() / 1000);
  exports.option_consume = consumeOption;
  exports.build_array = toArray;
  exports.encode_double_array = encodeDoubleArray;
  exports.encode_key_value = encode_key_value;
  exports.encode_context = encode_context;
  exports.build_eager = build_eager;
  exports.build_custom_headers = build_custom_headers;
  exports.generate_transformation_string = generate_transformation_string;
  exports.updateable_resource_params = updateable_resource_params;
  exports.extractUrlParams = extractUrlParams;
  exports.extractTransformationParams = extractTransformationParams;
  exports.patchFetchFormat = patchFetchFormat;
  exports.url = url;
  exports.video_url = video_url;
  exports.video_thumbnail_url = video_thumbnail_url;
  exports.api_url = api_url;
  exports.random_public_id = random_public_id;
  exports.signed_preloaded_image = signed_preloaded_image;
  exports.api_sign_request = api_sign_request;
  exports.clear_blank = clear_blank;
  exports.merge = merge;
  exports.sign_request = sign_request;
  exports.webhook_signature = webhook_signature;
  exports.verifyNotificationSignature = verifyNotificationSignature;
  exports.process_request_params = process_request_params;
  exports.private_download_url = private_download_url;
  exports.zip_download_url = zip_download_url;
  exports.download_archive_url = download_archive_url;
  exports.download_zip_url = download_zip_url;
  exports.cloudinary_js_config = cloudinary_js_config;
  exports.v1_adapters = v1_adapters;
  exports.as_safe_bool = as_safe_bool;
  exports.archive_params = archive_params;
  exports.build_explicit_api_params = build_explicit_api_params;
  exports.generate_responsive_breakpoints_string = generate_responsive_breakpoints_string;
  exports.build_streaming_profiles_param = build_streaming_profiles_param;
  exports.hashToParameters = hashToParameters;
  exports.present = present;
  exports.only = pickOnlyExistingValues;
  exports.pickOnlyExistingValues = pickOnlyExistingValues;
  exports.jsonArrayParam = jsonArrayParam;
  exports.download_folder = download_folder;
  exports.base_api_url_v1 = base_api_url_v1_1;
  exports.base_api_url_v2 = base_api_url_v2;
  exports.download_backedup_asset = download_backedup_asset;
  exports.compute_hash = compute_hash;
  exports.build_distribution_domain = build_distribution_domain;
  exports.sort_object_by_key = sort_object_by_key;
  exports.DEFAULT_POSTER_OPTIONS = DEFAULT_POSTER_OPTIONS;
  exports.DEFAULT_VIDEO_SOURCE_TYPES = DEFAULT_VIDEO_SOURCE_TYPES;
  Object.assign(module.exports, {
    normalize_expression,
    at,
    clone,
    extend,
    filter,
    includes,
    isArray,
    isEmpty,
    isNumber,
    isObject,
    isRemoteUrl,
    isString,
    isUndefined,
    keys: (source) => Object.keys(source),
    ensurePresenceOf
  });
});

// node_modules/q/q.js
var require_q = __commonJS((exports, module) => {
  /*!
   *
   * Copyright 2009-2017 Kris Kowal under the terms of the MIT
   * license found at https://github.com/kriskowal/q/blob/v1/LICENSE
   *
   * With parts by Tyler Close
   * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
   * at http://www.opensource.org/licenses/mit-license.html
   * Forked at ref_send.js version: 2009-05-11
   *
   * With parts by Mark Miller
   * Copyright (C) 2011 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   */
  (function(definition) {
    if (typeof bootstrap === "function") {
      bootstrap("promise", definition);
    } else if (typeof exports === "object" && typeof module === "object") {
      module.exports = definition();
    } else if (typeof define === "function" && define.amd) {
      define(definition);
    } else if (typeof ses !== "undefined") {
      if (!ses.ok()) {
        return;
      } else {
        ses.makeQ = definition;
      }
    } else if (typeof window !== "undefined" || typeof self !== "undefined") {
      var global2 = typeof window !== "undefined" ? window : self;
      var previousQ = global2.Q;
      global2.Q = definition();
      global2.Q.noConflict = function() {
        global2.Q = previousQ;
        return this;
      };
    } else {
      throw new Error("This environment was not anticipated by Q. Please file a bug.");
    }
  })(function() {
    var hasStacks = false;
    try {
      throw new Error;
    } catch (e) {
      hasStacks = !!e.stack;
    }
    var qStartingLine = captureLine();
    var qFileName;
    var noop = function() {
    };
    var nextTick = function() {
      var head = { task: undefined, next: null };
      var tail = head;
      var flushing = false;
      var requestTick = undefined;
      var isNodeJS = false;
      var laterQueue = [];
      function flush() {
        var task, domain;
        while (head.next) {
          head = head.next;
          task = head.task;
          head.task = undefined;
          domain = head.domain;
          if (domain) {
            head.domain = undefined;
            domain.enter();
          }
          runSingle(task, domain);
        }
        while (laterQueue.length) {
          task = laterQueue.pop();
          runSingle(task);
        }
        flushing = false;
      }
      function runSingle(task, domain) {
        try {
          task();
        } catch (e) {
          if (isNodeJS) {
            if (domain) {
              domain.exit();
            }
            setTimeout(flush, 0);
            if (domain) {
              domain.enter();
            }
            throw e;
          } else {
            setTimeout(function() {
              throw e;
            }, 0);
          }
        }
        if (domain) {
          domain.exit();
        }
      }
      nextTick = function(task) {
        tail = tail.next = {
          task,
          domain: isNodeJS && process.domain,
          next: null
        };
        if (!flushing) {
          flushing = true;
          requestTick();
        }
      };
      if (typeof process === "object" && process.toString() === "[object process]" && process.nextTick) {
        isNodeJS = true;
        requestTick = function() {
          process.nextTick(flush);
        };
      } else if (typeof setImmediate === "function") {
        if (typeof window !== "undefined") {
          requestTick = setImmediate.bind(window, flush);
        } else {
          requestTick = function() {
            setImmediate(flush);
          };
        }
      } else if (typeof MessageChannel !== "undefined") {
        var channel = new MessageChannel;
        channel.port1.onmessage = function() {
          requestTick = requestPortTick;
          channel.port1.onmessage = flush;
          flush();
        };
        var requestPortTick = function() {
          channel.port2.postMessage(0);
        };
        requestTick = function() {
          setTimeout(flush, 0);
          requestPortTick();
        };
      } else {
        requestTick = function() {
          setTimeout(flush, 0);
        };
      }
      nextTick.runAfter = function(task) {
        laterQueue.push(task);
        if (!flushing) {
          flushing = true;
          requestTick();
        }
      };
      return nextTick;
    }();
    var call = Function.call;
    function uncurryThis(f) {
      return function() {
        return call.apply(f, arguments);
      };
    }
    var array_slice = uncurryThis(Array.prototype.slice);
    var array_reduce = uncurryThis(Array.prototype.reduce || function(callback, basis) {
      var index = 0, length = this.length;
      if (arguments.length === 1) {
        do {
          if (index in this) {
            basis = this[index++];
            break;
          }
          if (++index >= length) {
            throw new TypeError;
          }
        } while (1);
      }
      for (;index < length; index++) {
        if (index in this) {
          basis = callback(basis, this[index], index);
        }
      }
      return basis;
    });
    var array_indexOf = uncurryThis(Array.prototype.indexOf || function(value) {
      for (var i = 0;i < this.length; i++) {
        if (this[i] === value) {
          return i;
        }
      }
      return -1;
    });
    var array_map = uncurryThis(Array.prototype.map || function(callback, thisp) {
      var self2 = this;
      var collect = [];
      array_reduce(self2, function(undefined2, value, index) {
        collect.push(callback.call(thisp, value, index, self2));
      }, undefined);
      return collect;
    });
    var object_create = Object.create || function(prototype) {
      function Type() {
      }
      Type.prototype = prototype;
      return new Type;
    };
    var object_defineProperty = Object.defineProperty || function(obj, prop, descriptor) {
      obj[prop] = descriptor.value;
      return obj;
    };
    var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
    var object_keys = Object.keys || function(object) {
      var keys = [];
      for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    var object_toString = uncurryThis(Object.prototype.toString);
    function isObject(value) {
      return value === Object(value);
    }
    function isStopIteration(exception) {
      return object_toString(exception) === "[object StopIteration]" || exception instanceof QReturnValue;
    }
    var QReturnValue;
    if (typeof ReturnValue !== "undefined") {
      QReturnValue = ReturnValue;
    } else {
      QReturnValue = function(value) {
        this.value = value;
      };
    }
    var STACK_JUMP_SEPARATOR = "From previous event:";
    function makeStackTraceLong(error, promise2) {
      if (hasStacks && promise2.stack && typeof error === "object" && error !== null && error.stack) {
        var stacks = [];
        for (var p = promise2;p; p = p.source) {
          if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
            object_defineProperty(error, "__minimumStackCounter__", { value: p.stackCounter, configurable: true });
            stacks.unshift(p.stack);
          }
        }
        stacks.unshift(error.stack);
        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        var stack = filterStackString(concatedStacks);
        object_defineProperty(error, "stack", { value: stack, configurable: true });
      }
    }
    function filterStackString(stackString) {
      var lines = stackString.split("\n");
      var desiredLines = [];
      for (var i = 0;i < lines.length; ++i) {
        var line = lines[i];
        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
          desiredLines.push(line);
        }
      }
      return desiredLines.join("\n");
    }
    function isNodeFrame(stackLine) {
      return stackLine.indexOf("(module.js:") !== -1 || stackLine.indexOf("(node.js:") !== -1;
    }
    function getFileNameAndLineNumber(stackLine) {
      var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
      if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
      }
      var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
      if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
      }
      var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
      if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
      }
    }
    function isInternalFrame(stackLine) {
      var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
      if (!fileNameAndLineNumber) {
        return false;
      }
      var fileName = fileNameAndLineNumber[0];
      var lineNumber = fileNameAndLineNumber[1];
      return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;
    }
    function captureLine() {
      if (!hasStacks) {
        return;
      }
      try {
        throw new Error;
      } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
          return;
        }
        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
      }
    }
    function deprecate(callback, name, alternative) {
      return function() {
        if (typeof console !== "undefined" && typeof console.warn === "function") {
          console.warn(name + " is deprecated, use " + alternative + " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
      };
    }
    function Q(value) {
      if (value instanceof Promise2) {
        return value;
      }
      if (isPromiseAlike(value)) {
        return coerce(value);
      } else {
        return fulfill(value);
      }
    }
    Q.resolve = Q;
    Q.nextTick = nextTick;
    Q.longStackSupport = false;
    var longStackCounter = 1;
    if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
      Q.longStackSupport = true;
    }
    Q.defer = defer;
    function defer() {
      var messages = [], progressListeners = [], resolvedPromise;
      var deferred = object_create(defer.prototype);
      var promise2 = object_create(Promise2.prototype);
      promise2.promiseDispatch = function(resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
          messages.push(args);
          if (op === "when" && operands[1]) {
            progressListeners.push(operands[1]);
          }
        } else {
          Q.nextTick(function() {
            resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
          });
        }
      };
      promise2.valueOf = function() {
        if (messages) {
          return promise2;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
          resolvedPromise = nearerValue;
        }
        return nearerValue;
      };
      promise2.inspect = function() {
        if (!resolvedPromise) {
          return { state: "pending" };
        }
        return resolvedPromise.inspect();
      };
      if (Q.longStackSupport && hasStacks) {
        try {
          throw new Error;
        } catch (e) {
          promise2.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
          promise2.stackCounter = longStackCounter++;
        }
      }
      function become(newPromise) {
        resolvedPromise = newPromise;
        if (Q.longStackSupport && hasStacks) {
          promise2.source = newPromise;
        }
        array_reduce(messages, function(undefined2, message) {
          Q.nextTick(function() {
            newPromise.promiseDispatch.apply(newPromise, message);
          });
        }, undefined);
        messages = undefined;
        progressListeners = undefined;
      }
      deferred.promise = promise2;
      deferred.resolve = function(value) {
        if (resolvedPromise) {
          return;
        }
        become(Q(value));
      };
      deferred.fulfill = function(value) {
        if (resolvedPromise) {
          return;
        }
        become(fulfill(value));
      };
      deferred.reject = function(reason) {
        if (resolvedPromise) {
          return;
        }
        become(reject(reason));
      };
      deferred.notify = function(progress2) {
        if (resolvedPromise) {
          return;
        }
        array_reduce(progressListeners, function(undefined2, progressListener) {
          Q.nextTick(function() {
            progressListener(progress2);
          });
        }, undefined);
      };
      return deferred;
    }
    defer.prototype.makeNodeResolver = function() {
      var self2 = this;
      return function(error, value) {
        if (error) {
          self2.reject(error);
        } else if (arguments.length > 2) {
          self2.resolve(array_slice(arguments, 1));
        } else {
          self2.resolve(value);
        }
      };
    };
    Q.Promise = promise;
    Q.promise = promise;
    function promise(resolver) {
      if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
      }
      var deferred = defer();
      try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
      } catch (reason) {
        deferred.reject(reason);
      }
      return deferred.promise;
    }
    promise.race = race;
    promise.all = all;
    promise.reject = reject;
    promise.resolve = Q;
    Q.passByCopy = function(object) {
      return object;
    };
    Promise2.prototype.passByCopy = function() {
      return this;
    };
    Q.join = function(x, y) {
      return Q(x).join(y);
    };
    Promise2.prototype.join = function(that) {
      return Q([this, that]).spread(function(x, y) {
        if (x === y) {
          return x;
        } else {
          throw new Error("Q can't join: not the same: " + x + " " + y);
        }
      });
    };
    Q.race = race;
    function race(answerPs) {
      return promise(function(resolve, reject2) {
        for (var i = 0, len = answerPs.length;i < len; i++) {
          Q(answerPs[i]).then(resolve, reject2);
        }
      });
    }
    Promise2.prototype.race = function() {
      return this.then(Q.race);
    };
    Q.makePromise = Promise2;
    function Promise2(descriptor, fallback, inspect) {
      if (fallback === undefined) {
        fallback = function(op) {
          return reject(new Error("Promise does not support operation: " + op));
        };
      }
      if (inspect === undefined) {
        inspect = function() {
          return { state: "unknown" };
        };
      }
      var promise2 = object_create(Promise2.prototype);
      promise2.promiseDispatch = function(resolve, op, args) {
        var result;
        try {
          if (descriptor[op]) {
            result = descriptor[op].apply(promise2, args);
          } else {
            result = fallback.call(promise2, op, args);
          }
        } catch (exception) {
          result = reject(exception);
        }
        if (resolve) {
          resolve(result);
        }
      };
      promise2.inspect = inspect;
      if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
          promise2.exception = inspected.reason;
        }
        promise2.valueOf = function() {
          var inspected2 = inspect();
          if (inspected2.state === "pending" || inspected2.state === "rejected") {
            return promise2;
          }
          return inspected2.value;
        };
      }
      return promise2;
    }
    Promise2.prototype.toString = function() {
      return "[object Promise]";
    };
    Promise2.prototype.then = function(fulfilled, rejected, progressed) {
      var self2 = this;
      var deferred = defer();
      var done = false;
      function _fulfilled(value) {
        try {
          return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
          return reject(exception);
        }
      }
      function _rejected(exception) {
        if (typeof rejected === "function") {
          makeStackTraceLong(exception, self2);
          try {
            return rejected(exception);
          } catch (newException) {
            return reject(newException);
          }
        }
        return reject(exception);
      }
      function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
      }
      Q.nextTick(function() {
        self2.promiseDispatch(function(value) {
          if (done) {
            return;
          }
          done = true;
          deferred.resolve(_fulfilled(value));
        }, "when", [function(exception) {
          if (done) {
            return;
          }
          done = true;
          deferred.resolve(_rejected(exception));
        }]);
      });
      self2.promiseDispatch(undefined, "when", [undefined, function(value) {
        var newValue;
        var threw = false;
        try {
          newValue = _progressed(value);
        } catch (e) {
          threw = true;
          if (Q.onerror) {
            Q.onerror(e);
          } else {
            throw e;
          }
        }
        if (!threw) {
          deferred.notify(newValue);
        }
      }]);
      return deferred.promise;
    };
    Q.tap = function(promise2, callback) {
      return Q(promise2).tap(callback);
    };
    Promise2.prototype.tap = function(callback) {
      callback = Q(callback);
      return this.then(function(value) {
        return callback.fcall(value).thenResolve(value);
      });
    };
    Q.when = when;
    function when(value, fulfilled, rejected, progressed) {
      return Q(value).then(fulfilled, rejected, progressed);
    }
    Promise2.prototype.thenResolve = function(value) {
      return this.then(function() {
        return value;
      });
    };
    Q.thenResolve = function(promise2, value) {
      return Q(promise2).thenResolve(value);
    };
    Promise2.prototype.thenReject = function(reason) {
      return this.then(function() {
        throw reason;
      });
    };
    Q.thenReject = function(promise2, reason) {
      return Q(promise2).thenReject(reason);
    };
    Q.nearer = nearer;
    function nearer(value) {
      if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
          return inspected.value;
        }
      }
      return value;
    }
    Q.isPromise = isPromise;
    function isPromise(object) {
      return object instanceof Promise2;
    }
    Q.isPromiseAlike = isPromiseAlike;
    function isPromiseAlike(object) {
      return isObject(object) && typeof object.then === "function";
    }
    Q.isPending = isPending;
    function isPending(object) {
      return isPromise(object) && object.inspect().state === "pending";
    }
    Promise2.prototype.isPending = function() {
      return this.inspect().state === "pending";
    };
    Q.isFulfilled = isFulfilled;
    function isFulfilled(object) {
      return !isPromise(object) || object.inspect().state === "fulfilled";
    }
    Promise2.prototype.isFulfilled = function() {
      return this.inspect().state === "fulfilled";
    };
    Q.isRejected = isRejected;
    function isRejected(object) {
      return isPromise(object) && object.inspect().state === "rejected";
    }
    Promise2.prototype.isRejected = function() {
      return this.inspect().state === "rejected";
    };
    var unhandledReasons = [];
    var unhandledRejections = [];
    var reportedUnhandledRejections = [];
    var trackUnhandledRejections = true;
    function resetUnhandledRejections() {
      unhandledReasons.length = 0;
      unhandledRejections.length = 0;
      if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
      }
    }
    function trackRejection(promise2, reason) {
      if (!trackUnhandledRejections) {
        return;
      }
      if (typeof process === "object" && typeof process.emit === "function") {
        Q.nextTick.runAfter(function() {
          if (array_indexOf(unhandledRejections, promise2) !== -1) {
            process.emit("unhandledRejection", reason, promise2);
            reportedUnhandledRejections.push(promise2);
          }
        });
      }
      unhandledRejections.push(promise2);
      if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
      } else {
        unhandledReasons.push("(no stack) " + reason);
      }
    }
    function untrackRejection(promise2) {
      if (!trackUnhandledRejections) {
        return;
      }
      var at = array_indexOf(unhandledRejections, promise2);
      if (at !== -1) {
        if (typeof process === "object" && typeof process.emit === "function") {
          Q.nextTick.runAfter(function() {
            var atReport = array_indexOf(reportedUnhandledRejections, promise2);
            if (atReport !== -1) {
              process.emit("rejectionHandled", unhandledReasons[at], promise2);
              reportedUnhandledRejections.splice(atReport, 1);
            }
          });
        }
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
      }
    }
    Q.resetUnhandledRejections = resetUnhandledRejections;
    Q.getUnhandledReasons = function() {
      return unhandledReasons.slice();
    };
    Q.stopUnhandledRejectionTracking = function() {
      resetUnhandledRejections();
      trackUnhandledRejections = false;
    };
    resetUnhandledRejections();
    Q.reject = reject;
    function reject(reason) {
      var rejection = Promise2({
        when: function(rejected) {
          if (rejected) {
            untrackRejection(this);
          }
          return rejected ? rejected(reason) : this;
        }
      }, function fallback() {
        return this;
      }, function inspect() {
        return { state: "rejected", reason };
      });
      trackRejection(rejection, reason);
      return rejection;
    }
    Q.fulfill = fulfill;
    function fulfill(value) {
      return Promise2({
        when: function() {
          return value;
        },
        get: function(name) {
          return value[name];
        },
        set: function(name, rhs) {
          value[name] = rhs;
        },
        delete: function(name) {
          delete value[name];
        },
        post: function(name, args) {
          if (name === null || name === undefined) {
            return value.apply(undefined, args);
          } else {
            return value[name].apply(value, args);
          }
        },
        apply: function(thisp, args) {
          return value.apply(thisp, args);
        },
        keys: function() {
          return object_keys(value);
        }
      }, undefined, function inspect() {
        return { state: "fulfilled", value };
      });
    }
    function coerce(promise2) {
      var deferred = defer();
      Q.nextTick(function() {
        try {
          promise2.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
          deferred.reject(exception);
        }
      });
      return deferred.promise;
    }
    Q.master = master;
    function master(object) {
      return Promise2({
        isDef: function() {
        }
      }, function fallback(op, args) {
        return dispatch(object, op, args);
      }, function() {
        return Q(object).inspect();
      });
    }
    Q.spread = spread;
    function spread(value, fulfilled, rejected) {
      return Q(value).spread(fulfilled, rejected);
    }
    Promise2.prototype.spread = function(fulfilled, rejected) {
      return this.all().then(function(array) {
        return fulfilled.apply(undefined, array);
      }, rejected);
    };
    Q.async = async;
    function async(makeGenerator) {
      return function() {
        function continuer(verb, arg) {
          var result;
          if (typeof StopIteration === "undefined") {
            try {
              result = generator[verb](arg);
            } catch (exception) {
              return reject(exception);
            }
            if (result.done) {
              return Q(result.value);
            } else {
              return when(result.value, callback, errback);
            }
          } else {
            try {
              result = generator[verb](arg);
            } catch (exception) {
              if (isStopIteration(exception)) {
                return Q(exception.value);
              } else {
                return reject(exception);
              }
            }
            return when(result, callback, errback);
          }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
      };
    }
    Q.spawn = spawn;
    function spawn(makeGenerator) {
      Q.done(Q.async(makeGenerator)());
    }
    Q["return"] = _return;
    function _return(value) {
      throw new QReturnValue(value);
    }
    Q.promised = promised;
    function promised(callback) {
      return function() {
        return spread([this, all(arguments)], function(self2, args) {
          return callback.apply(self2, args);
        });
      };
    }
    Q.dispatch = dispatch;
    function dispatch(object, op, args) {
      return Q(object).dispatch(op, args);
    }
    Promise2.prototype.dispatch = function(op, args) {
      var self2 = this;
      var deferred = defer();
      Q.nextTick(function() {
        self2.promiseDispatch(deferred.resolve, op, args);
      });
      return deferred.promise;
    };
    Q.get = function(object, key) {
      return Q(object).dispatch("get", [key]);
    };
    Promise2.prototype.get = function(key) {
      return this.dispatch("get", [key]);
    };
    Q.set = function(object, key, value) {
      return Q(object).dispatch("set", [key, value]);
    };
    Promise2.prototype.set = function(key, value) {
      return this.dispatch("set", [key, value]);
    };
    Q.del = Q["delete"] = function(object, key) {
      return Q(object).dispatch("delete", [key]);
    };
    Promise2.prototype.del = Promise2.prototype["delete"] = function(key) {
      return this.dispatch("delete", [key]);
    };
    Q.mapply = Q.post = function(object, name, args) {
      return Q(object).dispatch("post", [name, args]);
    };
    Promise2.prototype.mapply = Promise2.prototype.post = function(name, args) {
      return this.dispatch("post", [name, args]);
    };
    Q.send = Q.mcall = Q.invoke = function(object, name) {
      return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
    };
    Promise2.prototype.send = Promise2.prototype.mcall = Promise2.prototype.invoke = function(name) {
      return this.dispatch("post", [name, array_slice(arguments, 1)]);
    };
    Q.fapply = function(object, args) {
      return Q(object).dispatch("apply", [undefined, args]);
    };
    Promise2.prototype.fapply = function(args) {
      return this.dispatch("apply", [undefined, args]);
    };
    Q["try"] = Q.fcall = function(object) {
      return Q(object).dispatch("apply", [undefined, array_slice(arguments, 1)]);
    };
    Promise2.prototype.fcall = function() {
      return this.dispatch("apply", [undefined, array_slice(arguments)]);
    };
    Q.fbind = function(object) {
      var promise2 = Q(object);
      var args = array_slice(arguments, 1);
      return function fbound() {
        return promise2.dispatch("apply", [
          this,
          args.concat(array_slice(arguments))
        ]);
      };
    };
    Promise2.prototype.fbind = function() {
      var promise2 = this;
      var args = array_slice(arguments);
      return function fbound() {
        return promise2.dispatch("apply", [
          this,
          args.concat(array_slice(arguments))
        ]);
      };
    };
    Q.keys = function(object) {
      return Q(object).dispatch("keys", []);
    };
    Promise2.prototype.keys = function() {
      return this.dispatch("keys", []);
    };
    Q.all = all;
    function all(promises) {
      return when(promises, function(promises2) {
        var pendingCount = 0;
        var deferred = defer();
        array_reduce(promises2, function(undefined2, promise2, index) {
          var snapshot;
          if (isPromise(promise2) && (snapshot = promise2.inspect()).state === "fulfilled") {
            promises2[index] = snapshot.value;
          } else {
            ++pendingCount;
            when(promise2, function(value) {
              promises2[index] = value;
              if (--pendingCount === 0) {
                deferred.resolve(promises2);
              }
            }, deferred.reject, function(progress2) {
              deferred.notify({ index, value: progress2 });
            });
          }
        }, undefined);
        if (pendingCount === 0) {
          deferred.resolve(promises2);
        }
        return deferred.promise;
      });
    }
    Promise2.prototype.all = function() {
      return all(this);
    };
    Q.any = any;
    function any(promises) {
      if (promises.length === 0) {
        return Q.resolve();
      }
      var deferred = Q.defer();
      var pendingCount = 0;
      array_reduce(promises, function(prev, current, index) {
        var promise2 = promises[index];
        pendingCount++;
        when(promise2, onFulfilled, onRejected, onProgress);
        function onFulfilled(result) {
          deferred.resolve(result);
        }
        function onRejected(err) {
          pendingCount--;
          if (pendingCount === 0) {
            var rejection = err || new Error("" + err);
            rejection.message = "Q can't get fulfillment value from any promise, all " + "promises were rejected. Last error message: " + rejection.message;
            deferred.reject(rejection);
          }
        }
        function onProgress(progress2) {
          deferred.notify({
            index,
            value: progress2
          });
        }
      }, undefined);
      return deferred.promise;
    }
    Promise2.prototype.any = function() {
      return any(this);
    };
    Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
    function allResolved(promises) {
      return when(promises, function(promises2) {
        promises2 = array_map(promises2, Q);
        return when(all(array_map(promises2, function(promise2) {
          return when(promise2, noop, noop);
        })), function() {
          return promises2;
        });
      });
    }
    Promise2.prototype.allResolved = function() {
      return allResolved(this);
    };
    Q.allSettled = allSettled;
    function allSettled(promises) {
      return Q(promises).allSettled();
    }
    Promise2.prototype.allSettled = function() {
      return this.then(function(promises) {
        return all(array_map(promises, function(promise2) {
          promise2 = Q(promise2);
          function regardless() {
            return promise2.inspect();
          }
          return promise2.then(regardless, regardless);
        }));
      });
    };
    Q.fail = Q["catch"] = function(object, rejected) {
      return Q(object).then(undefined, rejected);
    };
    Promise2.prototype.fail = Promise2.prototype["catch"] = function(rejected) {
      return this.then(undefined, rejected);
    };
    Q.progress = progress;
    function progress(object, progressed) {
      return Q(object).then(undefined, undefined, progressed);
    }
    Promise2.prototype.progress = function(progressed) {
      return this.then(undefined, undefined, progressed);
    };
    Q.fin = Q["finally"] = function(object, callback) {
      return Q(object)["finally"](callback);
    };
    Promise2.prototype.fin = Promise2.prototype["finally"] = function(callback) {
      if (!callback || typeof callback.apply !== "function") {
        throw new Error("Q can't apply finally callback");
      }
      callback = Q(callback);
      return this.then(function(value) {
        return callback.fcall().then(function() {
          return value;
        });
      }, function(reason) {
        return callback.fcall().then(function() {
          throw reason;
        });
      });
    };
    Q.done = function(object, fulfilled, rejected, progress2) {
      return Q(object).done(fulfilled, rejected, progress2);
    };
    Promise2.prototype.done = function(fulfilled, rejected, progress2) {
      var onUnhandledError = function(error) {
        Q.nextTick(function() {
          makeStackTraceLong(error, promise2);
          if (Q.onerror) {
            Q.onerror(error);
          } else {
            throw error;
          }
        });
      };
      var promise2 = fulfilled || rejected || progress2 ? this.then(fulfilled, rejected, progress2) : this;
      if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
      }
      promise2.then(undefined, onUnhandledError);
    };
    Q.timeout = function(object, ms, error) {
      return Q(object).timeout(ms, error);
    };
    Promise2.prototype.timeout = function(ms, error) {
      var deferred = defer();
      var timeoutId = setTimeout(function() {
        if (!error || typeof error === "string") {
          error = new Error(error || "Timed out after " + ms + " ms");
          error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
      }, ms);
      this.then(function(value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
      }, function(exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
      }, deferred.notify);
      return deferred.promise;
    };
    Q.delay = function(object, timeout) {
      if (timeout === undefined) {
        timeout = object;
        object = undefined;
      }
      return Q(object).delay(timeout);
    };
    Promise2.prototype.delay = function(timeout) {
      return this.then(function(value) {
        var deferred = defer();
        setTimeout(function() {
          deferred.resolve(value);
        }, timeout);
        return deferred.promise;
      });
    };
    Q.nfapply = function(callback, args) {
      return Q(callback).nfapply(args);
    };
    Promise2.prototype.nfapply = function(args) {
      var deferred = defer();
      var nodeArgs = array_slice(args);
      nodeArgs.push(deferred.makeNodeResolver());
      this.fapply(nodeArgs).fail(deferred.reject);
      return deferred.promise;
    };
    Q.nfcall = function(callback) {
      var args = array_slice(arguments, 1);
      return Q(callback).nfapply(args);
    };
    Promise2.prototype.nfcall = function() {
      var nodeArgs = array_slice(arguments);
      var deferred = defer();
      nodeArgs.push(deferred.makeNodeResolver());
      this.fapply(nodeArgs).fail(deferred.reject);
      return deferred.promise;
    };
    Q.nfbind = Q.denodeify = function(callback) {
      if (callback === undefined) {
        throw new Error("Q can't wrap an undefined function");
      }
      var baseArgs = array_slice(arguments, 1);
      return function() {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
      };
    };
    Promise2.prototype.nfbind = Promise2.prototype.denodeify = function() {
      var args = array_slice(arguments);
      args.unshift(this);
      return Q.denodeify.apply(undefined, args);
    };
    Q.nbind = function(callback, thisp) {
      var baseArgs = array_slice(arguments, 2);
      return function() {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
          return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
      };
    };
    Promise2.prototype.nbind = function() {
      var args = array_slice(arguments, 0);
      args.unshift(this);
      return Q.nbind.apply(undefined, args);
    };
    Q.nmapply = Q.npost = function(object, name, args) {
      return Q(object).npost(name, args);
    };
    Promise2.prototype.nmapply = Promise2.prototype.npost = function(name, args) {
      var nodeArgs = array_slice(args || []);
      var deferred = defer();
      nodeArgs.push(deferred.makeNodeResolver());
      this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
      return deferred.promise;
    };
    Q.nsend = Q.nmcall = Q.ninvoke = function(object, name) {
      var nodeArgs = array_slice(arguments, 2);
      var deferred = defer();
      nodeArgs.push(deferred.makeNodeResolver());
      Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
      return deferred.promise;
    };
    Promise2.prototype.nsend = Promise2.prototype.nmcall = Promise2.prototype.ninvoke = function(name) {
      var nodeArgs = array_slice(arguments, 1);
      var deferred = defer();
      nodeArgs.push(deferred.makeNodeResolver());
      this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
      return deferred.promise;
    };
    Q.nodeify = nodeify;
    function nodeify(object, nodeback) {
      return Q(object).nodeify(nodeback);
    }
    Promise2.prototype.nodeify = function(nodeback) {
      if (nodeback) {
        this.then(function(value) {
          Q.nextTick(function() {
            nodeback(null, value);
          });
        }, function(error) {
          Q.nextTick(function() {
            nodeback(error);
          });
        });
      } else {
        return this;
      }
    };
    Q.noConflict = function() {
      throw new Error("Q.noConflict only works when Q is used as a global");
    };
    var qEndingLine = captureLine();
    return Q;
  });
});

// node_modules/cloudinary/lib/cache.js
var require_cache = __commonJS((exports, module) => {
  var CACHE = Symbol.for("com.cloudinary.cache");
  var CACHE_ADAPTER = Symbol.for("com.cloudinary.cacheAdapter");
  var { ensurePresenceOf, generate_transformation_string } = require_utils();

  class CacheAdapter {
    get(publicId, type, resourceType, transformation, format) {
    }
    set(publicId, type, resourceType, transformation, format, value) {
    }
    flushAll() {
    }
  }
  var Cache = {
    CacheAdapter,
    setAdapter(adapter) {
      if (this.adapter) {
        console.warn("Overriding existing cache adapter");
      }
      this.adapter = adapter;
    },
    getAdapter() {
      return this.adapter;
    },
    get(publicId, options) {
      if (!this.adapter) {
        return;
      }
      ensurePresenceOf({ publicId });
      let transformation = generate_transformation_string({ ...options });
      return this.adapter.get(publicId, options.type || "upload", options.resource_type || "image", transformation, options.format);
    },
    set(publicId, options, value) {
      if (!this.adapter) {
        return;
      }
      ensurePresenceOf({ publicId, value });
      let transformation = generate_transformation_string({ ...options });
      return this.adapter.set(publicId, options.type || "upload", options.resource_type || "image", transformation, options.format, value);
    },
    flushAll() {
      if (!this.adapter) {
        return;
      }
      return this.adapter.flushAll();
    }
  };
  Object.defineProperty(Cache, "instance", {
    get() {
      return global[CACHE];
    }
  });
  Object.defineProperty(Cache, "adapter", {
    get() {
      return global[CACHE_ADAPTER];
    },
    set(adapter) {
      global[CACHE_ADAPTER] = adapter;
    }
  });
  Object.freeze(Cache);
  var symbols = Object.getOwnPropertySymbols(global);
  if (symbols.indexOf(CACHE) < 0) {
    global[CACHE] = Cache;
  }
  module.exports = Cache;
});

// node_modules/cloudinary/lib/upload_stream.js
var require_upload_stream = __commonJS((exports, module) => {
  var Transform = import.meta.require("stream").Transform;

  class UploadStream extends Transform {
    constructor(options) {
      super();
      this.boundary = options.boundary;
    }
    _transform(data, encoding, next) {
      let buffer = Buffer.isBuffer(data) ? data : Buffer.from(data, encoding);
      this.push(buffer);
      next();
    }
    _flush(next) {
      this.push(Buffer.from("\r\n", "ascii"));
      this.push(Buffer.from("--" + this.boundary + "--", "ascii"));
      return next();
    }
  }
  module.exports = UploadStream;
});

// node_modules/cloudinary/lib/uploader.js
var require_uploader = __commonJS((exports) => {
  function call_tags_api(tag, command, public_ids = [], callback, options = {}) {
    return call_api("tags", callback, options, function() {
      let params = {
        timestamp: utils.timestamp(),
        public_ids: utils.build_array(public_ids),
        command,
        type: options.type
      };
      if (tag != null) {
        params.tag = tag;
      }
      return [params];
    });
  }
  function call_context_api(context, command, public_ids = [], callback, options = {}) {
    return call_api("context", callback, options, function() {
      let params = {
        timestamp: utils.timestamp(),
        public_ids: utils.build_array(public_ids),
        command,
        type: options.type
      };
      if (context != null) {
        params.context = utils.encode_context(context);
      }
      return [params];
    });
  }
  function cacheResults(result, { type, resource_type }) {
    if (result.responsive_breakpoints) {
      result.responsive_breakpoints.forEach(({
        transformation,
        url,
        breakpoints
      }) => Cache.set(result.public_id, { type, resource_type, raw_transformation: transformation, format: extname(breakpoints[0].url).slice(1) }, breakpoints.map((i) => i.width)));
    }
  }
  function parseResult(buffer, res) {
    let result = "";
    try {
      result = JSON.parse(buffer);
      if (result.error && !result.error.name) {
        result.error.name = "Error";
      }
    } catch (jsonError) {
      result = {
        error: {
          message: `Server return invalid JSON response. Status Code ${res.statusCode}. ${jsonError}`,
          name: "Error"
        }
      };
    }
    return result;
  }
  function call_api(action, callback, options, get_params) {
    if (typeof callback !== "function") {
      callback = function() {
      };
    }
    const USE_PROMISES = !options.disable_promises;
    let deferred = Q.defer();
    if (options == null) {
      options = {};
    }
    let [params, unsigned_params, file] = get_params.call();
    params = utils.process_request_params(params, options);
    params = extend(params, unsigned_params);
    let api_url = utils.api_url(action, options);
    let boundary = utils.random_public_id();
    let errorRaised = false;
    let handle_response = function(res) {
      if (errorRaised) {
      } else if (res.error) {
        errorRaised = true;
        if (USE_PROMISES) {
          deferred.reject(res);
        }
        callback(res);
      } else if (includes([200, 400, 401, 404, 420, 500], res.statusCode)) {
        let buffer = "";
        res.on("data", (d) => {
          buffer += d;
          return buffer;
        });
        res.on("end", () => {
          let result2;
          if (errorRaised) {
            return;
          }
          result2 = parseResult(buffer, res);
          if (result2.error) {
            result2.error.http_code = res.statusCode;
            if (USE_PROMISES) {
              deferred.reject(result2.error);
            }
          } else {
            cacheResults(result2, options);
            if (USE_PROMISES) {
              deferred.resolve(result2);
            }
          }
          callback(result2);
        });
        res.on("error", (error) => {
          errorRaised = true;
          if (USE_PROMISES) {
            deferred.reject(error);
          }
          callback({ error });
        });
      } else {
        let error = {
          message: `Server returned unexpected status code - ${res.statusCode}`,
          http_code: res.statusCode,
          name: "UnexpectedResponse"
        };
        if (USE_PROMISES) {
          deferred.reject(error);
        }
        callback({ error });
      }
    };
    let post_data = utils.hashToParameters(params).filter(([key, value]) => value != null).map(([key, value]) => Buffer.from(encodeFieldPart(boundary, key, value), "utf8"));
    let result = post(api_url, post_data, boundary, file, handle_response, options);
    if (isObject(result)) {
      return result;
    }
    if (USE_PROMISES) {
      return deferred.promise;
    }
  }
  function post(url, post_data, boundary, file, callback, options) {
    let file_header;
    let finish_buffer = Buffer.from("--" + boundary + "--", "ascii");
    let oauth_token = options.oauth_token || config().oauth_token;
    if (file != null || options.stream) {
      let filename = options.stream ? options.filename ? options.filename : "file" : basename(file);
      file_header = Buffer.from(encodeFilePart(boundary, "application/octet-stream", "file", filename), "binary");
    }
    let post_options = urlLib.parse(url);
    let headers = {
      "Content-Type": `multipart/form-data; boundary=${boundary}`,
      "User-Agent": utils.getUserAgent()
    };
    if (options.content_range != null) {
      headers["Content-Range"] = options.content_range;
    }
    if (options.x_unique_upload_id != null) {
      headers["X-Unique-Upload-Id"] = options.x_unique_upload_id;
    }
    if (options.extra_headers !== null) {
      headers = merge(headers, options.extra_headers);
    }
    if (oauth_token != null) {
      headers.Authorization = `Bearer ${oauth_token}`;
    }
    post_options = extend(post_options, {
      method: "POST",
      headers
    });
    if (options.agent != null) {
      post_options.agent = options.agent;
    }
    let proxy = options.api_proxy || config().api_proxy;
    if (!isEmpty(proxy)) {
      if (!post_options.agent && agent) {
        post_options.agent = agent;
      } else if (!post_options.agent) {
        post_options.agent = new https.Agent(proxy);
      } else {
        console.warn("Proxy is set, but request uses a custom agent, proxy is ignored.");
      }
    }
    let post_request = https.request(post_options, callback);
    let upload_stream = new UploadStream({ boundary });
    upload_stream.pipe(post_request);
    let timeout = false;
    post_request.on("error", function(error) {
      if (timeout) {
        error = {
          message: "Request Timeout",
          http_code: 499,
          name: "TimeoutError"
        };
      }
      return callback({ error });
    });
    post_request.setTimeout(options.timeout != null ? options.timeout : 60000, function() {
      timeout = true;
      return post_request.abort();
    });
    post_data.forEach((postDatum) => post_request.write(postDatum));
    if (options.stream) {
      post_request.write(file_header);
      return upload_stream;
    }
    if (file != null) {
      post_request.write(file_header);
      fs.createReadStream(file).on("error", function(error) {
        callback({
          error
        });
        return post_request.abort();
      }).pipe(upload_stream);
    } else {
      post_request.write(finish_buffer);
      post_request.end();
    }
    return true;
  }
  function encodeFieldPart(boundary, name, value) {
    return [
      `--${boundary}\r\n`,
      `Content-Disposition: form-data; name="${name}"\r\n`,
      "\r\n",
      `${value}\r\n`,
      ""
    ].join("");
  }
  function encodeFilePart(boundary, type, name, filename) {
    return [
      `--${boundary}\r\n`,
      `Content-Disposition: form-data; name="${name}"; filename="${filename}"\r\n`,
      `Content-Type: ${type}\r\n`,
      "\r\n",
      ""
    ].join("");
  }
  var fs = import.meta.require("fs");
  var { extname, basename } = import.meta.require("path");
  var Q = require_q();
  var Writable = import.meta.require("stream").Writable;
  var urlLib = import.meta.require("url");
  var { upload_prefix } = require_config()();
  var isSecure = !(upload_prefix && upload_prefix.slice(0, 5) === "http:");
  var https = isSecure ? import.meta.require("https") : import.meta.require("http");
  var Cache = require_cache();
  var utils = require_utils();
  var UploadStream = require_upload_stream();
  var config = require_config();
  var ensureOption = require_ensureOption().defaults(config());
  var agent = config.api_proxy ? new https.Agent(config.api_proxy) : null;
  var {
    build_upload_params,
    extend,
    includes,
    isEmpty,
    isObject,
    isRemoteUrl,
    merge,
    pickOnlyExistingValues
  } = utils;
  exports.unsigned_upload_stream = function unsigned_upload_stream(upload_preset, callback, options = {}) {
    return exports.upload_stream(callback, merge(options, {
      unsigned: true,
      upload_preset
    }));
  };
  exports.upload_stream = function upload_stream(callback, options = {}) {
    return exports.upload(null, callback, extend({
      stream: true
    }, options));
  };
  exports.unsigned_upload = function unsigned_upload(file, upload_preset, callback, options = {}) {
    return exports.upload(file, callback, merge(options, {
      unsigned: true,
      upload_preset
    }));
  };
  exports.upload = function upload(file, callback, options = {}) {
    return call_api("upload", callback, options, function() {
      let params = build_upload_params(options);
      return isRemoteUrl(file) ? [params, { file }] : [params, {}, file];
    });
  };
  exports.upload_large = function upload_large(path, callback, options = {}) {
    if (path != null && isRemoteUrl(path)) {
      return exports.upload(path, callback, options);
    }
    if (path != null && !options.filename) {
      options.filename = path.split(/(\\|\/)/g).pop().replace(/\.[^/.]+$/, "");
    }
    return exports.upload_chunked(path, callback, extend({
      resource_type: "raw"
    }, options));
  };
  exports.upload_chunked = function upload_chunked(path, callback, options) {
    let file_reader = fs.createReadStream(path);
    let out_stream = exports.upload_chunked_stream(callback, options);
    return file_reader.pipe(out_stream);
  };

  class Chunkable extends Writable {
    constructor(options) {
      super(options);
      this.chunk_size = options.chunk_size != null ? options.chunk_size : 20000000;
      this.buffer = Buffer.alloc(0);
      this.active = true;
      this.on("finish", () => {
        if (this.active) {
          this.emit("ready", this.buffer, true, function() {
          });
        }
      });
    }
    _write(data, encoding, done) {
      if (!this.active) {
        done();
      }
      if (this.buffer.length + data.length <= this.chunk_size) {
        this.buffer = Buffer.concat([this.buffer, data], this.buffer.length + data.length);
        done();
      } else {
        const grab = this.chunk_size - this.buffer.length;
        this.buffer = Buffer.concat([this.buffer, data.slice(0, grab)], this.buffer.length + grab);
        this.emit("ready", this.buffer, false, (active) => {
          this.active = active;
          if (this.active) {
            const remaining = data.slice(grab);
            this.buffer = Buffer.alloc(0);
            this._write(remaining, encoding, done);
          }
        });
      }
    }
  }
  exports.upload_large_stream = function upload_large_stream(_unused_, callback, options = {}) {
    return exports.upload_chunked_stream(callback, extend({
      resource_type: "raw"
    }, options));
  };
  exports.upload_chunked_stream = function upload_chunked_stream(callback, options = {}) {
    options = extend({}, options, {
      stream: true
    });
    options.x_unique_upload_id = utils.random_public_id();
    let params = build_upload_params(options);
    let chunk_size = options.chunk_size != null ? options.chunk_size : options.part_size;
    let chunker = new Chunkable({
      chunk_size
    });
    let sent = 0;
    chunker.on("ready", function(buffer, is_last, done) {
      let chunk_start = sent;
      sent += buffer.length;
      options.content_range = `bytes ${chunk_start}-${sent - 1}/${is_last ? sent : -1}`;
      params.timestamp = utils.timestamp();
      let finished_part = function(result) {
        const errorOrLast = result.error != null || is_last;
        if (errorOrLast && typeof callback === "function") {
          callback(result);
        }
        return done(!errorOrLast);
      };
      let stream = call_api("upload", finished_part, options, function() {
        return [params, {}, buffer];
      });
      return stream.write(buffer, "buffer", function() {
        return stream.end();
      });
    });
    return chunker;
  };
  exports.explicit = function explicit(public_id, callback, options = {}) {
    return call_api("explicit", callback, options, function() {
      return utils.build_explicit_api_params(public_id, options);
    });
  };
  exports.create_archive = function create_archive(callback, options = {}, target_format = null) {
    return call_api("generate_archive", callback, options, function() {
      let opt = utils.archive_params(options);
      if (target_format) {
        opt.target_format = target_format;
      }
      return [opt];
    });
  };
  exports.create_zip = function create_zip(callback, options = {}) {
    return exports.create_archive(callback, options, "zip");
  };
  exports.create_slideshow = function create_slideshow(options, callback) {
    options.resource_type = ensureOption(options, "resource_type", "video");
    return call_api("create_slideshow", callback, options, function() {
      const manifest_transformation = utils.generate_transformation_string(extend({}, options.manifest_transformation));
      const transformation = utils.generate_transformation_string(extend({}, ensureOption(options, "transformation", {})));
      return [
        {
          timestamp: utils.timestamp(),
          manifest_transformation,
          upload_preset: options.upload_preset,
          overwrite: options.overwrite,
          public_id: options.public_id,
          notification_url: options.notification_url,
          manifest_json: options.manifest_json,
          tags: options.tags,
          transformation
        }
      ];
    });
  };
  exports.destroy = function destroy(public_id, callback, options = {}) {
    return call_api("destroy", callback, options, function() {
      return [
        {
          timestamp: utils.timestamp(),
          type: options.type,
          invalidate: options.invalidate,
          public_id,
          notification_url: options.notification_url
        }
      ];
    });
  };
  exports.rename = function rename(from_public_id, to_public_id, callback, options = {}) {
    return call_api("rename", callback, options, function() {
      return [
        {
          timestamp: utils.timestamp(),
          type: options.type,
          from_public_id,
          to_public_id,
          overwrite: options.overwrite,
          invalidate: options.invalidate,
          to_type: options.to_type,
          context: options.context,
          metadata: options.metadata,
          notification_url: options.notification_url
        }
      ];
    });
  };
  var TEXT_PARAMS = ["public_id", "font_family", "font_size", "font_color", "text_align", "font_weight", "font_style", "background", "opacity", "text_decoration", "font_hinting", "font_antialiasing"];
  exports.text = function text(content, callback, options = {}) {
    return call_api("text", callback, options, function() {
      let textParams = pickOnlyExistingValues(options, ...TEXT_PARAMS);
      let params = {
        timestamp: utils.timestamp(),
        text: content,
        ...textParams
      };
      return [params];
    });
  };
  exports.generate_sprite = function generate_sprite(tag, callback, options = {}) {
    return call_api("sprite", callback, options, function() {
      return [utils.build_multi_and_sprite_params(tag, options)];
    });
  };
  exports.download_generated_sprite = function download_generated_sprite(tag, options = {}) {
    return utils.api_download_url("sprite", utils.build_multi_and_sprite_params(tag, options), options);
  };
  exports.download_multi = function download_multi(tag, options = {}) {
    return utils.api_download_url("multi", utils.build_multi_and_sprite_params(tag, options), options);
  };
  exports.multi = function multi(tag, callback, options = {}) {
    return call_api("multi", callback, options, function() {
      return [utils.build_multi_and_sprite_params(tag, options)];
    });
  };
  exports.explode = function explode(public_id, callback, options = {}) {
    return call_api("explode", callback, options, function() {
      const transformation = utils.generate_transformation_string(extend({}, options));
      return [
        {
          timestamp: utils.timestamp(),
          public_id,
          transformation,
          format: options.format,
          type: options.type,
          notification_url: options.notification_url
        }
      ];
    });
  };
  exports.add_tag = function add_tag(tag, public_ids = [], callback, options = {}) {
    const exclusive = utils.option_consume("exclusive", options);
    const command = exclusive ? "set_exclusive" : "add";
    return call_tags_api(tag, command, public_ids, callback, options);
  };
  exports.remove_tag = function remove_tag(tag, public_ids = [], callback, options = {}) {
    return call_tags_api(tag, "remove", public_ids, callback, options);
  };
  exports.remove_all_tags = function remove_all_tags(public_ids = [], callback, options = {}) {
    return call_tags_api(null, "remove_all", public_ids, callback, options);
  };
  exports.replace_tag = function replace_tag(tag, public_ids = [], callback, options = {}) {
    return call_tags_api(tag, "replace", public_ids, callback, options);
  };
  exports.add_context = function add_context(context, public_ids = [], callback, options = {}) {
    return call_context_api(context, "add", public_ids, callback, options);
  };
  exports.remove_all_context = function remove_all_context(public_ids = [], callback, options = {}) {
    return call_context_api(null, "remove_all", public_ids, callback, options);
  };
  exports.direct_upload = function direct_upload(callback_url, options = {}) {
    let params = build_upload_params(extend({
      callback: callback_url
    }, options));
    params = utils.process_request_params(params, options);
    let api_url = utils.api_url("upload", options);
    return {
      hidden_fields: params,
      form_attrs: {
        action: api_url,
        method: "POST",
        enctype: "multipart/form-data"
      }
    };
  };
  exports.upload_tag_params = function upload_tag_params(options = {}) {
    let params = build_upload_params(options);
    params = utils.process_request_params(params, options);
    return JSON.stringify(params);
  };
  exports.upload_url = function upload_url(options = {}) {
    if (options.resource_type == null) {
      options.resource_type = "auto";
    }
    return utils.api_url("upload", options);
  };
  exports.image_upload_tag = function image_upload_tag(field, options = {}) {
    let html_options = options.html || {};
    let tag_options = extend({
      type: "file",
      name: "file",
      "data-url": exports.upload_url(options),
      "data-form-data": exports.upload_tag_params(options),
      "data-cloudinary-field": field,
      "data-max-chunk-size": options.chunk_size,
      class: [html_options.class, "cloudinary-fileupload"].join(" ")
    }, html_options);
    return `<input ${utils.html_attrs(tag_options)}/>`;
  };
  exports.unsigned_image_upload_tag = function unsigned_image_upload_tag(field, upload_preset, options = {}) {
    return exports.image_upload_tag(field, merge(options, {
      unsigned: true,
      upload_preset
    }));
  };
  exports.update_metadata = function update_metadata(metadata, public_ids, callback, options = {}) {
    return call_api("metadata", callback, options, function() {
      let params = {
        metadata: utils.encode_context(metadata),
        public_ids: utils.build_array(public_ids),
        timestamp: utils.timestamp(),
        type: options.type,
        clear_invalid: options.clear_invalid
      };
      return [params];
    });
  };
});

// node_modules/cloudinary/lib/api_client/execute_request.js
var require_execute_request = __commonJS((exports, module) => {
  function execute_request(method, params, auth, api_url, callback, options = {}) {
    method = method.toUpperCase();
    const deferred = Q.defer();
    let query_params, handle_response;
    let key = auth.key;
    let secret = auth.secret;
    let oauth_token = auth.oauth_token;
    let content_type = "application/x-www-form-urlencoded";
    if (options.content_type === "json") {
      query_params = JSON.stringify(params);
      content_type = "application/json";
    } else {
      query_params = querystring.stringify(params);
    }
    if (method === "GET") {
      api_url += "?" + query_params;
    }
    let request_options = url.parse(api_url);
    request_options = extend(request_options, {
      method,
      headers: {
        "Content-Type": content_type,
        "User-Agent": utils.getUserAgent()
      }
    });
    if (oauth_token) {
      request_options.headers.Authorization = `Bearer ${oauth_token}`;
    } else {
      request_options.auth = key + ":" + secret;
    }
    if (options.agent != null) {
      request_options.agent = options.agent;
    }
    let proxy = options.api_proxy || config().api_proxy;
    if (!isEmpty(proxy)) {
      if (!request_options.agent && agent) {
        request_options.agent = agent;
      } else if (!request_options.agent) {
        request_options.agent = new https.Agent(proxy);
      } else {
        console.warn("Proxy is set, but request uses a custom agent, proxy is ignored.");
      }
    }
    if (method !== "GET") {
      request_options.headers["Content-Length"] = Buffer.byteLength(query_params);
    }
    handle_response = function(res) {
      const { hide_sensitive = false } = config();
      const sanitizedOptions = { ...request_options };
      if (hide_sensitive === true) {
        if ("auth" in sanitizedOptions) {
          delete sanitizedOptions.auth;
        }
        if ("Authorization" in sanitizedOptions.headers) {
          delete sanitizedOptions.headers.Authorization;
        }
      }
      if (includes([200, 400, 401, 403, 404, 409, 420, 500], res.statusCode)) {
        let buffer = "";
        let error = false;
        res.on("data", function(d) {
          buffer += d;
          return buffer;
        });
        res.on("end", function() {
          let result;
          if (error) {
            return;
          }
          try {
            result = JSON.parse(buffer);
          } catch (e) {
            result = {
              error: {
                message: "Server return invalid JSON response. Status Code " + res.statusCode
              }
            };
          }
          if (result.error) {
            result.error.http_code = res.statusCode;
          } else {
            if (res.headers["x-featureratelimit-limit"]) {
              result.rate_limit_allowed = parseInt(res.headers["x-featureratelimit-limit"]);
            }
            if (res.headers["x-featureratelimit-reset"]) {
              result.rate_limit_reset_at = new Date(res.headers["x-featureratelimit-reset"]);
            }
            if (res.headers["x-featureratelimit-remaining"]) {
              result.rate_limit_remaining = parseInt(res.headers["x-featureratelimit-remaining"]);
            }
          }
          if (result.error) {
            deferred.reject(Object.assign({
              request_options: sanitizedOptions,
              query_params
            }, result));
          } else {
            deferred.resolve(result);
          }
          if (typeof callback === "function") {
            callback(result);
          }
        });
        res.on("error", function(e) {
          error = true;
          let err_obj = {
            error: {
              message: e,
              http_code: res.statusCode,
              request_options: sanitizedOptions,
              query_params
            }
          };
          deferred.reject(err_obj.error);
          if (typeof callback === "function") {
            callback(err_obj);
          }
        });
      } else {
        let err_obj = {
          error: {
            message: "Server returned unexpected status code - " + res.statusCode,
            http_code: res.statusCode,
            request_options: sanitizedOptions,
            query_params
          }
        };
        deferred.reject(err_obj.error);
        if (typeof callback === "function") {
          callback(err_obj);
        }
      }
    };
    const request = https.request(request_options, handle_response);
    request.on("error", function(e) {
      deferred.reject(e);
      return typeof callback === "function" ? callback({ error: e }) : undefined;
    });
    request.setTimeout(ensureOption(options, "timeout", 60000));
    if (method !== "GET") {
      request.write(query_params);
    }
    request.end();
    return deferred.promise;
  }
  var config = require_config();
  var https = /^http:/.test(config().upload_prefix) ? import.meta.require("http") : import.meta.require("https");
  var querystring = import.meta.require("querystring");
  var Q = require_q();
  var url = import.meta.require("url");
  var utils = require_utils();
  var ensureOption = require_ensureOption().defaults(config());
  var { extend, includes, isEmpty } = utils;
  var agent = config.api_proxy ? new https.Agent(config.api_proxy) : null;
  module.exports = execute_request;
});

// node_modules/cloudinary/lib/api_client/call_api.js
var require_call_api = __commonJS((exports, module) => {
  function call_api(method, uri, params, callback, options) {
    ensurePresenceOf({ method, uri });
    const api_url = utils.base_api_url_v1()(uri, options);
    let auth = {};
    if (options.oauth_token || config().oauth_token) {
      auth = {
        oauth_token: ensureOption(options, "oauth_token")
      };
    } else {
      auth = {
        key: ensureOption(options, "api_key"),
        secret: ensureOption(options, "api_secret")
      };
    }
    return execute_request(method, params, auth, api_url, callback, options);
  }
  var config = require_config();
  var utils = require_utils();
  var ensureOption = require_ensureOption().defaults(config());
  var execute_request = require_execute_request();
  var { ensurePresenceOf } = utils;
  module.exports = call_api;
});

// node_modules/cloudinary/lib/api.js
var require_api = __commonJS((exports) => {
  function deleteResourcesParams(options, params = {}) {
    return extend(params, pickOnlyExistingValues(options, "keep_original", "invalidate", "next_cursor", "transformations"));
  }
  function getResourceParams(options) {
    return pickOnlyExistingValues(options, "exif", "cinemagraph_analysis", "colors", "derived_next_cursor", "faces", "image_metadata", "media_metadata", "pages", "phash", "coordinates", "max_results", "versions", "accessibility_analysis", "related", "related_next_cursor");
  }
  function publishResource(byKey, value, callback, options = {}) {
    let params, resource_type, uri;
    params = pickOnlyExistingValues(options, "type", "invalidate", "overwrite");
    params[byKey] = value;
    resource_type = options.resource_type || "image";
    uri = ["resources", resource_type, "publish_resources"];
    options = extend({
      resource_type
    }, options);
    return call_api("post", uri, params, callback, options);
  }
  function updateResourcesAccessMode(access_mode, by_key, value, callback, options = {}) {
    let params, resource_type, type;
    resource_type = options.resource_type || "image";
    type = options.type || "upload";
    params = {
      access_mode
    };
    params[by_key] = value;
    return call_api("post", "resources/" + resource_type + "/" + type + "/update_access_mode", params, callback, options);
  }
  var utils = require_utils();
  var call_api = require_call_api();
  var {
    extend,
    pickOnlyExistingValues
  } = utils;
  var TRANSFORMATIONS_URI = "transformations";
  exports.ping = function ping(callback, options = {}) {
    return call_api("get", ["ping"], {}, callback, options);
  };
  exports.usage = function usage(callback, options = {}) {
    const uri = ["usage"];
    if (options.date) {
      uri.push(options.date);
    }
    return call_api("get", uri, {}, callback, options);
  };
  exports.resource_types = function resource_types(callback, options = {}) {
    return call_api("get", ["resources"], {}, callback, options);
  };
  exports.resources = function resources(callback, options = {}) {
    let resource_type, type, uri;
    resource_type = options.resource_type || "image";
    type = options.type;
    uri = ["resources", resource_type];
    if (type != null) {
      uri.push(type);
    }
    if (options.start_at != null && Object.prototype.toString.call(options.start_at) === "[object Date]") {
      options.start_at = options.start_at.toUTCString();
    }
    return call_api("get", uri, pickOnlyExistingValues(options, "next_cursor", "max_results", "prefix", "tags", "context", "direction", "moderations", "start_at", "metadata", "fields"), callback, options);
  };
  exports.resources_by_tag = function resources_by_tag(tag, callback, options = {}) {
    let resource_type, uri;
    resource_type = options.resource_type || "image";
    uri = ["resources", resource_type, "tags", tag];
    return call_api("get", uri, pickOnlyExistingValues(options, "next_cursor", "max_results", "tags", "context", "direction", "moderations", "metadata", "fields"), callback, options);
  };
  exports.resources_by_context = function resources_by_context(key, value, callback, options = {}) {
    let params, resource_type, uri;
    resource_type = options.resource_type || "image";
    uri = ["resources", resource_type, "context"];
    params = pickOnlyExistingValues(options, "next_cursor", "max_results", "tags", "context", "direction", "moderations", "metadata", "fields");
    params.key = key;
    if (value != null) {
      params.value = value;
    }
    return call_api("get", uri, params, callback, options);
  };
  exports.resources_by_moderation = function resources_by_moderation(kind, status, callback, options = {}) {
    let resource_type, uri;
    resource_type = options.resource_type || "image";
    uri = ["resources", resource_type, "moderations", kind, status];
    return call_api("get", uri, pickOnlyExistingValues(options, "next_cursor", "max_results", "tags", "context", "direction", "moderations", "metadata", "fields"), callback, options);
  };
  exports.resource_by_asset_id = function resource_by_asset_id(asset_id, callback, options = {}) {
    const uri = ["resources", asset_id];
    return call_api("get", uri, getResourceParams(options), callback, options);
  };
  exports.resources_by_asset_folder = function resources_by_asset_folder(asset_folder, callback, options = {}) {
    let params, uri;
    uri = ["resources", "by_asset_folder"];
    params = pickOnlyExistingValues(options, "next_cursor", "max_results", "tags", "context", "moderations", "fields");
    params.asset_folder = asset_folder;
    return call_api("get", uri, params, callback, options);
  };
  exports.resources_by_asset_ids = function resources_by_asset_ids(asset_ids, callback, options = {}) {
    let params, uri;
    uri = ["resources", "by_asset_ids"];
    params = pickOnlyExistingValues(options, "tags", "context", "moderations", "fields");
    params["asset_ids[]"] = asset_ids;
    return call_api("get", uri, params, callback, options);
  };
  exports.resources_by_ids = function resources_by_ids(public_ids, callback, options = {}) {
    let params, resource_type, type, uri;
    resource_type = options.resource_type || "image";
    type = options.type || "upload";
    uri = ["resources", resource_type, type];
    params = pickOnlyExistingValues(options, "tags", "context", "moderations", "fields");
    params["public_ids[]"] = public_ids;
    return call_api("get", uri, params, callback, options);
  };
  exports.resource = function resource(public_id, callback, options = {}) {
    let resource_type, type, uri;
    resource_type = options.resource_type || "image";
    type = options.type || "upload";
    uri = ["resources", resource_type, type, public_id];
    return call_api("get", uri, getResourceParams(options), callback, options);
  };
  exports.restore = function restore(public_ids, callback, options = {}) {
    options.content_type = "json";
    let resource_type, type, uri;
    resource_type = options.resource_type || "image";
    type = options.type || "upload";
    uri = ["resources", resource_type, type, "restore"];
    return call_api("post", uri, {
      public_ids,
      versions: options.versions
    }, callback, options);
  };
  exports.update = function update(public_id, callback, options = {}) {
    let params, resource_type, type, uri;
    resource_type = options.resource_type || "image";
    type = options.type || "upload";
    uri = ["resources", resource_type, type, public_id];
    params = utils.updateable_resource_params(options);
    if (options.moderation_status != null) {
      params.moderation_status = options.moderation_status;
    }
    if (options.clear_invalid != null) {
      params.clear_invalid = options.clear_invalid;
    }
    return call_api("post", uri, params, callback, options);
  };
  exports.delete_resources = function delete_resources(public_ids, callback, options = {}) {
    let resource_type, type, uri;
    resource_type = options.resource_type || "image";
    type = options.type || "upload";
    uri = ["resources", resource_type, type];
    return call_api("delete", uri, deleteResourcesParams(options, {
      "public_ids[]": public_ids
    }), callback, options);
  };
  exports.delete_resources_by_prefix = function delete_resources_by_prefix(prefix, callback, options = {}) {
    let resource_type, type, uri;
    resource_type = options.resource_type || "image";
    type = options.type || "upload";
    uri = ["resources", resource_type, type];
    return call_api("delete", uri, deleteResourcesParams(options, {
      prefix
    }), callback, options);
  };
  exports.delete_resources_by_tag = function delete_resources_by_tag(tag, callback, options = {}) {
    let resource_type, uri;
    resource_type = options.resource_type || "image";
    uri = ["resources", resource_type, "tags", tag];
    return call_api("delete", uri, deleteResourcesParams(options), callback, options);
  };
  exports.delete_all_resources = function delete_all_resources(callback, options = {}) {
    let resource_type, type, uri;
    resource_type = options.resource_type || "image";
    type = options.type || "upload";
    uri = ["resources", resource_type, type];
    return call_api("delete", uri, deleteResourcesParams(options, {
      all: true
    }), callback, options);
  };
  var createRelationParams = (publicIds = []) => {
    return {
      assets_to_relate: Array.isArray(publicIds) ? publicIds : [publicIds]
    };
  };
  var deleteRelationParams = (publicIds = []) => {
    return {
      assets_to_unrelate: Array.isArray(publicIds) ? publicIds : [publicIds]
    };
  };
  exports.add_related_assets = (publicId, assetsToRelate, callback, options = {}) => {
    const params = createRelationParams(assetsToRelate);
    return call_api("post", ["resources", "related_assets", options.resource_type, options.type, publicId], params, callback, options);
  };
  exports.add_related_assets_by_asset_id = (assetId, assetsToRelate, callback, options = {}) => {
    const params = createRelationParams(assetsToRelate);
    return call_api("post", ["resources", "related_assets", assetId], params, callback, options);
  };
  exports.delete_related_assets = (publicId, assetsToUnrelate, callback, options = {}) => {
    const params = deleteRelationParams(assetsToUnrelate);
    return call_api("delete", ["resources", "related_assets", options.resource_type, options.type, publicId], params, callback, options);
  };
  exports.delete_related_assets_by_asset_id = (assetId, assetsToUnrelate, callback, options = {}) => {
    const params = deleteRelationParams(assetsToUnrelate);
    return call_api("delete", ["resources", "related_assets", assetId], params, callback, options);
  };
  exports.delete_derived_resources = function delete_derived_resources(derived_resource_ids, callback, options = {}) {
    let uri;
    uri = ["derived_resources"];
    return call_api("delete", uri, {
      "derived_resource_ids[]": derived_resource_ids
    }, callback, options);
  };
  exports.delete_derived_by_transformation = function delete_derived_by_transformation(public_ids, transformations, callback, options = {}) {
    let params, resource_type, type, uri;
    resource_type = options.resource_type || "image";
    type = options.type || "upload";
    uri = "resources/" + resource_type + "/" + type;
    params = extend({
      "public_ids[]": public_ids
    }, pickOnlyExistingValues(options, "invalidate"));
    params.keep_original = true;
    params.transformations = utils.build_eager(transformations);
    return call_api("delete", uri, params, callback, options);
  };
  exports.tags = function tags(callback, options = {}) {
    let resource_type, uri;
    resource_type = options.resource_type || "image";
    uri = ["tags", resource_type];
    return call_api("get", uri, pickOnlyExistingValues(options, "next_cursor", "max_results", "prefix"), callback, options);
  };
  exports.transformations = function transformations(callback, options = {}) {
    const params = pickOnlyExistingValues(options, "next_cursor", "max_results", "named");
    return call_api("get", TRANSFORMATIONS_URI, params, callback, options);
  };
  exports.transformation = function transformation(transformationName, callback, options = {}) {
    const params = pickOnlyExistingValues(options, "next_cursor", "max_results");
    params.transformation = utils.build_eager(transformationName);
    return call_api("get", TRANSFORMATIONS_URI, params, callback, options);
  };
  exports.delete_transformation = function delete_transformation(transformationName, callback, options = {}) {
    const params = {};
    params.transformation = utils.build_eager(transformationName);
    return call_api("delete", TRANSFORMATIONS_URI, params, callback, options);
  };
  exports.update_transformation = function update_transformation(transformationName, updates, callback, options = {}) {
    const params = pickOnlyExistingValues(updates, "allowed_for_strict");
    params.transformation = utils.build_eager(transformationName);
    if (updates.unsafe_update != null) {
      params.unsafe_update = utils.build_eager(updates.unsafe_update);
    }
    return call_api("put", TRANSFORMATIONS_URI, params, callback, options);
  };
  exports.create_transformation = function create_transformation(name, definition, callback, options = {}) {
    const params = { name };
    params.transformation = utils.build_eager(definition);
    return call_api("post", TRANSFORMATIONS_URI, params, callback, options);
  };
  exports.upload_presets = function upload_presets(callback, options = {}) {
    return call_api("get", ["upload_presets"], pickOnlyExistingValues(options, "next_cursor", "max_results"), callback, options);
  };
  exports.upload_preset = function upload_preset(name, callback, options = {}) {
    let uri;
    uri = ["upload_presets", name];
    return call_api("get", uri, {}, callback, options);
  };
  exports.delete_upload_preset = function delete_upload_preset(name, callback, options = {}) {
    let uri;
    uri = ["upload_presets", name];
    return call_api("delete", uri, {}, callback, options);
  };
  exports.update_upload_preset = function update_upload_preset(name, callback, options = {}) {
    let params, uri;
    uri = ["upload_presets", name];
    params = utils.merge(utils.clear_blank(utils.build_upload_params(options)), pickOnlyExistingValues(options, "unsigned", "disallow_public_id", "live"));
    return call_api("put", uri, params, callback, options);
  };
  exports.create_upload_preset = function create_upload_preset(callback, options = {}) {
    let params, uri;
    uri = ["upload_presets"];
    params = utils.merge(utils.clear_blank(utils.build_upload_params(options)), pickOnlyExistingValues(options, "name", "unsigned", "disallow_public_id", "live"));
    return call_api("post", uri, params, callback, options);
  };
  exports.root_folders = function root_folders(callback, options = {}) {
    let uri, params;
    uri = ["folders"];
    params = pickOnlyExistingValues(options, "next_cursor", "max_results");
    return call_api("get", uri, params, callback, options);
  };
  exports.sub_folders = function sub_folders(path, callback, options = {}) {
    let uri, params;
    uri = ["folders", path];
    params = pickOnlyExistingValues(options, "next_cursor", "max_results");
    return call_api("get", uri, params, callback, options);
  };
  exports.create_folder = function create_folder(path, callback, options = {}) {
    let uri;
    uri = ["folders", path];
    return call_api("post", uri, {}, callback, options);
  };
  exports.delete_folder = function delete_folder(path, callback, options = {}) {
    let uri;
    uri = ["folders", path];
    return call_api("delete", uri, {}, callback, options);
  };
  exports.rename_folder = function rename_folder(old_path, new_path, callback, options = {}) {
    let uri;
    uri = ["folders", old_path];
    let rename_folder_params = {
      to_folder: new_path
    };
    options.content_type = "json";
    return call_api("put", uri, rename_folder_params, callback, options);
  };
  exports.upload_mappings = function upload_mappings(callback, options = {}) {
    let params;
    params = pickOnlyExistingValues(options, "next_cursor", "max_results");
    return call_api("get", "upload_mappings", params, callback, options);
  };
  exports.upload_mapping = function upload_mapping(name, callback, options = {}) {
    if (name == null) {
      name = null;
    }
    return call_api("get", "upload_mappings", {
      folder: name
    }, callback, options);
  };
  exports.delete_upload_mapping = function delete_upload_mapping(name, callback, options = {}) {
    return call_api("delete", "upload_mappings", {
      folder: name
    }, callback, options);
  };
  exports.update_upload_mapping = function update_upload_mapping(name, callback, options = {}) {
    let params;
    params = pickOnlyExistingValues(options, "template");
    params.folder = name;
    return call_api("put", "upload_mappings", params, callback, options);
  };
  exports.create_upload_mapping = function create_upload_mapping(name, callback, options = {}) {
    let params;
    params = pickOnlyExistingValues(options, "template");
    params.folder = name;
    return call_api("post", "upload_mappings", params, callback, options);
  };
  exports.publish_by_prefix = function publish_by_prefix(prefix, callback, options = {}) {
    return publishResource("prefix", prefix, callback, options);
  };
  exports.publish_by_tag = function publish_by_tag(tag, callback, options = {}) {
    return publishResource("tag", tag, callback, options);
  };
  exports.publish_by_ids = function publish_by_ids(public_ids, callback, options = {}) {
    return publishResource("public_ids", public_ids, callback, options);
  };
  exports.list_streaming_profiles = function list_streaming_profiles(callback, options = {}) {
    return call_api("get", "streaming_profiles", {}, callback, options);
  };
  exports.get_streaming_profile = function get_streaming_profile(name, callback, options = {}) {
    return call_api("get", "streaming_profiles/" + name, {}, callback, options);
  };
  exports.delete_streaming_profile = function delete_streaming_profile(name, callback, options = {}) {
    return call_api("delete", "streaming_profiles/" + name, {}, callback, options);
  };
  exports.update_streaming_profile = function update_streaming_profile(name, callback, options = {}) {
    let params;
    params = utils.build_streaming_profiles_param(options);
    return call_api("put", "streaming_profiles/" + name, params, callback, options);
  };
  exports.create_streaming_profile = function create_streaming_profile(name, callback, options = {}) {
    let params;
    params = utils.build_streaming_profiles_param(options);
    params.name = name;
    return call_api("post", "streaming_profiles", params, callback, options);
  };
  exports.search = function search(params, callback, options = {}) {
    options.content_type = "json";
    return call_api("post", "resources/search", params, callback, options);
  };
  exports.visual_search = function visual_search(params, callback, options = {}) {
    const allowedParams = pickOnlyExistingValues(params, "image_url", "image_asset_id", "text");
    return call_api("get", ["resources", "visual_search"], allowedParams, callback, options);
  };
  exports.search_folders = function search_folders(params, callback, options = {}) {
    options.content_type = "json";
    return call_api("post", "folders/search", params, callback, options);
  };
  exports.update_resources_access_mode_by_prefix = function update_resources_access_mode_by_prefix(access_mode, prefix, callback, options = {}) {
    return updateResourcesAccessMode(access_mode, "prefix", prefix, callback, options);
  };
  exports.update_resources_access_mode_by_tag = function update_resources_access_mode_by_tag(access_mode, tag, callback, options = {}) {
    return updateResourcesAccessMode(access_mode, "tag", tag, callback, options);
  };
  exports.update_resources_access_mode_by_ids = function update_resources_access_mode_by_ids(access_mode, ids, callback, options = {}) {
    return updateResourcesAccessMode(access_mode, "public_ids[]", ids, callback, options);
  };
  exports.add_metadata_field = function add_metadata_field(field, callback, options = {}) {
    const params = pickOnlyExistingValues(field, "external_id", "type", "label", "mandatory", "default_value", "validation", "datasource", "restrictions");
    options.content_type = "json";
    return call_api("post", ["metadata_fields"], params, callback, options);
  };
  exports.list_metadata_fields = function list_metadata_fields(callback, options = {}) {
    return call_api("get", ["metadata_fields"], {}, callback, options);
  };
  exports.delete_metadata_field = function delete_metadata_field(field_external_id, callback, options = {}) {
    return call_api("delete", ["metadata_fields", field_external_id], {}, callback, options);
  };
  exports.metadata_field_by_field_id = function metadata_field_by_field_id(external_id, callback, options = {}) {
    return call_api("get", ["metadata_fields", external_id], {}, callback, options);
  };
  exports.update_metadata_field = function update_metadata_field(external_id, field, callback, options = {}) {
    const params = pickOnlyExistingValues(field, "external_id", "type", "label", "mandatory", "default_value", "validation", "datasource", "restrictions", "default_disabled");
    options.content_type = "json";
    return call_api("put", ["metadata_fields", external_id], params, callback, options);
  };
  exports.update_metadata_field_datasource = function update_metadata_field_datasource(field_external_id, entries_external_id, callback, options = {}) {
    const params = pickOnlyExistingValues(entries_external_id, "values");
    options.content_type = "json";
    return call_api("put", ["metadata_fields", field_external_id, "datasource"], params, callback, options);
  };
  exports.delete_datasource_entries = function delete_datasource_entries(field_external_id, entries_external_id, callback, options = {}) {
    options.content_type = "json";
    const params = { external_ids: entries_external_id };
    return call_api("delete", ["metadata_fields", field_external_id, "datasource"], params, callback, options);
  };
  exports.restore_metadata_field_datasource = function restore_metadata_field_datasource(field_external_id, entries_external_id, callback, options = {}) {
    options.content_type = "json";
    const params = { external_ids: entries_external_id };
    return call_api("post", ["metadata_fields", field_external_id, "datasource_restore"], params, callback, options);
  };
  exports.order_metadata_field_datasource = function order_metadata_field_datasource(field_external_id, sort_by, direction, callback, options = {}) {
    options.content_type = "json";
    const params = {
      order_by: sort_by,
      direction
    };
    return call_api("post", ["metadata_fields", field_external_id, "datasource", "order"], params, callback, options);
  };
  exports.reorder_metadata_fields = function reorder_metadata_fields(order_by, direction, callback, options = {}) {
    options.content_type = "json";
    const params = {
      order_by,
      direction
    };
    return call_api("put", ["metadata_fields", "order"], params, callback, options);
  };
  exports.list_metadata_rules = function list_metadata_rules(callback, options = {}) {
    return call_api("get", ["metadata_rules"], {}, callback, options);
  };
  exports.add_metadata_rule = function add_metadata_rule(metadata_rule, callback, options = {}) {
    options.content_type = "json";
    const params = pickOnlyExistingValues(metadata_rule, "metadata_field_id", "condition", "result", "name");
    return call_api("post", ["metadata_rules"], params, callback, options);
  };
  exports.update_metadata_rule = function update_metadata_rule(field_external_id, updated_metadata_rule, callback, options = {}) {
    options.content_type = "json";
    const params = pickOnlyExistingValues(updated_metadata_rule, "metadata_field_id", "condition", "result", "name", "state");
    return call_api("put", ["metadata_rules", field_external_id], params, callback, options);
  };
  exports.delete_metadata_rule = function delete_metadata_rule(field_external_id, callback, options = {}) {
    return call_api("delete", ["metadata_rules", field_external_id], {}, callback, options);
  };
  exports.config = function config(callback, options = {}) {
    const params = pickOnlyExistingValues(options, "settings");
    return call_api("get", ["config"], params, callback, options);
  };
});

// node_modules/cloudinary/lib/api_client/call_analysis_api.js
var require_call_analysis_api = __commonJS((exports, module) => {
  function call_analysis_api(method, uri, params, callback, options) {
    ensurePresenceOf({
      method,
      uri
    });
    const api_url = utils.base_api_url_v2()(uri, options);
    let auth = {};
    if (options.oauth_token || config().oauth_token) {
      auth = {
        oauth_token: ensureOption(options, "oauth_token")
      };
    } else {
      auth = {
        key: ensureOption(options, "api_key"),
        secret: ensureOption(options, "api_secret")
      };
    }
    options.content_type = "json";
    return execute_request(method, params, auth, api_url, callback, options);
  }
  var utils = require_utils();
  var config = require_config();
  var ensureOption = require_ensureOption().defaults(config());
  var execute_request = require_execute_request();
  var { ensurePresenceOf } = utils;
  module.exports = {
    call_analysis_api
  };
});

// node_modules/cloudinary/lib/analysis/index.js
var require_analysis = __commonJS((exports, module) => {
  function analyze_uri(uri, analysis_type, options = {}, callback) {
    const params = {
      uri,
      analysis_type
    };
    if (analysis_type === "custom") {
      if (!("model_name" in options) || !("model_version" in options)) {
        throw new Error('Setting analysis_type to "custom" requires additional params: "model_name" and "model_version"');
      }
      params.parameters = {
        custom: {
          model_name: options.model_name,
          model_version: options.model_version
        }
      };
    }
    let api_uri = ["analysis", "analyze", "uri"];
    return call_analysis_api("POST", api_uri, params, callback, options);
  }
  var utils = require_utils();
  var { call_analysis_api } = require_call_analysis_api();
  module.exports = {
    analyze_uri
  };
});

// node_modules/cloudinary/lib/api_client/call_account_api.js
var require_call_account_api = __commonJS((exports, module) => {
  function call_account_api(method, uri, params, callback, options) {
    ensurePresenceOf({ method, uri });
    const cloudinary = ensureOption(options, "upload_prefix", "https://api.cloudinary.com");
    const account_id = ensureOption(options, "account_id");
    const api_url = [cloudinary, "v1_1", "provisioning", "accounts", account_id].concat(uri).join("/");
    const auth = {
      key: ensureOption(options, "provisioning_api_key"),
      secret: ensureOption(options, "provisioning_api_secret")
    };
    return execute_request(method, params, auth, api_url, callback, options);
  }
  var config = require_config();
  var utils = require_utils();
  var ensureOption = require_ensureOption().defaults(config());
  var execute_request = require_execute_request();
  var { ensurePresenceOf } = utils;
  module.exports = call_account_api;
});

// node_modules/cloudinary/lib/provisioning/account.js
var require_account = __commonJS((exports, module) => {
  function sub_accounts(enabled, ids = [], prefix, options = {}, callback) {
    let params = {
      enabled,
      ids,
      prefix
    };
    let uri = ["sub_accounts"];
    return call_account_api("GET", uri, params, callback, options);
  }
  function sub_account(sub_account_id, options = {}, callback) {
    let uri = ["sub_accounts", sub_account_id];
    return call_account_api("GET", uri, {}, callback, options);
  }
  function create_sub_account(name, cloud_name, custom_attributes, enabled, base_account, options = {}, callback) {
    let params = {
      cloud_name,
      name,
      custom_attributes,
      enabled,
      base_sub_account_id: base_account
    };
    options.content_type = "json";
    let uri = ["sub_accounts"];
    return call_account_api("POST", uri, params, callback, options);
  }
  function delete_sub_account(sub_account_id, options = {}, callback) {
    let uri = ["sub_accounts", sub_account_id];
    return call_account_api("DELETE", uri, {}, callback, options);
  }
  function update_sub_account(sub_account_id, name, cloud_name, custom_attributes, enabled, options = {}, callback) {
    let params = {
      cloud_name,
      name,
      custom_attributes,
      enabled
    };
    options.content_type = "json";
    let uri = ["sub_accounts", sub_account_id];
    return call_account_api("PUT", uri, params, callback, options);
  }
  function user(user_id, options = {}, callback) {
    let uri = ["users", user_id];
    return call_account_api("GET", uri, {}, callback, options);
  }
  function users(pending, user_ids, prefix, sub_account_id, options = {}, callback) {
    let uri = ["users"];
    let params = {
      ids: user_ids,
      pending,
      prefix,
      sub_account_id
    };
    return call_account_api("GET", uri, pickOnlyExistingValues(params, "ids", "pending", "prefix", "sub_account_id"), callback, options);
  }
  function create_user(name, email, role, sub_account_ids, options = {}, callback) {
    let uri = ["users"];
    let params = {
      name,
      email,
      role,
      sub_account_ids
    };
    options.content_type = "json";
    return call_account_api("POST", uri, params, callback, options);
  }
  function update_user(user_id, name, email, role, sub_account_ids, options = {}, callback) {
    let uri = ["users", user_id];
    let params = {
      name,
      email,
      role,
      sub_account_ids
    };
    options.content_type = "json";
    return call_account_api("PUT", uri, params, callback, options);
  }
  function delete_user(user_id, options = {}, callback) {
    let uri = ["users", user_id];
    return call_account_api("DELETE", uri, {}, callback, options);
  }
  function create_user_group(name, options = {}, callback) {
    let uri = ["user_groups"];
    options.content_type = "json";
    let params = {
      name
    };
    return call_account_api("POST", uri, params, callback, options);
  }
  function update_user_group(group_id, name, options = {}, callback) {
    let uri = ["user_groups", group_id];
    let params = {
      name
    };
    return call_account_api("PUT", uri, params, callback, options);
  }
  function delete_user_group(group_id, options = {}, callback) {
    let uri = ["user_groups", group_id];
    return call_account_api("DELETE", uri, {}, callback, options);
  }
  function add_user_to_group(group_id, user_id, options = {}, callback) {
    let uri = ["user_groups", group_id, "users", user_id];
    return call_account_api("POST", uri, {}, callback, options);
  }
  function remove_user_from_group(group_id, user_id, options = {}, callback) {
    let uri = ["user_groups", group_id, "users", user_id];
    return call_account_api("DELETE", uri, {}, callback, options);
  }
  function user_group(group_id, options = {}, callback) {
    let uri = ["user_groups", group_id];
    return call_account_api("GET", uri, {}, callback, options);
  }
  function user_groups(options = {}, callback) {
    let uri = ["user_groups"];
    return call_account_api("GET", uri, {}, callback, options);
  }
  function user_group_users(group_id, options = {}, callback) {
    let uri = ["user_groups", group_id, "users"];
    return call_account_api("GET", uri, {}, callback, options);
  }
  function access_keys(sub_account_id, options = {}, callback) {
    const params = pickOnlyExistingValues({
      page_size: options.page_size,
      page: options.page,
      sort_by: options.sort_by,
      sort_order: options.sort_order
    }, "page_size", "page", "sort_by", "sort_order");
    const uri = ["sub_accounts", sub_account_id, "access_keys"];
    return call_account_api("GET", uri, params, callback, options);
  }
  function generate_access_key(sub_account_id, options = {}, callback) {
    const params = pickOnlyExistingValues({
      name: options.name,
      enabled: options.enabled
    }, "name", "enabled");
    options.content_type = "json";
    const uri = ["sub_accounts", sub_account_id, "access_keys"];
    return call_account_api("POST", uri, params, callback, options);
  }
  function update_access_key(sub_account_id, api_key, options = {}, callback) {
    const params = pickOnlyExistingValues({
      name: options.name,
      enabled: options.enabled
    }, "name", "enabled");
    options.content_type = "json";
    const uri = ["sub_accounts", sub_account_id, "access_keys", api_key];
    return call_account_api("PUT", uri, params, callback, options);
  }
  function delete_access_key(sub_account_id, api_key, options = {}, callback) {
    const uri = ["sub_accounts", sub_account_id, "access_keys", api_key];
    return call_account_api("DELETE", uri, {}, callback, options);
  }
  function delete_access_key_by_name(sub_account_id, options = {}, callback) {
    const params = { name: options.name };
    const uri = ["sub_accounts", sub_account_id, "access_keys"];
    return call_account_api("DELETE", uri, params, callback, options);
  }
  var utils = require_utils();
  var call_account_api = require_call_account_api();
  var { pickOnlyExistingValues } = utils;
  module.exports = {
    sub_accounts,
    create_sub_account,
    delete_sub_account,
    sub_account,
    update_sub_account,
    user,
    users,
    user_group,
    user_groups,
    user_group_users,
    remove_user_from_group,
    delete_user,
    update_user_group,
    update_user,
    create_user,
    create_user_group,
    add_user_to_group,
    delete_user_group,
    access_keys,
    generate_access_key,
    update_access_key,
    delete_access_key,
    delete_access_key_by_name
  };
});

// node_modules/cloudinary/lib/preloaded_file.js
var require_preloaded_file = __commonJS((exports, module) => {
  var PRELOADED_CLOUDINARY_PATH;
  var config;
  var utils;
  utils = require_utils();
  config = require_config();
  PRELOADED_CLOUDINARY_PATH = /^([^\/]+)\/([^\/]+)\/v(\d+)\/([^#]+)#([^\/]+)$/;

  class PreloadedFile {
    constructor(file_info) {
      let matches, public_id_and_format;
      matches = file_info.match(PRELOADED_CLOUDINARY_PATH);
      if (!matches) {
        throw "Invalid preloaded file info";
      }
      this.resource_type = matches[1];
      this.type = matches[2];
      this.version = matches[3];
      this.filename = matches[4];
      this.signature = matches[5];
      public_id_and_format = PreloadedFile.split_format(this.filename);
      this.public_id = public_id_and_format[0];
      this.format = public_id_and_format[1];
    }
    is_valid() {
      let expected_signature;
      expected_signature = utils.api_sign_request({
        public_id: this.public_id,
        version: this.version
      }, config().api_secret);
      return this.signature === expected_signature;
    }
    static split_format(identifier) {
      let format, last_dot, public_id;
      last_dot = identifier.lastIndexOf(".");
      if (last_dot === -1) {
        return [identifier, null];
      }
      public_id = identifier.substr(0, last_dot);
      format = identifier.substr(last_dot + 1);
      return [public_id, format];
    }
    identifier() {
      return `v${this.version}/${this.filename}`;
    }
    toString() {
      return `${this.resource_type}/${this.type}/v${this.version}/${this.filename}#${this.signature}`;
    }
    toJSON() {
      let result = {};
      Object.getOwnPropertyNames(this).forEach((key) => {
        let val = this[key];
        if (typeof val !== "function") {
          result[key] = val;
        }
      });
      return result;
    }
  }
  module.exports = PreloadedFile;
});

// node_modules/cloudinary/lib/utils/generateBreakpoints.js
var require_generateBreakpoints = __commonJS((exports, module) => {
  function generateBreakpoints(srcset) {
    let breakpoints = srcset.breakpoints || [];
    if (breakpoints.length) {
      return breakpoints;
    }
    let [min_width, max_width, max_images] = [srcset.min_width, srcset.max_width, srcset.max_images].map(Number);
    if ([min_width, max_width, max_images].some(Number.isNaN)) {
      throw "Either (min_width, max_width, max_images) " + "or breakpoints must be provided to the image srcset attribute";
    }
    if (min_width > max_width) {
      throw "min_width must be less than max_width";
    }
    if (max_images <= 0) {
      throw "max_images must be a positive integer";
    } else if (max_images === 1) {
      min_width = max_width;
    }
    let stepSize = Math.ceil((max_width - min_width) / Math.max(max_images - 1, 1));
    for (let current = min_width;current < max_width; current += stepSize) {
      breakpoints.push(current);
    }
    breakpoints.push(max_width);
    return breakpoints;
  }
  module.exports = generateBreakpoints;
});

// node_modules/cloudinary/lib/utils/srcsetUtils.js
var require_srcsetUtils = __commonJS((exports, module) => {
  function scaledUrl(public_id, width, transformation, options = {}) {
    let configParams = utils.extractUrlParams(options);
    transformation = transformation || options;
    configParams.raw_transformation = utils.generate_transformation_string([utils.extend({}, transformation), { crop: "scale", width }]);
    return utils.url(public_id, configParams);
  }
  function getOrGenerateBreakpoints(public_id, srcset = {}, options = {}) {
    let breakpoints = [];
    if (srcset.useCache) {
      breakpoints = Cache.get(public_id, options);
      if (!breakpoints) {
        breakpoints = [];
      }
    } else {
      breakpoints = generateBreakpoints(srcset);
    }
    return breakpoints;
  }
  function generateSrcsetAttribute(public_id, breakpoints, transformation, options) {
    options = utils.clone(options);
    utils.patchFetchFormat(options);
    return breakpoints.map((width) => `${scaledUrl(public_id, width, transformation, options)} ${width}w`).join(", ");
  }
  function generateSizesAttribute(breakpoints = []) {
    return breakpoints.map((width) => `(max-width: ${width}px) ${width}px`).join(", ");
  }
  function generateImageResponsiveAttributes(publicId, attributes = {}, srcsetData = {}, options = {}) {
    let responsiveAttributes = {};
    if (isEmpty(srcsetData)) {
      return responsiveAttributes;
    }
    const generateSizes = !attributes.sizes && srcsetData.sizes === true;
    const generateSrcset = !attributes.srcset;
    if (generateSrcset || generateSizes) {
      let breakpoints = getOrGenerateBreakpoints(publicId, srcsetData, options);
      if (generateSrcset) {
        let transformation = srcsetData.transformation;
        let srcsetAttr = generateSrcsetAttribute(publicId, breakpoints, transformation, options);
        if (!isEmpty(srcsetAttr)) {
          responsiveAttributes.srcset = srcsetAttr;
        }
      }
      if (generateSizes) {
        let sizesAttr = generateSizesAttribute(breakpoints);
        if (!isEmpty(sizesAttr)) {
          responsiveAttributes.sizes = sizesAttr;
        }
      }
    }
    return responsiveAttributes;
  }
  function generateMediaAttr(options = {}) {
    let mediaQuery = [];
    if (options.min_width != null) {
      mediaQuery.push(`(min-width: ${options.min_width}px)`);
    }
    if (options.max_width != null) {
      mediaQuery.push(`(max-width: ${options.max_width}px)`);
    }
    return mediaQuery.join(" and ");
  }
  var utils = require_utils();
  var generateBreakpoints = require_generateBreakpoints();
  var Cache = require_cache();
  var isEmpty = utils.isEmpty;
  module.exports = {
    srcsetUrl: scaledUrl,
    generateSrcsetAttribute,
    generateSizesAttribute,
    generateMediaAttr,
    generateImageResponsiveAttributes
  };
});

// node_modules/cloudinary/lib/v2/api.js
var require_api2 = __commonJS((exports) => {
  var api = require_api();
  var v1_adapters = require_utils().v1_adapters;
  v1_adapters(exports, api, {
    ping: 0,
    usage: 0,
    resource_types: 0,
    resources: 0,
    resources_by_tag: 1,
    resources_by_context: 2,
    resources_by_moderation: 2,
    resource_by_asset_id: 1,
    resources_by_asset_ids: 1,
    resources_by_ids: 1,
    resources_by_asset_folder: 1,
    resource: 1,
    restore: 1,
    update: 1,
    delete_resources: 1,
    delete_resources_by_prefix: 1,
    delete_resources_by_tag: 1,
    delete_all_resources: 0,
    delete_derived_resources: 1,
    tags: 0,
    transformations: 0,
    transformation: 1,
    delete_transformation: 1,
    update_transformation: 2,
    create_transformation: 2,
    upload_presets: 0,
    upload_preset: 1,
    delete_upload_preset: 1,
    update_upload_preset: 1,
    create_upload_preset: 0,
    root_folders: 0,
    sub_folders: 1,
    delete_folder: 1,
    rename_folder: 2,
    create_folder: 1,
    upload_mappings: 0,
    upload_mapping: 1,
    delete_upload_mapping: 1,
    update_upload_mapping: 1,
    create_upload_mapping: 1,
    list_streaming_profiles: 0,
    get_streaming_profile: 1,
    delete_streaming_profile: 1,
    update_streaming_profile: 1,
    create_streaming_profile: 1,
    publish_by_ids: 1,
    publish_by_tag: 1,
    publish_by_prefix: 1,
    update_resources_access_mode_by_prefix: 2,
    update_resources_access_mode_by_tag: 2,
    update_resources_access_mode_by_ids: 2,
    search: 1,
    search_folders: 1,
    visual_search: 1,
    delete_derived_by_transformation: 2,
    add_metadata_field: 1,
    list_metadata_fields: 1,
    delete_metadata_field: 1,
    metadata_field_by_field_id: 1,
    update_metadata_field: 2,
    update_metadata_field_datasource: 2,
    delete_datasource_entries: 2,
    restore_metadata_field_datasource: 2,
    order_metadata_field_datasource: 3,
    reorder_metadata_fields: 2,
    list_metadata_rules: 1,
    add_metadata_rule: 1,
    delete_metadata_rule: 1,
    update_metadata_rule: 2,
    add_related_assets: 2,
    add_related_assets_by_asset_id: 2,
    delete_related_assets: 2,
    delete_related_assets_by_asset_id: 2,
    config: 0
  });
});

// node_modules/cloudinary/lib/v2/uploader.js
var require_uploader2 = __commonJS((exports) => {
  var uploader = require_uploader();
  var v1_adapters = require_utils().v1_adapters;
  v1_adapters(exports, uploader, {
    unsigned_upload_stream: 1,
    upload_stream: 0,
    unsigned_upload: 2,
    upload: 1,
    upload_large_part: 0,
    upload_large: 1,
    upload_chunked: 1,
    upload_chunked_stream: 0,
    explicit: 1,
    destroy: 1,
    rename: 2,
    text: 1,
    generate_sprite: 1,
    multi: 1,
    explode: 1,
    add_tag: 2,
    remove_tag: 2,
    remove_all_tags: 1,
    add_context: 2,
    remove_all_context: 1,
    replace_tag: 2,
    create_archive: 0,
    create_zip: 0,
    update_metadata: 2
  });
  exports.direct_upload = uploader.direct_upload;
  exports.upload_tag_params = uploader.upload_tag_params;
  exports.upload_url = uploader.upload_url;
  exports.image_upload_tag = uploader.image_upload_tag;
  exports.unsigned_image_upload_tag = uploader.unsigned_image_upload_tag;
  exports.create_slideshow = uploader.create_slideshow;
  exports.download_generated_sprite = uploader.download_generated_sprite;
  exports.download_multi = uploader.download_multi;
});

// node_modules/cloudinary/lib/v2/search.js
var require_search = __commonJS((exports, module) => {
  var api = require_api2();
  var config = require_config();
  var {
    isEmpty,
    isNumber,
    compute_hash,
    build_distribution_domain,
    clear_blank,
    sort_object_by_key
  } = require_utils();
  var { base64Encode } = require_base64Encode();
  var Search = class Search2 {
    constructor() {
      this.query_hash = {
        sort_by: [],
        aggregate: [],
        with_field: [],
        fields: []
      };
      this._ttl = 300;
    }
    static instance() {
      return new Search2;
    }
    static expression(value) {
      return this.instance().expression(value);
    }
    static max_results(value) {
      return this.instance().max_results(value);
    }
    static next_cursor(value) {
      return this.instance().next_cursor(value);
    }
    static aggregate(value) {
      return this.instance().aggregate(value);
    }
    static with_field(value) {
      return this.instance().with_field(value);
    }
    static fields(value) {
      return this.instance().fields(value);
    }
    static sort_by(field_name, dir = "asc") {
      return this.instance().sort_by(field_name, dir);
    }
    static ttl(newTtl) {
      return this.instance().ttl(newTtl);
    }
    static execute(options, callback) {
      return this.instance().execute(options, callback);
    }
    expression(value) {
      this.query_hash.expression = value;
      return this;
    }
    max_results(value) {
      this.query_hash.max_results = value;
      return this;
    }
    next_cursor(value) {
      this.query_hash.next_cursor = value;
      return this;
    }
    aggregate(value) {
      const found = this.query_hash.aggregate.find((v) => v === value);
      if (!found) {
        this.query_hash.aggregate.push(value);
      }
      return this;
    }
    with_field(value) {
      if (Array.isArray(value)) {
        this.query_hash.with_field = this.query_hash.with_field.concat(value);
      } else {
        this.query_hash.with_field.push(value);
      }
      this.query_hash.with_field = Array.from(new Set(this.query_hash.with_field));
      return this;
    }
    fields(value) {
      if (Array.isArray(value)) {
        this.query_hash.fields = this.query_hash.fields.concat(value);
      } else {
        this.query_hash.fields.push(value);
      }
      this.query_hash.fields = Array.from(new Set(this.query_hash.fields));
      return this;
    }
    sort_by(field_name, dir = "desc") {
      let sort_bucket;
      sort_bucket = {};
      sort_bucket[field_name] = dir;
      const previously_sorted_obj = this.query_hash.sort_by.find((sort_by) => sort_by[field_name]);
      if (previously_sorted_obj) {
        previously_sorted_obj[field_name] = dir;
      } else {
        this.query_hash.sort_by.push(sort_bucket);
      }
      return this;
    }
    ttl(newTtl) {
      if (isNumber(newTtl)) {
        this._ttl = newTtl;
        return this;
      }
      throw new Error("New TTL value has to be a Number.");
    }
    to_query() {
      Object.keys(this.query_hash).forEach((k) => {
        let v = this.query_hash[k];
        if (!isNumber(v) && isEmpty(v)) {
          delete this.query_hash[k];
        }
      });
      return this.query_hash;
    }
    execute(options, callback) {
      if (callback === null) {
        callback = options;
      }
      options = options || {};
      return api.search(this.to_query(), options, callback);
    }
    to_url(ttl, next_cursor, options = {}) {
      const apiSecret = "api_secret" in options ? options.api_secret : config().api_secret;
      if (!apiSecret) {
        throw new Error("Must supply api_secret");
      }
      const urlTtl = ttl || this._ttl;
      const query = this.to_query();
      let urlCursor = next_cursor;
      if (query.next_cursor && !next_cursor) {
        urlCursor = query.next_cursor;
      }
      delete query.next_cursor;
      const dataOrderedByKey = sort_object_by_key(clear_blank(query));
      const encodedQuery = base64Encode(JSON.stringify(dataOrderedByKey));
      const urlPrefix = build_distribution_domain(options.source, options);
      const signature = compute_hash(`${urlTtl}${encodedQuery}${apiSecret}`, "sha256", "hex");
      const urlWithoutCursor = `${urlPrefix}/search/${signature}/${urlTtl}/${encodedQuery}`;
      return urlCursor ? `${urlWithoutCursor}/${urlCursor}` : urlWithoutCursor;
    }
  };
  module.exports = Search;
});

// node_modules/cloudinary/lib/v2/search_folders.js
var require_search_folders = __commonJS((exports, module) => {
  var Search = require_search();
  var api = require_api2();
  var SearchFolders = class SearchFolders2 extends Search {
    constructor() {
      super();
    }
    static instance() {
      return new SearchFolders2;
    }
    execute(options, callback) {
      if (callback === null) {
        callback = options;
      }
      options = options || {};
      return api.search_folders(this.to_query(), options, callback);
    }
  };
  module.exports = SearchFolders;
});

// node_modules/cloudinary/lib/v2/index.js
var require_v2 = __commonJS((exports, module) => {
  var v1 = require_cloudinary();
  var api = require_api2();
  var uploader = require_uploader2();
  var search = require_search();
  var search_folders = require_search_folders();
  var v2 = {
    ...v1,
    api,
    uploader,
    search,
    search_folders
  };
  module.exports = v2;
});

// node_modules/cloudinary/lib/cloudinary.js
var require_cloudinary = __commonJS((exports, module) => {
  function chainTransformations(options, transformation = []) {
    let urlOptions = cloudinary.utils.extractUrlParams(options);
    let currentTransformation = cloudinary.utils.extractTransformationParams(options);
    transformation = cloudinary.utils.build_array(transformation);
    urlOptions.transformation = [currentTransformation, ...transformation];
    return urlOptions;
  }
  var _ = require_lodash();
  exports.config = require_config();
  exports.utils = require_utils();
  exports.uploader = require_uploader();
  exports.api = require_api();
  exports.analysis = require_analysis();
  var account = require_account();
  exports.provisioning = {
    account
  };
  exports.PreloadedFile = require_preloaded_file();
  exports.Cache = require_cache();
  var cloudinary = exports;
  var optionConsume = cloudinary.utils.option_consume;
  exports.url = function url(public_id, options) {
    options = _.extend({}, options);
    return cloudinary.utils.url(public_id, options);
  };
  var { generateImageResponsiveAttributes, generateMediaAttr } = require_srcsetUtils();
  exports.image = function image(source, options) {
    let localOptions = _.extend({}, options);
    let srcsetParam = optionConsume(localOptions, "srcset");
    let attributes = optionConsume(localOptions, "attributes", {});
    let src = cloudinary.utils.url(source, localOptions);
    if ("html_width" in localOptions)
      localOptions.width = optionConsume(localOptions, "html_width");
    if ("html_height" in localOptions)
      localOptions.height = optionConsume(localOptions, "html_height");
    let client_hints = optionConsume(localOptions, "client_hints", cloudinary.config().client_hints);
    let responsive = optionConsume(localOptions, "responsive");
    let hidpi = optionConsume(localOptions, "hidpi");
    if ((responsive || hidpi) && !client_hints) {
      localOptions["data-src"] = src;
      let classes = [responsive ? "cld-responsive" : "cld-hidpi"];
      let current_class = optionConsume(localOptions, "class");
      if (current_class)
        classes.push(current_class);
      localOptions.class = classes.join(" ");
      src = optionConsume(localOptions, "responsive_placeholder", cloudinary.config().responsive_placeholder);
      if (src === "blank") {
        src = cloudinary.BLANK;
      }
    }
    let html = "<img ";
    if (src)
      html += "src='" + src + "' ";
    let responsiveAttributes = {};
    if (cloudinary.utils.isString(srcsetParam)) {
      responsiveAttributes.srcset = srcsetParam;
    } else {
      responsiveAttributes = generateImageResponsiveAttributes(source, attributes, srcsetParam, options);
    }
    if (!cloudinary.utils.isEmpty(responsiveAttributes)) {
      delete localOptions.width;
      delete localOptions.height;
    }
    html += cloudinary.utils.html_attrs(_.extend(localOptions, responsiveAttributes, attributes)) + "/>";
    return html;
  };
  exports.video = function video(public_id, options) {
    options = _.extend({}, options);
    public_id = public_id.replace(/\.(mp4|ogv|webm)$/, "");
    let source_types = optionConsume(options, "source_types", []);
    let source_transformation = optionConsume(options, "source_transformation", {});
    let sources = optionConsume(options, "sources", []);
    let fallback = optionConsume(options, "fallback_content", "");
    if (source_types.length === 0)
      source_types = cloudinary.utils.DEFAULT_VIDEO_SOURCE_TYPES;
    let video_options = _.cloneDeep(options);
    if (video_options.hasOwnProperty("poster")) {
      if (_.isPlainObject(video_options.poster)) {
        if (video_options.poster.hasOwnProperty("public_id")) {
          video_options.poster = cloudinary.utils.url(video_options.poster.public_id, video_options.poster);
        } else {
          video_options.poster = cloudinary.utils.url(public_id, _.extend({}, cloudinary.utils.DEFAULT_POSTER_OPTIONS, video_options.poster));
        }
      }
    } else {
      video_options.poster = cloudinary.utils.url(public_id, _.extend({}, cloudinary.utils.DEFAULT_POSTER_OPTIONS, options));
    }
    if (!video_options.poster)
      delete video_options.poster;
    let html = "<video ";
    if (!video_options.hasOwnProperty("resource_type"))
      video_options.resource_type = "video";
    let multi_source_types = _.isArray(source_types) && source_types.length > 1;
    let has_sources = _.isArray(sources) && sources.length > 0;
    let source = public_id;
    if (!multi_source_types && !has_sources) {
      source = source + "." + cloudinary.utils.build_array(source_types)[0];
    }
    let src = cloudinary.utils.url(source, video_options);
    if (!multi_source_types && !has_sources)
      video_options.src = src;
    if (video_options.hasOwnProperty("html_width"))
      video_options.width = optionConsume(video_options, "html_width");
    if (video_options.hasOwnProperty("html_height"))
      video_options.height = optionConsume(video_options, "html_height");
    html = html + cloudinary.utils.html_attrs(video_options) + ">";
    if (multi_source_types && !has_sources) {
      sources = source_types.map((source_type) => ({
        type: source_type,
        transformations: source_transformation[source_type] || {}
      }));
    }
    if (_.isArray(sources) && sources.length > 0) {
      html += sources.map((source_data) => {
        let source_type = source_data.type;
        let codecs = source_data.codecs;
        let transformation = source_data.transformations || {};
        src = cloudinary.utils.url(source + "." + source_type, _.extend({ resource_type: "video" }, _.cloneDeep(options), _.cloneDeep(transformation)));
        return cloudinary.utils.create_source_tag(src, source_type, codecs);
      }).join("");
    }
    return `${html}${fallback}</video>`;
  };
  exports.source = function source(public_id, options = {}) {
    let srcsetParam = cloudinary.utils.extend({}, options.srcset, cloudinary.config().srcset);
    let attributes = options.attributes || {};
    cloudinary.utils.extend(attributes, generateImageResponsiveAttributes(public_id, attributes, srcsetParam, options));
    if (!attributes.srcset) {
      attributes.srcset = cloudinary.url(public_id, options);
    }
    if (!attributes.media && options.media) {
      attributes.media = generateMediaAttr(options.media);
    }
    return `<source ${cloudinary.utils.html_attrs(attributes)}>`;
  };
  exports.picture = function picture(public_id, options = {}) {
    let sources = options.sources || [];
    options = cloudinary.utils.clone(options);
    delete options.sources;
    cloudinary.utils.patchFetchFormat(options);
    return "<picture>" + sources.map((source) => {
      let sourceOptions = chainTransformations(options, source.transformation);
      sourceOptions.media = source;
      return cloudinary.source(public_id, sourceOptions);
    }).join("") + cloudinary.image(public_id, options) + "</picture>";
  };
  exports.cloudinary_js_config = cloudinary.utils.cloudinary_js_config;
  exports.CF_SHARED_CDN = cloudinary.utils.CF_SHARED_CDN;
  exports.AKAMAI_SHARED_CDN = cloudinary.utils.AKAMAI_SHARED_CDN;
  exports.SHARED_CDN = cloudinary.utils.SHARED_CDN;
  exports.BLANK = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
  exports.v2 = require_v2();
});

// node_modules/bson/lib/bson.cjs
var require_bson = __commonJS((exports) => {
  function isUint8Array(value) {
    return TypedArrayPrototypeGetSymbolToStringTag(value) === "Uint8Array";
  }
  function isAnyArrayBuffer(value) {
    return typeof value === "object" && value != null && Symbol.toStringTag in value && (value[Symbol.toStringTag] === "ArrayBuffer" || value[Symbol.toStringTag] === "SharedArrayBuffer");
  }
  function isRegExp(regexp2) {
    return regexp2 instanceof RegExp || Object.prototype.toString.call(regexp2) === "[object RegExp]";
  }
  function isMap(value) {
    return typeof value === "object" && value != null && Symbol.toStringTag in value && value[Symbol.toStringTag] === "Map";
  }
  function isDate(date) {
    return date instanceof Date || Object.prototype.toString.call(date) === "[object Date]";
  }
  function defaultInspect(x, _options) {
    return JSON.stringify(x, (k, v) => {
      if (typeof v === "bigint") {
        return { $numberLong: `${v}` };
      } else if (isMap(v)) {
        return Object.fromEntries(v);
      }
      return v;
    });
  }
  function getStylizeFunction(options) {
    const stylizeExists = options != null && typeof options === "object" && "stylize" in options && typeof options.stylize === "function";
    if (stylizeExists) {
      return options.stylize;
    }
  }
  function parseUtf8(buffer2, start, end, fatal) {
    if (fatal) {
      TextDecoderFatal ??= new TextDecoder("utf8", { fatal: true });
      try {
        return TextDecoderFatal.decode(buffer2.subarray(start, end));
      } catch (cause) {
        throw new BSONError("Invalid UTF-8 string in BSON document", { cause });
      }
    }
    TextDecoderNonFatal ??= new TextDecoder("utf8", { fatal: false });
    return TextDecoderNonFatal.decode(buffer2.subarray(start, end));
  }
  function tryReadBasicLatin(uint8array, start, end) {
    if (uint8array.length === 0) {
      return "";
    }
    const stringByteLength = end - start;
    if (stringByteLength === 0) {
      return "";
    }
    if (stringByteLength > 20) {
      return null;
    }
    if (stringByteLength === 1 && uint8array[start] < 128) {
      return String.fromCharCode(uint8array[start]);
    }
    if (stringByteLength === 2 && uint8array[start] < 128 && uint8array[start + 1] < 128) {
      return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]);
    }
    if (stringByteLength === 3 && uint8array[start] < 128 && uint8array[start + 1] < 128 && uint8array[start + 2] < 128) {
      return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]) + String.fromCharCode(uint8array[start + 2]);
    }
    const latinBytes = [];
    for (let i = start;i < end; i++) {
      const byte = uint8array[i];
      if (byte > 127) {
        return null;
      }
      latinBytes.push(byte);
    }
    return String.fromCharCode(...latinBytes);
  }
  function tryWriteBasicLatin(destination, source, offset) {
    if (source.length === 0)
      return 0;
    if (source.length > 25)
      return null;
    if (destination.length - offset < source.length)
      return null;
    for (let charOffset = 0, destinationOffset = offset;charOffset < source.length; charOffset++, destinationOffset++) {
      const char = source.charCodeAt(charOffset);
      if (char > 127)
        return null;
      destination[destinationOffset] = char;
    }
    return source.length;
  }
  function nodejsMathRandomBytes(byteLength) {
    return nodeJsByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));
  }
  function isReactNative() {
    const { navigator: navigator2 } = globalThis;
    return typeof navigator2 === "object" && navigator2.product === "ReactNative";
  }
  function webMathRandomBytes(byteLength) {
    if (byteLength < 0) {
      throw new RangeError(`The argument 'byteLength' is invalid. Received ${byteLength}`);
    }
    return webByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));
  }
  function validateBinaryVector(vector) {
    if (vector.sub_type !== Binary.SUBTYPE_VECTOR)
      return;
    const size = vector.position;
    const datatype = vector.buffer[0];
    const padding = vector.buffer[1];
    if ((datatype === Binary.VECTOR_TYPE.Float32 || datatype === Binary.VECTOR_TYPE.Int8) && padding !== 0) {
      throw new BSONError("Invalid Vector: padding must be zero for int8 and float32 vectors");
    }
    if (datatype === Binary.VECTOR_TYPE.PackedBit && padding !== 0 && size === 2) {
      throw new BSONError("Invalid Vector: padding must be zero for packed bit vectors that are empty");
    }
    if (datatype === Binary.VECTOR_TYPE.PackedBit && padding > 7) {
      throw new BSONError(`Invalid Vector: padding must be a value between 0 and 7. found: ${padding}`);
    }
  }
  function isDBRefLike(value) {
    return value != null && typeof value === "object" && "$id" in value && value.$id != null && "$ref" in value && typeof value.$ref === "string" && (!("$db" in value) || ("$db" in value) && typeof value.$db === "string");
  }
  function removeLeadingZerosAndExplicitPlus(str) {
    if (str === "") {
      return str;
    }
    let startIndex = 0;
    const isNegative = str[startIndex] === "-";
    const isExplicitlyPositive = str[startIndex] === "+";
    if (isExplicitlyPositive || isNegative) {
      startIndex += 1;
    }
    let foundInsignificantZero = false;
    for (;startIndex < str.length && str[startIndex] === "0"; ++startIndex) {
      foundInsignificantZero = true;
    }
    if (!foundInsignificantZero) {
      return isExplicitlyPositive ? str.slice(1) : str;
    }
    return `${isNegative ? "-" : ""}${str.length === startIndex ? "0" : str.slice(startIndex)}`;
  }
  function validateStringCharacters(str, radix) {
    radix = radix ?? 10;
    const validCharacters = "0123456789abcdefghijklmnopqrstuvwxyz".slice(0, radix);
    const regex = new RegExp(`[^-+${validCharacters}]`, "i");
    return regex.test(str) ? false : str;
  }
  function isDigit(value) {
    return !isNaN(parseInt(value, 10));
  }
  function divideu128(value) {
    const DIVISOR = Long.fromNumber(1000 * 1000 * 1000);
    let _rem = Long.fromNumber(0);
    if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {
      return { quotient: value, rem: _rem };
    }
    for (let i = 0;i <= 3; i++) {
      _rem = _rem.shiftLeft(32);
      _rem = _rem.add(new Long(value.parts[i], 0));
      value.parts[i] = _rem.div(DIVISOR).low;
      _rem = _rem.modulo(DIVISOR);
    }
    return { quotient: value, rem: _rem };
  }
  function multiply64x2(left, right) {
    if (!left && !right) {
      return { high: Long.fromNumber(0), low: Long.fromNumber(0) };
    }
    const leftHigh = left.shiftRightUnsigned(32);
    const leftLow = new Long(left.getLowBits(), 0);
    const rightHigh = right.shiftRightUnsigned(32);
    const rightLow = new Long(right.getLowBits(), 0);
    let productHigh = leftHigh.multiply(rightHigh);
    let productMid = leftHigh.multiply(rightLow);
    const productMid2 = leftLow.multiply(rightHigh);
    let productLow = leftLow.multiply(rightLow);
    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
    productMid = new Long(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));
    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
    productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));
    return { high: productHigh, low: productLow };
  }
  function lessThan(left, right) {
    const uhleft = left.high >>> 0;
    const uhright = right.high >>> 0;
    if (uhleft < uhright) {
      return true;
    } else if (uhleft === uhright) {
      const ulleft = left.low >>> 0;
      const ulright = right.low >>> 0;
      if (ulleft < ulright)
        return true;
    }
    return false;
  }
  function invalidErr(string, message) {
    throw new BSONError(`"${string}" is not a valid Decimal128 string - ${message}`);
  }
  function internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined) {
    let totalLength = 4 + 1;
    if (Array.isArray(object)) {
      for (let i = 0;i < object.length; i++) {
        totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);
      }
    } else {
      if (typeof object?.toBSON === "function") {
        object = object.toBSON();
      }
      for (const key of Object.keys(object)) {
        totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);
      }
    }
    return totalLength;
  }
  function calculateElement(name, value, serializeFunctions = false, isArray = false, ignoreUndefined = false) {
    if (typeof value?.toBSON === "function") {
      value = value.toBSON();
    }
    switch (typeof value) {
      case "string":
        return 1 + ByteUtils.utf8ByteLength(name) + 1 + 4 + ByteUtils.utf8ByteLength(value) + 1;
      case "number":
        if (Math.floor(value) === value && value >= JS_INT_MIN && value <= JS_INT_MAX) {
          if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (4 + 1);
          } else {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
          }
        } else {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
        }
      case "undefined":
        if (isArray || !ignoreUndefined)
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
        return 0;
      case "boolean":
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 1);
      case "object":
        if (value != null && typeof value._bsontype === "string" && value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
          throw new BSONVersionError;
        } else if (value == null || value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;
        } else if (value._bsontype === "ObjectId") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (12 + 1);
        } else if (value instanceof Date || isDate(value)) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
        } else if (ArrayBuffer.isView(value) || value instanceof ArrayBuffer || isAnyArrayBuffer(value)) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 4 + 1) + value.byteLength;
        } else if (value._bsontype === "Long" || value._bsontype === "Double" || value._bsontype === "Timestamp") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
        } else if (value._bsontype === "Decimal128") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (16 + 1);
        } else if (value._bsontype === "Code") {
          if (value.scope != null && Object.keys(value.scope).length > 0) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1 + internalCalculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
          } else {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1;
          }
        } else if (value._bsontype === "Binary") {
          const binary = value;
          if (binary.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1 + 4);
          } else {
            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1);
          }
        } else if (value._bsontype === "Symbol") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + ByteUtils.utf8ByteLength(value.value) + 4 + 1 + 1;
        } else if (value._bsontype === "DBRef") {
          const ordered_values = Object.assign({
            $ref: value.collection,
            $id: value.oid
          }, value.fields);
          if (value.db != null) {
            ordered_values["$db"] = value.db;
          }
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + internalCalculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);
        } else if (value instanceof RegExp || isRegExp(value)) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.source) + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
        } else if (value._bsontype === "BSONRegExp") {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.pattern) + 1 + ByteUtils.utf8ByteLength(value.options) + 1;
        } else {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + internalCalculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;
        }
      case "function":
        if (serializeFunctions) {
          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.toString()) + 1;
        }
        return 0;
      case "bigint":
        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);
      case "symbol":
        return 0;
      default:
        throw new BSONError(`Unrecognized JS type: ${typeof value}`);
    }
  }
  function alphabetize(str) {
    return str.split("").sort().join("");
  }
  function internalDeserialize(buffer2, options, isArray) {
    options = options == null ? {} : options;
    const index = options && options.index ? options.index : 0;
    const size = NumberUtils.getInt32LE(buffer2, index);
    if (size < 5) {
      throw new BSONError(`bson size must be >= 5, is ${size}`);
    }
    if (options.allowObjectSmallerThanBufferSize && buffer2.length < size) {
      throw new BSONError(`buffer length ${buffer2.length} must be >= bson size ${size}`);
    }
    if (!options.allowObjectSmallerThanBufferSize && buffer2.length !== size) {
      throw new BSONError(`buffer length ${buffer2.length} must === bson size ${size}`);
    }
    if (size + index > buffer2.byteLength) {
      throw new BSONError(`(bson size ${size} + options.index ${index} must be <= buffer length ${buffer2.byteLength})`);
    }
    if (buffer2[index + size - 1] !== 0) {
      throw new BSONError("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
    }
    return deserializeObject(buffer2, index, options, isArray);
  }
  function deserializeObject(buffer2, index, options, isArray = false) {
    const fieldsAsRaw = options["fieldsAsRaw"] == null ? null : options["fieldsAsRaw"];
    const raw2 = options["raw"] == null ? false : options["raw"];
    const bsonRegExp = typeof options["bsonRegExp"] === "boolean" ? options["bsonRegExp"] : false;
    const promoteBuffers = options.promoteBuffers ?? false;
    const promoteLongs = options.promoteLongs ?? true;
    const promoteValues = options.promoteValues ?? true;
    const useBigInt64 = options.useBigInt64 ?? false;
    if (useBigInt64 && !promoteValues) {
      throw new BSONError("Must either request bigint or Long for int64 deserialization");
    }
    if (useBigInt64 && !promoteLongs) {
      throw new BSONError("Must either request bigint or Long for int64 deserialization");
    }
    const validation = options.validation == null ? { utf8: true } : options.validation;
    let globalUTFValidation = true;
    let validationSetting;
    let utf8KeysSet;
    const utf8ValidatedKeys = validation.utf8;
    if (typeof utf8ValidatedKeys === "boolean") {
      validationSetting = utf8ValidatedKeys;
    } else {
      globalUTFValidation = false;
      const utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function(key) {
        return utf8ValidatedKeys[key];
      });
      if (utf8ValidationValues.length === 0) {
        throw new BSONError("UTF-8 validation setting cannot be empty");
      }
      if (typeof utf8ValidationValues[0] !== "boolean") {
        throw new BSONError("Invalid UTF-8 validation option, must specify boolean values");
      }
      validationSetting = utf8ValidationValues[0];
      if (!utf8ValidationValues.every((item) => item === validationSetting)) {
        throw new BSONError("Invalid UTF-8 validation option - keys must be all true or all false");
      }
    }
    if (!globalUTFValidation) {
      utf8KeysSet = new Set;
      for (const key of Object.keys(utf8ValidatedKeys)) {
        utf8KeysSet.add(key);
      }
    }
    const startIndex = index;
    if (buffer2.length < 5)
      throw new BSONError("corrupt bson message < 5 bytes long");
    const size = NumberUtils.getInt32LE(buffer2, index);
    index += 4;
    if (size < 5 || size > buffer2.length)
      throw new BSONError("corrupt bson message");
    const object = isArray ? [] : {};
    let arrayIndex = 0;
    const done = false;
    let isPossibleDBRef = isArray ? false : null;
    while (!done) {
      const elementType = buffer2[index++];
      if (elementType === 0)
        break;
      let i = index;
      while (buffer2[i] !== 0 && i < buffer2.length) {
        i++;
      }
      if (i >= buffer2.byteLength)
        throw new BSONError("Bad BSON Document: illegal CString");
      const name = isArray ? arrayIndex++ : ByteUtils.toUTF8(buffer2, index, i, false);
      let shouldValidateKey = true;
      if (globalUTFValidation || utf8KeysSet?.has(name)) {
        shouldValidateKey = validationSetting;
      } else {
        shouldValidateKey = !validationSetting;
      }
      if (isPossibleDBRef !== false && name[0] === "$") {
        isPossibleDBRef = allowedDBRefKeys.test(name);
      }
      let value;
      index = i + 1;
      if (elementType === BSON_DATA_STRING) {
        const stringSize = NumberUtils.getInt32LE(buffer2, index);
        index += 4;
        if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
          throw new BSONError("bad string length in bson");
        }
        value = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
        index = index + stringSize;
      } else if (elementType === BSON_DATA_OID) {
        const oid = ByteUtils.allocateUnsafe(12);
        for (let i2 = 0;i2 < 12; i2++)
          oid[i2] = buffer2[index + i2];
        value = new ObjectId2(oid);
        index = index + 12;
      } else if (elementType === BSON_DATA_INT && promoteValues === false) {
        value = new Int32(NumberUtils.getInt32LE(buffer2, index));
        index += 4;
      } else if (elementType === BSON_DATA_INT) {
        value = NumberUtils.getInt32LE(buffer2, index);
        index += 4;
      } else if (elementType === BSON_DATA_NUMBER) {
        value = NumberUtils.getFloat64LE(buffer2, index);
        index += 8;
        if (promoteValues === false)
          value = new Double(value);
      } else if (elementType === BSON_DATA_DATE) {
        const lowBits = NumberUtils.getInt32LE(buffer2, index);
        const highBits = NumberUtils.getInt32LE(buffer2, index + 4);
        index += 8;
        value = new Date(new Long(lowBits, highBits).toNumber());
      } else if (elementType === BSON_DATA_BOOLEAN) {
        if (buffer2[index] !== 0 && buffer2[index] !== 1)
          throw new BSONError("illegal boolean type value");
        value = buffer2[index++] === 1;
      } else if (elementType === BSON_DATA_OBJECT) {
        const _index = index;
        const objectSize = NumberUtils.getInt32LE(buffer2, index);
        if (objectSize <= 0 || objectSize > buffer2.length - index)
          throw new BSONError("bad embedded document length in bson");
        if (raw2) {
          value = buffer2.subarray(index, index + objectSize);
        } else {
          let objectOptions = options;
          if (!globalUTFValidation) {
            objectOptions = { ...options, validation: { utf8: shouldValidateKey } };
          }
          value = deserializeObject(buffer2, _index, objectOptions, false);
        }
        index = index + objectSize;
      } else if (elementType === BSON_DATA_ARRAY) {
        const _index = index;
        const objectSize = NumberUtils.getInt32LE(buffer2, index);
        let arrayOptions = options;
        const stopIndex = index + objectSize;
        if (fieldsAsRaw && fieldsAsRaw[name]) {
          arrayOptions = { ...options, raw: true };
        }
        if (!globalUTFValidation) {
          arrayOptions = { ...arrayOptions, validation: { utf8: shouldValidateKey } };
        }
        value = deserializeObject(buffer2, _index, arrayOptions, true);
        index = index + objectSize;
        if (buffer2[index - 1] !== 0)
          throw new BSONError("invalid array terminator byte");
        if (index !== stopIndex)
          throw new BSONError("corrupted array bson");
      } else if (elementType === BSON_DATA_UNDEFINED) {
        value = undefined;
      } else if (elementType === BSON_DATA_NULL) {
        value = null;
      } else if (elementType === BSON_DATA_LONG) {
        if (useBigInt64) {
          value = NumberUtils.getBigInt64LE(buffer2, index);
          index += 8;
        } else {
          const lowBits = NumberUtils.getInt32LE(buffer2, index);
          const highBits = NumberUtils.getInt32LE(buffer2, index + 4);
          index += 8;
          const long = new Long(lowBits, highBits);
          if (promoteLongs && promoteValues === true) {
            value = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
          } else {
            value = long;
          }
        }
      } else if (elementType === BSON_DATA_DECIMAL128) {
        const bytes = ByteUtils.allocateUnsafe(16);
        for (let i2 = 0;i2 < 16; i2++)
          bytes[i2] = buffer2[index + i2];
        index = index + 16;
        value = new Decimal128(bytes);
      } else if (elementType === BSON_DATA_BINARY) {
        let binarySize = NumberUtils.getInt32LE(buffer2, index);
        index += 4;
        const totalBinarySize = binarySize;
        const subType = buffer2[index++];
        if (binarySize < 0)
          throw new BSONError("Negative binary type element size found");
        if (binarySize > buffer2.byteLength)
          throw new BSONError("Binary type size larger than document size");
        if (subType === Binary.SUBTYPE_BYTE_ARRAY) {
          binarySize = NumberUtils.getInt32LE(buffer2, index);
          index += 4;
          if (binarySize < 0)
            throw new BSONError("Negative binary type element size found for subtype 0x02");
          if (binarySize > totalBinarySize - 4)
            throw new BSONError("Binary type with subtype 0x02 contains too long binary size");
          if (binarySize < totalBinarySize - 4)
            throw new BSONError("Binary type with subtype 0x02 contains too short binary size");
        }
        if (promoteBuffers && promoteValues) {
          value = ByteUtils.toLocalBufferType(buffer2.subarray(index, index + binarySize));
        } else {
          value = new Binary(buffer2.subarray(index, index + binarySize), subType);
          if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {
            value = value.toUUID();
          }
        }
        index = index + binarySize;
      } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) {
        i = index;
        while (buffer2[i] !== 0 && i < buffer2.length) {
          i++;
        }
        if (i >= buffer2.length)
          throw new BSONError("Bad BSON Document: illegal CString");
        const source = ByteUtils.toUTF8(buffer2, index, i, false);
        index = i + 1;
        i = index;
        while (buffer2[i] !== 0 && i < buffer2.length) {
          i++;
        }
        if (i >= buffer2.length)
          throw new BSONError("Bad BSON Document: illegal CString");
        const regExpOptions = ByteUtils.toUTF8(buffer2, index, i, false);
        index = i + 1;
        const optionsArray = new Array(regExpOptions.length);
        for (i = 0;i < regExpOptions.length; i++) {
          switch (regExpOptions[i]) {
            case "m":
              optionsArray[i] = "m";
              break;
            case "s":
              optionsArray[i] = "g";
              break;
            case "i":
              optionsArray[i] = "i";
              break;
          }
        }
        value = new RegExp(source, optionsArray.join(""));
      } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) {
        i = index;
        while (buffer2[i] !== 0 && i < buffer2.length) {
          i++;
        }
        if (i >= buffer2.length)
          throw new BSONError("Bad BSON Document: illegal CString");
        const source = ByteUtils.toUTF8(buffer2, index, i, false);
        index = i + 1;
        i = index;
        while (buffer2[i] !== 0 && i < buffer2.length) {
          i++;
        }
        if (i >= buffer2.length)
          throw new BSONError("Bad BSON Document: illegal CString");
        const regExpOptions = ByteUtils.toUTF8(buffer2, index, i, false);
        index = i + 1;
        value = new BSONRegExp(source, regExpOptions);
      } else if (elementType === BSON_DATA_SYMBOL) {
        const stringSize = NumberUtils.getInt32LE(buffer2, index);
        index += 4;
        if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
          throw new BSONError("bad string length in bson");
        }
        const symbol = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
        value = promoteValues ? symbol : new BSONSymbol(symbol);
        index = index + stringSize;
      } else if (elementType === BSON_DATA_TIMESTAMP) {
        value = new Timestamp({
          i: NumberUtils.getUint32LE(buffer2, index),
          t: NumberUtils.getUint32LE(buffer2, index + 4)
        });
        index += 8;
      } else if (elementType === BSON_DATA_MIN_KEY) {
        value = new MinKey;
      } else if (elementType === BSON_DATA_MAX_KEY) {
        value = new MaxKey;
      } else if (elementType === BSON_DATA_CODE) {
        const stringSize = NumberUtils.getInt32LE(buffer2, index);
        index += 4;
        if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
          throw new BSONError("bad string length in bson");
        }
        const functionString = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
        value = new Code(functionString);
        index = index + stringSize;
      } else if (elementType === BSON_DATA_CODE_W_SCOPE) {
        const totalSize = NumberUtils.getInt32LE(buffer2, index);
        index += 4;
        if (totalSize < 4 + 4 + 4 + 1) {
          throw new BSONError("code_w_scope total size shorter minimum expected length");
        }
        const stringSize = NumberUtils.getInt32LE(buffer2, index);
        index += 4;
        if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0) {
          throw new BSONError("bad string length in bson");
        }
        const functionString = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
        index = index + stringSize;
        const _index = index;
        const objectSize = NumberUtils.getInt32LE(buffer2, index);
        const scopeObject = deserializeObject(buffer2, _index, options, false);
        index = index + objectSize;
        if (totalSize < 4 + 4 + objectSize + stringSize) {
          throw new BSONError("code_w_scope total size is too short, truncating scope");
        }
        if (totalSize > 4 + 4 + objectSize + stringSize) {
          throw new BSONError("code_w_scope total size is too long, clips outer document");
        }
        value = new Code(functionString, scopeObject);
      } else if (elementType === BSON_DATA_DBPOINTER) {
        const stringSize = NumberUtils.getInt32LE(buffer2, index);
        index += 4;
        if (stringSize <= 0 || stringSize > buffer2.length - index || buffer2[index + stringSize - 1] !== 0)
          throw new BSONError("bad string length in bson");
        const namespace = ByteUtils.toUTF8(buffer2, index, index + stringSize - 1, shouldValidateKey);
        index = index + stringSize;
        const oidBuffer = ByteUtils.allocateUnsafe(12);
        for (let i2 = 0;i2 < 12; i2++)
          oidBuffer[i2] = buffer2[index + i2];
        const oid = new ObjectId2(oidBuffer);
        index = index + 12;
        value = new DBRef(namespace, oid);
      } else {
        throw new BSONError(`Detected unknown BSON type ${elementType.toString(16)} for fieldname "${name}"`);
      }
      if (name === "__proto__") {
        Object.defineProperty(object, name, {
          value,
          writable: true,
          enumerable: true,
          configurable: true
        });
      } else {
        object[name] = value;
      }
    }
    if (size !== index - startIndex) {
      if (isArray)
        throw new BSONError("corrupt array bson");
      throw new BSONError("corrupt object bson");
    }
    if (!isPossibleDBRef)
      return object;
    if (isDBRefLike(object)) {
      const copy = Object.assign({}, object);
      delete copy.$ref;
      delete copy.$id;
      delete copy.$db;
      return new DBRef(object.$ref, object.$id, object.$db, copy);
    }
    return object;
  }
  function serializeString(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_STRING;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes + 1;
    buffer2[index - 1] = 0;
    const size = ByteUtils.encodeUTF8Into(buffer2, value, index + 4);
    NumberUtils.setInt32LE(buffer2, index, size + 1);
    index = index + 4 + size;
    buffer2[index++] = 0;
    return index;
  }
  function serializeNumber(buffer2, key, value, index) {
    const isNegativeZero = Object.is(value, -0);
    const type = !isNegativeZero && Number.isSafeInteger(value) && value <= BSON_INT32_MAX && value >= BSON_INT32_MIN ? BSON_DATA_INT : BSON_DATA_NUMBER;
    buffer2[index++] = type;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    if (type === BSON_DATA_INT) {
      index += NumberUtils.setInt32LE(buffer2, index, value);
    } else {
      index += NumberUtils.setFloat64LE(buffer2, index, value);
    }
    return index;
  }
  function serializeBigInt(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_LONG;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index += numberOfWrittenBytes;
    buffer2[index++] = 0;
    index += NumberUtils.setBigInt64LE(buffer2, index, value);
    return index;
  }
  function serializeNull(buffer2, key, _2, index) {
    buffer2[index++] = BSON_DATA_NULL;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    return index;
  }
  function serializeBoolean(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_BOOLEAN;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    buffer2[index++] = value ? 1 : 0;
    return index;
  }
  function serializeDate(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_DATE;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const dateInMilis = Long.fromNumber(value.getTime());
    const lowBits = dateInMilis.getLowBits();
    const highBits = dateInMilis.getHighBits();
    index += NumberUtils.setInt32LE(buffer2, index, lowBits);
    index += NumberUtils.setInt32LE(buffer2, index, highBits);
    return index;
  }
  function serializeRegExp(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_REGEXP;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    if (value.source && value.source.match(regexp) != null) {
      throw new BSONError("value " + value.source + " must not contain null bytes");
    }
    index = index + ByteUtils.encodeUTF8Into(buffer2, value.source, index);
    buffer2[index++] = 0;
    if (value.ignoreCase)
      buffer2[index++] = 105;
    if (value.global)
      buffer2[index++] = 115;
    if (value.multiline)
      buffer2[index++] = 109;
    buffer2[index++] = 0;
    return index;
  }
  function serializeBSONRegExp(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_REGEXP;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    if (value.pattern.match(regexp) != null) {
      throw new BSONError("pattern " + value.pattern + " must not contain null bytes");
    }
    index = index + ByteUtils.encodeUTF8Into(buffer2, value.pattern, index);
    buffer2[index++] = 0;
    const sortedOptions = value.options.split("").sort().join("");
    index = index + ByteUtils.encodeUTF8Into(buffer2, sortedOptions, index);
    buffer2[index++] = 0;
    return index;
  }
  function serializeMinMax(buffer2, key, value, index) {
    if (value === null) {
      buffer2[index++] = BSON_DATA_NULL;
    } else if (value._bsontype === "MinKey") {
      buffer2[index++] = BSON_DATA_MIN_KEY;
    } else {
      buffer2[index++] = BSON_DATA_MAX_KEY;
    }
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    return index;
  }
  function serializeObjectId(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_OID;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    index += value.serializeInto(buffer2, index);
    return index;
  }
  function serializeBuffer(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_BINARY;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const size = value.length;
    index += NumberUtils.setInt32LE(buffer2, index, size);
    buffer2[index++] = BSON_BINARY_SUBTYPE_DEFAULT;
    if (size <= 16) {
      for (let i = 0;i < size; i++)
        buffer2[index + i] = value[i];
    } else {
      buffer2.set(value, index);
    }
    index = index + size;
    return index;
  }
  function serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path) {
    if (path.has(value)) {
      throw new BSONError("Cannot convert circular structure to BSON");
    }
    path.add(value);
    buffer2[index++] = Array.isArray(value) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const endIndex = serializeInto(buffer2, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
    path.delete(value);
    return endIndex;
  }
  function serializeDecimal128(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_DECIMAL128;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    for (let i = 0;i < 16; i++)
      buffer2[index + i] = value.bytes[i];
    return index + 16;
  }
  function serializeLong(buffer2, key, value, index) {
    buffer2[index++] = value._bsontype === "Long" ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const lowBits = value.getLowBits();
    const highBits = value.getHighBits();
    index += NumberUtils.setInt32LE(buffer2, index, lowBits);
    index += NumberUtils.setInt32LE(buffer2, index, highBits);
    return index;
  }
  function serializeInt32(buffer2, key, value, index) {
    value = value.valueOf();
    buffer2[index++] = BSON_DATA_INT;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    index += NumberUtils.setInt32LE(buffer2, index, value);
    return index;
  }
  function serializeDouble(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_NUMBER;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    index += NumberUtils.setFloat64LE(buffer2, index, value.value);
    return index;
  }
  function serializeFunction(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_CODE;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const functionString = value.toString();
    const size = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
    NumberUtils.setInt32LE(buffer2, index, size);
    index = index + 4 + size - 1;
    buffer2[index++] = 0;
    return index;
  }
  function serializeCode(buffer2, key, value, index, checkKeys = false, depth = 0, serializeFunctions = false, ignoreUndefined = true, path) {
    if (value.scope && typeof value.scope === "object") {
      buffer2[index++] = BSON_DATA_CODE_W_SCOPE;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      let startIndex = index;
      const functionString = value.code;
      index = index + 4;
      const codeSize = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
      NumberUtils.setInt32LE(buffer2, index, codeSize);
      buffer2[index + 4 + codeSize - 1] = 0;
      index = index + codeSize + 4;
      const endIndex = serializeInto(buffer2, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);
      index = endIndex - 1;
      const totalSize = endIndex - startIndex;
      startIndex += NumberUtils.setInt32LE(buffer2, startIndex, totalSize);
      buffer2[index++] = 0;
    } else {
      buffer2[index++] = BSON_DATA_CODE;
      const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
      index = index + numberOfWrittenBytes;
      buffer2[index++] = 0;
      const functionString = value.code.toString();
      const size = ByteUtils.encodeUTF8Into(buffer2, functionString, index + 4) + 1;
      NumberUtils.setInt32LE(buffer2, index, size);
      index = index + 4 + size - 1;
      buffer2[index++] = 0;
    }
    return index;
  }
  function serializeBinary(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_BINARY;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const data = value.buffer;
    let size = value.position;
    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY)
      size = size + 4;
    index += NumberUtils.setInt32LE(buffer2, index, size);
    buffer2[index++] = value.sub_type;
    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
      size = size - 4;
      index += NumberUtils.setInt32LE(buffer2, index, size);
    }
    if (value.sub_type === Binary.SUBTYPE_VECTOR) {
      validateBinaryVector(value);
    }
    if (size <= 16) {
      for (let i = 0;i < size; i++)
        buffer2[index + i] = data[i];
    } else {
      buffer2.set(data, index);
    }
    index = index + value.position;
    return index;
  }
  function serializeSymbol(buffer2, key, value, index) {
    buffer2[index++] = BSON_DATA_SYMBOL;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    const size = ByteUtils.encodeUTF8Into(buffer2, value.value, index + 4) + 1;
    NumberUtils.setInt32LE(buffer2, index, size);
    index = index + 4 + size - 1;
    buffer2[index++] = 0;
    return index;
  }
  function serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path) {
    buffer2[index++] = BSON_DATA_OBJECT;
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer2, key, index);
    index = index + numberOfWrittenBytes;
    buffer2[index++] = 0;
    let startIndex = index;
    let output = {
      $ref: value.collection || value.namespace,
      $id: value.oid
    };
    if (value.db != null) {
      output.$db = value.db;
    }
    output = Object.assign(output, value.fields);
    const endIndex = serializeInto(buffer2, output, false, index, depth + 1, serializeFunctions, true, path);
    const size = endIndex - startIndex;
    startIndex += NumberUtils.setInt32LE(buffer2, index, size);
    return endIndex;
  }
  function serializeInto(buffer2, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {
    if (path == null) {
      if (object == null) {
        buffer2[0] = 5;
        buffer2[1] = 0;
        buffer2[2] = 0;
        buffer2[3] = 0;
        buffer2[4] = 0;
        return 5;
      }
      if (Array.isArray(object)) {
        throw new BSONError("serialize does not support an array as the root input");
      }
      if (typeof object !== "object") {
        throw new BSONError("serialize does not support non-object as the root input");
      } else if ("_bsontype" in object && typeof object._bsontype === "string") {
        throw new BSONError(`BSON types cannot be serialized as a document`);
      } else if (isDate(object) || isRegExp(object) || isUint8Array(object) || isAnyArrayBuffer(object)) {
        throw new BSONError(`date, regexp, typedarray, and arraybuffer cannot be BSON documents`);
      }
      path = new Set;
    }
    path.add(object);
    let index = startingIndex + 4;
    if (Array.isArray(object)) {
      for (let i = 0;i < object.length; i++) {
        const key = `${i}`;
        let value = object[i];
        if (typeof value?.toBSON === "function") {
          value = value.toBSON();
        }
        const type = typeof value;
        if (value === undefined) {
          index = serializeNull(buffer2, key, value, index);
        } else if (value === null) {
          index = serializeNull(buffer2, key, value, index);
        } else if (type === "string") {
          index = serializeString(buffer2, key, value, index);
        } else if (type === "number") {
          index = serializeNumber(buffer2, key, value, index);
        } else if (type === "bigint") {
          index = serializeBigInt(buffer2, key, value, index);
        } else if (type === "boolean") {
          index = serializeBoolean(buffer2, key, value, index);
        } else if (type === "object" && value._bsontype == null) {
          if (value instanceof Date || isDate(value)) {
            index = serializeDate(buffer2, key, value, index);
          } else if (value instanceof Uint8Array || isUint8Array(value)) {
            index = serializeBuffer(buffer2, key, value, index);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index = serializeRegExp(buffer2, key, value, index);
          } else {
            index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
          }
        } else if (type === "object") {
          if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
            throw new BSONVersionError;
          } else if (value._bsontype === "ObjectId") {
            index = serializeObjectId(buffer2, key, value, index);
          } else if (value._bsontype === "Decimal128") {
            index = serializeDecimal128(buffer2, key, value, index);
          } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
            index = serializeLong(buffer2, key, value, index);
          } else if (value._bsontype === "Double") {
            index = serializeDouble(buffer2, key, value, index);
          } else if (value._bsontype === "Code") {
            index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
          } else if (value._bsontype === "Binary") {
            index = serializeBinary(buffer2, key, value, index);
          } else if (value._bsontype === "BSONSymbol") {
            index = serializeSymbol(buffer2, key, value, index);
          } else if (value._bsontype === "DBRef") {
            index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path);
          } else if (value._bsontype === "BSONRegExp") {
            index = serializeBSONRegExp(buffer2, key, value, index);
          } else if (value._bsontype === "Int32") {
            index = serializeInt32(buffer2, key, value, index);
          } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
            index = serializeMinMax(buffer2, key, value, index);
          } else if (typeof value._bsontype !== "undefined") {
            throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
          }
        } else if (type === "function" && serializeFunctions) {
          index = serializeFunction(buffer2, key, value, index);
        }
      }
    } else if (object instanceof Map || isMap(object)) {
      const iterator = object.entries();
      let done = false;
      while (!done) {
        const entry = iterator.next();
        done = !!entry.done;
        if (done)
          continue;
        const key = entry.value[0];
        let value = entry.value[1];
        if (typeof value?.toBSON === "function") {
          value = value.toBSON();
        }
        const type = typeof value;
        if (typeof key === "string" && !ignoreKeys.has(key)) {
          if (key.match(regexp) != null) {
            throw new BSONError("key " + key + " must not contain null bytes");
          }
          if (checkKeys) {
            if (key[0] === "$") {
              throw new BSONError("key " + key + " must not start with '$'");
            } else if (key.includes(".")) {
              throw new BSONError("key " + key + " must not contain '.'");
            }
          }
        }
        if (value === undefined) {
          if (ignoreUndefined === false)
            index = serializeNull(buffer2, key, value, index);
        } else if (value === null) {
          index = serializeNull(buffer2, key, value, index);
        } else if (type === "string") {
          index = serializeString(buffer2, key, value, index);
        } else if (type === "number") {
          index = serializeNumber(buffer2, key, value, index);
        } else if (type === "bigint") {
          index = serializeBigInt(buffer2, key, value, index);
        } else if (type === "boolean") {
          index = serializeBoolean(buffer2, key, value, index);
        } else if (type === "object" && value._bsontype == null) {
          if (value instanceof Date || isDate(value)) {
            index = serializeDate(buffer2, key, value, index);
          } else if (value instanceof Uint8Array || isUint8Array(value)) {
            index = serializeBuffer(buffer2, key, value, index);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index = serializeRegExp(buffer2, key, value, index);
          } else {
            index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
          }
        } else if (type === "object") {
          if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
            throw new BSONVersionError;
          } else if (value._bsontype === "ObjectId") {
            index = serializeObjectId(buffer2, key, value, index);
          } else if (value._bsontype === "Decimal128") {
            index = serializeDecimal128(buffer2, key, value, index);
          } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
            index = serializeLong(buffer2, key, value, index);
          } else if (value._bsontype === "Double") {
            index = serializeDouble(buffer2, key, value, index);
          } else if (value._bsontype === "Code") {
            index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
          } else if (value._bsontype === "Binary") {
            index = serializeBinary(buffer2, key, value, index);
          } else if (value._bsontype === "BSONSymbol") {
            index = serializeSymbol(buffer2, key, value, index);
          } else if (value._bsontype === "DBRef") {
            index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path);
          } else if (value._bsontype === "BSONRegExp") {
            index = serializeBSONRegExp(buffer2, key, value, index);
          } else if (value._bsontype === "Int32") {
            index = serializeInt32(buffer2, key, value, index);
          } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
            index = serializeMinMax(buffer2, key, value, index);
          } else if (typeof value._bsontype !== "undefined") {
            throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
          }
        } else if (type === "function" && serializeFunctions) {
          index = serializeFunction(buffer2, key, value, index);
        }
      }
    } else {
      if (typeof object?.toBSON === "function") {
        object = object.toBSON();
        if (object != null && typeof object !== "object") {
          throw new BSONError("toBSON function did not return an object");
        }
      }
      for (const key of Object.keys(object)) {
        let value = object[key];
        if (typeof value?.toBSON === "function") {
          value = value.toBSON();
        }
        const type = typeof value;
        if (typeof key === "string" && !ignoreKeys.has(key)) {
          if (key.match(regexp) != null) {
            throw new BSONError("key " + key + " must not contain null bytes");
          }
          if (checkKeys) {
            if (key[0] === "$") {
              throw new BSONError("key " + key + " must not start with '$'");
            } else if (key.includes(".")) {
              throw new BSONError("key " + key + " must not contain '.'");
            }
          }
        }
        if (value === undefined) {
          if (ignoreUndefined === false)
            index = serializeNull(buffer2, key, value, index);
        } else if (value === null) {
          index = serializeNull(buffer2, key, value, index);
        } else if (type === "string") {
          index = serializeString(buffer2, key, value, index);
        } else if (type === "number") {
          index = serializeNumber(buffer2, key, value, index);
        } else if (type === "bigint") {
          index = serializeBigInt(buffer2, key, value, index);
        } else if (type === "boolean") {
          index = serializeBoolean(buffer2, key, value, index);
        } else if (type === "object" && value._bsontype == null) {
          if (value instanceof Date || isDate(value)) {
            index = serializeDate(buffer2, key, value, index);
          } else if (value instanceof Uint8Array || isUint8Array(value)) {
            index = serializeBuffer(buffer2, key, value, index);
          } else if (value instanceof RegExp || isRegExp(value)) {
            index = serializeRegExp(buffer2, key, value, index);
          } else {
            index = serializeObject(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
          }
        } else if (type === "object") {
          if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
            throw new BSONVersionError;
          } else if (value._bsontype === "ObjectId") {
            index = serializeObjectId(buffer2, key, value, index);
          } else if (value._bsontype === "Decimal128") {
            index = serializeDecimal128(buffer2, key, value, index);
          } else if (value._bsontype === "Long" || value._bsontype === "Timestamp") {
            index = serializeLong(buffer2, key, value, index);
          } else if (value._bsontype === "Double") {
            index = serializeDouble(buffer2, key, value, index);
          } else if (value._bsontype === "Code") {
            index = serializeCode(buffer2, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);
          } else if (value._bsontype === "Binary") {
            index = serializeBinary(buffer2, key, value, index);
          } else if (value._bsontype === "BSONSymbol") {
            index = serializeSymbol(buffer2, key, value, index);
          } else if (value._bsontype === "DBRef") {
            index = serializeDBRef(buffer2, key, value, index, depth, serializeFunctions, path);
          } else if (value._bsontype === "BSONRegExp") {
            index = serializeBSONRegExp(buffer2, key, value, index);
          } else if (value._bsontype === "Int32") {
            index = serializeInt32(buffer2, key, value, index);
          } else if (value._bsontype === "MinKey" || value._bsontype === "MaxKey") {
            index = serializeMinMax(buffer2, key, value, index);
          } else if (typeof value._bsontype !== "undefined") {
            throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
          }
        } else if (type === "function" && serializeFunctions) {
          index = serializeFunction(buffer2, key, value, index);
        }
      }
    }
    path.delete(object);
    buffer2[index++] = 0;
    const size = index - startingIndex;
    startingIndex += NumberUtils.setInt32LE(buffer2, startingIndex, size);
    return index;
  }
  function isBSONType(value) {
    return value != null && typeof value === "object" && "_bsontype" in value && typeof value._bsontype === "string";
  }
  function deserializeValue(value, options = {}) {
    if (typeof value === "number") {
      const in32BitRange = value <= BSON_INT32_MAX && value >= BSON_INT32_MIN;
      const in64BitRange = value <= BSON_INT64_MAX && value >= BSON_INT64_MIN;
      if (options.relaxed || options.legacy) {
        return value;
      }
      if (Number.isInteger(value) && !Object.is(value, -0)) {
        if (in32BitRange) {
          return new Int32(value);
        }
        if (in64BitRange) {
          if (options.useBigInt64) {
            return BigInt(value);
          }
          return Long.fromNumber(value);
        }
      }
      return new Double(value);
    }
    if (value == null || typeof value !== "object")
      return value;
    if (value.$undefined)
      return null;
    const keys = Object.keys(value).filter((k) => k.startsWith("$") && value[k] != null);
    for (let i = 0;i < keys.length; i++) {
      const c = keysToCodecs[keys[i]];
      if (c)
        return c.fromExtendedJSON(value, options);
    }
    if (value.$date != null) {
      const d = value.$date;
      const date = new Date;
      if (options.legacy) {
        if (typeof d === "number")
          date.setTime(d);
        else if (typeof d === "string")
          date.setTime(Date.parse(d));
        else if (typeof d === "bigint")
          date.setTime(Number(d));
        else
          throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);
      } else {
        if (typeof d === "string")
          date.setTime(Date.parse(d));
        else if (Long.isLong(d))
          date.setTime(d.toNumber());
        else if (typeof d === "number" && options.relaxed)
          date.setTime(d);
        else if (typeof d === "bigint")
          date.setTime(Number(d));
        else
          throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);
      }
      return date;
    }
    if (value.$code != null) {
      const copy = Object.assign({}, value);
      if (value.$scope) {
        copy.$scope = deserializeValue(value.$scope);
      }
      return Code.fromExtendedJSON(value);
    }
    if (isDBRefLike(value) || value.$dbPointer) {
      const v = value.$ref ? value : value.$dbPointer;
      if (v instanceof DBRef)
        return v;
      const dollarKeys = Object.keys(v).filter((k) => k.startsWith("$"));
      let valid = true;
      dollarKeys.forEach((k) => {
        if (["$ref", "$id", "$db"].indexOf(k) === -1)
          valid = false;
      });
      if (valid)
        return DBRef.fromExtendedJSON(v);
    }
    return value;
  }
  function serializeArray(array, options) {
    return array.map((v, index) => {
      options.seenObjects.push({ propertyName: `index ${index}`, obj: null });
      try {
        return serializeValue(v, options);
      } finally {
        options.seenObjects.pop();
      }
    });
  }
  function getISOString(date) {
    const isoStr = date.toISOString();
    return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + "Z";
  }
  function serializeValue(value, options) {
    if (value instanceof Map || isMap(value)) {
      const obj = Object.create(null);
      for (const [k, v] of value) {
        if (typeof k !== "string") {
          throw new BSONError("Can only serialize maps with string keys");
        }
        obj[k] = v;
      }
      return serializeValue(obj, options);
    }
    if ((typeof value === "object" || typeof value === "function") && value !== null) {
      const index = options.seenObjects.findIndex((entry) => entry.obj === value);
      if (index !== -1) {
        const props = options.seenObjects.map((entry) => entry.propertyName);
        const leadingPart = props.slice(0, index).map((prop) => `${prop} -> `).join("");
        const alreadySeen = props[index];
        const circularPart = " -> " + props.slice(index + 1, props.length - 1).map((prop) => `${prop} -> `).join("");
        const current = props[props.length - 1];
        const leadingSpace = " ".repeat(leadingPart.length + alreadySeen.length / 2);
        const dashes = "-".repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);
        throw new BSONError("Converting circular structure to EJSON:\n" + `    ${leadingPart}${alreadySeen}${circularPart}${current}\n` + `    ${leadingSpace}\\${dashes}/`);
      }
      options.seenObjects[options.seenObjects.length - 1].obj = value;
    }
    if (Array.isArray(value))
      return serializeArray(value, options);
    if (value === undefined)
      return null;
    if (value instanceof Date || isDate(value)) {
      const dateNum = value.getTime(), inRange = dateNum > -1 && dateNum < 253402318800000;
      if (options.legacy) {
        return options.relaxed && inRange ? { $date: value.getTime() } : { $date: getISOString(value) };
      }
      return options.relaxed && inRange ? { $date: getISOString(value) } : { $date: { $numberLong: value.getTime().toString() } };
    }
    if (typeof value === "number" && (!options.relaxed || !isFinite(value))) {
      if (Number.isInteger(value) && !Object.is(value, -0)) {
        if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {
          return { $numberInt: value.toString() };
        }
        if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) {
          return { $numberLong: value.toString() };
        }
      }
      return { $numberDouble: Object.is(value, -0) ? "-0.0" : value.toString() };
    }
    if (typeof value === "bigint") {
      if (!options.relaxed) {
        return { $numberLong: BigInt.asIntN(64, value).toString() };
      }
      return Number(BigInt.asIntN(64, value));
    }
    if (value instanceof RegExp || isRegExp(value)) {
      let flags = value.flags;
      if (flags === undefined) {
        const match = value.toString().match(/[gimuy]*$/);
        if (match) {
          flags = match[0];
        }
      }
      const rx = new BSONRegExp(value.source, flags);
      return rx.toExtendedJSON(options);
    }
    if (value != null && typeof value === "object")
      return serializeDocument(value, options);
    return value;
  }
  function serializeDocument(doc, options) {
    if (doc == null || typeof doc !== "object")
      throw new BSONError("not an object instance");
    const bsontype = doc._bsontype;
    if (typeof bsontype === "undefined") {
      const _doc = {};
      for (const name of Object.keys(doc)) {
        options.seenObjects.push({ propertyName: name, obj: null });
        try {
          const value = serializeValue(doc[name], options);
          if (name === "__proto__") {
            Object.defineProperty(_doc, name, {
              value,
              writable: true,
              enumerable: true,
              configurable: true
            });
          } else {
            _doc[name] = value;
          }
        } finally {
          options.seenObjects.pop();
        }
      }
      return _doc;
    } else if (doc != null && typeof doc === "object" && typeof doc._bsontype === "string" && doc[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {
      throw new BSONVersionError;
    } else if (isBSONType(doc)) {
      let outDoc = doc;
      if (typeof outDoc.toExtendedJSON !== "function") {
        const mapper = BSON_TYPE_MAPPINGS[doc._bsontype];
        if (!mapper) {
          throw new BSONError("Unrecognized or invalid _bsontype: " + doc._bsontype);
        }
        outDoc = mapper(outDoc);
      }
      if (bsontype === "Code" && outDoc.scope) {
        outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));
      } else if (bsontype === "DBRef" && outDoc.oid) {
        outDoc = new DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));
      }
      return outDoc.toExtendedJSON(options);
    } else {
      throw new BSONError("_bsontype must be a string, but was: " + typeof bsontype);
    }
  }
  function parse(text, options) {
    const ejsonOptions = {
      useBigInt64: options?.useBigInt64 ?? false,
      relaxed: options?.relaxed ?? true,
      legacy: options?.legacy ?? false
    };
    return JSON.parse(text, (key, value) => {
      if (key.indexOf("\0") !== -1) {
        throw new BSONError(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(key)}`);
      }
      return deserializeValue(value, ejsonOptions);
    });
  }
  function stringify(value, replacer, space, options) {
    if (space != null && typeof space === "object") {
      options = space;
      space = 0;
    }
    if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
      options = replacer;
      replacer = undefined;
      space = 0;
    }
    const serializeOptions = Object.assign({ relaxed: true, legacy: false }, options, {
      seenObjects: [{ propertyName: "(root)", obj: null }]
    });
    const doc = serializeValue(value, serializeOptions);
    return JSON.stringify(doc, replacer, space);
  }
  function EJSONserialize(value, options) {
    options = options || {};
    return JSON.parse(stringify(value, options));
  }
  function EJSONdeserialize(ejson, options) {
    options = options || {};
    return parse(JSON.stringify(ejson), options);
  }
  function getSize(source, offset) {
    try {
      return NumberUtils.getNonnegativeInt32LE(source, offset);
    } catch (cause) {
      throw new BSONOffsetError("BSON size cannot be negative", offset, { cause });
    }
  }
  function findNull(bytes, offset) {
    let nullTerminatorOffset = offset;
    for (;bytes[nullTerminatorOffset] !== 0; nullTerminatorOffset++)
      ;
    if (nullTerminatorOffset === bytes.length - 1) {
      throw new BSONOffsetError("Null terminator not found", offset);
    }
    return nullTerminatorOffset;
  }
  function parseToElements(bytes, startOffset = 0) {
    startOffset ??= 0;
    if (bytes.length < 5) {
      throw new BSONOffsetError(`Input must be at least 5 bytes, got ${bytes.length} bytes`, startOffset);
    }
    const documentSize = getSize(bytes, startOffset);
    if (documentSize > bytes.length - startOffset) {
      throw new BSONOffsetError(`Parsed documentSize (${documentSize} bytes) does not match input length (${bytes.length} bytes)`, startOffset);
    }
    if (bytes[startOffset + documentSize - 1] !== 0) {
      throw new BSONOffsetError("BSON documents must end in 0x00", startOffset + documentSize);
    }
    const elements = [];
    let offset = startOffset + 4;
    while (offset <= documentSize + startOffset) {
      const type = bytes[offset];
      offset += 1;
      if (type === 0) {
        if (offset - startOffset !== documentSize) {
          throw new BSONOffsetError(`Invalid 0x00 type byte`, offset);
        }
        break;
      }
      const nameOffset = offset;
      const nameLength = findNull(bytes, offset) - nameOffset;
      offset += nameLength + 1;
      let length;
      if (type === 1 || type === 18 || type === 9 || type === 17) {
        length = 8;
      } else if (type === 16) {
        length = 4;
      } else if (type === 7) {
        length = 12;
      } else if (type === 19) {
        length = 16;
      } else if (type === 8) {
        length = 1;
      } else if (type === 10 || type === 6 || type === 127 || type === 255) {
        length = 0;
      } else if (type === 11) {
        length = findNull(bytes, findNull(bytes, offset) + 1) + 1 - offset;
      } else if (type === 3 || type === 4 || type === 15) {
        length = getSize(bytes, offset);
      } else if (type === 2 || type === 5 || type === 12 || type === 13 || type === 14) {
        length = getSize(bytes, offset) + 4;
        if (type === 5) {
          length += 1;
        }
        if (type === 12) {
          length += 12;
        }
      } else {
        throw new BSONOffsetError(`Invalid 0x${type.toString(16).padStart(2, "0")} type byte`, offset);
      }
      if (length > documentSize) {
        throw new BSONOffsetError("value reports length larger than document", offset);
      }
      elements.push([type, nameOffset, nameLength, offset, length]);
      offset += length;
    }
    return elements;
  }
  function setInternalBufferSize(size) {
    if (buffer.length < size) {
      buffer = ByteUtils.allocate(size);
    }
  }
  function serialize(object, options = {}) {
    const checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
    const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
    const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
    const minInternalBufferSize = typeof options.minInternalBufferSize === "number" ? options.minInternalBufferSize : MAXSIZE;
    if (buffer.length < minInternalBufferSize) {
      buffer = ByteUtils.allocate(minInternalBufferSize);
    }
    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
    const finishedBuffer = ByteUtils.allocateUnsafe(serializationIndex);
    finishedBuffer.set(buffer.subarray(0, serializationIndex), 0);
    return finishedBuffer;
  }
  function serializeWithBufferAndIndex(object, finalBuffer, options = {}) {
    const checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
    const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
    const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
    const startIndex = typeof options.index === "number" ? options.index : 0;
    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);
    finalBuffer.set(buffer.subarray(0, serializationIndex), startIndex);
    return startIndex + serializationIndex - 1;
  }
  function deserialize(buffer2, options = {}) {
    return internalDeserialize(ByteUtils.toLocalBufferType(buffer2), options);
  }
  function calculateObjectSize(object, options = {}) {
    options = options || {};
    const serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
    const ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : true;
    return internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined);
  }
  function deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
    const internalOptions = Object.assign({ allowObjectSmallerThanBufferSize: true, index: 0 }, options);
    const bufferData = ByteUtils.toLocalBufferType(data);
    let index = startIndex;
    for (let i = 0;i < numberOfDocuments; i++) {
      const size = NumberUtils.getInt32LE(bufferData, index);
      internalOptions.index = index;
      documents[docStartIndex + i] = internalDeserialize(bufferData, internalOptions);
      index = index + size;
    }
    return index;
  }
  var TypedArrayPrototypeGetSymbolToStringTag = (() => {
    const g = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array.prototype), Symbol.toStringTag).get;
    return (value) => g.call(value);
  })();
  var BSON_MAJOR_VERSION = 6;
  var BSON_VERSION_SYMBOL = Symbol.for("@@mdb.bson.version");
  var BSON_INT32_MAX = 2147483647;
  var BSON_INT32_MIN = -2147483648;
  var BSON_INT64_MAX = Math.pow(2, 63) - 1;
  var BSON_INT64_MIN = -Math.pow(2, 63);
  var JS_INT_MAX = Math.pow(2, 53);
  var JS_INT_MIN = -Math.pow(2, 53);
  var BSON_DATA_NUMBER = 1;
  var BSON_DATA_STRING = 2;
  var BSON_DATA_OBJECT = 3;
  var BSON_DATA_ARRAY = 4;
  var BSON_DATA_BINARY = 5;
  var BSON_DATA_UNDEFINED = 6;
  var BSON_DATA_OID = 7;
  var BSON_DATA_BOOLEAN = 8;
  var BSON_DATA_DATE = 9;
  var BSON_DATA_NULL = 10;
  var BSON_DATA_REGEXP = 11;
  var BSON_DATA_DBPOINTER = 12;
  var BSON_DATA_CODE = 13;
  var BSON_DATA_SYMBOL = 14;
  var BSON_DATA_CODE_W_SCOPE = 15;
  var BSON_DATA_INT = 16;
  var BSON_DATA_TIMESTAMP = 17;
  var BSON_DATA_LONG = 18;
  var BSON_DATA_DECIMAL128 = 19;
  var BSON_DATA_MIN_KEY = 255;
  var BSON_DATA_MAX_KEY = 127;
  var BSON_BINARY_SUBTYPE_DEFAULT = 0;
  var BSON_BINARY_SUBTYPE_UUID_NEW = 4;
  var BSONType = Object.freeze({
    double: 1,
    string: 2,
    object: 3,
    array: 4,
    binData: 5,
    undefined: 6,
    objectId: 7,
    bool: 8,
    date: 9,
    null: 10,
    regex: 11,
    dbPointer: 12,
    javascript: 13,
    symbol: 14,
    javascriptWithScope: 15,
    int: 16,
    timestamp: 17,
    long: 18,
    decimal: 19,
    minKey: -1,
    maxKey: 127
  });

  class BSONError extends Error {
    get bsonError() {
      return true;
    }
    get name() {
      return "BSONError";
    }
    constructor(message, options) {
      super(message, options);
    }
    static isBSONError(value) {
      return value != null && typeof value === "object" && "bsonError" in value && value.bsonError === true && "name" in value && "message" in value && "stack" in value;
    }
  }

  class BSONVersionError extends BSONError {
    get name() {
      return "BSONVersionError";
    }
    constructor() {
      super(`Unsupported BSON version, bson types must be from bson ${BSON_MAJOR_VERSION}.x.x`);
    }
  }

  class BSONRuntimeError extends BSONError {
    get name() {
      return "BSONRuntimeError";
    }
    constructor(message) {
      super(message);
    }
  }

  class BSONOffsetError extends BSONError {
    get name() {
      return "BSONOffsetError";
    }
    constructor(message, offset, options) {
      super(`${message}. offset: ${offset}`, options);
      this.offset = offset;
    }
  }
  var TextDecoderFatal;
  var TextDecoderNonFatal;
  var nodejsRandomBytes = (() => {
    try {
      return import.meta.require("crypto").randomBytes;
    } catch {
      return nodejsMathRandomBytes;
    }
  })();
  var nodeJsByteUtils = {
    toLocalBufferType(potentialBuffer) {
      if (Buffer.isBuffer(potentialBuffer)) {
        return potentialBuffer;
      }
      if (ArrayBuffer.isView(potentialBuffer)) {
        return Buffer.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);
      }
      const stringTag = potentialBuffer?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialBuffer);
      if (stringTag === "ArrayBuffer" || stringTag === "SharedArrayBuffer" || stringTag === "[object ArrayBuffer]" || stringTag === "[object SharedArrayBuffer]") {
        return Buffer.from(potentialBuffer);
      }
      throw new BSONError(`Cannot create Buffer from the passed potentialBuffer.`);
    },
    allocate(size) {
      return Buffer.alloc(size);
    },
    allocateUnsafe(size) {
      return Buffer.allocUnsafe(size);
    },
    equals(a, b) {
      return nodeJsByteUtils.toLocalBufferType(a).equals(b);
    },
    fromNumberArray(array) {
      return Buffer.from(array);
    },
    fromBase64(base64) {
      return Buffer.from(base64, "base64");
    },
    toBase64(buffer2) {
      return nodeJsByteUtils.toLocalBufferType(buffer2).toString("base64");
    },
    fromISO88591(codePoints) {
      return Buffer.from(codePoints, "binary");
    },
    toISO88591(buffer2) {
      return nodeJsByteUtils.toLocalBufferType(buffer2).toString("binary");
    },
    fromHex(hex) {
      return Buffer.from(hex, "hex");
    },
    toHex(buffer2) {
      return nodeJsByteUtils.toLocalBufferType(buffer2).toString("hex");
    },
    toUTF8(buffer2, start, end, fatal) {
      const basicLatin = end - start <= 20 ? tryReadBasicLatin(buffer2, start, end) : null;
      if (basicLatin != null) {
        return basicLatin;
      }
      const string = nodeJsByteUtils.toLocalBufferType(buffer2).toString("utf8", start, end);
      if (fatal) {
        for (let i = 0;i < string.length; i++) {
          if (string.charCodeAt(i) === 65533) {
            parseUtf8(buffer2, start, end, true);
            break;
          }
        }
      }
      return string;
    },
    utf8ByteLength(input) {
      return Buffer.byteLength(input, "utf8");
    },
    encodeUTF8Into(buffer2, source, byteOffset) {
      const latinBytesWritten = tryWriteBasicLatin(buffer2, source, byteOffset);
      if (latinBytesWritten != null) {
        return latinBytesWritten;
      }
      return nodeJsByteUtils.toLocalBufferType(buffer2).write(source, byteOffset, undefined, "utf8");
    },
    randomBytes: nodejsRandomBytes,
    swap32(buffer2) {
      return nodeJsByteUtils.toLocalBufferType(buffer2).swap32();
    }
  };
  var webRandomBytes = (() => {
    const { crypto: crypto3 } = globalThis;
    if (crypto3 != null && typeof crypto3.getRandomValues === "function") {
      return (byteLength) => {
        return crypto3.getRandomValues(webByteUtils.allocate(byteLength));
      };
    } else {
      if (isReactNative()) {
        const { console: console2 } = globalThis;
        console2?.warn?.("BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.");
      }
      return webMathRandomBytes;
    }
  })();
  var HEX_DIGIT = /(\d|[a-f])/i;
  var webByteUtils = {
    toLocalBufferType(potentialUint8array) {
      const stringTag = potentialUint8array?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialUint8array);
      if (stringTag === "Uint8Array") {
        return potentialUint8array;
      }
      if (ArrayBuffer.isView(potentialUint8array)) {
        return new Uint8Array(potentialUint8array.buffer.slice(potentialUint8array.byteOffset, potentialUint8array.byteOffset + potentialUint8array.byteLength));
      }
      if (stringTag === "ArrayBuffer" || stringTag === "SharedArrayBuffer" || stringTag === "[object ArrayBuffer]" || stringTag === "[object SharedArrayBuffer]") {
        return new Uint8Array(potentialUint8array);
      }
      throw new BSONError(`Cannot make a Uint8Array from passed potentialBuffer.`);
    },
    allocate(size) {
      if (typeof size !== "number") {
        throw new TypeError(`The "size" argument must be of type number. Received ${String(size)}`);
      }
      return new Uint8Array(size);
    },
    allocateUnsafe(size) {
      return webByteUtils.allocate(size);
    },
    equals(a, b) {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      for (let i = 0;i < a.byteLength; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    },
    fromNumberArray(array) {
      return Uint8Array.from(array);
    },
    fromBase64(base64) {
      return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0));
    },
    toBase64(uint8array) {
      return btoa(webByteUtils.toISO88591(uint8array));
    },
    fromISO88591(codePoints) {
      return Uint8Array.from(codePoints, (c) => c.charCodeAt(0) & 255);
    },
    toISO88591(uint8array) {
      return Array.from(Uint16Array.from(uint8array), (b) => String.fromCharCode(b)).join("");
    },
    fromHex(hex) {
      const evenLengthHex = hex.length % 2 === 0 ? hex : hex.slice(0, hex.length - 1);
      const buffer2 = [];
      for (let i = 0;i < evenLengthHex.length; i += 2) {
        const firstDigit = evenLengthHex[i];
        const secondDigit = evenLengthHex[i + 1];
        if (!HEX_DIGIT.test(firstDigit)) {
          break;
        }
        if (!HEX_DIGIT.test(secondDigit)) {
          break;
        }
        const hexDigit = Number.parseInt(`${firstDigit}${secondDigit}`, 16);
        buffer2.push(hexDigit);
      }
      return Uint8Array.from(buffer2);
    },
    toHex(uint8array) {
      return Array.from(uint8array, (byte) => byte.toString(16).padStart(2, "0")).join("");
    },
    toUTF8(uint8array, start, end, fatal) {
      const basicLatin = end - start <= 20 ? tryReadBasicLatin(uint8array, start, end) : null;
      if (basicLatin != null) {
        return basicLatin;
      }
      return parseUtf8(uint8array, start, end, fatal);
    },
    utf8ByteLength(input) {
      return new TextEncoder().encode(input).byteLength;
    },
    encodeUTF8Into(uint8array, source, byteOffset) {
      const bytes = new TextEncoder().encode(source);
      uint8array.set(bytes, byteOffset);
      return bytes.byteLength;
    },
    randomBytes: webRandomBytes,
    swap32(buffer2) {
      if (buffer2.length % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0;i < buffer2.length; i += 4) {
        const byte0 = buffer2[i];
        const byte1 = buffer2[i + 1];
        const byte2 = buffer2[i + 2];
        const byte3 = buffer2[i + 3];
        buffer2[i] = byte3;
        buffer2[i + 1] = byte2;
        buffer2[i + 2] = byte1;
        buffer2[i + 3] = byte0;
      }
      return buffer2;
    }
  };
  var hasGlobalBuffer = typeof Buffer === "function" && Buffer.prototype?._isBuffer !== true;
  var ByteUtils = hasGlobalBuffer ? nodeJsByteUtils : webByteUtils;

  class BSONValue {
    get [BSON_VERSION_SYMBOL]() {
      return BSON_MAJOR_VERSION;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, options, inspect) {
      return this.inspect(depth, options, inspect);
    }
  }
  var FLOAT = new Float64Array(1);
  var FLOAT_BYTES = new Uint8Array(FLOAT.buffer, 0, 8);
  FLOAT[0] = -1;
  var isBigEndian = FLOAT_BYTES[7] === 0;
  var NumberUtils = {
    isBigEndian,
    getNonnegativeInt32LE(source, offset) {
      if (source[offset + 3] > 127) {
        throw new RangeError(`Size cannot be negative at offset: ${offset}`);
      }
      return source[offset] | source[offset + 1] << 8 | source[offset + 2] << 16 | source[offset + 3] << 24;
    },
    getInt32LE(source, offset) {
      return source[offset] | source[offset + 1] << 8 | source[offset + 2] << 16 | source[offset + 3] << 24;
    },
    getUint32LE(source, offset) {
      return source[offset] + source[offset + 1] * 256 + source[offset + 2] * 65536 + source[offset + 3] * 16777216;
    },
    getUint32BE(source, offset) {
      return source[offset + 3] + source[offset + 2] * 256 + source[offset + 1] * 65536 + source[offset] * 16777216;
    },
    getBigInt64LE(source, offset) {
      const lo = NumberUtils.getUint32LE(source, offset);
      const hi = NumberUtils.getUint32LE(source, offset + 4);
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    },
    getFloat64LE: isBigEndian ? (source, offset) => {
      FLOAT_BYTES[7] = source[offset];
      FLOAT_BYTES[6] = source[offset + 1];
      FLOAT_BYTES[5] = source[offset + 2];
      FLOAT_BYTES[4] = source[offset + 3];
      FLOAT_BYTES[3] = source[offset + 4];
      FLOAT_BYTES[2] = source[offset + 5];
      FLOAT_BYTES[1] = source[offset + 6];
      FLOAT_BYTES[0] = source[offset + 7];
      return FLOAT[0];
    } : (source, offset) => {
      FLOAT_BYTES[0] = source[offset];
      FLOAT_BYTES[1] = source[offset + 1];
      FLOAT_BYTES[2] = source[offset + 2];
      FLOAT_BYTES[3] = source[offset + 3];
      FLOAT_BYTES[4] = source[offset + 4];
      FLOAT_BYTES[5] = source[offset + 5];
      FLOAT_BYTES[6] = source[offset + 6];
      FLOAT_BYTES[7] = source[offset + 7];
      return FLOAT[0];
    },
    setInt32BE(destination, offset, value) {
      destination[offset + 3] = value;
      value >>>= 8;
      destination[offset + 2] = value;
      value >>>= 8;
      destination[offset + 1] = value;
      value >>>= 8;
      destination[offset] = value;
      return 4;
    },
    setInt32LE(destination, offset, value) {
      destination[offset] = value;
      value >>>= 8;
      destination[offset + 1] = value;
      value >>>= 8;
      destination[offset + 2] = value;
      value >>>= 8;
      destination[offset + 3] = value;
      return 4;
    },
    setBigInt64LE(destination, offset, value) {
      const mask32bits = BigInt(4294967295);
      let lo = Number(value & mask32bits);
      destination[offset] = lo;
      lo >>= 8;
      destination[offset + 1] = lo;
      lo >>= 8;
      destination[offset + 2] = lo;
      lo >>= 8;
      destination[offset + 3] = lo;
      let hi = Number(value >> BigInt(32) & mask32bits);
      destination[offset + 4] = hi;
      hi >>= 8;
      destination[offset + 5] = hi;
      hi >>= 8;
      destination[offset + 6] = hi;
      hi >>= 8;
      destination[offset + 7] = hi;
      return 8;
    },
    setFloat64LE: isBigEndian ? (destination, offset, value) => {
      FLOAT[0] = value;
      destination[offset] = FLOAT_BYTES[7];
      destination[offset + 1] = FLOAT_BYTES[6];
      destination[offset + 2] = FLOAT_BYTES[5];
      destination[offset + 3] = FLOAT_BYTES[4];
      destination[offset + 4] = FLOAT_BYTES[3];
      destination[offset + 5] = FLOAT_BYTES[2];
      destination[offset + 6] = FLOAT_BYTES[1];
      destination[offset + 7] = FLOAT_BYTES[0];
      return 8;
    } : (destination, offset, value) => {
      FLOAT[0] = value;
      destination[offset] = FLOAT_BYTES[0];
      destination[offset + 1] = FLOAT_BYTES[1];
      destination[offset + 2] = FLOAT_BYTES[2];
      destination[offset + 3] = FLOAT_BYTES[3];
      destination[offset + 4] = FLOAT_BYTES[4];
      destination[offset + 5] = FLOAT_BYTES[5];
      destination[offset + 6] = FLOAT_BYTES[6];
      destination[offset + 7] = FLOAT_BYTES[7];
      return 8;
    }
  };

  class Binary extends BSONValue {
    get _bsontype() {
      return "Binary";
    }
    constructor(buffer2, subType) {
      super();
      if (!(buffer2 == null) && typeof buffer2 === "string" && !ArrayBuffer.isView(buffer2) && !isAnyArrayBuffer(buffer2) && !Array.isArray(buffer2)) {
        throw new BSONError("Binary can only be constructed from Uint8Array or number[]");
      }
      this.sub_type = subType ?? Binary.BSON_BINARY_SUBTYPE_DEFAULT;
      if (buffer2 == null) {
        this.buffer = ByteUtils.allocate(Binary.BUFFER_SIZE);
        this.position = 0;
      } else {
        this.buffer = Array.isArray(buffer2) ? ByteUtils.fromNumberArray(buffer2) : ByteUtils.toLocalBufferType(buffer2);
        this.position = this.buffer.byteLength;
      }
    }
    put(byteValue) {
      if (typeof byteValue === "string" && byteValue.length !== 1) {
        throw new BSONError("only accepts single character String");
      } else if (typeof byteValue !== "number" && byteValue.length !== 1)
        throw new BSONError("only accepts single character Uint8Array or Array");
      let decodedByte;
      if (typeof byteValue === "string") {
        decodedByte = byteValue.charCodeAt(0);
      } else if (typeof byteValue === "number") {
        decodedByte = byteValue;
      } else {
        decodedByte = byteValue[0];
      }
      if (decodedByte < 0 || decodedByte > 255) {
        throw new BSONError("only accepts number in a valid unsigned byte range 0-255");
      }
      if (this.buffer.byteLength > this.position) {
        this.buffer[this.position++] = decodedByte;
      } else {
        const newSpace = ByteUtils.allocate(Binary.BUFFER_SIZE + this.buffer.length);
        newSpace.set(this.buffer, 0);
        this.buffer = newSpace;
        this.buffer[this.position++] = decodedByte;
      }
    }
    write(sequence, offset) {
      offset = typeof offset === "number" ? offset : this.position;
      if (this.buffer.byteLength < offset + sequence.length) {
        const newSpace = ByteUtils.allocate(this.buffer.byteLength + sequence.length);
        newSpace.set(this.buffer, 0);
        this.buffer = newSpace;
      }
      if (ArrayBuffer.isView(sequence)) {
        this.buffer.set(ByteUtils.toLocalBufferType(sequence), offset);
        this.position = offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;
      } else if (typeof sequence === "string") {
        throw new BSONError("input cannot be string");
      }
    }
    read(position, length) {
      length = length && length > 0 ? length : this.position;
      const end = position + length;
      return this.buffer.subarray(position, end > this.position ? this.position : end);
    }
    value() {
      return this.buffer.length === this.position ? this.buffer : this.buffer.subarray(0, this.position);
    }
    length() {
      return this.position;
    }
    toJSON() {
      return ByteUtils.toBase64(this.buffer.subarray(0, this.position));
    }
    toString(encoding) {
      if (encoding === "hex")
        return ByteUtils.toHex(this.buffer.subarray(0, this.position));
      if (encoding === "base64")
        return ByteUtils.toBase64(this.buffer.subarray(0, this.position));
      if (encoding === "utf8" || encoding === "utf-8")
        return ByteUtils.toUTF8(this.buffer, 0, this.position, false);
      return ByteUtils.toUTF8(this.buffer, 0, this.position, false);
    }
    toExtendedJSON(options) {
      options = options || {};
      if (this.sub_type === Binary.SUBTYPE_VECTOR) {
        validateBinaryVector(this);
      }
      const base64String = ByteUtils.toBase64(this.buffer);
      const subType = Number(this.sub_type).toString(16);
      if (options.legacy) {
        return {
          $binary: base64String,
          $type: subType.length === 1 ? "0" + subType : subType
        };
      }
      return {
        $binary: {
          base64: base64String,
          subType: subType.length === 1 ? "0" + subType : subType
        }
      };
    }
    toUUID() {
      if (this.sub_type === Binary.SUBTYPE_UUID) {
        return new UUID(this.buffer.subarray(0, this.position));
      }
      throw new BSONError(`Binary sub_type "${this.sub_type}" is not supported for converting to UUID. Only "${Binary.SUBTYPE_UUID}" is currently supported.`);
    }
    static createFromHexString(hex, subType) {
      return new Binary(ByteUtils.fromHex(hex), subType);
    }
    static createFromBase64(base64, subType) {
      return new Binary(ByteUtils.fromBase64(base64), subType);
    }
    static fromExtendedJSON(doc, options) {
      options = options || {};
      let data;
      let type;
      if ("$binary" in doc) {
        if (options.legacy && typeof doc.$binary === "string" && "$type" in doc) {
          type = doc.$type ? parseInt(doc.$type, 16) : 0;
          data = ByteUtils.fromBase64(doc.$binary);
        } else {
          if (typeof doc.$binary !== "string") {
            type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;
            data = ByteUtils.fromBase64(doc.$binary.base64);
          }
        }
      } else if ("$uuid" in doc) {
        type = 4;
        data = UUID.bytesFromString(doc.$uuid);
      }
      if (!data) {
        throw new BSONError(`Unexpected Binary Extended JSON format ${JSON.stringify(doc)}`);
      }
      return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary(data, type);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      const base64 = ByteUtils.toBase64(this.buffer.subarray(0, this.position));
      const base64Arg = inspect(base64, options);
      const subTypeArg = inspect(this.sub_type, options);
      return `Binary.createFromBase64(${base64Arg}, ${subTypeArg})`;
    }
    toInt8Array() {
      if (this.sub_type !== Binary.SUBTYPE_VECTOR) {
        throw new BSONError("Binary sub_type is not Vector");
      }
      if (this.buffer[0] !== Binary.VECTOR_TYPE.Int8) {
        throw new BSONError("Binary datatype field is not Int8");
      }
      return new Int8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
    }
    toFloat32Array() {
      if (this.sub_type !== Binary.SUBTYPE_VECTOR) {
        throw new BSONError("Binary sub_type is not Vector");
      }
      if (this.buffer[0] !== Binary.VECTOR_TYPE.Float32) {
        throw new BSONError("Binary datatype field is not Float32");
      }
      const floatBytes = new Uint8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
      if (NumberUtils.isBigEndian)
        ByteUtils.swap32(floatBytes);
      return new Float32Array(floatBytes.buffer);
    }
    toPackedBits() {
      if (this.sub_type !== Binary.SUBTYPE_VECTOR) {
        throw new BSONError("Binary sub_type is not Vector");
      }
      if (this.buffer[0] !== Binary.VECTOR_TYPE.PackedBit) {
        throw new BSONError("Binary datatype field is not packed bit");
      }
      return new Uint8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));
    }
    toBits() {
      if (this.sub_type !== Binary.SUBTYPE_VECTOR) {
        throw new BSONError("Binary sub_type is not Vector");
      }
      if (this.buffer[0] !== Binary.VECTOR_TYPE.PackedBit) {
        throw new BSONError("Binary datatype field is not packed bit");
      }
      const byteCount = this.length() - 2;
      const bitCount = byteCount * 8 - this.buffer[1];
      const bits = new Int8Array(bitCount);
      for (let bitOffset = 0;bitOffset < bits.length; bitOffset++) {
        const byteOffset = bitOffset / 8 | 0;
        const byte = this.buffer[byteOffset + 2];
        const shift = 7 - bitOffset % 8;
        const bit = byte >> shift & 1;
        bits[bitOffset] = bit;
      }
      return bits;
    }
    static fromInt8Array(array) {
      const buffer2 = ByteUtils.allocate(array.byteLength + 2);
      buffer2[0] = Binary.VECTOR_TYPE.Int8;
      buffer2[1] = 0;
      const intBytes = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
      buffer2.set(intBytes, 2);
      return new this(buffer2, this.SUBTYPE_VECTOR);
    }
    static fromFloat32Array(array) {
      const binaryBytes = ByteUtils.allocate(array.byteLength + 2);
      binaryBytes[0] = Binary.VECTOR_TYPE.Float32;
      binaryBytes[1] = 0;
      const floatBytes = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
      binaryBytes.set(floatBytes, 2);
      if (NumberUtils.isBigEndian)
        ByteUtils.swap32(new Uint8Array(binaryBytes.buffer, 2));
      return new this(binaryBytes, this.SUBTYPE_VECTOR);
    }
    static fromPackedBits(array, padding = 0) {
      const buffer2 = ByteUtils.allocate(array.byteLength + 2);
      buffer2[0] = Binary.VECTOR_TYPE.PackedBit;
      buffer2[1] = padding;
      buffer2.set(array, 2);
      return new this(buffer2, this.SUBTYPE_VECTOR);
    }
    static fromBits(bits) {
      const byteLength = bits.length + 7 >>> 3;
      const bytes = new Uint8Array(byteLength + 2);
      bytes[0] = Binary.VECTOR_TYPE.PackedBit;
      const remainder = bits.length % 8;
      bytes[1] = remainder === 0 ? 0 : 8 - remainder;
      for (let bitOffset = 0;bitOffset < bits.length; bitOffset++) {
        const byteOffset = bitOffset >>> 3;
        const bit = bits[bitOffset];
        if (bit !== 0 && bit !== 1) {
          throw new BSONError(`Invalid bit value at ${bitOffset}: must be 0 or 1, found ${bits[bitOffset]}`);
        }
        if (bit === 0)
          continue;
        const shift = 7 - bitOffset % 8;
        bytes[byteOffset + 2] |= bit << shift;
      }
      return new this(bytes, Binary.SUBTYPE_VECTOR);
    }
  }
  Binary.BSON_BINARY_SUBTYPE_DEFAULT = 0;
  Binary.BUFFER_SIZE = 256;
  Binary.SUBTYPE_DEFAULT = 0;
  Binary.SUBTYPE_FUNCTION = 1;
  Binary.SUBTYPE_BYTE_ARRAY = 2;
  Binary.SUBTYPE_UUID_OLD = 3;
  Binary.SUBTYPE_UUID = 4;
  Binary.SUBTYPE_MD5 = 5;
  Binary.SUBTYPE_ENCRYPTED = 6;
  Binary.SUBTYPE_COLUMN = 7;
  Binary.SUBTYPE_SENSITIVE = 8;
  Binary.SUBTYPE_VECTOR = 9;
  Binary.SUBTYPE_USER_DEFINED = 128;
  Binary.VECTOR_TYPE = Object.freeze({
    Int8: 3,
    Float32: 39,
    PackedBit: 16
  });
  var UUID_BYTE_LENGTH = 16;
  var UUID_WITHOUT_DASHES = /^[0-9A-F]{32}$/i;
  var UUID_WITH_DASHES = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;

  class UUID extends Binary {
    constructor(input) {
      let bytes;
      if (input == null) {
        bytes = UUID.generate();
      } else if (input instanceof UUID) {
        bytes = ByteUtils.toLocalBufferType(new Uint8Array(input.buffer));
      } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {
        bytes = ByteUtils.toLocalBufferType(input);
      } else if (typeof input === "string") {
        bytes = UUID.bytesFromString(input);
      } else {
        throw new BSONError("Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).");
      }
      super(bytes, BSON_BINARY_SUBTYPE_UUID_NEW);
    }
    get id() {
      return this.buffer;
    }
    set id(value) {
      this.buffer = value;
    }
    toHexString(includeDashes = true) {
      if (includeDashes) {
        return [
          ByteUtils.toHex(this.buffer.subarray(0, 4)),
          ByteUtils.toHex(this.buffer.subarray(4, 6)),
          ByteUtils.toHex(this.buffer.subarray(6, 8)),
          ByteUtils.toHex(this.buffer.subarray(8, 10)),
          ByteUtils.toHex(this.buffer.subarray(10, 16))
        ].join("-");
      }
      return ByteUtils.toHex(this.buffer);
    }
    toString(encoding) {
      if (encoding === "hex")
        return ByteUtils.toHex(this.id);
      if (encoding === "base64")
        return ByteUtils.toBase64(this.id);
      return this.toHexString();
    }
    toJSON() {
      return this.toHexString();
    }
    equals(otherId) {
      if (!otherId) {
        return false;
      }
      if (otherId instanceof UUID) {
        return ByteUtils.equals(otherId.id, this.id);
      }
      try {
        return ByteUtils.equals(new UUID(otherId).id, this.id);
      } catch {
        return false;
      }
    }
    toBinary() {
      return new Binary(this.id, Binary.SUBTYPE_UUID);
    }
    static generate() {
      const bytes = ByteUtils.randomBytes(UUID_BYTE_LENGTH);
      bytes[6] = bytes[6] & 15 | 64;
      bytes[8] = bytes[8] & 63 | 128;
      return bytes;
    }
    static isValid(input) {
      if (!input) {
        return false;
      }
      if (typeof input === "string") {
        return UUID.isValidUUIDString(input);
      }
      if (isUint8Array(input)) {
        return input.byteLength === UUID_BYTE_LENGTH;
      }
      return input._bsontype === "Binary" && input.sub_type === this.SUBTYPE_UUID && input.buffer.byteLength === 16;
    }
    static createFromHexString(hexString) {
      const buffer2 = UUID.bytesFromString(hexString);
      return new UUID(buffer2);
    }
    static createFromBase64(base64) {
      return new UUID(ByteUtils.fromBase64(base64));
    }
    static bytesFromString(representation) {
      if (!UUID.isValidUUIDString(representation)) {
        throw new BSONError("UUID string representation must be 32 hex digits or canonical hyphenated representation");
      }
      return ByteUtils.fromHex(representation.replace(/-/g, ""));
    }
    static isValidUUIDString(representation) {
      return UUID_WITHOUT_DASHES.test(representation) || UUID_WITH_DASHES.test(representation);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      return `new UUID(${inspect(this.toHexString(), options)})`;
    }
  }

  class Code extends BSONValue {
    get _bsontype() {
      return "Code";
    }
    constructor(code, scope) {
      super();
      this.code = code.toString();
      this.scope = scope ?? null;
    }
    toJSON() {
      if (this.scope != null) {
        return { code: this.code, scope: this.scope };
      }
      return { code: this.code };
    }
    toExtendedJSON() {
      if (this.scope) {
        return { $code: this.code, $scope: this.scope };
      }
      return { $code: this.code };
    }
    static fromExtendedJSON(doc) {
      return new Code(doc.$code, doc.$scope);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      let parametersString = inspect(this.code, options);
      const multiLineFn = parametersString.includes("\n");
      if (this.scope != null) {
        parametersString += `,${multiLineFn ? "\n" : " "}${inspect(this.scope, options)}`;
      }
      const endingNewline = multiLineFn && this.scope === null;
      return `new Code(${multiLineFn ? "\n" : ""}${parametersString}${endingNewline ? "\n" : ""})`;
    }
  }

  class DBRef extends BSONValue {
    get _bsontype() {
      return "DBRef";
    }
    constructor(collection, oid, db, fields) {
      super();
      const parts = collection.split(".");
      if (parts.length === 2) {
        db = parts.shift();
        collection = parts.shift();
      }
      this.collection = collection;
      this.oid = oid;
      this.db = db;
      this.fields = fields || {};
    }
    get namespace() {
      return this.collection;
    }
    set namespace(value) {
      this.collection = value;
    }
    toJSON() {
      const o = Object.assign({
        $ref: this.collection,
        $id: this.oid
      }, this.fields);
      if (this.db != null)
        o.$db = this.db;
      return o;
    }
    toExtendedJSON(options) {
      options = options || {};
      let o = {
        $ref: this.collection,
        $id: this.oid
      };
      if (options.legacy) {
        return o;
      }
      if (this.db)
        o.$db = this.db;
      o = Object.assign(o, this.fields);
      return o;
    }
    static fromExtendedJSON(doc) {
      const copy = Object.assign({}, doc);
      delete copy.$ref;
      delete copy.$id;
      delete copy.$db;
      return new DBRef(doc.$ref, doc.$id, doc.$db, copy);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      const args = [
        inspect(this.namespace, options),
        inspect(this.oid, options),
        ...this.db ? [inspect(this.db, options)] : [],
        ...Object.keys(this.fields).length > 0 ? [inspect(this.fields, options)] : []
      ];
      args[1] = inspect === defaultInspect ? `new ObjectId(${args[1]})` : args[1];
      return `new DBRef(${args.join(", ")})`;
    }
  }
  var wasm = undefined;
  try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
  } catch {
  }
  var TWO_PWR_16_DBL = 1 << 16;
  var TWO_PWR_24_DBL = 1 << 24;
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
  var INT_CACHE = {};
  var UINT_CACHE = {};
  var MAX_INT64_STRING_LENGTH = 20;
  var DECIMAL_REG_EX = /^(\+?0|(\+|-)?[1-9][0-9]*)$/;

  class Long extends BSONValue {
    get _bsontype() {
      return "Long";
    }
    get __isLong__() {
      return true;
    }
    constructor(lowOrValue = 0, highOrUnsigned, unsigned) {
      super();
      const unsignedBool = typeof highOrUnsigned === "boolean" ? highOrUnsigned : Boolean(unsigned);
      const high = typeof highOrUnsigned === "number" ? highOrUnsigned : 0;
      const res = typeof lowOrValue === "string" ? Long.fromString(lowOrValue, unsignedBool) : typeof lowOrValue === "bigint" ? Long.fromBigInt(lowOrValue, unsignedBool) : { low: lowOrValue | 0, high: high | 0, unsigned: unsignedBool };
      this.low = res.low;
      this.high = res.high;
      this.unsigned = res.unsigned;
    }
    static fromBits(lowBits, highBits, unsigned) {
      return new Long(lowBits, highBits, unsigned);
    }
    static fromInt(value, unsigned) {
      let obj, cachedObj, cache;
      if (unsigned) {
        value >>>= 0;
        if (cache = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
          UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache = -128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = Long.fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
          INT_CACHE[value] = obj;
        return obj;
      }
    }
    static fromNumber(value, unsigned) {
      if (isNaN(value))
        return unsigned ? Long.UZERO : Long.ZERO;
      if (unsigned) {
        if (value < 0)
          return Long.UZERO;
        if (value >= TWO_PWR_64_DBL)
          return Long.MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL)
          return Long.MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
          return Long.MAX_VALUE;
      }
      if (value < 0)
        return Long.fromNumber(-value, unsigned).neg();
      return Long.fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }
    static fromBigInt(value, unsigned) {
      const FROM_BIGINT_BIT_MASK = BigInt(4294967295);
      const FROM_BIGINT_BIT_SHIFT = BigInt(32);
      return new Long(Number(value & FROM_BIGINT_BIT_MASK), Number(value >> FROM_BIGINT_BIT_SHIFT & FROM_BIGINT_BIT_MASK), unsigned);
    }
    static _fromString(str, unsigned, radix) {
      if (str.length === 0)
        throw new BSONError("empty string");
      if (radix < 2 || 36 < radix)
        throw new BSONError("radix");
      let p;
      if ((p = str.indexOf("-")) > 0)
        throw new BSONError("interior hyphen");
      else if (p === 0) {
        return Long._fromString(str.substring(1), unsigned, radix).neg();
      }
      const radixToPower = Long.fromNumber(Math.pow(radix, 8));
      let result = Long.ZERO;
      for (let i = 0;i < str.length; i += 8) {
        const size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          const power = Long.fromNumber(Math.pow(radix, size));
          result = result.mul(power).add(Long.fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(Long.fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    static fromStringStrict(str, unsignedOrRadix, radix) {
      let unsigned = false;
      if (typeof unsignedOrRadix === "number") {
        radix = unsignedOrRadix, unsignedOrRadix = false;
      } else {
        unsigned = !!unsignedOrRadix;
      }
      radix ??= 10;
      if (str.trim() !== str) {
        throw new BSONError(`Input: '${str}' contains leading and/or trailing whitespace`);
      }
      if (!validateStringCharacters(str, radix)) {
        throw new BSONError(`Input: '${str}' contains invalid characters for radix: ${radix}`);
      }
      const cleanedStr = removeLeadingZerosAndExplicitPlus(str);
      const result = Long._fromString(cleanedStr, unsigned, radix);
      if (result.toString(radix).toLowerCase() !== cleanedStr.toLowerCase()) {
        throw new BSONError(`Input: ${str} is not representable as ${result.unsigned ? "an unsigned" : "a signed"} 64-bit Long ${radix != null ? `with radix: ${radix}` : ""}`);
      }
      return result;
    }
    static fromString(str, unsignedOrRadix, radix) {
      let unsigned = false;
      if (typeof unsignedOrRadix === "number") {
        radix = unsignedOrRadix, unsignedOrRadix = false;
      } else {
        unsigned = !!unsignedOrRadix;
      }
      radix ??= 10;
      if (str === "NaN" && radix < 24) {
        return Long.ZERO;
      } else if ((str === "Infinity" || str === "+Infinity" || str === "-Infinity") && radix < 35) {
        return Long.ZERO;
      }
      return Long._fromString(str, unsigned, radix);
    }
    static fromBytes(bytes, unsigned, le) {
      return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
    }
    static fromBytesLE(bytes, unsigned) {
      return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
    }
    static fromBytesBE(bytes, unsigned) {
      return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
    }
    static isLong(value) {
      return value != null && typeof value === "object" && "__isLong__" in value && value.__isLong__ === true;
    }
    static fromValue(val, unsigned) {
      if (typeof val === "number")
        return Long.fromNumber(val, unsigned);
      if (typeof val === "string")
        return Long.fromString(val, unsigned);
      return Long.fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    add(addend) {
      if (!Long.isLong(addend))
        addend = Long.fromValue(addend);
      const a48 = this.high >>> 16;
      const a32 = this.high & 65535;
      const a16 = this.low >>> 16;
      const a00 = this.low & 65535;
      const b48 = addend.high >>> 16;
      const b32 = addend.high & 65535;
      const b16 = addend.low >>> 16;
      const b00 = addend.low & 65535;
      let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    }
    and(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    }
    compare(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      if (this.eq(other))
        return 0;
      const thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    }
    comp(other) {
      return this.compare(other);
    }
    divide(divisor) {
      if (!Long.isLong(divisor))
        divisor = Long.fromValue(divisor);
      if (divisor.isZero())
        throw new BSONError("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        const low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
        return Long.fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? Long.UZERO : Long.ZERO;
      let approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(Long.MIN_VALUE)) {
          if (divisor.eq(Long.ONE) || divisor.eq(Long.NEG_ONE))
            return Long.MIN_VALUE;
          else if (divisor.eq(Long.MIN_VALUE))
            return Long.ONE;
          else {
            const halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(Long.ZERO)) {
              return divisor.isNegative() ? Long.ONE : Long.NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(Long.MIN_VALUE))
          return this.unsigned ? Long.UZERO : Long.ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = Long.ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return Long.UZERO;
        if (divisor.gt(this.shru(1)))
          return Long.UONE;
        res = Long.UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        const log2 = Math.ceil(Math.log(approx) / Math.LN2);
        const delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
        let approxRes = Long.fromNumber(approx);
        let approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = Long.fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = Long.ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    }
    div(divisor) {
      return this.divide(divisor);
    }
    equals(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    }
    eq(other) {
      return this.equals(other);
    }
    getHighBits() {
      return this.high;
    }
    getHighBitsUnsigned() {
      return this.high >>> 0;
    }
    getLowBits() {
      return this.low;
    }
    getLowBitsUnsigned() {
      return this.low >>> 0;
    }
    getNumBitsAbs() {
      if (this.isNegative()) {
        return this.eq(Long.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      }
      const val = this.high !== 0 ? this.high : this.low;
      let bit;
      for (bit = 31;bit > 0; bit--)
        if ((val & 1 << bit) !== 0)
          break;
      return this.high !== 0 ? bit + 33 : bit + 1;
    }
    greaterThan(other) {
      return this.comp(other) > 0;
    }
    gt(other) {
      return this.greaterThan(other);
    }
    greaterThanOrEqual(other) {
      return this.comp(other) >= 0;
    }
    gte(other) {
      return this.greaterThanOrEqual(other);
    }
    ge(other) {
      return this.greaterThanOrEqual(other);
    }
    isEven() {
      return (this.low & 1) === 0;
    }
    isNegative() {
      return !this.unsigned && this.high < 0;
    }
    isOdd() {
      return (this.low & 1) === 1;
    }
    isPositive() {
      return this.unsigned || this.high >= 0;
    }
    isZero() {
      return this.high === 0 && this.low === 0;
    }
    lessThan(other) {
      return this.comp(other) < 0;
    }
    lt(other) {
      return this.lessThan(other);
    }
    lessThanOrEqual(other) {
      return this.comp(other) <= 0;
    }
    lte(other) {
      return this.lessThanOrEqual(other);
    }
    modulo(divisor) {
      if (!Long.isLong(divisor))
        divisor = Long.fromValue(divisor);
      if (wasm) {
        const low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
        return Long.fromBits(low, wasm.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    }
    mod(divisor) {
      return this.modulo(divisor);
    }
    rem(divisor) {
      return this.modulo(divisor);
    }
    multiply(multiplier) {
      if (this.isZero())
        return Long.ZERO;
      if (!Long.isLong(multiplier))
        multiplier = Long.fromValue(multiplier);
      if (wasm) {
        const low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
        return Long.fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (multiplier.isZero())
        return Long.ZERO;
      if (this.eq(Long.MIN_VALUE))
        return multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO;
      if (multiplier.eq(Long.MIN_VALUE))
        return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(Long.TWO_PWR_24) && multiplier.lt(Long.TWO_PWR_24))
        return Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      const a48 = this.high >>> 16;
      const a32 = this.high & 65535;
      const a16 = this.low >>> 16;
      const a00 = this.low & 65535;
      const b48 = multiplier.high >>> 16;
      const b32 = multiplier.high & 65535;
      const b16 = multiplier.low >>> 16;
      const b00 = multiplier.low & 65535;
      let c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    }
    mul(multiplier) {
      return this.multiply(multiplier);
    }
    negate() {
      if (!this.unsigned && this.eq(Long.MIN_VALUE))
        return Long.MIN_VALUE;
      return this.not().add(Long.ONE);
    }
    neg() {
      return this.negate();
    }
    not() {
      return Long.fromBits(~this.low, ~this.high, this.unsigned);
    }
    notEquals(other) {
      return !this.equals(other);
    }
    neq(other) {
      return this.notEquals(other);
    }
    ne(other) {
      return this.notEquals(other);
    }
    or(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    }
    shiftLeft(numBits) {
      if (Long.isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return Long.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return Long.fromBits(0, this.low << numBits - 32, this.unsigned);
    }
    shl(numBits) {
      return this.shiftLeft(numBits);
    }
    shiftRight(numBits) {
      if (Long.isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return Long.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return Long.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    }
    shr(numBits) {
      return this.shiftRight(numBits);
    }
    shiftRightUnsigned(numBits) {
      if (Long.isLong(numBits))
        numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0)
        return this;
      else {
        const high = this.high;
        if (numBits < 32) {
          const low = this.low;
          return Long.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32)
          return Long.fromBits(high, 0, this.unsigned);
        else
          return Long.fromBits(high >>> numBits - 32, 0, this.unsigned);
      }
    }
    shr_u(numBits) {
      return this.shiftRightUnsigned(numBits);
    }
    shru(numBits) {
      return this.shiftRightUnsigned(numBits);
    }
    subtract(subtrahend) {
      if (!Long.isLong(subtrahend))
        subtrahend = Long.fromValue(subtrahend);
      return this.add(subtrahend.neg());
    }
    sub(subtrahend) {
      return this.subtract(subtrahend);
    }
    toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    }
    toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    }
    toBigInt() {
      return BigInt(this.toString());
    }
    toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    }
    toBytesLE() {
      const hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    }
    toBytesBE() {
      const hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    }
    toSigned() {
      if (!this.unsigned)
        return this;
      return Long.fromBits(this.low, this.high, false);
    }
    toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw new BSONError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(Long.MIN_VALUE)) {
          const radixLong = Long.fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      const radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned);
      let rem = this;
      let result = "";
      while (true) {
        const remDiv = rem.div(radixToPower);
        const intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;
        let digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    }
    toUnsigned() {
      if (this.unsigned)
        return this;
      return Long.fromBits(this.low, this.high, true);
    }
    xor(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    }
    eqz() {
      return this.isZero();
    }
    le(other) {
      return this.lessThanOrEqual(other);
    }
    toExtendedJSON(options) {
      if (options && options.relaxed)
        return this.toNumber();
      return { $numberLong: this.toString() };
    }
    static fromExtendedJSON(doc, options) {
      const { useBigInt64 = false, relaxed = true } = { ...options };
      if (doc.$numberLong.length > MAX_INT64_STRING_LENGTH) {
        throw new BSONError("$numberLong string is too long");
      }
      if (!DECIMAL_REG_EX.test(doc.$numberLong)) {
        throw new BSONError(`\$numberLong string "${doc.$numberLong}" is in an invalid format`);
      }
      if (useBigInt64) {
        const bigIntResult = BigInt(doc.$numberLong);
        return BigInt.asIntN(64, bigIntResult);
      }
      const longResult = Long.fromString(doc.$numberLong);
      if (relaxed) {
        return longResult.toNumber();
      }
      return longResult;
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      const longVal = inspect(this.toString(), options);
      const unsignedVal = this.unsigned ? `, ${inspect(this.unsigned, options)}` : "";
      return `new Long(${longVal}${unsignedVal})`;
    }
  }
  Long.TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL);
  Long.MAX_UNSIGNED_VALUE = Long.fromBits(4294967295 | 0, 4294967295 | 0, true);
  Long.ZERO = Long.fromInt(0);
  Long.UZERO = Long.fromInt(0, true);
  Long.ONE = Long.fromInt(1);
  Long.UONE = Long.fromInt(1, true);
  Long.NEG_ONE = Long.fromInt(-1);
  Long.MAX_VALUE = Long.fromBits(4294967295 | 0, 2147483647 | 0, false);
  Long.MIN_VALUE = Long.fromBits(0, 2147483648 | 0, false);
  var PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
  var PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
  var PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
  var EXPONENT_MAX = 6111;
  var EXPONENT_MIN = -6176;
  var EXPONENT_BIAS = 6176;
  var MAX_DIGITS = 34;
  var NAN_BUFFER = ByteUtils.fromNumberArray([
    124,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ].reverse());
  var INF_NEGATIVE_BUFFER = ByteUtils.fromNumberArray([
    248,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ].reverse());
  var INF_POSITIVE_BUFFER = ByteUtils.fromNumberArray([
    120,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ].reverse());
  var EXPONENT_REGEX = /^([-+])?(\d+)?$/;
  var COMBINATION_MASK = 31;
  var EXPONENT_MASK = 16383;
  var COMBINATION_INFINITY = 30;
  var COMBINATION_NAN = 31;

  class Decimal128 extends BSONValue {
    get _bsontype() {
      return "Decimal128";
    }
    constructor(bytes) {
      super();
      if (typeof bytes === "string") {
        this.bytes = Decimal128.fromString(bytes).bytes;
      } else if (bytes instanceof Uint8Array || isUint8Array(bytes)) {
        if (bytes.byteLength !== 16) {
          throw new BSONError("Decimal128 must take a Buffer of 16 bytes");
        }
        this.bytes = bytes;
      } else {
        throw new BSONError("Decimal128 must take a Buffer or string");
      }
    }
    static fromString(representation) {
      return Decimal128._fromString(representation, { allowRounding: false });
    }
    static fromStringWithRounding(representation) {
      return Decimal128._fromString(representation, { allowRounding: true });
    }
    static _fromString(representation, options) {
      let isNegative = false;
      let sawSign = false;
      let sawRadix = false;
      let foundNonZero = false;
      let significantDigits = 0;
      let nDigitsRead = 0;
      let nDigits = 0;
      let radixPosition = 0;
      let firstNonZero = 0;
      const digits = [0];
      let nDigitsStored = 0;
      let digitsInsert = 0;
      let lastDigit = 0;
      let exponent = 0;
      let significandHigh = new Long(0, 0);
      let significandLow = new Long(0, 0);
      let biasedExponent = 0;
      let index = 0;
      if (representation.length >= 7000) {
        throw new BSONError("" + representation + " not a valid Decimal128 string");
      }
      const stringMatch = representation.match(PARSE_STRING_REGEXP);
      const infMatch = representation.match(PARSE_INF_REGEXP);
      const nanMatch = representation.match(PARSE_NAN_REGEXP);
      if (!stringMatch && !infMatch && !nanMatch || representation.length === 0) {
        throw new BSONError("" + representation + " not a valid Decimal128 string");
      }
      if (stringMatch) {
        const unsignedNumber = stringMatch[2];
        const e = stringMatch[4];
        const expSign = stringMatch[5];
        const expNumber = stringMatch[6];
        if (e && expNumber === undefined)
          invalidErr(representation, "missing exponent power");
        if (e && unsignedNumber === undefined)
          invalidErr(representation, "missing exponent base");
        if (e === undefined && (expSign || expNumber)) {
          invalidErr(representation, "missing e before exponent");
        }
      }
      if (representation[index] === "+" || representation[index] === "-") {
        sawSign = true;
        isNegative = representation[index++] === "-";
      }
      if (!isDigit(representation[index]) && representation[index] !== ".") {
        if (representation[index] === "i" || representation[index] === "I") {
          return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
        } else if (representation[index] === "N") {
          return new Decimal128(NAN_BUFFER);
        }
      }
      while (isDigit(representation[index]) || representation[index] === ".") {
        if (representation[index] === ".") {
          if (sawRadix)
            invalidErr(representation, "contains multiple periods");
          sawRadix = true;
          index = index + 1;
          continue;
        }
        if (nDigitsStored < MAX_DIGITS) {
          if (representation[index] !== "0" || foundNonZero) {
            if (!foundNonZero) {
              firstNonZero = nDigitsRead;
            }
            foundNonZero = true;
            digits[digitsInsert++] = parseInt(representation[index], 10);
            nDigitsStored = nDigitsStored + 1;
          }
        }
        if (foundNonZero)
          nDigits = nDigits + 1;
        if (sawRadix)
          radixPosition = radixPosition + 1;
        nDigitsRead = nDigitsRead + 1;
        index = index + 1;
      }
      if (sawRadix && !nDigitsRead)
        throw new BSONError("" + representation + " not a valid Decimal128 string");
      if (representation[index] === "e" || representation[index] === "E") {
        const match = representation.substr(++index).match(EXPONENT_REGEX);
        if (!match || !match[2])
          return new Decimal128(NAN_BUFFER);
        exponent = parseInt(match[0], 10);
        index = index + match[0].length;
      }
      if (representation[index])
        return new Decimal128(NAN_BUFFER);
      if (!nDigitsStored) {
        digits[0] = 0;
        nDigits = 1;
        nDigitsStored = 1;
        significantDigits = 0;
      } else {
        lastDigit = nDigitsStored - 1;
        significantDigits = nDigits;
        if (significantDigits !== 1) {
          while (representation[firstNonZero + significantDigits - 1 + Number(sawSign) + Number(sawRadix)] === "0") {
            significantDigits = significantDigits - 1;
          }
        }
      }
      if (exponent <= radixPosition && radixPosition > exponent + (1 << 14)) {
        exponent = EXPONENT_MIN;
      } else {
        exponent = exponent - radixPosition;
      }
      while (exponent > EXPONENT_MAX) {
        lastDigit = lastDigit + 1;
        if (lastDigit >= MAX_DIGITS) {
          if (significantDigits === 0) {
            exponent = EXPONENT_MAX;
            break;
          }
          invalidErr(representation, "overflow");
        }
        exponent = exponent - 1;
      }
      if (options.allowRounding) {
        while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
          if (lastDigit === 0 && significantDigits < nDigitsStored) {
            exponent = EXPONENT_MIN;
            significantDigits = 0;
            break;
          }
          if (nDigitsStored < nDigits) {
            nDigits = nDigits - 1;
          } else {
            lastDigit = lastDigit - 1;
          }
          if (exponent < EXPONENT_MAX) {
            exponent = exponent + 1;
          } else {
            const digitsString = digits.join("");
            if (digitsString.match(/^0+$/)) {
              exponent = EXPONENT_MAX;
              break;
            }
            invalidErr(representation, "overflow");
          }
        }
        if (lastDigit + 1 < significantDigits) {
          let endOfString = nDigitsRead;
          if (sawRadix) {
            firstNonZero = firstNonZero + 1;
            endOfString = endOfString + 1;
          }
          if (sawSign) {
            firstNonZero = firstNonZero + 1;
            endOfString = endOfString + 1;
          }
          const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
          let roundBit = 0;
          if (roundDigit >= 5) {
            roundBit = 1;
            if (roundDigit === 5) {
              roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;
              for (let i = firstNonZero + lastDigit + 2;i < endOfString; i++) {
                if (parseInt(representation[i], 10)) {
                  roundBit = 1;
                  break;
                }
              }
            }
          }
          if (roundBit) {
            let dIdx = lastDigit;
            for (;dIdx >= 0; dIdx--) {
              if (++digits[dIdx] > 9) {
                digits[dIdx] = 0;
                if (dIdx === 0) {
                  if (exponent < EXPONENT_MAX) {
                    exponent = exponent + 1;
                    digits[dIdx] = 1;
                  } else {
                    return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);
                  }
                }
              } else {
                break;
              }
            }
          }
        }
      } else {
        while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
          if (lastDigit === 0) {
            if (significantDigits === 0) {
              exponent = EXPONENT_MIN;
              break;
            }
            invalidErr(representation, "exponent underflow");
          }
          if (nDigitsStored < nDigits) {
            if (representation[nDigits - 1 + Number(sawSign) + Number(sawRadix)] !== "0" && significantDigits !== 0) {
              invalidErr(representation, "inexact rounding");
            }
            nDigits = nDigits - 1;
          } else {
            if (digits[lastDigit] !== 0) {
              invalidErr(representation, "inexact rounding");
            }
            lastDigit = lastDigit - 1;
          }
          if (exponent < EXPONENT_MAX) {
            exponent = exponent + 1;
          } else {
            invalidErr(representation, "overflow");
          }
        }
        if (lastDigit + 1 < significantDigits) {
          if (sawRadix) {
            firstNonZero = firstNonZero + 1;
          }
          if (sawSign) {
            firstNonZero = firstNonZero + 1;
          }
          const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);
          if (roundDigit !== 0) {
            invalidErr(representation, "inexact rounding");
          }
        }
      }
      significandHigh = Long.fromNumber(0);
      significandLow = Long.fromNumber(0);
      if (significantDigits === 0) {
        significandHigh = Long.fromNumber(0);
        significandLow = Long.fromNumber(0);
      } else if (lastDigit < 17) {
        let dIdx = 0;
        significandLow = Long.fromNumber(digits[dIdx++]);
        significandHigh = new Long(0, 0);
        for (;dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long.fromNumber(10));
          significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
        }
      } else {
        let dIdx = 0;
        significandHigh = Long.fromNumber(digits[dIdx++]);
        for (;dIdx <= lastDigit - 17; dIdx++) {
          significandHigh = significandHigh.multiply(Long.fromNumber(10));
          significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));
        }
        significandLow = Long.fromNumber(digits[dIdx++]);
        for (;dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(Long.fromNumber(10));
          significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));
        }
      }
      const significand = multiply64x2(significandHigh, Long.fromString("100000000000000000"));
      significand.low = significand.low.add(significandLow);
      if (lessThan(significand.low, significandLow)) {
        significand.high = significand.high.add(Long.fromNumber(1));
      }
      biasedExponent = exponent + EXPONENT_BIAS;
      const dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };
      if (significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))) {
        dec.high = dec.high.or(Long.fromNumber(3).shiftLeft(61));
        dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(16383).shiftLeft(47)));
        dec.high = dec.high.or(significand.high.and(Long.fromNumber(140737488355327)));
      } else {
        dec.high = dec.high.or(Long.fromNumber(biasedExponent & 16383).shiftLeft(49));
        dec.high = dec.high.or(significand.high.and(Long.fromNumber(562949953421311)));
      }
      dec.low = significand.low;
      if (isNegative) {
        dec.high = dec.high.or(Long.fromString("9223372036854775808"));
      }
      const buffer2 = ByteUtils.allocateUnsafe(16);
      index = 0;
      buffer2[index++] = dec.low.low & 255;
      buffer2[index++] = dec.low.low >> 8 & 255;
      buffer2[index++] = dec.low.low >> 16 & 255;
      buffer2[index++] = dec.low.low >> 24 & 255;
      buffer2[index++] = dec.low.high & 255;
      buffer2[index++] = dec.low.high >> 8 & 255;
      buffer2[index++] = dec.low.high >> 16 & 255;
      buffer2[index++] = dec.low.high >> 24 & 255;
      buffer2[index++] = dec.high.low & 255;
      buffer2[index++] = dec.high.low >> 8 & 255;
      buffer2[index++] = dec.high.low >> 16 & 255;
      buffer2[index++] = dec.high.low >> 24 & 255;
      buffer2[index++] = dec.high.high & 255;
      buffer2[index++] = dec.high.high >> 8 & 255;
      buffer2[index++] = dec.high.high >> 16 & 255;
      buffer2[index++] = dec.high.high >> 24 & 255;
      return new Decimal128(buffer2);
    }
    toString() {
      let biased_exponent;
      let significand_digits = 0;
      const significand = new Array(36);
      for (let i = 0;i < significand.length; i++)
        significand[i] = 0;
      let index = 0;
      let is_zero = false;
      let significand_msb;
      let significand128 = { parts: [0, 0, 0, 0] };
      let j, k;
      const string = [];
      index = 0;
      const buffer2 = this.bytes;
      const low = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      const midl = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      const midh = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      const high = buffer2[index++] | buffer2[index++] << 8 | buffer2[index++] << 16 | buffer2[index++] << 24;
      index = 0;
      const dec = {
        low: new Long(low, midl),
        high: new Long(midh, high)
      };
      if (dec.high.lessThan(Long.ZERO)) {
        string.push("-");
      }
      const combination = high >> 26 & COMBINATION_MASK;
      if (combination >> 3 === 3) {
        if (combination === COMBINATION_INFINITY) {
          return string.join("") + "Infinity";
        } else if (combination === COMBINATION_NAN) {
          return "NaN";
        } else {
          biased_exponent = high >> 15 & EXPONENT_MASK;
          significand_msb = 8 + (high >> 14 & 1);
        }
      } else {
        significand_msb = high >> 14 & 7;
        biased_exponent = high >> 17 & EXPONENT_MASK;
      }
      const exponent = biased_exponent - EXPONENT_BIAS;
      significand128.parts[0] = (high & 16383) + ((significand_msb & 15) << 14);
      significand128.parts[1] = midh;
      significand128.parts[2] = midl;
      significand128.parts[3] = low;
      if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {
        is_zero = true;
      } else {
        for (k = 3;k >= 0; k--) {
          let least_digits = 0;
          const result = divideu128(significand128);
          significand128 = result.quotient;
          least_digits = result.rem.low;
          if (!least_digits)
            continue;
          for (j = 8;j >= 0; j--) {
            significand[k * 9 + j] = least_digits % 10;
            least_digits = Math.floor(least_digits / 10);
          }
        }
      }
      if (is_zero) {
        significand_digits = 1;
        significand[index] = 0;
      } else {
        significand_digits = 36;
        while (!significand[index]) {
          significand_digits = significand_digits - 1;
          index = index + 1;
        }
      }
      const scientific_exponent = significand_digits - 1 + exponent;
      if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
        if (significand_digits > 34) {
          string.push(`${0}`);
          if (exponent > 0)
            string.push(`E+${exponent}`);
          else if (exponent < 0)
            string.push(`E${exponent}`);
          return string.join("");
        }
        string.push(`${significand[index++]}`);
        significand_digits = significand_digits - 1;
        if (significand_digits) {
          string.push(".");
        }
        for (let i = 0;i < significand_digits; i++) {
          string.push(`${significand[index++]}`);
        }
        string.push("E");
        if (scientific_exponent > 0) {
          string.push(`+${scientific_exponent}`);
        } else {
          string.push(`${scientific_exponent}`);
        }
      } else {
        if (exponent >= 0) {
          for (let i = 0;i < significand_digits; i++) {
            string.push(`${significand[index++]}`);
          }
        } else {
          let radix_position = significand_digits + exponent;
          if (radix_position > 0) {
            for (let i = 0;i < radix_position; i++) {
              string.push(`${significand[index++]}`);
            }
          } else {
            string.push("0");
          }
          string.push(".");
          while (radix_position++ < 0) {
            string.push("0");
          }
          for (let i = 0;i < significand_digits - Math.max(radix_position - 1, 0); i++) {
            string.push(`${significand[index++]}`);
          }
        }
      }
      return string.join("");
    }
    toJSON() {
      return { $numberDecimal: this.toString() };
    }
    toExtendedJSON() {
      return { $numberDecimal: this.toString() };
    }
    static fromExtendedJSON(doc) {
      return Decimal128.fromString(doc.$numberDecimal);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      const d128string = inspect(this.toString(), options);
      return `new Decimal128(${d128string})`;
    }
  }

  class Double extends BSONValue {
    get _bsontype() {
      return "Double";
    }
    constructor(value) {
      super();
      if (value instanceof Number) {
        value = value.valueOf();
      }
      this.value = +value;
    }
    static fromString(value) {
      const coercedValue = Number(value);
      if (value === "NaN")
        return new Double(NaN);
      if (value === "Infinity")
        return new Double(Infinity);
      if (value === "-Infinity")
        return new Double(-Infinity);
      if (!Number.isFinite(coercedValue)) {
        throw new BSONError(`Input: ${value} is not representable as a Double`);
      }
      if (value.trim() !== value) {
        throw new BSONError(`Input: '${value}' contains whitespace`);
      }
      if (value === "") {
        throw new BSONError(`Input is an empty string`);
      }
      if (/[^-0-9.+eE]/.test(value)) {
        throw new BSONError(`Input: '${value}' is not in decimal or exponential notation`);
      }
      return new Double(coercedValue);
    }
    valueOf() {
      return this.value;
    }
    toJSON() {
      return this.value;
    }
    toString(radix) {
      return this.value.toString(radix);
    }
    toExtendedJSON(options) {
      if (options && (options.legacy || options.relaxed && isFinite(this.value))) {
        return this.value;
      }
      if (Object.is(Math.sign(this.value), -0)) {
        return { $numberDouble: "-0.0" };
      }
      return {
        $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()
      };
    }
    static fromExtendedJSON(doc, options) {
      const doubleValue = parseFloat(doc.$numberDouble);
      return options && options.relaxed ? doubleValue : new Double(doubleValue);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      return `new Double(${inspect(this.value, options)})`;
    }
  }

  class Int32 extends BSONValue {
    get _bsontype() {
      return "Int32";
    }
    constructor(value) {
      super();
      if (value instanceof Number) {
        value = value.valueOf();
      }
      this.value = +value | 0;
    }
    static fromString(value) {
      const cleanedValue = removeLeadingZerosAndExplicitPlus(value);
      const coercedValue = Number(value);
      if (BSON_INT32_MAX < coercedValue) {
        throw new BSONError(`Input: '${value}' is larger than the maximum value for Int32`);
      } else if (BSON_INT32_MIN > coercedValue) {
        throw new BSONError(`Input: '${value}' is smaller than the minimum value for Int32`);
      } else if (!Number.isSafeInteger(coercedValue)) {
        throw new BSONError(`Input: '${value}' is not a safe integer`);
      } else if (coercedValue.toString() !== cleanedValue) {
        throw new BSONError(`Input: '${value}' is not a valid Int32 string`);
      }
      return new Int32(coercedValue);
    }
    valueOf() {
      return this.value;
    }
    toString(radix) {
      return this.value.toString(radix);
    }
    toJSON() {
      return this.value;
    }
    toExtendedJSON(options) {
      if (options && (options.relaxed || options.legacy))
        return this.value;
      return { $numberInt: this.value.toString() };
    }
    static fromExtendedJSON(doc, options) {
      return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int32(doc.$numberInt);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      return `new Int32(${inspect(this.value, options)})`;
    }
  }

  class MaxKey extends BSONValue {
    get _bsontype() {
      return "MaxKey";
    }
    toExtendedJSON() {
      return { $maxKey: 1 };
    }
    static fromExtendedJSON() {
      return new MaxKey;
    }
    inspect() {
      return "new MaxKey()";
    }
  }

  class MinKey extends BSONValue {
    get _bsontype() {
      return "MinKey";
    }
    toExtendedJSON() {
      return { $minKey: 1 };
    }
    static fromExtendedJSON() {
      return new MinKey;
    }
    inspect() {
      return "new MinKey()";
    }
  }
  var PROCESS_UNIQUE = null;
  var __idCache = new WeakMap;

  class ObjectId2 extends BSONValue {
    get _bsontype() {
      return "ObjectId";
    }
    constructor(inputId) {
      super();
      let workingId;
      if (typeof inputId === "object" && inputId && "id" in inputId) {
        if (typeof inputId.id !== "string" && !ArrayBuffer.isView(inputId.id)) {
          throw new BSONError("Argument passed in must have an id that is of type string or Buffer");
        }
        if ("toHexString" in inputId && typeof inputId.toHexString === "function") {
          workingId = ByteUtils.fromHex(inputId.toHexString());
        } else {
          workingId = inputId.id;
        }
      } else {
        workingId = inputId;
      }
      if (workingId == null || typeof workingId === "number") {
        this.buffer = ObjectId2.generate(typeof workingId === "number" ? workingId : undefined);
      } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {
        this.buffer = ByteUtils.toLocalBufferType(workingId);
      } else if (typeof workingId === "string") {
        if (ObjectId2.validateHexString(workingId)) {
          this.buffer = ByteUtils.fromHex(workingId);
          if (ObjectId2.cacheHexString) {
            __idCache.set(this, workingId);
          }
        } else {
          throw new BSONError("input must be a 24 character hex string, 12 byte Uint8Array, or an integer");
        }
      } else {
        throw new BSONError("Argument passed in does not match the accepted types");
      }
    }
    get id() {
      return this.buffer;
    }
    set id(value) {
      this.buffer = value;
      if (ObjectId2.cacheHexString) {
        __idCache.set(this, ByteUtils.toHex(value));
      }
    }
    static validateHexString(string) {
      if (string?.length !== 24)
        return false;
      for (let i = 0;i < 24; i++) {
        const char = string.charCodeAt(i);
        if (char >= 48 && char <= 57 || char >= 97 && char <= 102 || char >= 65 && char <= 70) {
          continue;
        }
        return false;
      }
      return true;
    }
    toHexString() {
      if (ObjectId2.cacheHexString) {
        const __id = __idCache.get(this);
        if (__id)
          return __id;
      }
      const hexString = ByteUtils.toHex(this.id);
      if (ObjectId2.cacheHexString) {
        __idCache.set(this, hexString);
      }
      return hexString;
    }
    static getInc() {
      return ObjectId2.index = (ObjectId2.index + 1) % 16777215;
    }
    static generate(time2) {
      if (typeof time2 !== "number") {
        time2 = Math.floor(Date.now() / 1000);
      }
      const inc = ObjectId2.getInc();
      const buffer2 = ByteUtils.allocateUnsafe(12);
      NumberUtils.setInt32BE(buffer2, 0, time2);
      if (PROCESS_UNIQUE === null) {
        PROCESS_UNIQUE = ByteUtils.randomBytes(5);
      }
      buffer2[4] = PROCESS_UNIQUE[0];
      buffer2[5] = PROCESS_UNIQUE[1];
      buffer2[6] = PROCESS_UNIQUE[2];
      buffer2[7] = PROCESS_UNIQUE[3];
      buffer2[8] = PROCESS_UNIQUE[4];
      buffer2[11] = inc & 255;
      buffer2[10] = inc >> 8 & 255;
      buffer2[9] = inc >> 16 & 255;
      return buffer2;
    }
    toString(encoding) {
      if (encoding === "base64")
        return ByteUtils.toBase64(this.id);
      if (encoding === "hex")
        return this.toHexString();
      return this.toHexString();
    }
    toJSON() {
      return this.toHexString();
    }
    static is(variable) {
      return variable != null && typeof variable === "object" && "_bsontype" in variable && variable._bsontype === "ObjectId";
    }
    equals(otherId) {
      if (otherId === undefined || otherId === null) {
        return false;
      }
      if (ObjectId2.is(otherId)) {
        return this.buffer[11] === otherId.buffer[11] && ByteUtils.equals(this.buffer, otherId.buffer);
      }
      if (typeof otherId === "string") {
        return otherId.toLowerCase() === this.toHexString();
      }
      if (typeof otherId === "object" && typeof otherId.toHexString === "function") {
        const otherIdString = otherId.toHexString();
        const thisIdString = this.toHexString();
        return typeof otherIdString === "string" && otherIdString.toLowerCase() === thisIdString;
      }
      return false;
    }
    getTimestamp() {
      const timestamp = new Date;
      const time2 = NumberUtils.getUint32BE(this.buffer, 0);
      timestamp.setTime(Math.floor(time2) * 1000);
      return timestamp;
    }
    static createPk() {
      return new ObjectId2;
    }
    serializeInto(uint8array, index) {
      uint8array[index] = this.buffer[0];
      uint8array[index + 1] = this.buffer[1];
      uint8array[index + 2] = this.buffer[2];
      uint8array[index + 3] = this.buffer[3];
      uint8array[index + 4] = this.buffer[4];
      uint8array[index + 5] = this.buffer[5];
      uint8array[index + 6] = this.buffer[6];
      uint8array[index + 7] = this.buffer[7];
      uint8array[index + 8] = this.buffer[8];
      uint8array[index + 9] = this.buffer[9];
      uint8array[index + 10] = this.buffer[10];
      uint8array[index + 11] = this.buffer[11];
      return 12;
    }
    static createFromTime(time2) {
      const buffer2 = ByteUtils.allocate(12);
      for (let i = 11;i >= 4; i--)
        buffer2[i] = 0;
      NumberUtils.setInt32BE(buffer2, 0, time2);
      return new ObjectId2(buffer2);
    }
    static createFromHexString(hexString) {
      if (hexString?.length !== 24) {
        throw new BSONError("hex string must be 24 characters");
      }
      return new ObjectId2(ByteUtils.fromHex(hexString));
    }
    static createFromBase64(base64) {
      if (base64?.length !== 16) {
        throw new BSONError("base64 string must be 16 characters");
      }
      return new ObjectId2(ByteUtils.fromBase64(base64));
    }
    static isValid(id) {
      if (id == null)
        return false;
      if (typeof id === "string")
        return ObjectId2.validateHexString(id);
      try {
        new ObjectId2(id);
        return true;
      } catch {
        return false;
      }
    }
    toExtendedJSON() {
      if (this.toHexString)
        return { $oid: this.toHexString() };
      return { $oid: this.toString("hex") };
    }
    static fromExtendedJSON(doc) {
      return new ObjectId2(doc.$oid);
    }
    isCached() {
      return ObjectId2.cacheHexString && __idCache.has(this);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      return `new ObjectId(${inspect(this.toHexString(), options)})`;
    }
  }
  ObjectId2.index = Math.floor(Math.random() * 16777215);

  class BSONRegExp extends BSONValue {
    get _bsontype() {
      return "BSONRegExp";
    }
    constructor(pattern, options) {
      super();
      this.pattern = pattern;
      this.options = alphabetize(options ?? "");
      if (this.pattern.indexOf("\0") !== -1) {
        throw new BSONError(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);
      }
      if (this.options.indexOf("\0") !== -1) {
        throw new BSONError(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);
      }
      for (let i = 0;i < this.options.length; i++) {
        if (!(this.options[i] === "i" || this.options[i] === "m" || this.options[i] === "x" || this.options[i] === "l" || this.options[i] === "s" || this.options[i] === "u")) {
          throw new BSONError(`The regular expression option [${this.options[i]}] is not supported`);
        }
      }
    }
    static parseOptions(options) {
      return options ? options.split("").sort().join("") : "";
    }
    toExtendedJSON(options) {
      options = options || {};
      if (options.legacy) {
        return { $regex: this.pattern, $options: this.options };
      }
      return { $regularExpression: { pattern: this.pattern, options: this.options } };
    }
    static fromExtendedJSON(doc) {
      if ("$regex" in doc) {
        if (typeof doc.$regex !== "string") {
          if (doc.$regex._bsontype === "BSONRegExp") {
            return doc;
          }
        } else {
          return new BSONRegExp(doc.$regex, BSONRegExp.parseOptions(doc.$options));
        }
      }
      if ("$regularExpression" in doc) {
        return new BSONRegExp(doc.$regularExpression.pattern, BSONRegExp.parseOptions(doc.$regularExpression.options));
      }
      throw new BSONError(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(doc)}`);
    }
    inspect(depth, options, inspect) {
      const stylize = getStylizeFunction(options) ?? ((v) => v);
      inspect ??= defaultInspect;
      const pattern = stylize(inspect(this.pattern), "regexp");
      const flags = stylize(inspect(this.options), "regexp");
      return `new BSONRegExp(${pattern}, ${flags})`;
    }
  }

  class BSONSymbol extends BSONValue {
    get _bsontype() {
      return "BSONSymbol";
    }
    constructor(value) {
      super();
      this.value = value;
    }
    valueOf() {
      return this.value;
    }
    toString() {
      return this.value;
    }
    toJSON() {
      return this.value;
    }
    toExtendedJSON() {
      return { $symbol: this.value };
    }
    static fromExtendedJSON(doc) {
      return new BSONSymbol(doc.$symbol);
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      return `new BSONSymbol(${inspect(this.value, options)})`;
    }
  }
  var LongWithoutOverridesClass = Long;

  class Timestamp extends LongWithoutOverridesClass {
    get _bsontype() {
      return "Timestamp";
    }
    get i() {
      return this.low >>> 0;
    }
    get t() {
      return this.high >>> 0;
    }
    constructor(low) {
      if (low == null) {
        super(0, 0, true);
      } else if (typeof low === "bigint") {
        super(low, true);
      } else if (Long.isLong(low)) {
        super(low.low, low.high, true);
      } else if (typeof low === "object" && "t" in low && "i" in low) {
        if (typeof low.t !== "number" && (typeof low.t !== "object" || low.t._bsontype !== "Int32")) {
          throw new BSONError("Timestamp constructed from { t, i } must provide t as a number");
        }
        if (typeof low.i !== "number" && (typeof low.i !== "object" || low.i._bsontype !== "Int32")) {
          throw new BSONError("Timestamp constructed from { t, i } must provide i as a number");
        }
        const t = Number(low.t);
        const i = Number(low.i);
        if (t < 0 || Number.isNaN(t)) {
          throw new BSONError("Timestamp constructed from { t, i } must provide a positive t");
        }
        if (i < 0 || Number.isNaN(i)) {
          throw new BSONError("Timestamp constructed from { t, i } must provide a positive i");
        }
        if (t > 4294967295) {
          throw new BSONError("Timestamp constructed from { t, i } must provide t equal or less than uint32 max");
        }
        if (i > 4294967295) {
          throw new BSONError("Timestamp constructed from { t, i } must provide i equal or less than uint32 max");
        }
        super(i, t, true);
      } else {
        throw new BSONError("A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }");
      }
    }
    toJSON() {
      return {
        $timestamp: this.toString()
      };
    }
    static fromInt(value) {
      return new Timestamp(Long.fromInt(value, true));
    }
    static fromNumber(value) {
      return new Timestamp(Long.fromNumber(value, true));
    }
    static fromBits(lowBits, highBits) {
      return new Timestamp({ i: lowBits, t: highBits });
    }
    static fromString(str, optRadix) {
      return new Timestamp(Long.fromString(str, true, optRadix));
    }
    toExtendedJSON() {
      return { $timestamp: { t: this.t, i: this.i } };
    }
    static fromExtendedJSON(doc) {
      const i = Long.isLong(doc.$timestamp.i) ? doc.$timestamp.i.getLowBitsUnsigned() : doc.$timestamp.i;
      const t = Long.isLong(doc.$timestamp.t) ? doc.$timestamp.t.getLowBitsUnsigned() : doc.$timestamp.t;
      return new Timestamp({ t, i });
    }
    inspect(depth, options, inspect) {
      inspect ??= defaultInspect;
      const t = inspect(this.t, options);
      const i = inspect(this.i, options);
      return `new Timestamp({ t: ${t}, i: ${i} })`;
    }
  }
  Timestamp.MAX_VALUE = Long.MAX_UNSIGNED_VALUE;
  var JS_INT_MAX_LONG = Long.fromNumber(JS_INT_MAX);
  var JS_INT_MIN_LONG = Long.fromNumber(JS_INT_MIN);
  var allowedDBRefKeys = /^\$ref$|^\$id$|^\$db$/;
  var regexp = /\x00/;
  var ignoreKeys = new Set(["$db", "$ref", "$id", "$clusterTime"]);
  var keysToCodecs = {
    $oid: ObjectId2,
    $binary: Binary,
    $uuid: Binary,
    $symbol: BSONSymbol,
    $numberInt: Int32,
    $numberDecimal: Decimal128,
    $numberDouble: Double,
    $numberLong: Long,
    $minKey: MinKey,
    $maxKey: MaxKey,
    $regex: BSONRegExp,
    $regularExpression: BSONRegExp,
    $timestamp: Timestamp
  };
  var BSON_TYPE_MAPPINGS = {
    Binary: (o) => new Binary(o.value(), o.sub_type),
    Code: (o) => new Code(o.code, o.scope),
    DBRef: (o) => new DBRef(o.collection || o.namespace, o.oid, o.db, o.fields),
    Decimal128: (o) => new Decimal128(o.bytes),
    Double: (o) => new Double(o.value),
    Int32: (o) => new Int32(o.value),
    Long: (o) => Long.fromBits(o.low != null ? o.low : o.low_, o.low != null ? o.high : o.high_, o.low != null ? o.unsigned : o.unsigned_),
    MaxKey: () => new MaxKey,
    MinKey: () => new MinKey,
    ObjectId: (o) => new ObjectId2(o),
    BSONRegExp: (o) => new BSONRegExp(o.pattern, o.options),
    BSONSymbol: (o) => new BSONSymbol(o.value),
    Timestamp: (o) => Timestamp.fromBits(o.low, o.high)
  };
  var EJSON = Object.create(null);
  EJSON.parse = parse;
  EJSON.stringify = stringify;
  EJSON.serialize = EJSONserialize;
  EJSON.deserialize = EJSONdeserialize;
  Object.freeze(EJSON);
  var onDemand = Object.create(null);
  onDemand.parseToElements = parseToElements;
  onDemand.ByteUtils = ByteUtils;
  onDemand.NumberUtils = NumberUtils;
  Object.freeze(onDemand);
  var MAXSIZE = 1024 * 1024 * 17;
  var buffer = ByteUtils.allocate(MAXSIZE);
  var bson = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    BSONError,
    BSONOffsetError,
    BSONRegExp,
    BSONRuntimeError,
    BSONSymbol,
    BSONType,
    BSONValue,
    BSONVersionError,
    Binary,
    Code,
    DBRef,
    Decimal128,
    Double,
    EJSON,
    Int32,
    Long,
    MaxKey,
    MinKey,
    ObjectId: ObjectId2,
    Timestamp,
    UUID,
    calculateObjectSize,
    deserialize,
    deserializeStream,
    onDemand,
    serialize,
    serializeWithBufferAndIndex,
    setInternalBufferSize
  });
  exports.BSON = bson;
  exports.BSONError = BSONError;
  exports.BSONOffsetError = BSONOffsetError;
  exports.BSONRegExp = BSONRegExp;
  exports.BSONRuntimeError = BSONRuntimeError;
  exports.BSONSymbol = BSONSymbol;
  exports.BSONType = BSONType;
  exports.BSONValue = BSONValue;
  exports.BSONVersionError = BSONVersionError;
  exports.Binary = Binary;
  exports.Code = Code;
  exports.DBRef = DBRef;
  exports.Decimal128 = Decimal128;
  exports.Double = Double;
  exports.EJSON = EJSON;
  exports.Int32 = Int32;
  exports.Long = Long;
  exports.MaxKey = MaxKey;
  exports.MinKey = MinKey;
  exports.ObjectId = ObjectId2;
  exports.Timestamp = Timestamp;
  exports.UUID = UUID;
  exports.calculateObjectSize = calculateObjectSize;
  exports.deserialize = deserialize;
  exports.deserializeStream = deserializeStream;
  exports.onDemand = onDemand;
  exports.serialize = serialize;
  exports.serializeWithBufferAndIndex = serializeWithBufferAndIndex;
  exports.setInternalBufferSize = setInternalBufferSize;
});

// node_modules/mongoose/lib/types/decimal128.js
var require_decimal128 = __commonJS((exports, module) => {
  module.exports = require_bson().Decimal128;
});

// node_modules/mongoose/lib/helpers/symbols.js
var require_symbols = __commonJS((exports) => {
  exports.arrayAtomicsBackupSymbol = Symbol("mongoose#Array#atomicsBackup");
  exports.arrayAtomicsSymbol = Symbol("mongoose#Array#_atomics");
  exports.arrayParentSymbol = Symbol("mongoose#Array#_parent");
  exports.arrayPathSymbol = Symbol("mongoose#Array#_path");
  exports.arraySchemaSymbol = Symbol("mongoose#Array#_schema");
  exports.documentArrayParent = Symbol("mongoose#documentArrayParent");
  exports.documentIsSelected = Symbol("mongoose#Document#isSelected");
  exports.documentIsModified = Symbol("mongoose#Document#isModified");
  exports.documentModifiedPaths = Symbol("mongoose#Document#modifiedPaths");
  exports.documentSchemaSymbol = Symbol("mongoose#Document#schema");
  exports.getSymbol = Symbol("mongoose#Document#get");
  exports.modelSymbol = Symbol("mongoose#Model");
  exports.objectIdSymbol = Symbol("mongoose#ObjectId");
  exports.populateModelSymbol = Symbol("mongoose#PopulateOptions#Model");
  exports.schemaTypeSymbol = Symbol("mongoose#schemaType");
  exports.sessionNewDocuments = Symbol("mongoose#ClientSession#newDocuments");
  exports.scopeSymbol = Symbol("mongoose#Document#scope");
  exports.validatorErrorSymbol = Symbol("mongoose#validatorError");
});

// node_modules/mongoose/lib/types/objectid.js
var require_objectid = __commonJS((exports, module) => {
  var ObjectId2 = require_bson().ObjectId;
  var objectIdSymbol = require_symbols().objectIdSymbol;
  Object.defineProperty(ObjectId2.prototype, "_id", {
    enumerable: false,
    configurable: true,
    get: function() {
      return this;
    }
  });
  /*!
   * Convenience `valueOf()` to allow comparing ObjectIds using double equals re: gh-7299
   */
  if (!ObjectId2.prototype.hasOwnProperty("valueOf")) {
    ObjectId2.prototype.valueOf = function objectIdValueOf() {
      return this.toString();
    };
  }
  ObjectId2.prototype[objectIdSymbol] = true;
  module.exports = ObjectId2;
});

// node_modules/mongoose/lib/helpers/specialProperties.js
var require_specialProperties = __commonJS((exports, module) => {
  module.exports = new Set(["__proto__", "constructor", "prototype"]);
});

// node_modules/mongoose/lib/types/array/isMongooseArray.js
var require_isMongooseArray = __commonJS((exports) => {
  exports.isMongooseArray = function(mongooseArray) {
    return Array.isArray(mongooseArray) && mongooseArray.isMongooseArray;
  };
});

// node_modules/mongoose/lib/helpers/isMongooseObject.js
var require_isMongooseObject = __commonJS((exports, module) => {
  var isMongooseArray = require_isMongooseArray().isMongooseArray;
  module.exports = function(v) {
    return v != null && (isMongooseArray(v) || v.$__ != null || v.isMongooseBuffer || v.$isMongooseMap);
  };
});

// node_modules/mongoose/lib/helpers/getFunctionName.js
var require_getFunctionName = __commonJS((exports, module) => {
  var functionNameRE = /^function\s*([^\s(]+)/;
  module.exports = function(fn) {
    return fn.name || (fn.toString().trim().match(functionNameRE) || [])[1];
  };
});

// node_modules/mongoose/lib/helpers/isBsonType.js
var require_isBsonType = __commonJS((exports, module) => {
  function isBsonType(obj, typename) {
    return obj != null && obj._bsontype === typename;
  }
  module.exports = isBsonType;
});

// node_modules/mongoose/lib/helpers/isObject.js
var require_isObject2 = __commonJS((exports, module) => {
  module.exports = function(arg) {
    return Buffer.isBuffer(arg) || Object.prototype.toString.call(arg) === "[object Object]";
  };
});

// node_modules/mongoose/lib/helpers/isPOJO.js
var require_isPOJO = __commonJS((exports, module) => {
  module.exports = function isPOJO(arg) {
    if (arg == null || typeof arg !== "object") {
      return false;
    }
    const proto = Object.getPrototypeOf(arg);
    return !proto || proto.constructor.name === "Object";
  };
});

// node_modules/mongoose/lib/helpers/query/trusted.js
var require_trusted = __commonJS((exports) => {
  var trustedSymbol = Symbol("mongoose#trustedSymbol");
  exports.trustedSymbol = trustedSymbol;
  exports.trusted = function trusted(obj) {
    if (obj == null || typeof obj !== "object") {
      return obj;
    }
    obj[trustedSymbol] = true;
    return obj;
  };
});

// node_modules/mongoose/lib/helpers/clone.js
var require_clone2 = __commonJS((exports, module) => {
  function clone(obj, options, isArrayChild) {
    if (obj == null) {
      return obj;
    }
    if (isBsonType(obj, "Double")) {
      return new BSON.Double(obj.value);
    }
    if (typeof obj === "number" || typeof obj === "string" || typeof obj === "boolean" || typeof obj === "bigint") {
      return obj;
    }
    if (Array.isArray(obj)) {
      return cloneArray(isMongooseArray(obj) ? obj.__array : obj, options);
    }
    if (isMongooseObject(obj)) {
      if (options) {
        if (options.retainDocuments && obj.$__ != null) {
          const clonedDoc = obj.$clone();
          if (obj.__index != null) {
            clonedDoc.__index = obj.__index;
          }
          if (obj.__parentArray != null) {
            clonedDoc.__parentArray = obj.__parentArray;
          }
          clonedDoc.$__parent = obj.$__parent;
          return clonedDoc;
        }
      }
      const isSingleNested = obj.$isSingleNested;
      if (isPOJO(obj) && obj.$__ != null && obj._doc != null) {
        return obj._doc;
      }
      let ret;
      if (options && options.json && typeof obj.toJSON === "function") {
        ret = obj.toJSON(options);
      } else {
        ret = obj.toObject(options);
      }
      if (options && options.minimize && !obj.constructor.$__required && isSingleNested && Object.keys(ret).length === 0) {
        return;
      }
      return ret;
    }
    const objConstructor = obj.constructor;
    if (objConstructor) {
      switch (getFunctionName(objConstructor)) {
        case "Object":
          return cloneObject(obj, options, isArrayChild);
        case "Date":
          return new objConstructor(+obj);
        case "RegExp":
          return cloneRegExp(obj);
        default:
          break;
      }
    }
    if (isBsonType(obj, "ObjectId")) {
      if (options && options.flattenObjectIds) {
        return obj.toJSON();
      }
      return new ObjectId2(obj.id);
    }
    if (isBsonType(obj, "Decimal128")) {
      if (options && options.flattenDecimals) {
        return obj.toJSON();
      }
      return Decimal.fromString(obj.toString());
    }
    if (!objConstructor && isObject(obj)) {
      return cloneObject(obj, options, isArrayChild);
    }
    if (typeof obj === "object" && obj[symbols.schemaTypeSymbol]) {
      return obj.clone();
    }
    if (options && options.bson && typeof obj.toBSON === "function") {
      return obj;
    }
    if (typeof obj.valueOf === "function") {
      return obj.valueOf();
    }
    return cloneObject(obj, options, isArrayChild);
  }
  function cloneObject(obj, options, isArrayChild) {
    const minimize = options && options.minimize;
    const omitUndefined = options && options.omitUndefined;
    const seen = options && options._seen;
    const ret = {};
    let hasKeys;
    if (seen && seen.has(obj)) {
      return seen.get(obj);
    } else if (seen) {
      seen.set(obj, ret);
    }
    if (trustedSymbol in obj) {
      ret[trustedSymbol] = obj[trustedSymbol];
    }
    const keys = Object.keys(obj);
    const len = keys.length;
    for (let i = 0;i < len; ++i) {
      const key = keys[i];
      if (specialProperties.has(key)) {
        continue;
      }
      const val = clone(obj[key], options, false);
      if ((minimize === false || omitUndefined) && typeof val === "undefined") {
        delete ret[key];
      } else if (minimize !== true || typeof val !== "undefined") {
        hasKeys || (hasKeys = true);
        ret[key] = val;
      }
    }
    return minimize && !isArrayChild ? hasKeys && ret : ret;
  }
  function cloneArray(arr, options) {
    let i = 0;
    const len = arr.length;
    const ret = new Array(len);
    for (i = 0;i < len; ++i) {
      ret[i] = clone(arr[i], options, true);
    }
    return ret;
  }
  function cloneRegExp(regexp) {
    const ret = new RegExp(regexp.source, regexp.flags);
    if (ret.lastIndex !== regexp.lastIndex) {
      ret.lastIndex = regexp.lastIndex;
    }
    return ret;
  }
  var Decimal = require_decimal128();
  var ObjectId2 = require_objectid();
  var specialProperties = require_specialProperties();
  var isMongooseObject = require_isMongooseObject();
  var getFunctionName = require_getFunctionName();
  var isBsonType = require_isBsonType();
  var isMongooseArray = require_isMongooseArray().isMongooseArray;
  var isObject = require_isObject2();
  var isPOJO = require_isPOJO();
  var symbols = require_symbols();
  var trustedSymbol = require_trusted().trustedSymbol;
  var BSON = require_bson();
  module.exports = clone;
  /*!
   * ignore
   */
});

// node_modules/mongoose/lib/connectionState.js
var require_connectionState = __commonJS((exports, module) => {
  /*!
   * Connection states
   */
  var STATES = module.exports = exports = Object.create(null);
  var disconnected = "disconnected";
  var connected = "connected";
  var connecting = "connecting";
  var disconnecting = "disconnecting";
  var uninitialized = "uninitialized";
  STATES[0] = disconnected;
  STATES[1] = connected;
  STATES[2] = connecting;
  STATES[3] = disconnecting;
  STATES[99] = uninitialized;
  STATES[disconnected] = 0;
  STATES[connected] = 1;
  STATES[connecting] = 2;
  STATES[disconnecting] = 3;
  STATES[uninitialized] = 99;
});

// node_modules/mongoose/lib/helpers/immediate.js
var require_immediate = __commonJS((exports, module) => {
  /*!
   * Centralize this so we can more easily work around issues with people
   * stubbing out `process.nextTick()` in tests using sinon:
   * https://github.com/sinonjs/lolex#automatically-incrementing-mocked-time
   * See gh-6074
   */
  var nextTick = typeof process !== "undefined" && typeof process.nextTick === "function" ? process.nextTick.bind(process) : (cb) => setTimeout(cb, 0);
  module.exports = function immediate(cb) {
    return nextTick(cb);
  };
});

// node_modules/mongoose/lib/collection.js
var require_collection = __commonJS((exports, module) => {
  function Collection(name, conn, opts) {
    if (opts === undefined) {
      opts = {};
    }
    this.opts = opts;
    this.name = name;
    this.collectionName = name;
    this.conn = conn;
    this.queue = [];
    this.buffer = !conn?._hasOpened;
    this.emitter = new EventEmitter;
    if (STATES.connected === this.conn.readyState) {
      this.onOpen();
    }
  }
  /*!
   * Module dependencies.
   */
  var EventEmitter = import.meta.require("events").EventEmitter;
  var STATES = require_connectionState();
  var immediate = require_immediate();
  Collection.prototype.name;
  Collection.prototype.collectionName;
  Collection.prototype.conn;
  Collection.prototype.onOpen = function() {
    this.buffer = false;
    immediate(() => this.doQueue());
  };
  Collection.prototype.onClose = function() {
  };
  Collection.prototype.addQueue = function(name, args) {
    this.queue.push([name, args]);
    return this;
  };
  Collection.prototype.removeQueue = function(name, args) {
    const index = this.queue.findIndex((v) => v[0] === name && v[1] === args);
    if (index === -1) {
      return false;
    }
    this.queue.splice(index, 1);
    return true;
  };
  Collection.prototype.doQueue = function() {
    for (const method of this.queue) {
      if (typeof method[0] === "function") {
        method[0].apply(this, method[1]);
      } else {
        this[method[0]].apply(this, method[1]);
      }
    }
    this.queue = [];
    const _this = this;
    immediate(function() {
      _this.emitter.emit("queue");
    });
    return this;
  };
  Collection.prototype.ensureIndex = function() {
    throw new Error("Collection#ensureIndex unimplemented by driver");
  };
  Collection.prototype.createIndex = function() {
    throw new Error("Collection#createIndex unimplemented by driver");
  };
  Collection.prototype.findAndModify = function() {
    throw new Error("Collection#findAndModify unimplemented by driver");
  };
  Collection.prototype.findOneAndUpdate = function() {
    throw new Error("Collection#findOneAndUpdate unimplemented by driver");
  };
  Collection.prototype.findOneAndDelete = function() {
    throw new Error("Collection#findOneAndDelete unimplemented by driver");
  };
  Collection.prototype.findOneAndReplace = function() {
    throw new Error("Collection#findOneAndReplace unimplemented by driver");
  };
  Collection.prototype.findOne = function() {
    throw new Error("Collection#findOne unimplemented by driver");
  };
  Collection.prototype.find = function() {
    throw new Error("Collection#find unimplemented by driver");
  };
  Collection.prototype.insert = function() {
    throw new Error("Collection#insert unimplemented by driver");
  };
  Collection.prototype.insertOne = function() {
    throw new Error("Collection#insertOne unimplemented by driver");
  };
  Collection.prototype.insertMany = function() {
    throw new Error("Collection#insertMany unimplemented by driver");
  };
  Collection.prototype.save = function() {
    throw new Error("Collection#save unimplemented by driver");
  };
  Collection.prototype.updateOne = function() {
    throw new Error("Collection#updateOne unimplemented by driver");
  };
  Collection.prototype.updateMany = function() {
    throw new Error("Collection#updateMany unimplemented by driver");
  };
  Collection.prototype.deleteOne = function() {
    throw new Error("Collection#deleteOne unimplemented by driver");
  };
  Collection.prototype.deleteMany = function() {
    throw new Error("Collection#deleteMany unimplemented by driver");
  };
  Collection.prototype.getIndexes = function() {
    throw new Error("Collection#getIndexes unimplemented by driver");
  };
  Collection.prototype.watch = function() {
    throw new Error("Collection#watch unimplemented by driver");
  };
  /*!
   * ignore
   */
  Collection.prototype._shouldBufferCommands = function _shouldBufferCommands() {
    const opts = this.opts;
    if (opts.bufferCommands != null) {
      return opts.bufferCommands;
    }
    if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferCommands != null) {
      return opts.schemaUserProvidedOptions.bufferCommands;
    }
    return this.conn._shouldBufferCommands();
  };
  /*!
   * ignore
   */
  Collection.prototype._getBufferTimeoutMS = function _getBufferTimeoutMS() {
    const conn = this.conn;
    const opts = this.opts;
    if (opts.bufferTimeoutMS != null) {
      return opts.bufferTimeoutMS;
    }
    if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferTimeoutMS != null) {
      return opts.schemaUserProvidedOptions.bufferTimeoutMS;
    }
    return conn._getBufferTimeoutMS();
  };
  /*!
   * Module exports.
   */
  module.exports = Collection;
});

// node_modules/mongoose/lib/error/mongooseError.js
var require_mongooseError = __commonJS((exports, module) => {
  /*!
   * ignore
   */

  class MongooseError extends Error {
  }
  Object.defineProperty(MongooseError.prototype, "name", {
    value: "MongooseError"
  });
  module.exports = MongooseError;
});

// node_modules/mongodb/lib/bson.js
var require_bson2 = __commonJS((exports) => {
  function parseToElementsToArray(bytes, offset) {
    const res = bson_1.BSON.onDemand.parseToElements(bytes, offset);
    return Array.isArray(res) ? res : [...res];
  }
  function pluckBSONSerializeOptions(options) {
    const { fieldsAsRaw, useBigInt64, promoteValues, promoteBuffers, promoteLongs, serializeFunctions, ignoreUndefined, bsonRegExp, raw: raw2, enableUtf8Validation } = options;
    return {
      fieldsAsRaw,
      useBigInt64,
      promoteValues,
      promoteBuffers,
      promoteLongs,
      serializeFunctions,
      ignoreUndefined,
      bsonRegExp,
      raw: raw2,
      enableUtf8Validation
    };
  }
  function resolveBSONOptions(options, parent) {
    const parentOptions = parent?.bsonOptions;
    return {
      raw: options?.raw ?? parentOptions?.raw ?? false,
      useBigInt64: options?.useBigInt64 ?? parentOptions?.useBigInt64 ?? false,
      promoteLongs: options?.promoteLongs ?? parentOptions?.promoteLongs ?? true,
      promoteValues: options?.promoteValues ?? parentOptions?.promoteValues ?? true,
      promoteBuffers: options?.promoteBuffers ?? parentOptions?.promoteBuffers ?? false,
      ignoreUndefined: options?.ignoreUndefined ?? parentOptions?.ignoreUndefined ?? false,
      bsonRegExp: options?.bsonRegExp ?? parentOptions?.bsonRegExp ?? false,
      serializeFunctions: options?.serializeFunctions ?? parentOptions?.serializeFunctions ?? false,
      fieldsAsRaw: options?.fieldsAsRaw ?? parentOptions?.fieldsAsRaw ?? {},
      enableUtf8Validation: options?.enableUtf8Validation ?? parentOptions?.enableUtf8Validation ?? true
    };
  }
  function parseUtf8ValidationOption(options) {
    const enableUtf8Validation = options?.enableUtf8Validation;
    if (enableUtf8Validation === false) {
      return { utf8: false };
    }
    return { utf8: { writeErrors: false } };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toUTF8 = exports.getBigInt64LE = exports.getFloat64LE = exports.getInt32LE = exports.UUID = exports.Timestamp = exports.serialize = exports.ObjectId = exports.MinKey = exports.MaxKey = exports.Long = exports.Int32 = exports.EJSON = exports.Double = exports.deserialize = exports.Decimal128 = exports.DBRef = exports.Code = exports.calculateObjectSize = exports.BSONType = exports.BSONSymbol = exports.BSONRegExp = exports.BSONError = exports.BSON = exports.Binary = undefined;
  exports.parseToElementsToArray = parseToElementsToArray;
  exports.pluckBSONSerializeOptions = pluckBSONSerializeOptions;
  exports.resolveBSONOptions = resolveBSONOptions;
  exports.parseUtf8ValidationOption = parseUtf8ValidationOption;
  var bson_1 = require_bson();
  var bson_2 = require_bson();
  Object.defineProperty(exports, "Binary", { enumerable: true, get: function() {
    return bson_2.Binary;
  } });
  Object.defineProperty(exports, "BSON", { enumerable: true, get: function() {
    return bson_2.BSON;
  } });
  Object.defineProperty(exports, "BSONError", { enumerable: true, get: function() {
    return bson_2.BSONError;
  } });
  Object.defineProperty(exports, "BSONRegExp", { enumerable: true, get: function() {
    return bson_2.BSONRegExp;
  } });
  Object.defineProperty(exports, "BSONSymbol", { enumerable: true, get: function() {
    return bson_2.BSONSymbol;
  } });
  Object.defineProperty(exports, "BSONType", { enumerable: true, get: function() {
    return bson_2.BSONType;
  } });
  Object.defineProperty(exports, "calculateObjectSize", { enumerable: true, get: function() {
    return bson_2.calculateObjectSize;
  } });
  Object.defineProperty(exports, "Code", { enumerable: true, get: function() {
    return bson_2.Code;
  } });
  Object.defineProperty(exports, "DBRef", { enumerable: true, get: function() {
    return bson_2.DBRef;
  } });
  Object.defineProperty(exports, "Decimal128", { enumerable: true, get: function() {
    return bson_2.Decimal128;
  } });
  Object.defineProperty(exports, "deserialize", { enumerable: true, get: function() {
    return bson_2.deserialize;
  } });
  Object.defineProperty(exports, "Double", { enumerable: true, get: function() {
    return bson_2.Double;
  } });
  Object.defineProperty(exports, "EJSON", { enumerable: true, get: function() {
    return bson_2.EJSON;
  } });
  Object.defineProperty(exports, "Int32", { enumerable: true, get: function() {
    return bson_2.Int32;
  } });
  Object.defineProperty(exports, "Long", { enumerable: true, get: function() {
    return bson_2.Long;
  } });
  Object.defineProperty(exports, "MaxKey", { enumerable: true, get: function() {
    return bson_2.MaxKey;
  } });
  Object.defineProperty(exports, "MinKey", { enumerable: true, get: function() {
    return bson_2.MinKey;
  } });
  Object.defineProperty(exports, "ObjectId", { enumerable: true, get: function() {
    return bson_2.ObjectId;
  } });
  Object.defineProperty(exports, "serialize", { enumerable: true, get: function() {
    return bson_2.serialize;
  } });
  Object.defineProperty(exports, "Timestamp", { enumerable: true, get: function() {
    return bson_2.Timestamp;
  } });
  Object.defineProperty(exports, "UUID", { enumerable: true, get: function() {
    return bson_2.UUID;
  } });
  exports.getInt32LE = bson_1.BSON.onDemand.NumberUtils.getInt32LE;
  exports.getFloat64LE = bson_1.BSON.onDemand.NumberUtils.getFloat64LE;
  exports.getBigInt64LE = bson_1.BSON.onDemand.NumberUtils.getBigInt64LE;
  exports.toUTF8 = bson_1.BSON.onDemand.ByteUtils.toUTF8;
});

// node_modules/mongodb/lib/error.js
var require_error = __commonJS((exports) => {
  function isAggregateError(e) {
    return e != null && typeof e === "object" && "errors" in e && Array.isArray(e.errors);
  }
  function needsRetryableWriteLabel(error, maxWireVersion, serverType) {
    if (error instanceof MongoNetworkError) {
      return true;
    }
    if (error instanceof MongoError) {
      if ((maxWireVersion >= 9 || isRetryableWriteError(error)) && !error.hasErrorLabel(exports.MongoErrorLabel.HandshakeError)) {
        return false;
      }
    }
    if (error instanceof MongoWriteConcernError) {
      if (serverType === "Mongos" && maxWireVersion < 9) {
        return RETRYABLE_WRITE_ERROR_CODES.has(error.result.code ?? 0);
      }
      const code = error.result.writeConcernError.code ?? Number(error.code);
      return RETRYABLE_WRITE_ERROR_CODES.has(Number.isNaN(code) ? 0 : code);
    }
    if (error instanceof MongoError) {
      return RETRYABLE_WRITE_ERROR_CODES.has(Number(error.code));
    }
    const isNotWritablePrimaryError2 = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(error.message);
    if (isNotWritablePrimaryError2) {
      return true;
    }
    const isNodeIsRecoveringError = exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(error.message);
    if (isNodeIsRecoveringError) {
      return true;
    }
    return false;
  }
  function isRetryableWriteError(error) {
    return error.hasErrorLabel(exports.MongoErrorLabel.RetryableWriteError) || error.hasErrorLabel(exports.MongoErrorLabel.PoolRequstedRetry);
  }
  function isRetryableReadError(error) {
    const hasRetryableErrorCode = typeof error.code === "number" ? RETRYABLE_READ_ERROR_CODES.has(error.code) : false;
    if (hasRetryableErrorCode) {
      return true;
    }
    if (error instanceof MongoNetworkError) {
      return true;
    }
    const isNotWritablePrimaryError2 = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(error.message);
    if (isNotWritablePrimaryError2) {
      return true;
    }
    const isNodeIsRecoveringError = exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(error.message);
    if (isNodeIsRecoveringError) {
      return true;
    }
    return false;
  }
  function isRecoveringError(err) {
    if (typeof err.code === "number") {
      return SDAM_RECOVERING_CODES.has(err.code);
    }
    return exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE.test(err.message) || exports.NODE_IS_RECOVERING_ERROR_MESSAGE.test(err.message);
  }
  function isNotWritablePrimaryError(err) {
    if (typeof err.code === "number") {
      return SDAM_NOT_PRIMARY_CODES.has(err.code);
    }
    if (isRecoveringError(err)) {
      return false;
    }
    return exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE.test(err.message);
  }
  function isNodeShuttingDownError(err) {
    return !!(typeof err.code === "number" && SDAM_NODE_SHUTTING_DOWN_ERROR_CODES.has(err.code));
  }
  function isSDAMUnrecoverableError(error) {
    if (error instanceof MongoParseError || error == null) {
      return true;
    }
    return isRecoveringError(error) || isNotWritablePrimaryError(error);
  }
  function isNetworkTimeoutError(err) {
    return !!(err instanceof MongoNetworkError && err.message.match(/timed out/));
  }
  function isResumableError(error, wireVersion) {
    if (error == null || !(error instanceof MongoError)) {
      return false;
    }
    if (error instanceof MongoNetworkError) {
      return true;
    }
    if (wireVersion != null && wireVersion >= 9) {
      if (error.code === exports.MONGODB_ERROR_CODES.CursorNotFound) {
        return true;
      }
      return error.hasErrorLabel(exports.MongoErrorLabel.ResumableChangeStreamError);
    }
    if (typeof error.code === "number") {
      return exports.GET_MORE_RESUMABLE_CODES.has(error.code);
    }
    return false;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoWriteConcernError = exports.MongoServerSelectionError = exports.MongoSystemError = exports.MongoMissingDependencyError = exports.MongoMissingCredentialsError = exports.MongoCompatibilityError = exports.MongoInvalidArgumentError = exports.MongoParseError = exports.MongoNetworkTimeoutError = exports.MongoNetworkError = exports.MongoTopologyClosedError = exports.MongoCursorExhaustedError = exports.MongoServerClosedError = exports.MongoCursorInUseError = exports.MongoOperationTimeoutError = exports.MongoUnexpectedServerResponseError = exports.MongoGridFSChunkError = exports.MongoGridFSStreamError = exports.MongoTailableCursorError = exports.MongoChangeStreamError = exports.MongoClientBulkWriteExecutionError = exports.MongoClientBulkWriteCursorError = exports.MongoClientBulkWriteError = exports.MongoGCPError = exports.MongoAzureError = exports.MongoOIDCError = exports.MongoAWSError = exports.MongoKerberosError = exports.MongoExpiredSessionError = exports.MongoTransactionError = exports.MongoNotConnectedError = exports.MongoDecompressionError = exports.MongoBatchReExecutionError = exports.MongoStalePrimaryError = exports.MongoRuntimeError = exports.MongoAPIError = exports.MongoDriverError = exports.MongoServerError = exports.MongoError = exports.MongoErrorLabel = exports.GET_MORE_RESUMABLE_CODES = exports.MONGODB_ERROR_CODES = exports.NODE_IS_RECOVERING_ERROR_MESSAGE = exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE = exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE = undefined;
  exports.needsRetryableWriteLabel = needsRetryableWriteLabel;
  exports.isRetryableWriteError = isRetryableWriteError;
  exports.isRetryableReadError = isRetryableReadError;
  exports.isNodeShuttingDownError = isNodeShuttingDownError;
  exports.isSDAMUnrecoverableError = isSDAMUnrecoverableError;
  exports.isNetworkTimeoutError = isNetworkTimeoutError;
  exports.isResumableError = isResumableError;
  exports.LEGACY_NOT_WRITABLE_PRIMARY_ERROR_MESSAGE = new RegExp("not master", "i");
  exports.LEGACY_NOT_PRIMARY_OR_SECONDARY_ERROR_MESSAGE = new RegExp("not master or secondary", "i");
  exports.NODE_IS_RECOVERING_ERROR_MESSAGE = new RegExp("node is recovering", "i");
  exports.MONGODB_ERROR_CODES = Object.freeze({
    HostUnreachable: 6,
    HostNotFound: 7,
    AuthenticationFailed: 18,
    NetworkTimeout: 89,
    ShutdownInProgress: 91,
    PrimarySteppedDown: 189,
    ExceededTimeLimit: 262,
    SocketException: 9001,
    NotWritablePrimary: 10107,
    InterruptedAtShutdown: 11600,
    InterruptedDueToReplStateChange: 11602,
    NotPrimaryNoSecondaryOk: 13435,
    NotPrimaryOrSecondary: 13436,
    StaleShardVersion: 63,
    StaleEpoch: 150,
    StaleConfig: 13388,
    RetryChangeStream: 234,
    FailedToSatisfyReadPreference: 133,
    CursorNotFound: 43,
    LegacyNotPrimary: 10058,
    WriteConcernFailed: 64,
    NamespaceNotFound: 26,
    IllegalOperation: 20,
    MaxTimeMSExpired: 50,
    UnknownReplWriteConcern: 79,
    UnsatisfiableWriteConcern: 100,
    Reauthenticate: 391,
    ReadConcernMajorityNotAvailableYet: 134
  });
  exports.GET_MORE_RESUMABLE_CODES = new Set([
    exports.MONGODB_ERROR_CODES.HostUnreachable,
    exports.MONGODB_ERROR_CODES.HostNotFound,
    exports.MONGODB_ERROR_CODES.NetworkTimeout,
    exports.MONGODB_ERROR_CODES.ShutdownInProgress,
    exports.MONGODB_ERROR_CODES.PrimarySteppedDown,
    exports.MONGODB_ERROR_CODES.ExceededTimeLimit,
    exports.MONGODB_ERROR_CODES.SocketException,
    exports.MONGODB_ERROR_CODES.NotWritablePrimary,
    exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
    exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
    exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
    exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary,
    exports.MONGODB_ERROR_CODES.StaleShardVersion,
    exports.MONGODB_ERROR_CODES.StaleEpoch,
    exports.MONGODB_ERROR_CODES.StaleConfig,
    exports.MONGODB_ERROR_CODES.RetryChangeStream,
    exports.MONGODB_ERROR_CODES.FailedToSatisfyReadPreference,
    exports.MONGODB_ERROR_CODES.CursorNotFound
  ]);
  exports.MongoErrorLabel = Object.freeze({
    RetryableWriteError: "RetryableWriteError",
    TransientTransactionError: "TransientTransactionError",
    UnknownTransactionCommitResult: "UnknownTransactionCommitResult",
    ResumableChangeStreamError: "ResumableChangeStreamError",
    HandshakeError: "HandshakeError",
    ResetPool: "ResetPool",
    PoolRequstedRetry: "PoolRequstedRetry",
    InterruptInUseConnections: "InterruptInUseConnections",
    NoWritesPerformed: "NoWritesPerformed"
  });

  class MongoError extends Error {
    get errorLabels() {
      return Array.from(this.errorLabelSet);
    }
    constructor(message, options) {
      super(message, options);
      this.errorLabelSet = new Set;
    }
    static buildErrorMessage(e) {
      if (typeof e === "string") {
        return e;
      }
      if (isAggregateError(e) && e.message.length === 0) {
        return e.errors.length === 0 ? "AggregateError has an empty errors array. Please check the `cause` property for more information." : e.errors.map(({ message }) => message).join(", ");
      }
      return e != null && typeof e === "object" && "message" in e && typeof e.message === "string" ? e.message : "empty error message";
    }
    get name() {
      return "MongoError";
    }
    get errmsg() {
      return this.message;
    }
    hasErrorLabel(label) {
      return this.errorLabelSet.has(label);
    }
    addErrorLabel(label) {
      this.errorLabelSet.add(label);
    }
  }
  exports.MongoError = MongoError;

  class MongoServerError extends MongoError {
    constructor(message) {
      super(message.message || message.errmsg || message.$err || "n/a");
      if (message.errorLabels) {
        for (const label of message.errorLabels)
          this.addErrorLabel(label);
      }
      this.errorResponse = message;
      for (const name in message) {
        if (name !== "errorLabels" && name !== "errmsg" && name !== "message" && name !== "errorResponse") {
          this[name] = message[name];
        }
      }
    }
    get name() {
      return "MongoServerError";
    }
  }
  exports.MongoServerError = MongoServerError;

  class MongoDriverError extends MongoError {
    constructor(message, options) {
      super(message, options);
    }
    get name() {
      return "MongoDriverError";
    }
  }
  exports.MongoDriverError = MongoDriverError;

  class MongoAPIError extends MongoDriverError {
    constructor(message, options) {
      super(message, options);
    }
    get name() {
      return "MongoAPIError";
    }
  }
  exports.MongoAPIError = MongoAPIError;

  class MongoRuntimeError extends MongoDriverError {
    constructor(message, options) {
      super(message, options);
    }
    get name() {
      return "MongoRuntimeError";
    }
  }
  exports.MongoRuntimeError = MongoRuntimeError;

  class MongoStalePrimaryError extends MongoRuntimeError {
    constructor(serverDescription, maxSetVersion, maxElectionId, options) {
      super(`primary marked stale due to electionId/setVersion mismatch: server setVersion: ${serverDescription.setVersion}, server electionId: ${serverDescription.electionId}, topology setVersion: ${maxSetVersion}, topology electionId: ${maxElectionId}`, options);
    }
    get name() {
      return "MongoStalePrimaryError";
    }
  }
  exports.MongoStalePrimaryError = MongoStalePrimaryError;

  class MongoBatchReExecutionError extends MongoAPIError {
    constructor(message = "This batch has already been executed, create new batch to execute") {
      super(message);
    }
    get name() {
      return "MongoBatchReExecutionError";
    }
  }
  exports.MongoBatchReExecutionError = MongoBatchReExecutionError;

  class MongoDecompressionError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoDecompressionError";
    }
  }
  exports.MongoDecompressionError = MongoDecompressionError;

  class MongoNotConnectedError extends MongoAPIError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoNotConnectedError";
    }
  }
  exports.MongoNotConnectedError = MongoNotConnectedError;

  class MongoTransactionError extends MongoAPIError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoTransactionError";
    }
  }
  exports.MongoTransactionError = MongoTransactionError;

  class MongoExpiredSessionError extends MongoAPIError {
    constructor(message = "Cannot use a session that has ended") {
      super(message);
    }
    get name() {
      return "MongoExpiredSessionError";
    }
  }
  exports.MongoExpiredSessionError = MongoExpiredSessionError;

  class MongoKerberosError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoKerberosError";
    }
  }
  exports.MongoKerberosError = MongoKerberosError;

  class MongoAWSError extends MongoRuntimeError {
    constructor(message, options) {
      super(message, options);
    }
    get name() {
      return "MongoAWSError";
    }
  }
  exports.MongoAWSError = MongoAWSError;

  class MongoOIDCError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoOIDCError";
    }
  }
  exports.MongoOIDCError = MongoOIDCError;

  class MongoAzureError extends MongoOIDCError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoAzureError";
    }
  }
  exports.MongoAzureError = MongoAzureError;

  class MongoGCPError extends MongoOIDCError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoGCPError";
    }
  }
  exports.MongoGCPError = MongoGCPError;

  class MongoClientBulkWriteError extends MongoServerError {
    constructor(message) {
      super(message);
      this.writeConcernErrors = [];
      this.writeErrors = new Map;
    }
    get name() {
      return "MongoClientBulkWriteError";
    }
  }
  exports.MongoClientBulkWriteError = MongoClientBulkWriteError;

  class MongoClientBulkWriteCursorError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoClientBulkWriteCursorError";
    }
  }
  exports.MongoClientBulkWriteCursorError = MongoClientBulkWriteCursorError;

  class MongoClientBulkWriteExecutionError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoClientBulkWriteExecutionError";
    }
  }
  exports.MongoClientBulkWriteExecutionError = MongoClientBulkWriteExecutionError;

  class MongoChangeStreamError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoChangeStreamError";
    }
  }
  exports.MongoChangeStreamError = MongoChangeStreamError;

  class MongoTailableCursorError extends MongoAPIError {
    constructor(message = "Tailable cursor does not support this operation") {
      super(message);
    }
    get name() {
      return "MongoTailableCursorError";
    }
  }
  exports.MongoTailableCursorError = MongoTailableCursorError;

  class MongoGridFSStreamError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoGridFSStreamError";
    }
  }
  exports.MongoGridFSStreamError = MongoGridFSStreamError;

  class MongoGridFSChunkError extends MongoRuntimeError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoGridFSChunkError";
    }
  }
  exports.MongoGridFSChunkError = MongoGridFSChunkError;

  class MongoUnexpectedServerResponseError extends MongoRuntimeError {
    constructor(message, options) {
      super(message, options);
    }
    get name() {
      return "MongoUnexpectedServerResponseError";
    }
  }
  exports.MongoUnexpectedServerResponseError = MongoUnexpectedServerResponseError;

  class MongoOperationTimeoutError extends MongoDriverError {
    get name() {
      return "MongoOperationTimeoutError";
    }
  }
  exports.MongoOperationTimeoutError = MongoOperationTimeoutError;

  class MongoCursorInUseError extends MongoAPIError {
    constructor(message = "Cursor is already initialized") {
      super(message);
    }
    get name() {
      return "MongoCursorInUseError";
    }
  }
  exports.MongoCursorInUseError = MongoCursorInUseError;

  class MongoServerClosedError extends MongoAPIError {
    constructor(message = "Server is closed") {
      super(message);
    }
    get name() {
      return "MongoServerClosedError";
    }
  }
  exports.MongoServerClosedError = MongoServerClosedError;

  class MongoCursorExhaustedError extends MongoAPIError {
    constructor(message) {
      super(message || "Cursor is exhausted");
    }
    get name() {
      return "MongoCursorExhaustedError";
    }
  }
  exports.MongoCursorExhaustedError = MongoCursorExhaustedError;

  class MongoTopologyClosedError extends MongoAPIError {
    constructor(message = "Topology is closed") {
      super(message);
    }
    get name() {
      return "MongoTopologyClosedError";
    }
  }
  exports.MongoTopologyClosedError = MongoTopologyClosedError;

  class MongoNetworkError extends MongoError {
    constructor(message, options) {
      super(message, { cause: options?.cause });
      this.beforeHandshake = !!options?.beforeHandshake;
    }
    get name() {
      return "MongoNetworkError";
    }
  }
  exports.MongoNetworkError = MongoNetworkError;

  class MongoNetworkTimeoutError extends MongoNetworkError {
    constructor(message, options) {
      super(message, options);
    }
    get name() {
      return "MongoNetworkTimeoutError";
    }
  }
  exports.MongoNetworkTimeoutError = MongoNetworkTimeoutError;

  class MongoParseError extends MongoDriverError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoParseError";
    }
  }
  exports.MongoParseError = MongoParseError;

  class MongoInvalidArgumentError extends MongoAPIError {
    constructor(message, options) {
      super(message, options);
    }
    get name() {
      return "MongoInvalidArgumentError";
    }
  }
  exports.MongoInvalidArgumentError = MongoInvalidArgumentError;

  class MongoCompatibilityError extends MongoAPIError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoCompatibilityError";
    }
  }
  exports.MongoCompatibilityError = MongoCompatibilityError;

  class MongoMissingCredentialsError extends MongoAPIError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoMissingCredentialsError";
    }
  }
  exports.MongoMissingCredentialsError = MongoMissingCredentialsError;

  class MongoMissingDependencyError extends MongoAPIError {
    constructor(message, options) {
      super(message, options);
      this.dependencyName = options.dependencyName;
    }
    get name() {
      return "MongoMissingDependencyError";
    }
  }
  exports.MongoMissingDependencyError = MongoMissingDependencyError;

  class MongoSystemError extends MongoError {
    constructor(message, reason) {
      if (reason && reason.error) {
        super(MongoError.buildErrorMessage(reason.error.message || reason.error), {
          cause: reason.error
        });
      } else {
        super(message);
      }
      if (reason) {
        this.reason = reason;
      }
      this.code = reason.error?.code;
    }
    get name() {
      return "MongoSystemError";
    }
  }
  exports.MongoSystemError = MongoSystemError;

  class MongoServerSelectionError extends MongoSystemError {
    constructor(message, reason) {
      super(message, reason);
    }
    get name() {
      return "MongoServerSelectionError";
    }
  }
  exports.MongoServerSelectionError = MongoServerSelectionError;

  class MongoWriteConcernError extends MongoServerError {
    constructor(result) {
      super({ ...result.writeConcernError, ...result });
      this.errInfo = result.writeConcernError.errInfo;
      this.result = result;
    }
    get name() {
      return "MongoWriteConcernError";
    }
  }
  exports.MongoWriteConcernError = MongoWriteConcernError;
  var RETRYABLE_READ_ERROR_CODES = new Set([
    exports.MONGODB_ERROR_CODES.HostUnreachable,
    exports.MONGODB_ERROR_CODES.HostNotFound,
    exports.MONGODB_ERROR_CODES.NetworkTimeout,
    exports.MONGODB_ERROR_CODES.ShutdownInProgress,
    exports.MONGODB_ERROR_CODES.PrimarySteppedDown,
    exports.MONGODB_ERROR_CODES.SocketException,
    exports.MONGODB_ERROR_CODES.NotWritablePrimary,
    exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
    exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
    exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
    exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary,
    exports.MONGODB_ERROR_CODES.ExceededTimeLimit,
    exports.MONGODB_ERROR_CODES.ReadConcernMajorityNotAvailableYet
  ]);
  var RETRYABLE_WRITE_ERROR_CODES = RETRYABLE_READ_ERROR_CODES;
  var SDAM_RECOVERING_CODES = new Set([
    exports.MONGODB_ERROR_CODES.ShutdownInProgress,
    exports.MONGODB_ERROR_CODES.PrimarySteppedDown,
    exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
    exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
    exports.MONGODB_ERROR_CODES.NotPrimaryOrSecondary
  ]);
  var SDAM_NOT_PRIMARY_CODES = new Set([
    exports.MONGODB_ERROR_CODES.NotWritablePrimary,
    exports.MONGODB_ERROR_CODES.NotPrimaryNoSecondaryOk,
    exports.MONGODB_ERROR_CODES.LegacyNotPrimary
  ]);
  var SDAM_NODE_SHUTTING_DOWN_ERROR_CODES = new Set([
    exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
    exports.MONGODB_ERROR_CODES.ShutdownInProgress
  ]);
});

// node_modules/mongodb/lib/read_preference.js
var require_read_preference = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReadPreference = exports.ReadPreferenceMode = undefined;
  var error_1 = require_error();
  exports.ReadPreferenceMode = Object.freeze({
    primary: "primary",
    primaryPreferred: "primaryPreferred",
    secondary: "secondary",
    secondaryPreferred: "secondaryPreferred",
    nearest: "nearest"
  });

  class ReadPreference {
    constructor(mode, tags, options) {
      if (!ReadPreference.isValid(mode)) {
        throw new error_1.MongoInvalidArgumentError(`Invalid read preference mode ${JSON.stringify(mode)}`);
      }
      if (options == null && typeof tags === "object" && !Array.isArray(tags)) {
        options = tags;
        tags = undefined;
      } else if (tags && !Array.isArray(tags)) {
        throw new error_1.MongoInvalidArgumentError("ReadPreference tags must be an array");
      }
      this.mode = mode;
      this.tags = tags;
      this.hedge = options?.hedge;
      this.maxStalenessSeconds = undefined;
      this.minWireVersion = undefined;
      options = options ?? {};
      if (options.maxStalenessSeconds != null) {
        if (options.maxStalenessSeconds <= 0) {
          throw new error_1.MongoInvalidArgumentError("maxStalenessSeconds must be a positive integer");
        }
        this.maxStalenessSeconds = options.maxStalenessSeconds;
        this.minWireVersion = 5;
      }
      if (this.mode === ReadPreference.PRIMARY) {
        if (this.tags && Array.isArray(this.tags) && this.tags.length > 0) {
          throw new error_1.MongoInvalidArgumentError("Primary read preference cannot be combined with tags");
        }
        if (this.maxStalenessSeconds) {
          throw new error_1.MongoInvalidArgumentError("Primary read preference cannot be combined with maxStalenessSeconds");
        }
        if (this.hedge) {
          throw new error_1.MongoInvalidArgumentError("Primary read preference cannot be combined with hedge");
        }
      }
    }
    get preference() {
      return this.mode;
    }
    static fromString(mode) {
      return new ReadPreference(mode);
    }
    static fromOptions(options) {
      if (!options)
        return;
      const readPreference = options.readPreference ?? options.session?.transaction.options.readPreference;
      const readPreferenceTags = options.readPreferenceTags;
      if (readPreference == null) {
        return;
      }
      if (typeof readPreference === "string") {
        return new ReadPreference(readPreference, readPreferenceTags, {
          maxStalenessSeconds: options.maxStalenessSeconds,
          hedge: options.hedge
        });
      } else if (!(readPreference instanceof ReadPreference) && typeof readPreference === "object") {
        const mode = readPreference.mode || readPreference.preference;
        if (mode && typeof mode === "string") {
          return new ReadPreference(mode, readPreference.tags ?? readPreferenceTags, {
            maxStalenessSeconds: readPreference.maxStalenessSeconds,
            hedge: options.hedge
          });
        }
      }
      if (readPreferenceTags) {
        readPreference.tags = readPreferenceTags;
      }
      return readPreference;
    }
    static translate(options) {
      if (options.readPreference == null)
        return options;
      const r = options.readPreference;
      if (typeof r === "string") {
        options.readPreference = new ReadPreference(r);
      } else if (r && !(r instanceof ReadPreference) && typeof r === "object") {
        const mode = r.mode || r.preference;
        if (mode && typeof mode === "string") {
          options.readPreference = new ReadPreference(mode, r.tags, {
            maxStalenessSeconds: r.maxStalenessSeconds
          });
        }
      } else if (!(r instanceof ReadPreference)) {
        throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${r}`);
      }
      return options;
    }
    static isValid(mode) {
      const VALID_MODES = new Set([
        ReadPreference.PRIMARY,
        ReadPreference.PRIMARY_PREFERRED,
        ReadPreference.SECONDARY,
        ReadPreference.SECONDARY_PREFERRED,
        ReadPreference.NEAREST,
        null
      ]);
      return VALID_MODES.has(mode);
    }
    isValid(mode) {
      return ReadPreference.isValid(typeof mode === "string" ? mode : this.mode);
    }
    secondaryOk() {
      const NEEDS_SECONDARYOK = new Set([
        ReadPreference.PRIMARY_PREFERRED,
        ReadPreference.SECONDARY,
        ReadPreference.SECONDARY_PREFERRED,
        ReadPreference.NEAREST
      ]);
      return NEEDS_SECONDARYOK.has(this.mode);
    }
    equals(readPreference) {
      return readPreference.mode === this.mode;
    }
    toJSON() {
      const readPreference = { mode: this.mode };
      if (Array.isArray(this.tags))
        readPreference.tags = this.tags;
      if (this.maxStalenessSeconds)
        readPreference.maxStalenessSeconds = this.maxStalenessSeconds;
      if (this.hedge)
        readPreference.hedge = this.hedge;
      return readPreference;
    }
  }
  exports.ReadPreference = ReadPreference;
  ReadPreference.PRIMARY = exports.ReadPreferenceMode.primary;
  ReadPreference.PRIMARY_PREFERRED = exports.ReadPreferenceMode.primaryPreferred;
  ReadPreference.SECONDARY = exports.ReadPreferenceMode.secondary;
  ReadPreference.SECONDARY_PREFERRED = exports.ReadPreferenceMode.secondaryPreferred;
  ReadPreference.NEAREST = exports.ReadPreferenceMode.nearest;
  ReadPreference.primary = new ReadPreference(exports.ReadPreferenceMode.primary);
  ReadPreference.primaryPreferred = new ReadPreference(exports.ReadPreferenceMode.primaryPreferred);
  ReadPreference.secondary = new ReadPreference(exports.ReadPreferenceMode.secondary);
  ReadPreference.secondaryPreferred = new ReadPreference(exports.ReadPreferenceMode.secondaryPreferred);
  ReadPreference.nearest = new ReadPreference(exports.ReadPreferenceMode.nearest);
});

// node_modules/mongodb/lib/sdam/common.js
var require_common = __commonJS((exports) => {
  function _advanceClusterTime(entity, $clusterTime) {
    if (entity.clusterTime == null) {
      entity.clusterTime = $clusterTime;
    } else {
      if ($clusterTime.clusterTime.greaterThan(entity.clusterTime.clusterTime)) {
        entity.clusterTime = $clusterTime;
      }
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServerType = exports.TopologyType = exports.STATE_CONNECTED = exports.STATE_CONNECTING = exports.STATE_CLOSED = exports.STATE_CLOSING = undefined;
  exports._advanceClusterTime = _advanceClusterTime;
  exports.STATE_CLOSING = "closing";
  exports.STATE_CLOSED = "closed";
  exports.STATE_CONNECTING = "connecting";
  exports.STATE_CONNECTED = "connected";
  exports.TopologyType = Object.freeze({
    Single: "Single",
    ReplicaSetNoPrimary: "ReplicaSetNoPrimary",
    ReplicaSetWithPrimary: "ReplicaSetWithPrimary",
    Sharded: "Sharded",
    Unknown: "Unknown",
    LoadBalanced: "LoadBalanced"
  });
  exports.ServerType = Object.freeze({
    Standalone: "Standalone",
    Mongos: "Mongos",
    PossiblePrimary: "PossiblePrimary",
    RSPrimary: "RSPrimary",
    RSSecondary: "RSSecondary",
    RSArbiter: "RSArbiter",
    RSOther: "RSOther",
    RSGhost: "RSGhost",
    Unknown: "Unknown",
    LoadBalancer: "LoadBalancer"
  });
});

// node_modules/mongodb/lib/sdam/server_selection.js
var require_server_selection = __commonJS((exports) => {
  function writableServerSelector() {
    return function writableServer(topologyDescription, servers) {
      return latencyWindowReducer(topologyDescription, servers.filter((s) => s.isWritable));
    };
  }
  function sameServerSelector(description) {
    return function sameServerSelector(topologyDescription, servers) {
      if (!description)
        return [];
      return servers.filter((sd) => {
        return sd.address === description.address && sd.type !== common_1.ServerType.Unknown;
      });
    };
  }
  function secondaryWritableServerSelector(wireVersion, readPreference) {
    if (!readPreference || !wireVersion || wireVersion && wireVersion < exports.MIN_SECONDARY_WRITE_WIRE_VERSION) {
      return readPreferenceServerSelector(read_preference_1.ReadPreference.primary);
    }
    return readPreferenceServerSelector(readPreference);
  }
  function maxStalenessReducer(readPreference, topologyDescription, servers) {
    if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {
      return servers;
    }
    const maxStaleness = readPreference.maxStalenessSeconds;
    const maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;
    if (maxStaleness < maxStalenessVariance) {
      throw new error_1.MongoInvalidArgumentError(`Option "maxStalenessSeconds" must be at least ${maxStalenessVariance} seconds`);
    }
    if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {
      throw new error_1.MongoInvalidArgumentError(`Option "maxStalenessSeconds" must be at least ${SMALLEST_MAX_STALENESS_SECONDS} seconds`);
    }
    if (topologyDescription.type === common_1.TopologyType.ReplicaSetWithPrimary) {
      const primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];
      return servers.reduce((result, server) => {
        const stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;
        const staleness = stalenessMS / 1000;
        const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;
        if (staleness <= maxStalenessSeconds) {
          result.push(server);
        }
        return result;
      }, []);
    }
    if (topologyDescription.type === common_1.TopologyType.ReplicaSetNoPrimary) {
      if (servers.length === 0) {
        return servers;
      }
      const sMax = servers.reduce((max, s) => s.lastWriteDate > max.lastWriteDate ? s : max);
      return servers.reduce((result, server) => {
        const stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;
        const staleness = stalenessMS / 1000;
        const maxStalenessSeconds = readPreference.maxStalenessSeconds ?? 0;
        if (staleness <= maxStalenessSeconds) {
          result.push(server);
        }
        return result;
      }, []);
    }
    return servers;
  }
  function tagSetMatch(tagSet, serverTags) {
    const keys = Object.keys(tagSet);
    const serverTagKeys = Object.keys(serverTags);
    for (let i = 0;i < keys.length; ++i) {
      const key = keys[i];
      if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {
        return false;
      }
    }
    return true;
  }
  function tagSetReducer(readPreference, servers) {
    if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {
      return servers;
    }
    for (let i = 0;i < readPreference.tags.length; ++i) {
      const tagSet = readPreference.tags[i];
      const serversMatchingTagset = servers.reduce((matched, server) => {
        if (tagSetMatch(tagSet, server.tags))
          matched.push(server);
        return matched;
      }, []);
      if (serversMatchingTagset.length) {
        return serversMatchingTagset;
      }
    }
    return [];
  }
  function latencyWindowReducer(topologyDescription, servers) {
    const low = servers.reduce((min, server) => Math.min(server.roundTripTime, min), Infinity);
    const high = low + topologyDescription.localThresholdMS;
    return servers.reduce((result, server) => {
      if (server.roundTripTime <= high && server.roundTripTime >= low)
        result.push(server);
      return result;
    }, []);
  }
  function primaryFilter(server) {
    return server.type === common_1.ServerType.RSPrimary;
  }
  function secondaryFilter(server) {
    return server.type === common_1.ServerType.RSSecondary;
  }
  function nearestFilter(server) {
    return server.type === common_1.ServerType.RSSecondary || server.type === common_1.ServerType.RSPrimary;
  }
  function knownFilter(server) {
    return server.type !== common_1.ServerType.Unknown;
  }
  function loadBalancerFilter(server) {
    return server.type === common_1.ServerType.LoadBalancer;
  }
  function readPreferenceServerSelector(readPreference) {
    if (!readPreference.isValid()) {
      throw new error_1.MongoInvalidArgumentError("Invalid read preference specified");
    }
    return function readPreferenceServers(topologyDescription, servers, deprioritized = []) {
      const commonWireVersion = topologyDescription.commonWireVersion;
      if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {
        throw new error_1.MongoCompatibilityError(`Minimum wire version '${readPreference.minWireVersion}' required, but found '${commonWireVersion}'`);
      }
      if (topologyDescription.type === common_1.TopologyType.LoadBalanced) {
        return servers.filter(loadBalancerFilter);
      }
      if (topologyDescription.type === common_1.TopologyType.Unknown) {
        return [];
      }
      if (topologyDescription.type === common_1.TopologyType.Single) {
        return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));
      }
      if (topologyDescription.type === common_1.TopologyType.Sharded) {
        const filtered = servers.filter((server) => {
          return !deprioritized.includes(server);
        });
        const selectable = filtered.length > 0 ? filtered : deprioritized;
        return latencyWindowReducer(topologyDescription, selectable.filter(knownFilter));
      }
      const mode = readPreference.mode;
      if (mode === read_preference_1.ReadPreference.PRIMARY) {
        return servers.filter(primaryFilter);
      }
      if (mode === read_preference_1.ReadPreference.PRIMARY_PREFERRED) {
        const result = servers.filter(primaryFilter);
        if (result.length) {
          return result;
        }
      }
      const filter = mode === read_preference_1.ReadPreference.NEAREST ? nearestFilter : secondaryFilter;
      const selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));
      if (mode === read_preference_1.ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {
        return servers.filter(primaryFilter);
      }
      return selectedServers;
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MIN_SECONDARY_WRITE_WIRE_VERSION = undefined;
  exports.writableServerSelector = writableServerSelector;
  exports.sameServerSelector = sameServerSelector;
  exports.secondaryWritableServerSelector = secondaryWritableServerSelector;
  exports.readPreferenceServerSelector = readPreferenceServerSelector;
  var error_1 = require_error();
  var read_preference_1 = require_read_preference();
  var common_1 = require_common();
  var IDLE_WRITE_PERIOD = 1e4;
  var SMALLEST_MAX_STALENESS_SECONDS = 90;
  exports.MIN_SECONDARY_WRITE_WIRE_VERSION = 13;
});

// node_modules/mongodb/lib/cmap/wire_protocol/constants.js
var require_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OP_MSG = exports.OP_COMPRESSED = exports.OP_DELETE = exports.OP_QUERY = exports.OP_INSERT = exports.OP_UPDATE = exports.OP_REPLY = exports.MIN_SUPPORTED_QE_SERVER_VERSION = exports.MIN_SUPPORTED_QE_WIRE_VERSION = exports.MAX_SUPPORTED_WIRE_VERSION = exports.MIN_SUPPORTED_WIRE_VERSION = exports.MAX_SUPPORTED_SERVER_VERSION = exports.MIN_SUPPORTED_SERVER_VERSION = undefined;
  exports.MIN_SUPPORTED_SERVER_VERSION = "4.0";
  exports.MAX_SUPPORTED_SERVER_VERSION = "8.0";
  exports.MIN_SUPPORTED_WIRE_VERSION = 7;
  exports.MAX_SUPPORTED_WIRE_VERSION = 25;
  exports.MIN_SUPPORTED_QE_WIRE_VERSION = 21;
  exports.MIN_SUPPORTED_QE_SERVER_VERSION = "7.0";
  exports.OP_REPLY = 1;
  exports.OP_UPDATE = 2001;
  exports.OP_INSERT = 2002;
  exports.OP_QUERY = 2004;
  exports.OP_DELETE = 2006;
  exports.OP_COMPRESSED = 2012;
  exports.OP_MSG = 2013;
});

// node_modules/mongodb/lib/constants.js
var require_constants2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.END = exports.CHANGE = exports.INIT = exports.MORE = exports.RESPONSE = exports.SERVER_HEARTBEAT_FAILED = exports.SERVER_HEARTBEAT_SUCCEEDED = exports.SERVER_HEARTBEAT_STARTED = exports.COMMAND_FAILED = exports.COMMAND_SUCCEEDED = exports.COMMAND_STARTED = exports.CLUSTER_TIME_RECEIVED = exports.CONNECTION_CHECKED_IN = exports.CONNECTION_CHECKED_OUT = exports.CONNECTION_CHECK_OUT_FAILED = exports.CONNECTION_CHECK_OUT_STARTED = exports.CONNECTION_CLOSED = exports.CONNECTION_READY = exports.CONNECTION_CREATED = exports.CONNECTION_POOL_READY = exports.CONNECTION_POOL_CLEARED = exports.CONNECTION_POOL_CLOSED = exports.CONNECTION_POOL_CREATED = exports.WAITING_FOR_SUITABLE_SERVER = exports.SERVER_SELECTION_SUCCEEDED = exports.SERVER_SELECTION_FAILED = exports.SERVER_SELECTION_STARTED = exports.TOPOLOGY_DESCRIPTION_CHANGED = exports.TOPOLOGY_CLOSED = exports.TOPOLOGY_OPENING = exports.SERVER_DESCRIPTION_CHANGED = exports.SERVER_CLOSED = exports.SERVER_OPENING = exports.DESCRIPTION_RECEIVED = exports.UNPINNED = exports.PINNED = exports.MESSAGE = exports.ENDED = exports.CLOSED = exports.CONNECT = exports.OPEN = exports.CLOSE = exports.TIMEOUT = exports.ERROR = exports.SYSTEM_JS_COLLECTION = exports.SYSTEM_COMMAND_COLLECTION = exports.SYSTEM_USER_COLLECTION = exports.SYSTEM_PROFILE_COLLECTION = exports.SYSTEM_INDEX_COLLECTION = exports.SYSTEM_NAMESPACE_COLLECTION = undefined;
  exports.kDecoratedKeys = exports.kDecorateResult = exports.LEGACY_HELLO_COMMAND_CAMEL_CASE = exports.LEGACY_HELLO_COMMAND = exports.MONGO_CLIENT_EVENTS = exports.LOCAL_SERVER_EVENTS = exports.SERVER_RELAY_EVENTS = exports.APM_EVENTS = exports.TOPOLOGY_EVENTS = exports.CMAP_EVENTS = exports.HEARTBEAT_EVENTS = exports.RESUME_TOKEN_CHANGED = undefined;
  exports.SYSTEM_NAMESPACE_COLLECTION = "system.namespaces";
  exports.SYSTEM_INDEX_COLLECTION = "system.indexes";
  exports.SYSTEM_PROFILE_COLLECTION = "system.profile";
  exports.SYSTEM_USER_COLLECTION = "system.users";
  exports.SYSTEM_COMMAND_COLLECTION = "$cmd";
  exports.SYSTEM_JS_COLLECTION = "system.js";
  exports.ERROR = "error";
  exports.TIMEOUT = "timeout";
  exports.CLOSE = "close";
  exports.OPEN = "open";
  exports.CONNECT = "connect";
  exports.CLOSED = "closed";
  exports.ENDED = "ended";
  exports.MESSAGE = "message";
  exports.PINNED = "pinned";
  exports.UNPINNED = "unpinned";
  exports.DESCRIPTION_RECEIVED = "descriptionReceived";
  exports.SERVER_OPENING = "serverOpening";
  exports.SERVER_CLOSED = "serverClosed";
  exports.SERVER_DESCRIPTION_CHANGED = "serverDescriptionChanged";
  exports.TOPOLOGY_OPENING = "topologyOpening";
  exports.TOPOLOGY_CLOSED = "topologyClosed";
  exports.TOPOLOGY_DESCRIPTION_CHANGED = "topologyDescriptionChanged";
  exports.SERVER_SELECTION_STARTED = "serverSelectionStarted";
  exports.SERVER_SELECTION_FAILED = "serverSelectionFailed";
  exports.SERVER_SELECTION_SUCCEEDED = "serverSelectionSucceeded";
  exports.WAITING_FOR_SUITABLE_SERVER = "waitingForSuitableServer";
  exports.CONNECTION_POOL_CREATED = "connectionPoolCreated";
  exports.CONNECTION_POOL_CLOSED = "connectionPoolClosed";
  exports.CONNECTION_POOL_CLEARED = "connectionPoolCleared";
  exports.CONNECTION_POOL_READY = "connectionPoolReady";
  exports.CONNECTION_CREATED = "connectionCreated";
  exports.CONNECTION_READY = "connectionReady";
  exports.CONNECTION_CLOSED = "connectionClosed";
  exports.CONNECTION_CHECK_OUT_STARTED = "connectionCheckOutStarted";
  exports.CONNECTION_CHECK_OUT_FAILED = "connectionCheckOutFailed";
  exports.CONNECTION_CHECKED_OUT = "connectionCheckedOut";
  exports.CONNECTION_CHECKED_IN = "connectionCheckedIn";
  exports.CLUSTER_TIME_RECEIVED = "clusterTimeReceived";
  exports.COMMAND_STARTED = "commandStarted";
  exports.COMMAND_SUCCEEDED = "commandSucceeded";
  exports.COMMAND_FAILED = "commandFailed";
  exports.SERVER_HEARTBEAT_STARTED = "serverHeartbeatStarted";
  exports.SERVER_HEARTBEAT_SUCCEEDED = "serverHeartbeatSucceeded";
  exports.SERVER_HEARTBEAT_FAILED = "serverHeartbeatFailed";
  exports.RESPONSE = "response";
  exports.MORE = "more";
  exports.INIT = "init";
  exports.CHANGE = "change";
  exports.END = "end";
  exports.RESUME_TOKEN_CHANGED = "resumeTokenChanged";
  exports.HEARTBEAT_EVENTS = Object.freeze([
    exports.SERVER_HEARTBEAT_STARTED,
    exports.SERVER_HEARTBEAT_SUCCEEDED,
    exports.SERVER_HEARTBEAT_FAILED
  ]);
  exports.CMAP_EVENTS = Object.freeze([
    exports.CONNECTION_POOL_CREATED,
    exports.CONNECTION_POOL_READY,
    exports.CONNECTION_POOL_CLEARED,
    exports.CONNECTION_POOL_CLOSED,
    exports.CONNECTION_CREATED,
    exports.CONNECTION_READY,
    exports.CONNECTION_CLOSED,
    exports.CONNECTION_CHECK_OUT_STARTED,
    exports.CONNECTION_CHECK_OUT_FAILED,
    exports.CONNECTION_CHECKED_OUT,
    exports.CONNECTION_CHECKED_IN
  ]);
  exports.TOPOLOGY_EVENTS = Object.freeze([
    exports.SERVER_OPENING,
    exports.SERVER_CLOSED,
    exports.SERVER_DESCRIPTION_CHANGED,
    exports.TOPOLOGY_OPENING,
    exports.TOPOLOGY_CLOSED,
    exports.TOPOLOGY_DESCRIPTION_CHANGED,
    exports.ERROR,
    exports.TIMEOUT,
    exports.CLOSE
  ]);
  exports.APM_EVENTS = Object.freeze([
    exports.COMMAND_STARTED,
    exports.COMMAND_SUCCEEDED,
    exports.COMMAND_FAILED
  ]);
  exports.SERVER_RELAY_EVENTS = Object.freeze([
    exports.SERVER_HEARTBEAT_STARTED,
    exports.SERVER_HEARTBEAT_SUCCEEDED,
    exports.SERVER_HEARTBEAT_FAILED,
    exports.COMMAND_STARTED,
    exports.COMMAND_SUCCEEDED,
    exports.COMMAND_FAILED,
    ...exports.CMAP_EVENTS
  ]);
  exports.LOCAL_SERVER_EVENTS = Object.freeze([
    exports.CONNECT,
    exports.DESCRIPTION_RECEIVED,
    exports.CLOSED,
    exports.ENDED
  ]);
  exports.MONGO_CLIENT_EVENTS = Object.freeze([
    ...exports.CMAP_EVENTS,
    ...exports.APM_EVENTS,
    ...exports.TOPOLOGY_EVENTS,
    ...exports.HEARTBEAT_EVENTS
  ]);
  exports.LEGACY_HELLO_COMMAND = "ismaster";
  exports.LEGACY_HELLO_COMMAND_CAMEL_CASE = "isMaster";
  exports.kDecorateResult = Symbol.for("@@mdb.decorateDecryptionResult");
  exports.kDecoratedKeys = Symbol.for("@@mdb.decryptedKeys");
});

// node_modules/mongodb/lib/read_concern.js
var require_read_concern = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReadConcern = exports.ReadConcernLevel = undefined;
  exports.ReadConcernLevel = Object.freeze({
    local: "local",
    majority: "majority",
    linearizable: "linearizable",
    available: "available",
    snapshot: "snapshot"
  });

  class ReadConcern {
    constructor(level) {
      this.level = exports.ReadConcernLevel[level] ?? level;
    }
    static fromOptions(options) {
      if (options == null) {
        return;
      }
      if (options.readConcern) {
        const { readConcern } = options;
        if (readConcern instanceof ReadConcern) {
          return readConcern;
        } else if (typeof readConcern === "string") {
          return new ReadConcern(readConcern);
        } else if ("level" in readConcern && readConcern.level) {
          return new ReadConcern(readConcern.level);
        }
      }
      if (options.level) {
        return new ReadConcern(options.level);
      }
      return;
    }
    static get MAJORITY() {
      return exports.ReadConcernLevel.majority;
    }
    static get AVAILABLE() {
      return exports.ReadConcernLevel.available;
    }
    static get LINEARIZABLE() {
      return exports.ReadConcernLevel.linearizable;
    }
    static get SNAPSHOT() {
      return exports.ReadConcernLevel.snapshot;
    }
    toJSON() {
      return { level: this.level };
    }
  }
  exports.ReadConcern = ReadConcern;
});

// node_modules/mongodb/lib/cmap/wire_protocol/on_demand/document.js
var require_document = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OnDemandDocument = undefined;
  var bson_1 = require_bson2();

  class OnDemandDocument {
    constructor(bson, offset = 0, isArray = false, elements) {
      this.bson = bson;
      this.offset = offset;
      this.isArray = isArray;
      this.cache = Object.create(null);
      this.indexFound = Object.create(null);
      this.elements = elements ?? (0, bson_1.parseToElementsToArray)(this.bson, offset);
    }
    isElementName(name, element) {
      const nameLength = element[2];
      const nameOffset = element[1];
      if (name.length !== nameLength)
        return false;
      const nameEnd = nameOffset + nameLength;
      for (let byteIndex = nameOffset, charIndex = 0;charIndex < name.length && byteIndex < nameEnd; charIndex++, byteIndex++) {
        if (this.bson[byteIndex] !== name.charCodeAt(charIndex))
          return false;
      }
      return true;
    }
    getElement(name) {
      const cachedElement = this.cache[name];
      if (cachedElement === false)
        return null;
      if (cachedElement != null) {
        return cachedElement;
      }
      if (typeof name === "number") {
        if (this.isArray) {
          if (name < this.elements.length) {
            const element = this.elements[name];
            const cachedElement2 = { element, value: undefined };
            this.cache[name] = cachedElement2;
            this.indexFound[name] = true;
            return cachedElement2;
          } else {
            return null;
          }
        } else {
          return null;
        }
      }
      for (let index = 0;index < this.elements.length; index++) {
        const element = this.elements[index];
        if (!(index in this.indexFound) && this.isElementName(name, element)) {
          const cachedElement2 = { element, value: undefined };
          this.cache[name] = cachedElement2;
          this.indexFound[index] = true;
          return cachedElement2;
        }
      }
      this.cache[name] = false;
      return null;
    }
    toJSValue(element, as) {
      const type = element[0];
      const offset = element[3];
      const length = element[4];
      if (as !== type) {
        return null;
      }
      switch (as) {
        case bson_1.BSONType.null:
        case bson_1.BSONType.undefined:
          return null;
        case bson_1.BSONType.double:
          return (0, bson_1.getFloat64LE)(this.bson, offset);
        case bson_1.BSONType.int:
          return (0, bson_1.getInt32LE)(this.bson, offset);
        case bson_1.BSONType.long:
          return (0, bson_1.getBigInt64LE)(this.bson, offset);
        case bson_1.BSONType.bool:
          return Boolean(this.bson[offset]);
        case bson_1.BSONType.objectId:
          return new bson_1.ObjectId(this.bson.subarray(offset, offset + 12));
        case bson_1.BSONType.timestamp:
          return new bson_1.Timestamp((0, bson_1.getBigInt64LE)(this.bson, offset));
        case bson_1.BSONType.string:
          return (0, bson_1.toUTF8)(this.bson, offset + 4, offset + length - 1, false);
        case bson_1.BSONType.binData: {
          const totalBinarySize = (0, bson_1.getInt32LE)(this.bson, offset);
          const subType = this.bson[offset + 4];
          if (subType === 2) {
            const subType2BinarySize = (0, bson_1.getInt32LE)(this.bson, offset + 1 + 4);
            if (subType2BinarySize < 0)
              throw new bson_1.BSONError("Negative binary type element size found for subtype 0x02");
            if (subType2BinarySize > totalBinarySize - 4)
              throw new bson_1.BSONError("Binary type with subtype 0x02 contains too long binary size");
            if (subType2BinarySize < totalBinarySize - 4)
              throw new bson_1.BSONError("Binary type with subtype 0x02 contains too short binary size");
            return new bson_1.Binary(this.bson.subarray(offset + 1 + 4 + 4, offset + 1 + 4 + 4 + subType2BinarySize), 2);
          }
          return new bson_1.Binary(this.bson.subarray(offset + 1 + 4, offset + 1 + 4 + totalBinarySize), subType);
        }
        case bson_1.BSONType.date:
          return new Date(Number((0, bson_1.getBigInt64LE)(this.bson, offset)));
        case bson_1.BSONType.object:
          return new OnDemandDocument(this.bson, offset);
        case bson_1.BSONType.array:
          return new OnDemandDocument(this.bson, offset, true);
        default:
          throw new bson_1.BSONError(`Unsupported BSON type: ${as}`);
      }
    }
    size() {
      return this.elements.length;
    }
    has(name) {
      const cachedElement = this.cache[name];
      if (cachedElement === false)
        return false;
      if (cachedElement != null)
        return true;
      return this.getElement(name) != null;
    }
    get(name, as, required) {
      const element = this.getElement(name);
      if (element == null) {
        if (required === true) {
          throw new bson_1.BSONError(`BSON element "${name}" is missing`);
        } else {
          return null;
        }
      }
      if (element.value == null) {
        const value = this.toJSValue(element.element, as);
        if (value == null) {
          if (required === true) {
            throw new bson_1.BSONError(`BSON element "${name}" is missing`);
          } else {
            return null;
          }
        }
        element.value = value;
      }
      return element.value;
    }
    getNumber(name, required) {
      const maybeBool = this.get(name, bson_1.BSONType.bool);
      const bool = maybeBool == null ? null : maybeBool ? 1 : 0;
      const maybeLong = this.get(name, bson_1.BSONType.long);
      const long = maybeLong == null ? null : Number(maybeLong);
      const result = bool ?? long ?? this.get(name, bson_1.BSONType.int) ?? this.get(name, bson_1.BSONType.double);
      if (required === true && result == null) {
        throw new bson_1.BSONError(`BSON element "${name}" is missing`);
      }
      return result;
    }
    toObject(options) {
      return (0, bson_1.deserialize)(this.bson, {
        ...options,
        index: this.offset,
        allowObjectSmallerThanBufferSize: true
      });
    }
    toBytes() {
      const size = (0, bson_1.getInt32LE)(this.bson, this.offset);
      return this.bson.subarray(this.offset, this.offset + size);
    }
  }
  exports.OnDemandDocument = OnDemandDocument;
});

// node_modules/mongodb/lib/cmap/wire_protocol/responses.js
var require_responses = __commonJS((exports) => {
  function isErrorResponse(bson, elements) {
    for (let eIdx = 0;eIdx < elements.length; eIdx++) {
      const element = elements[eIdx];
      if (element[2] === 2) {
        const nameOffset = element[1];
        if (bson[nameOffset] === 111 && bson[nameOffset + 1] === 107) {
          const valueOffset = element[3];
          const valueLength = element[4];
          for (let i = valueOffset;i < valueOffset + valueLength; i++) {
            if (bson[i] !== 0)
              return false;
          }
          return true;
        }
      }
    }
    return true;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ClientBulkWriteCursorResponse = exports.ExplainedCursorResponse = exports.CursorResponse = exports.MongoDBResponse = undefined;
  exports.isErrorResponse = isErrorResponse;
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var utils_1 = require_utils2();
  var document_1 = require_document();

  class MongoDBResponse extends document_1.OnDemandDocument {
    get(name, as, required) {
      try {
        return super.get(name, as, required);
      } catch (cause) {
        throw new error_1.MongoUnexpectedServerResponseError(cause.message, { cause });
      }
    }
    static is(value) {
      return value instanceof MongoDBResponse;
    }
    static make(bson) {
      const elements = (0, bson_1.parseToElementsToArray)(bson, 0);
      const isError = isErrorResponse(bson, elements);
      return isError ? new MongoDBResponse(bson, 0, false, elements) : new this(bson, 0, false, elements);
    }
    get isMaxTimeExpiredError() {
      const isTopLevel = this.ok === 0 && this.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;
      if (isTopLevel)
        return true;
      if (this.ok === 0)
        return false;
      const isWriteConcern = this.get("writeConcernError", bson_1.BSONType.object)?.getNumber("code") === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;
      if (isWriteConcern)
        return true;
      const writeErrors = this.get("writeErrors", bson_1.BSONType.array);
      if (writeErrors?.size()) {
        for (let i = 0;i < writeErrors.size(); i++) {
          const isWriteError = writeErrors.get(i, bson_1.BSONType.object)?.getNumber("code") === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;
          if (isWriteError)
            return true;
        }
      }
      return false;
    }
    get recoveryToken() {
      return this.get("recoveryToken", bson_1.BSONType.object)?.toObject({
        promoteValues: false,
        promoteLongs: false,
        promoteBuffers: false,
        validation: { utf8: true }
      }) ?? null;
    }
    get atClusterTime() {
      return this.get("cursor", bson_1.BSONType.object)?.get("atClusterTime", bson_1.BSONType.timestamp) ?? this.get("atClusterTime", bson_1.BSONType.timestamp);
    }
    get operationTime() {
      return this.get("operationTime", bson_1.BSONType.timestamp);
    }
    get ok() {
      return this.getNumber("ok") ? 1 : 0;
    }
    get $err() {
      return this.get("$err", bson_1.BSONType.string);
    }
    get errmsg() {
      return this.get("errmsg", bson_1.BSONType.string);
    }
    get code() {
      return this.getNumber("code");
    }
    get $clusterTime() {
      if (!("clusterTime" in this)) {
        const clusterTimeDoc = this.get("$clusterTime", bson_1.BSONType.object);
        if (clusterTimeDoc == null) {
          this.clusterTime = null;
          return null;
        }
        const clusterTime = clusterTimeDoc.get("clusterTime", bson_1.BSONType.timestamp, true);
        const signature = clusterTimeDoc.get("signature", bson_1.BSONType.object)?.toObject();
        this.clusterTime = { clusterTime, signature };
      }
      return this.clusterTime ?? null;
    }
    toObject(options) {
      const exactBSONOptions = {
        ...(0, bson_1.pluckBSONSerializeOptions)(options ?? {}),
        validation: (0, bson_1.parseUtf8ValidationOption)(options)
      };
      return super.toObject(exactBSONOptions);
    }
  }
  exports.MongoDBResponse = MongoDBResponse;
  MongoDBResponse.empty = new MongoDBResponse(new Uint8Array([13, 0, 0, 0, 16, 111, 107, 0, 1, 0, 0, 0, 0]));

  class CursorResponse extends MongoDBResponse {
    constructor() {
      super(...arguments);
      this._batch = null;
      this.iterated = 0;
      this._encryptedBatch = null;
    }
    static is(value) {
      return value instanceof CursorResponse || value === CursorResponse.emptyGetMore;
    }
    get cursor() {
      return this.get("cursor", bson_1.BSONType.object, true);
    }
    get id() {
      try {
        return bson_1.Long.fromBigInt(this.cursor.get("id", bson_1.BSONType.long, true));
      } catch (cause) {
        throw new error_1.MongoUnexpectedServerResponseError(cause.message, { cause });
      }
    }
    get ns() {
      const namespace = this.cursor.get("ns", bson_1.BSONType.string);
      if (namespace != null)
        return (0, utils_1.ns)(namespace);
      return null;
    }
    get length() {
      return Math.max(this.batchSize - this.iterated, 0);
    }
    get encryptedBatch() {
      if (this.encryptedResponse == null)
        return null;
      if (this._encryptedBatch != null)
        return this._encryptedBatch;
      const cursor = this.encryptedResponse?.get("cursor", bson_1.BSONType.object);
      if (cursor?.has("firstBatch"))
        this._encryptedBatch = cursor.get("firstBatch", bson_1.BSONType.array, true);
      else if (cursor?.has("nextBatch"))
        this._encryptedBatch = cursor.get("nextBatch", bson_1.BSONType.array, true);
      else
        throw new error_1.MongoUnexpectedServerResponseError("Cursor document did not contain a batch");
      return this._encryptedBatch;
    }
    get batch() {
      if (this._batch != null)
        return this._batch;
      const cursor = this.cursor;
      if (cursor.has("firstBatch"))
        this._batch = cursor.get("firstBatch", bson_1.BSONType.array, true);
      else if (cursor.has("nextBatch"))
        this._batch = cursor.get("nextBatch", bson_1.BSONType.array, true);
      else
        throw new error_1.MongoUnexpectedServerResponseError("Cursor document did not contain a batch");
      return this._batch;
    }
    get batchSize() {
      return this.batch?.size();
    }
    get postBatchResumeToken() {
      return this.cursor.get("postBatchResumeToken", bson_1.BSONType.object)?.toObject({
        promoteValues: false,
        promoteLongs: false,
        promoteBuffers: false,
        validation: { utf8: true }
      }) ?? null;
    }
    shift(options) {
      if (this.iterated >= this.batchSize) {
        return null;
      }
      const result = this.batch.get(this.iterated, bson_1.BSONType.object, true) ?? null;
      const encryptedResult = this.encryptedBatch?.get(this.iterated, bson_1.BSONType.object, true) ?? null;
      this.iterated += 1;
      if (options?.raw) {
        return result.toBytes();
      } else {
        const object = result.toObject(options);
        if (encryptedResult) {
          (0, utils_1.decorateDecryptionResult)(object, encryptedResult.toObject(options), true);
        }
        return object;
      }
    }
    clear() {
      this.iterated = this.batchSize;
    }
  }
  exports.CursorResponse = CursorResponse;
  CursorResponse.emptyGetMore = {
    id: new bson_1.Long(0),
    length: 0,
    shift: () => null
  };

  class ExplainedCursorResponse extends CursorResponse {
    constructor() {
      super(...arguments);
      this.isExplain = true;
      this._length = 1;
    }
    get id() {
      return bson_1.Long.fromBigInt(0n);
    }
    get batchSize() {
      return 0;
    }
    get ns() {
      return null;
    }
    get length() {
      return this._length;
    }
    shift(options) {
      if (this._length === 0)
        return null;
      this._length -= 1;
      return this.toObject(options);
    }
  }
  exports.ExplainedCursorResponse = ExplainedCursorResponse;

  class ClientBulkWriteCursorResponse extends CursorResponse {
    get insertedCount() {
      return this.get("nInserted", bson_1.BSONType.int, true);
    }
    get upsertedCount() {
      return this.get("nUpserted", bson_1.BSONType.int, true);
    }
    get matchedCount() {
      return this.get("nMatched", bson_1.BSONType.int, true);
    }
    get modifiedCount() {
      return this.get("nModified", bson_1.BSONType.int, true);
    }
    get deletedCount() {
      return this.get("nDeleted", bson_1.BSONType.int, true);
    }
    get writeConcernError() {
      return this.get("writeConcernError", bson_1.BSONType.object, false);
    }
  }
  exports.ClientBulkWriteCursorResponse = ClientBulkWriteCursorResponse;
});

// node_modules/mongodb/lib/write_concern.js
var require_write_concern = __commonJS((exports) => {
  function throwIfWriteConcernError(response) {
    if (typeof response === "object" && response != null) {
      const writeConcernError = responses_1.MongoDBResponse.is(response) && response.has("writeConcernError") ? response.toObject() : !responses_1.MongoDBResponse.is(response) && ("writeConcernError" in response) ? response : null;
      if (writeConcernError != null) {
        throw new error_1.MongoWriteConcernError(writeConcernError);
      }
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WriteConcern = exports.WRITE_CONCERN_KEYS = undefined;
  exports.throwIfWriteConcernError = throwIfWriteConcernError;
  var responses_1 = require_responses();
  var error_1 = require_error();
  exports.WRITE_CONCERN_KEYS = ["w", "wtimeout", "j", "journal", "fsync"];

  class WriteConcern {
    constructor(w, wtimeoutMS, journal, fsync) {
      if (w != null) {
        if (!Number.isNaN(Number(w))) {
          this.w = Number(w);
        } else {
          this.w = w;
        }
      }
      if (wtimeoutMS != null) {
        this.wtimeoutMS = this.wtimeout = wtimeoutMS;
      }
      if (journal != null) {
        this.journal = this.j = journal;
      }
      if (fsync != null) {
        this.journal = this.j = fsync ? true : false;
      }
    }
    static apply(command, writeConcern) {
      const wc = {};
      if (writeConcern.w != null)
        wc.w = writeConcern.w;
      if (writeConcern.wtimeoutMS != null)
        wc.wtimeout = writeConcern.wtimeoutMS;
      if (writeConcern.journal != null)
        wc.j = writeConcern.j;
      command.writeConcern = wc;
      return command;
    }
    static fromOptions(options, inherit) {
      if (options == null)
        return;
      inherit = inherit ?? {};
      let opts;
      if (typeof options === "string" || typeof options === "number") {
        opts = { w: options };
      } else if (options instanceof WriteConcern) {
        opts = options;
      } else {
        opts = options.writeConcern;
      }
      const parentOpts = inherit instanceof WriteConcern ? inherit : inherit.writeConcern;
      const { w = undefined, wtimeout = undefined, j = undefined, fsync = undefined, journal = undefined, wtimeoutMS = undefined } = {
        ...parentOpts,
        ...opts
      };
      if (w != null || wtimeout != null || wtimeoutMS != null || j != null || journal != null || fsync != null) {
        return new WriteConcern(w, wtimeout ?? wtimeoutMS, j ?? journal, fsync);
      }
      return;
    }
  }
  exports.WriteConcern = WriteConcern;
});

// node_modules/mongodb/lib/utils.js
var require_utils2 = __commonJS((exports) => {
  function isUint8Array(value) {
    return value != null && typeof value === "object" && Symbol.toStringTag in value && value[Symbol.toStringTag] === "Uint8Array";
  }
  function hostMatchesWildcards(host, wildcards) {
    for (const wildcard of wildcards) {
      if (host === wildcard || wildcard.startsWith("*.") && host?.endsWith(wildcard.substring(2, wildcard.length)) || wildcard.startsWith("*/") && host?.endsWith(wildcard.substring(2, wildcard.length))) {
        return true;
      }
    }
    return false;
  }
  function normalizeHintField(hint) {
    let finalHint = undefined;
    if (typeof hint === "string") {
      finalHint = hint;
    } else if (Array.isArray(hint)) {
      finalHint = {};
      hint.forEach((param) => {
        finalHint[param] = 1;
      });
    } else if (hint != null && typeof hint === "object") {
      finalHint = {};
      for (const name in hint) {
        finalHint[name] = hint[name];
      }
    }
    return finalHint;
  }
  function isObject(arg) {
    return TO_STRING(arg) === "[object Object]";
  }
  function mergeOptions(target, source) {
    return { ...target, ...source };
  }
  function filterOptions(options, names) {
    const filterOptions2 = {};
    for (const name in options) {
      if (names.includes(name)) {
        filterOptions2[name] = options[name];
      }
    }
    return filterOptions2;
  }
  function applyRetryableWrites(target, db) {
    if (db && db.s.options?.retryWrites) {
      target.retryWrites = true;
    }
    return target;
  }
  function isPromiseLike(value) {
    return value != null && typeof value === "object" && "then" in value && typeof value.then === "function";
  }
  function decorateWithCollation(command, target, options) {
    const capabilities = getTopology(target).capabilities;
    if (options.collation && typeof options.collation === "object") {
      if (capabilities && capabilities.commandsTakeCollation) {
        command.collation = options.collation;
      } else {
        throw new error_1.MongoCompatibilityError(`Current topology does not support collation`);
      }
    }
  }
  function decorateWithReadConcern(command, coll, options) {
    if (options && options.session && options.session.inTransaction()) {
      return;
    }
    const readConcern = Object.assign({}, command.readConcern || {});
    if (coll.s.readConcern) {
      Object.assign(readConcern, coll.s.readConcern);
    }
    if (Object.keys(readConcern).length > 0) {
      Object.assign(command, { readConcern });
    }
  }
  function getTopology(provider) {
    if ("topology" in provider && provider.topology) {
      return provider.topology;
    } else if ("client" in provider && provider.client.topology) {
      return provider.client.topology;
    }
    throw new error_1.MongoNotConnectedError("MongoClient must be connected to perform this operation");
  }
  function ns(ns2) {
    return MongoDBNamespace.fromString(ns2);
  }
  function* makeCounter(seed = 0) {
    let count = seed;
    while (true) {
      const newCount = count;
      count += 1;
      yield newCount;
    }
  }
  function uuidV4() {
    const result = crypto3.randomBytes(16);
    result[6] = result[6] & 15 | 64;
    result[8] = result[8] & 63 | 128;
    return result;
  }
  function maxWireVersion(topologyOrServer) {
    if (topologyOrServer) {
      if (topologyOrServer.loadBalanced || topologyOrServer.serverApi?.version) {
        return constants_1.MAX_SUPPORTED_WIRE_VERSION;
      }
      if (topologyOrServer.hello) {
        return topologyOrServer.hello.maxWireVersion;
      }
      if ("lastHello" in topologyOrServer && typeof topologyOrServer.lastHello === "function") {
        const lastHello = topologyOrServer.lastHello();
        if (lastHello) {
          return lastHello.maxWireVersion;
        }
      }
      if (topologyOrServer.description && "maxWireVersion" in topologyOrServer.description && topologyOrServer.description.maxWireVersion != null) {
        return topologyOrServer.description.maxWireVersion;
      }
    }
    return 0;
  }
  function arrayStrictEqual(arr, arr2) {
    if (!Array.isArray(arr) || !Array.isArray(arr2)) {
      return false;
    }
    return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);
  }
  function errorStrictEqual(lhs, rhs) {
    if (lhs === rhs) {
      return true;
    }
    if (!lhs || !rhs) {
      return lhs === rhs;
    }
    if (lhs == null && rhs != null || lhs != null && rhs == null) {
      return false;
    }
    if (lhs.constructor.name !== rhs.constructor.name) {
      return false;
    }
    if (lhs.message !== rhs.message) {
      return false;
    }
    return true;
  }
  function makeStateMachine(stateTable) {
    return function stateTransition(target, newState) {
      const legalStates = stateTable[target.s.state];
      if (legalStates && legalStates.indexOf(newState) < 0) {
        throw new error_1.MongoRuntimeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);
      }
      target.emit("stateChanged", target.s.state, newState);
      target.s.state = newState;
    };
  }
  function now() {
    const hrtime = process.hrtime();
    return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1e6);
  }
  function calculateDurationInMs(started) {
    if (typeof started !== "number") {
      return -1;
    }
    const elapsed = now() - started;
    return elapsed < 0 ? 0 : elapsed;
  }
  function hasAtomicOperators(doc) {
    if (Array.isArray(doc)) {
      for (const document2 of doc) {
        if (hasAtomicOperators(document2)) {
          return true;
        }
      }
      return false;
    }
    const keys = Object.keys(doc);
    return keys.length > 0 && keys[0][0] === "$";
  }
  function resolveTimeoutOptions(client, options) {
    const { socketTimeoutMS, serverSelectionTimeoutMS, waitQueueTimeoutMS, timeoutMS } = client.s.options;
    return { socketTimeoutMS, serverSelectionTimeoutMS, waitQueueTimeoutMS, timeoutMS, ...options };
  }
  function resolveOptions(parent, options) {
    const result = Object.assign({}, options, (0, bson_1.resolveBSONOptions)(options, parent));
    const timeoutMS = options?.timeoutMS ?? parent?.timeoutMS;
    const session = options?.session;
    if (!session?.inTransaction()) {
      const readConcern = read_concern_1.ReadConcern.fromOptions(options) ?? parent?.readConcern;
      if (readConcern) {
        result.readConcern = readConcern;
      }
      let writeConcern = write_concern_1.WriteConcern.fromOptions(options) ?? parent?.writeConcern;
      if (writeConcern) {
        if (timeoutMS != null) {
          writeConcern = write_concern_1.WriteConcern.fromOptions({
            ...writeConcern,
            wtimeout: undefined,
            wtimeoutMS: undefined
          });
        }
        result.writeConcern = writeConcern;
      }
    }
    result.timeoutMS = timeoutMS;
    const readPreference = read_preference_1.ReadPreference.fromOptions(options) ?? parent?.readPreference;
    if (readPreference) {
      result.readPreference = readPreference;
    }
    const isConvenientTransaction = session?.explicit && session?.timeoutContext != null;
    if (isConvenientTransaction && options?.timeoutMS != null) {
      throw new error_1.MongoInvalidArgumentError("An operation cannot be given a timeoutMS setting when inside a withTransaction call that has a timeoutMS setting");
    }
    return result;
  }
  function isSuperset(set, subset) {
    set = Array.isArray(set) ? new Set(set) : set;
    subset = Array.isArray(subset) ? new Set(subset) : subset;
    for (const elem of subset) {
      if (!set.has(elem)) {
        return false;
      }
    }
    return true;
  }
  function isHello(doc) {
    return doc[constants_2.LEGACY_HELLO_COMMAND] || doc.hello ? true : false;
  }
  function setDifference(setA, setB) {
    const difference = new Set(setA);
    for (const elem of setB) {
      difference.delete(elem);
    }
    return difference;
  }
  function isRecord(value, requiredKeys = undefined) {
    if (!isObject(value)) {
      return false;
    }
    const ctor = value.constructor;
    if (ctor && ctor.prototype) {
      if (!isObject(ctor.prototype)) {
        return false;
      }
      if (!HAS_OWN(ctor.prototype, "isPrototypeOf")) {
        return false;
      }
    }
    if (requiredKeys) {
      const keys = Object.keys(value);
      return isSuperset(keys, requiredKeys);
    }
    return true;
  }
  function emitWarning(message) {
    return process.emitWarning(message, { code: exports.MONGODB_WARNING_CODE });
  }
  function emitWarningOnce(message) {
    if (!emittedWarnings.has(message)) {
      emittedWarnings.add(message);
      return emitWarning(message);
    }
  }
  function enumToString(en) {
    return Object.values(en).join(", ");
  }
  function supportsRetryableWrites(server) {
    if (!server) {
      return false;
    }
    if (server.loadBalanced) {
      return true;
    }
    if (server.description.logicalSessionTimeoutMinutes != null) {
      if (server.description.type !== common_1.ServerType.Standalone) {
        return true;
      }
    }
    return false;
  }
  function shuffle(sequence, limit = 0) {
    const items = Array.from(sequence);
    if (limit > items.length) {
      throw new error_1.MongoRuntimeError("Limit must be less than the number of items");
    }
    let remainingItemsToShuffle = items.length;
    const lowerBound = limit % items.length === 0 ? 1 : items.length - limit;
    while (remainingItemsToShuffle > lowerBound) {
      const randomIndex = Math.floor(Math.random() * remainingItemsToShuffle);
      remainingItemsToShuffle -= 1;
      const swapHold = items[remainingItemsToShuffle];
      items[remainingItemsToShuffle] = items[randomIndex];
      items[randomIndex] = swapHold;
    }
    return limit % items.length === 0 ? items : items.slice(lowerBound);
  }
  function commandSupportsReadConcern(command) {
    if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {
      return true;
    }
    return false;
  }
  function compareObjectId(oid1, oid2) {
    if (oid1 == null && oid2 == null) {
      return 0;
    }
    if (oid1 == null) {
      return -1;
    }
    if (oid2 == null) {
      return 1;
    }
    return exports.ByteUtils.compare(oid1.id, oid2.id);
  }
  function parseInteger(value) {
    if (typeof value === "number")
      return Math.trunc(value);
    const parsedValue = Number.parseInt(String(value), 10);
    return Number.isNaN(parsedValue) ? null : parsedValue;
  }
  function parseUnsignedInteger(value) {
    const parsedInt = parseInteger(value);
    return parsedInt != null && parsedInt >= 0 ? parsedInt : null;
  }
  function checkParentDomainMatch(address, srvHost) {
    const normalizedAddress = address.endsWith(".") ? address.slice(0, address.length - 1) : address;
    const normalizedSrvHost = srvHost.endsWith(".") ? srvHost.slice(0, srvHost.length - 1) : srvHost;
    const allCharacterBeforeFirstDot = /^.*?\./;
    const srvIsLessThanThreeParts = normalizedSrvHost.split(".").length < 3;
    const addressDomain = `.${normalizedAddress.replace(allCharacterBeforeFirstDot, "")}`;
    let srvHostDomain = srvIsLessThanThreeParts ? normalizedSrvHost : `.${normalizedSrvHost.replace(allCharacterBeforeFirstDot, "")}`;
    if (!srvHostDomain.startsWith(".")) {
      srvHostDomain = "." + srvHostDomain;
    }
    if (srvIsLessThanThreeParts && normalizedAddress.split(".").length <= normalizedSrvHost.split(".").length) {
      throw new error_1.MongoAPIError("Server record does not have at least one more domain level than parent URI");
    }
    if (!addressDomain.endsWith(srvHostDomain)) {
      throw new error_1.MongoAPIError("Server record does not share hostname with parent URI");
    }
  }
  function get(url2, options = {}) {
    return new Promise((resolve, reject) => {
      let timeoutId;
      const request2 = http.get(url2, options, (response) => {
        response.setEncoding("utf8");
        let body = "";
        response.on("data", (chunk) => body += chunk);
        response.on("end", () => {
          (0, timers_1.clearTimeout)(timeoutId);
          resolve({ status: response.statusCode, body });
        });
      }).on("error", (error) => {
        (0, timers_1.clearTimeout)(timeoutId);
        reject(error);
      }).end();
      timeoutId = (0, timers_1.setTimeout)(() => {
        request2.destroy(new error_1.MongoNetworkTimeoutError(`request timed out after 10 seconds`));
      }, 1e4);
    });
  }
  async function request(uri, options = {}) {
    return await new Promise((resolve, reject) => {
      const requestOptions = {
        method: "GET",
        timeout: 1e4,
        json: true,
        ...url.parse(uri),
        ...options
      };
      const req = http.request(requestOptions, (res) => {
        res.setEncoding("utf8");
        let data = "";
        res.on("data", (d) => {
          data += d;
        });
        res.once("end", () => {
          if (options.json === false) {
            resolve(data);
            return;
          }
          try {
            const parsed = JSON.parse(data);
            resolve(parsed);
          } catch {
            reject(new error_1.MongoRuntimeError(`Invalid JSON response: "${data}"`));
          }
        });
      });
      req.once("timeout", () => req.destroy(new error_1.MongoNetworkTimeoutError(`Network request to ${uri} timed out after ${options.timeout} ms`)));
      req.once("error", (error) => reject(error));
      req.end();
    });
  }
  function isHostMatch(match, host) {
    return host && match.test(host.toLowerCase()) ? true : false;
  }
  function promiseWithResolvers() {
    let resolve;
    let reject;
    const promise = new Promise(function withResolversExecutor(promiseResolve, promiseReject) {
      resolve = promiseResolve;
      reject = promiseReject;
    });
    return { promise, resolve, reject };
  }
  function squashError(_error) {
    return;
  }
  async function once(ee, name, options) {
    options?.signal?.throwIfAborted();
    const { promise, resolve, reject } = promiseWithResolvers();
    const onEvent = (data) => resolve(data);
    const onError = (error) => reject(error);
    const abortListener = addAbortListener(options?.signal, function() {
      reject(this.reason);
    });
    ee.once(name, onEvent).once("error", onError);
    try {
      return await promise;
    } finally {
      ee.off(name, onEvent);
      ee.off("error", onError);
      abortListener?.[exports.kDispose]();
    }
  }
  function maybeAddIdToDocuments(coll, docOrDocs, options) {
    const forceServerObjectId = typeof options.forceServerObjectId === "boolean" ? options.forceServerObjectId : coll.s.db.options?.forceServerObjectId;
    if (forceServerObjectId === true) {
      return docOrDocs;
    }
    const transform = (doc) => {
      if (doc._id == null) {
        doc._id = coll.s.pkFactory.createPk();
      }
      return doc;
    };
    return Array.isArray(docOrDocs) ? docOrDocs.map(transform) : transform(docOrDocs);
  }
  async function fileIsAccessible(fileName, mode) {
    try {
      await fs_1.promises.access(fileName, mode);
      return true;
    } catch {
      return false;
    }
  }
  function csotMin(duration1, duration2) {
    if (duration1 === 0)
      return duration2;
    if (duration2 === 0)
      return duration1;
    return Math.min(duration1, duration2);
  }
  function noop() {
    return;
  }
  function decorateDecryptionResult(decrypted, original, isTopLevelDecorateCall = true) {
    if (isTopLevelDecorateCall) {
      if (Buffer.isBuffer(original)) {
        original = (0, bson_1.deserialize)(original);
      }
      if (Buffer.isBuffer(decrypted)) {
        throw new error_1.MongoRuntimeError("Expected result of decryption to be deserialized BSON object");
      }
    }
    if (!decrypted || typeof decrypted !== "object")
      return;
    for (const k of Object.keys(decrypted)) {
      const originalValue = original[k];
      if (originalValue && originalValue._bsontype === "Binary" && originalValue.sub_type === 6) {
        if (!decrypted[constants_2.kDecoratedKeys]) {
          Object.defineProperty(decrypted, constants_2.kDecoratedKeys, {
            value: [],
            configurable: true,
            enumerable: false,
            writable: false
          });
        }
        decrypted[constants_2.kDecoratedKeys].push(k);
        continue;
      }
      decorateDecryptionResult(decrypted[k], originalValue, false);
    }
  }
  function addAbortListener(signal, listener) {
    if (signal == null)
      return;
    signal.addEventListener("abort", listener, { once: true });
    return { [exports.kDispose]: () => signal.removeEventListener("abort", listener) };
  }
  async function abortable(promise, { signal }) {
    if (signal == null) {
      return await promise;
    }
    const { promise: aborted, reject } = promiseWithResolvers();
    const abortListener = signal.aborted ? reject(signal.reason) : addAbortListener(signal, function() {
      reject(this.reason);
    });
    try {
      return await Promise.race([promise, aborted]);
    } finally {
      abortListener?.[exports.kDispose]();
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.kDispose = exports.randomBytes = exports.COSMOS_DB_MSG = exports.DOCUMENT_DB_MSG = exports.COSMOS_DB_CHECK = exports.DOCUMENT_DB_CHECK = exports.MONGODB_WARNING_CODE = exports.DEFAULT_PK_FACTORY = exports.HostAddress = exports.BufferPool = exports.List = exports.MongoDBCollectionNamespace = exports.MongoDBNamespace = exports.ByteUtils = undefined;
  exports.isUint8Array = isUint8Array;
  exports.hostMatchesWildcards = hostMatchesWildcards;
  exports.normalizeHintField = normalizeHintField;
  exports.isObject = isObject;
  exports.mergeOptions = mergeOptions;
  exports.filterOptions = filterOptions;
  exports.applyRetryableWrites = applyRetryableWrites;
  exports.isPromiseLike = isPromiseLike;
  exports.decorateWithCollation = decorateWithCollation;
  exports.decorateWithReadConcern = decorateWithReadConcern;
  exports.getTopology = getTopology;
  exports.ns = ns;
  exports.makeCounter = makeCounter;
  exports.uuidV4 = uuidV4;
  exports.maxWireVersion = maxWireVersion;
  exports.arrayStrictEqual = arrayStrictEqual;
  exports.errorStrictEqual = errorStrictEqual;
  exports.makeStateMachine = makeStateMachine;
  exports.now = now;
  exports.calculateDurationInMs = calculateDurationInMs;
  exports.hasAtomicOperators = hasAtomicOperators;
  exports.resolveTimeoutOptions = resolveTimeoutOptions;
  exports.resolveOptions = resolveOptions;
  exports.isSuperset = isSuperset;
  exports.isHello = isHello;
  exports.setDifference = setDifference;
  exports.isRecord = isRecord;
  exports.emitWarning = emitWarning;
  exports.emitWarningOnce = emitWarningOnce;
  exports.enumToString = enumToString;
  exports.supportsRetryableWrites = supportsRetryableWrites;
  exports.shuffle = shuffle;
  exports.commandSupportsReadConcern = commandSupportsReadConcern;
  exports.compareObjectId = compareObjectId;
  exports.parseInteger = parseInteger;
  exports.parseUnsignedInteger = parseUnsignedInteger;
  exports.checkParentDomainMatch = checkParentDomainMatch;
  exports.get = get;
  exports.request = request;
  exports.isHostMatch = isHostMatch;
  exports.promiseWithResolvers = promiseWithResolvers;
  exports.squashError = squashError;
  exports.once = once;
  exports.maybeAddIdToDocuments = maybeAddIdToDocuments;
  exports.fileIsAccessible = fileIsAccessible;
  exports.csotMin = csotMin;
  exports.noop = noop;
  exports.decorateDecryptionResult = decorateDecryptionResult;
  exports.addAbortListener = addAbortListener;
  exports.abortable = abortable;
  var crypto3 = import.meta.require("crypto");
  var fs_1 = import.meta.require("fs");
  var http = import.meta.require("http");
  var timers_1 = import.meta.require("timers");
  var url = import.meta.require("url");
  var url_1 = import.meta.require("url");
  var util_1 = import.meta.require("util");
  var bson_1 = require_bson2();
  var constants_1 = require_constants();
  var constants_2 = require_constants2();
  var error_1 = require_error();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var common_1 = require_common();
  var write_concern_1 = require_write_concern();
  exports.ByteUtils = {
    toLocalBufferType(buffer) {
      return Buffer.isBuffer(buffer) ? buffer : Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    },
    equals(seqA, seqB) {
      return exports.ByteUtils.toLocalBufferType(seqA).equals(seqB);
    },
    compare(seqA, seqB) {
      return exports.ByteUtils.toLocalBufferType(seqA).compare(seqB);
    },
    toBase64(uint8array) {
      return exports.ByteUtils.toLocalBufferType(uint8array).toString("base64");
    }
  };
  var TO_STRING = (object) => Object.prototype.toString.call(object);

  class MongoDBNamespace {
    constructor(db, collection) {
      this.db = db;
      this.collection = collection;
      this.collection = collection === "" ? undefined : collection;
    }
    toString() {
      return this.collection ? `${this.db}.${this.collection}` : this.db;
    }
    withCollection(collection) {
      return new MongoDBCollectionNamespace(this.db, collection);
    }
    static fromString(namespace) {
      if (typeof namespace !== "string" || namespace === "") {
        throw new error_1.MongoRuntimeError(`Cannot parse namespace from "${namespace}"`);
      }
      const [db, ...collectionParts] = namespace.split(".");
      const collection = collectionParts.join(".");
      return new MongoDBNamespace(db, collection === "" ? undefined : collection);
    }
  }
  exports.MongoDBNamespace = MongoDBNamespace;

  class MongoDBCollectionNamespace extends MongoDBNamespace {
    constructor(db, collection) {
      super(db, collection);
      this.collection = collection;
    }
    static fromString(namespace) {
      return super.fromString(namespace);
    }
  }
  exports.MongoDBCollectionNamespace = MongoDBCollectionNamespace;
  var HAS_OWN = (object, prop) => Object.prototype.hasOwnProperty.call(object, prop);

  class List {
    get length() {
      return this.count;
    }
    get [Symbol.toStringTag]() {
      return "List";
    }
    constructor() {
      this.count = 0;
      this.head = {
        next: null,
        prev: null,
        value: null
      };
      this.head.next = this.head;
      this.head.prev = this.head;
    }
    toArray() {
      return Array.from(this);
    }
    toString() {
      return `head <=> ${this.toArray().join(" <=> ")} <=> head`;
    }
    *[Symbol.iterator]() {
      for (const node of this.nodes()) {
        yield node.value;
      }
    }
    *nodes() {
      let ptr = this.head.next;
      while (ptr !== this.head) {
        const { next } = ptr;
        yield ptr;
        ptr = next;
      }
    }
    push(value) {
      this.count += 1;
      const newNode = {
        next: this.head,
        prev: this.head.prev,
        value
      };
      this.head.prev.next = newNode;
      this.head.prev = newNode;
    }
    pushMany(iterable) {
      for (const value of iterable) {
        this.push(value);
      }
    }
    unshift(value) {
      this.count += 1;
      const newNode = {
        next: this.head.next,
        prev: this.head,
        value
      };
      this.head.next.prev = newNode;
      this.head.next = newNode;
    }
    remove(node) {
      if (node === this.head || this.length === 0) {
        return null;
      }
      this.count -= 1;
      const prevNode = node.prev;
      const nextNode = node.next;
      prevNode.next = nextNode;
      nextNode.prev = prevNode;
      return node.value;
    }
    shift() {
      return this.remove(this.head.next);
    }
    pop() {
      return this.remove(this.head.prev);
    }
    prune(filter) {
      for (const node of this.nodes()) {
        if (filter(node.value)) {
          this.remove(node);
        }
      }
    }
    clear() {
      this.count = 0;
      this.head.next = this.head;
      this.head.prev = this.head;
    }
    first() {
      return this.head.next.value;
    }
    last() {
      return this.head.prev.value;
    }
  }
  exports.List = List;

  class BufferPool {
    constructor() {
      this.buffers = new List;
      this.totalByteLength = 0;
    }
    get length() {
      return this.totalByteLength;
    }
    append(buffer) {
      this.buffers.push(buffer);
      this.totalByteLength += buffer.length;
    }
    getInt32() {
      if (this.totalByteLength < 4) {
        return null;
      }
      const firstBuffer = this.buffers.first();
      if (firstBuffer != null && firstBuffer.byteLength >= 4) {
        return firstBuffer.readInt32LE(0);
      }
      const top4Bytes = this.read(4);
      const value = top4Bytes.readInt32LE(0);
      this.totalByteLength += 4;
      this.buffers.unshift(top4Bytes);
      return value;
    }
    read(size) {
      if (typeof size !== "number" || size < 0) {
        throw new error_1.MongoInvalidArgumentError('Argument "size" must be a non-negative number');
      }
      if (size > this.totalByteLength) {
        return Buffer.alloc(0);
      }
      const result = Buffer.allocUnsafe(size);
      for (let bytesRead = 0;bytesRead < size; ) {
        const buffer = this.buffers.shift();
        if (buffer == null) {
          break;
        }
        const bytesRemaining = size - bytesRead;
        const bytesReadable = Math.min(bytesRemaining, buffer.byteLength);
        const bytes = buffer.subarray(0, bytesReadable);
        result.set(bytes, bytesRead);
        bytesRead += bytesReadable;
        this.totalByteLength -= bytesReadable;
        if (bytesReadable < buffer.byteLength) {
          this.buffers.unshift(buffer.subarray(bytesReadable));
        }
      }
      return result;
    }
  }
  exports.BufferPool = BufferPool;

  class HostAddress {
    constructor(hostString) {
      this.host = undefined;
      this.port = undefined;
      this.socketPath = undefined;
      this.isIPv6 = false;
      const escapedHost = hostString.split(" ").join("%20");
      if (escapedHost.endsWith(".sock")) {
        this.socketPath = decodeURIComponent(escapedHost);
        return;
      }
      const urlString = `iLoveJS://${escapedHost}`;
      let url2;
      try {
        url2 = new url_1.URL(urlString);
      } catch (urlError) {
        const runtimeError = new error_1.MongoRuntimeError(`Unable to parse ${escapedHost} with URL`);
        runtimeError.cause = urlError;
        throw runtimeError;
      }
      const hostname = url2.hostname;
      const port = url2.port;
      let normalized = decodeURIComponent(hostname).toLowerCase();
      if (normalized.startsWith("[") && normalized.endsWith("]")) {
        this.isIPv6 = true;
        normalized = normalized.substring(1, hostname.length - 1);
      }
      this.host = normalized.toLowerCase();
      if (typeof port === "number") {
        this.port = port;
      } else if (typeof port === "string" && port !== "") {
        this.port = Number.parseInt(port, 10);
      } else {
        this.port = 27017;
      }
      if (this.port === 0) {
        throw new error_1.MongoParseError("Invalid port (zero) with hostname");
      }
      Object.freeze(this);
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.inspect();
    }
    inspect() {
      return `new HostAddress('${this.toString()}')`;
    }
    toString() {
      if (typeof this.host === "string") {
        if (this.isIPv6) {
          return `[${this.host}]:${this.port}`;
        }
        return `${this.host}:${this.port}`;
      }
      return `${this.socketPath}`;
    }
    static fromString(s) {
      return new HostAddress(s);
    }
    static fromHostPort(host, port) {
      if (host.includes(":")) {
        host = `[${host}]`;
      }
      return HostAddress.fromString(`${host}:${port}`);
    }
    static fromSrvRecord({ name, port }) {
      return HostAddress.fromHostPort(name, port);
    }
    toHostPort() {
      if (this.socketPath) {
        return { host: this.socketPath, port: 0 };
      }
      const host = this.host ?? "";
      const port = this.port ?? 0;
      return { host, port };
    }
  }
  exports.HostAddress = HostAddress;
  exports.DEFAULT_PK_FACTORY = {
    createPk() {
      return new bson_1.ObjectId;
    }
  };
  exports.MONGODB_WARNING_CODE = "MONGODB DRIVER";
  var emittedWarnings = new Set;
  exports.DOCUMENT_DB_CHECK = /(\.docdb\.amazonaws\.com$)|(\.docdb-elastic\.amazonaws\.com$)/;
  exports.COSMOS_DB_CHECK = /\.cosmos\.azure\.com$/;
  exports.DOCUMENT_DB_MSG = "You appear to be connected to a DocumentDB cluster. For more information regarding feature compatibility and support please visit https://www.mongodb.com/supportability/documentdb";
  exports.COSMOS_DB_MSG = "You appear to be connected to a CosmosDB cluster. For more information regarding feature compatibility and support please visit https://www.mongodb.com/supportability/cosmosdb";
  exports.randomBytes = (0, util_1.promisify)(crypto3.randomBytes);
  exports.kDispose = Symbol.dispose ?? Symbol("dispose");
});

// node_modules/mongodb/lib/timeout.js
var require_timeout = __commonJS((exports) => {
  function isLegacyTimeoutContextOptions(v) {
    return v != null && typeof v === "object" && "serverSelectionTimeoutMS" in v && typeof v.serverSelectionTimeoutMS === "number" && "waitQueueTimeoutMS" in v && typeof v.waitQueueTimeoutMS === "number";
  }
  function isCSOTTimeoutContextOptions(v) {
    return v != null && typeof v === "object" && "serverSelectionTimeoutMS" in v && typeof v.serverSelectionTimeoutMS === "number" && "timeoutMS" in v && typeof v.timeoutMS === "number";
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LegacyTimeoutContext = exports.CSOTTimeoutContext = exports.TimeoutContext = exports.Timeout = exports.TimeoutError = undefined;
  var timers_1 = import.meta.require("timers");
  var error_1 = require_error();
  var utils_1 = require_utils2();

  class TimeoutError extends Error {
    get name() {
      return "TimeoutError";
    }
    constructor(message, options) {
      super(message, options);
      this.duration = options.duration;
    }
    static is(error) {
      return error != null && typeof error === "object" && "name" in error && error.name === "TimeoutError";
    }
  }
  exports.TimeoutError = TimeoutError;

  class Timeout extends Promise {
    get remainingTime() {
      if (this.timedOut)
        return 0;
      if (this.duration === 0)
        return Infinity;
      return this.start + this.duration - Math.trunc(performance.now());
    }
    get timeElapsed() {
      return Math.trunc(performance.now()) - this.start;
    }
    constructor(executor = () => null, options) {
      const duration = options?.duration ?? 0;
      const unref = !!options?.unref;
      const rejection = options?.rejection;
      if (duration < 0) {
        throw new error_1.MongoInvalidArgumentError("Cannot create a Timeout with a negative duration");
      }
      let reject;
      super((_2, promiseReject) => {
        reject = promiseReject;
        executor(utils_1.noop, promiseReject);
      });
      this.ended = null;
      this.timedOut = false;
      this.cleared = false;
      this.duration = duration;
      this.start = Math.trunc(performance.now());
      if (rejection == null && this.duration > 0) {
        this.id = (0, timers_1.setTimeout)(() => {
          this.ended = Math.trunc(performance.now());
          this.timedOut = true;
          reject(new TimeoutError(`Expired after ${duration}ms`, { duration }));
        }, this.duration);
        if (typeof this.id.unref === "function" && unref) {
          this.id.unref();
        }
      } else if (rejection != null) {
        this.ended = Math.trunc(performance.now());
        this.timedOut = true;
        reject(rejection);
      }
    }
    clear() {
      (0, timers_1.clearTimeout)(this.id);
      this.id = undefined;
      this.timedOut = false;
      this.cleared = true;
    }
    throwIfExpired() {
      if (this.timedOut)
        throw new TimeoutError("Timed out", { duration: this.duration });
    }
    static expires(duration, unref) {
      return new Timeout(undefined, { duration, unref });
    }
    static reject(rejection) {
      return new Timeout(undefined, { duration: 0, unref: true, rejection });
    }
  }
  exports.Timeout = Timeout;

  class TimeoutContext {
    static create(options) {
      if (options.session?.timeoutContext != null)
        return options.session?.timeoutContext;
      if (isCSOTTimeoutContextOptions(options))
        return new CSOTTimeoutContext(options);
      else if (isLegacyTimeoutContextOptions(options))
        return new LegacyTimeoutContext(options);
      else
        throw new error_1.MongoRuntimeError("Unrecognized options");
    }
  }
  exports.TimeoutContext = TimeoutContext;

  class CSOTTimeoutContext extends TimeoutContext {
    constructor(options) {
      super();
      this.minRoundTripTime = 0;
      this.start = Math.trunc(performance.now());
      this.timeoutMS = options.timeoutMS;
      this.serverSelectionTimeoutMS = options.serverSelectionTimeoutMS;
      this.socketTimeoutMS = options.socketTimeoutMS;
      this.clearServerSelectionTimeout = false;
    }
    get maxTimeMS() {
      return this.remainingTimeMS - this.minRoundTripTime;
    }
    get remainingTimeMS() {
      const timePassed = Math.trunc(performance.now()) - this.start;
      return this.timeoutMS <= 0 ? Infinity : this.timeoutMS - timePassed;
    }
    csotEnabled() {
      return true;
    }
    get serverSelectionTimeout() {
      if (typeof this._serverSelectionTimeout !== "object" || this._serverSelectionTimeout?.cleared) {
        const { remainingTimeMS, serverSelectionTimeoutMS } = this;
        if (remainingTimeMS <= 0)
          return Timeout.reject(new error_1.MongoOperationTimeoutError(`Timed out in server selection after ${this.timeoutMS}ms`));
        const usingServerSelectionTimeoutMS = serverSelectionTimeoutMS !== 0 && (0, utils_1.csotMin)(remainingTimeMS, serverSelectionTimeoutMS) === serverSelectionTimeoutMS;
        if (usingServerSelectionTimeoutMS) {
          this._serverSelectionTimeout = Timeout.expires(serverSelectionTimeoutMS);
        } else {
          if (remainingTimeMS > 0 && Number.isFinite(remainingTimeMS)) {
            this._serverSelectionTimeout = Timeout.expires(remainingTimeMS);
          } else {
            this._serverSelectionTimeout = null;
          }
        }
      }
      return this._serverSelectionTimeout;
    }
    get connectionCheckoutTimeout() {
      if (typeof this._connectionCheckoutTimeout !== "object" || this._connectionCheckoutTimeout?.cleared) {
        if (typeof this._serverSelectionTimeout === "object") {
          this._connectionCheckoutTimeout = this._serverSelectionTimeout;
        } else {
          throw new error_1.MongoRuntimeError("Unreachable. If you are seeing this error, please file a ticket on the NODE driver project on Jira");
        }
      }
      return this._connectionCheckoutTimeout;
    }
    get timeoutForSocketWrite() {
      const { remainingTimeMS } = this;
      if (!Number.isFinite(remainingTimeMS))
        return null;
      if (remainingTimeMS > 0)
        return Timeout.expires(remainingTimeMS);
      return Timeout.reject(new error_1.MongoOperationTimeoutError("Timed out before socket write"));
    }
    get timeoutForSocketRead() {
      const { remainingTimeMS } = this;
      if (!Number.isFinite(remainingTimeMS))
        return null;
      if (remainingTimeMS > 0)
        return Timeout.expires(remainingTimeMS);
      return Timeout.reject(new error_1.MongoOperationTimeoutError("Timed out before socket read"));
    }
    refresh() {
      this.start = Math.trunc(performance.now());
      this.minRoundTripTime = 0;
      this._serverSelectionTimeout?.clear();
      this._connectionCheckoutTimeout?.clear();
    }
    clear() {
      this._serverSelectionTimeout?.clear();
      this._connectionCheckoutTimeout?.clear();
    }
    getRemainingTimeMSOrThrow(message) {
      const { remainingTimeMS } = this;
      if (remainingTimeMS <= 0)
        throw new error_1.MongoOperationTimeoutError(message ?? `Expired after ${this.timeoutMS}ms`);
      return remainingTimeMS;
    }
    clone() {
      const timeoutContext = new CSOTTimeoutContext({
        timeoutMS: this.timeoutMS,
        serverSelectionTimeoutMS: this.serverSelectionTimeoutMS
      });
      timeoutContext.start = this.start;
      return timeoutContext;
    }
    refreshed() {
      return new CSOTTimeoutContext(this);
    }
    addMaxTimeMSToCommand(command, options) {
      if (options.omitMaxTimeMS)
        return;
      const maxTimeMS = this.remainingTimeMS - this.minRoundTripTime;
      if (maxTimeMS > 0 && Number.isFinite(maxTimeMS))
        command.maxTimeMS = maxTimeMS;
    }
    getSocketTimeoutMS() {
      return 0;
    }
  }
  exports.CSOTTimeoutContext = CSOTTimeoutContext;

  class LegacyTimeoutContext extends TimeoutContext {
    constructor(options) {
      super();
      this.options = options;
      this.clearServerSelectionTimeout = true;
    }
    csotEnabled() {
      return false;
    }
    get serverSelectionTimeout() {
      if (this.options.serverSelectionTimeoutMS != null && this.options.serverSelectionTimeoutMS > 0)
        return Timeout.expires(this.options.serverSelectionTimeoutMS);
      return null;
    }
    get connectionCheckoutTimeout() {
      if (this.options.waitQueueTimeoutMS != null && this.options.waitQueueTimeoutMS > 0)
        return Timeout.expires(this.options.waitQueueTimeoutMS);
      return null;
    }
    get timeoutForSocketWrite() {
      return null;
    }
    get timeoutForSocketRead() {
      return null;
    }
    refresh() {
      return;
    }
    clear() {
      return;
    }
    get maxTimeMS() {
      return null;
    }
    refreshed() {
      return new LegacyTimeoutContext(this.options);
    }
    addMaxTimeMSToCommand(_command, _options) {
    }
    getSocketTimeoutMS() {
      return this.options.socketTimeoutMS;
    }
  }
  exports.LegacyTimeoutContext = LegacyTimeoutContext;
});

// node_modules/mongodb/lib/operations/operation.js
var require_operation = __commonJS((exports) => {
  function defineAspects(operation, aspects) {
    if (!Array.isArray(aspects) && !(aspects instanceof Set)) {
      aspects = [aspects];
    }
    aspects = new Set(aspects);
    Object.defineProperty(operation, "aspects", {
      value: aspects,
      writable: false
    });
    return aspects;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbstractOperation = exports.Aspect = undefined;
  exports.defineAspects = defineAspects;
  var bson_1 = require_bson2();
  var read_preference_1 = require_read_preference();
  exports.Aspect = {
    READ_OPERATION: Symbol("READ_OPERATION"),
    WRITE_OPERATION: Symbol("WRITE_OPERATION"),
    RETRYABLE: Symbol("RETRYABLE"),
    EXPLAINABLE: Symbol("EXPLAINABLE"),
    SKIP_COLLATION: Symbol("SKIP_COLLATION"),
    CURSOR_CREATING: Symbol("CURSOR_CREATING"),
    MUST_SELECT_SAME_SERVER: Symbol("MUST_SELECT_SAME_SERVER"),
    COMMAND_BATCHING: Symbol("COMMAND_BATCHING")
  };

  class AbstractOperation {
    constructor(options = {}) {
      this.readPreference = this.hasAspect(exports.Aspect.WRITE_OPERATION) ? read_preference_1.ReadPreference.primary : read_preference_1.ReadPreference.fromOptions(options) ?? read_preference_1.ReadPreference.primary;
      this.bsonOptions = (0, bson_1.resolveBSONOptions)(options);
      this._session = options.session != null ? options.session : undefined;
      this.options = options;
      this.bypassPinningCheck = !!options.bypassPinningCheck;
      this.trySecondaryWrite = false;
    }
    hasAspect(aspect) {
      const ctor = this.constructor;
      if (ctor.aspects == null) {
        return false;
      }
      return ctor.aspects.has(aspect);
    }
    get session() {
      return this._session;
    }
    clearSession() {
      this._session = undefined;
    }
    resetBatch() {
      return true;
    }
    get canRetryRead() {
      return this.hasAspect(exports.Aspect.RETRYABLE) && this.hasAspect(exports.Aspect.READ_OPERATION);
    }
    get canRetryWrite() {
      return this.hasAspect(exports.Aspect.RETRYABLE) && this.hasAspect(exports.Aspect.WRITE_OPERATION);
    }
  }
  exports.AbstractOperation = AbstractOperation;
});

// node_modules/mongodb/lib/operations/execute_operation.js
var require_execute_operation = __commonJS((exports) => {
  async function executeOperation(client, operation, timeoutContext) {
    if (!(operation instanceof operation_1.AbstractOperation)) {
      throw new error_1.MongoRuntimeError("This method requires a valid operation instance");
    }
    const topology = client.topology == null ? await (0, utils_1.abortable)(autoConnect(client), operation.options) : client.topology;
    let session = operation.session;
    let owner;
    if (session == null) {
      owner = Symbol();
      session = client.startSession({ owner, explicit: false });
    } else if (session.hasEnded) {
      throw new error_1.MongoExpiredSessionError("Use of expired sessions is not permitted");
    } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {
      throw new error_1.MongoCompatibilityError("Snapshot reads require MongoDB 5.0 or later");
    } else if (session.client !== client) {
      throw new error_1.MongoInvalidArgumentError("ClientSession must be from the same MongoClient");
    }
    const readPreference = operation.readPreference ?? read_preference_1.ReadPreference.primary;
    const inTransaction = !!session?.inTransaction();
    const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);
    if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary) && (hasReadAspect || operation.commandName === "runCommand")) {
      throw new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`);
    }
    if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {
      session.unpin();
    }
    timeoutContext ??= timeout_1.TimeoutContext.create({
      session,
      serverSelectionTimeoutMS: client.s.options.serverSelectionTimeoutMS,
      waitQueueTimeoutMS: client.s.options.waitQueueTimeoutMS,
      timeoutMS: operation.options.timeoutMS
    });
    try {
      return await tryOperation(operation, {
        topology,
        timeoutContext,
        session,
        readPreference
      });
    } finally {
      if (session?.owner != null && session.owner === owner) {
        await session.endSession();
      }
    }
  }
  async function autoConnect(client) {
    if (client.topology == null) {
      if (client.s.hasBeenClosed) {
        throw new error_1.MongoNotConnectedError("Client must be connected before running operations");
      }
      client.s.options.__skipPingOnConnect = true;
      try {
        await client.connect();
        if (client.topology == null) {
          throw new error_1.MongoRuntimeError("client.connect did not create a topology but also did not throw");
        }
        return client.topology;
      } finally {
        delete client.s.options.__skipPingOnConnect;
      }
    }
    return client.topology;
  }
  async function tryOperation(operation, { topology, timeoutContext, session, readPreference }) {
    let selector;
    if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {
      selector = (0, server_selection_1.sameServerSelector)(operation.server?.description);
    } else if (operation.trySecondaryWrite) {
      selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);
    } else {
      selector = readPreference;
    }
    let server = await topology.selectServer(selector, {
      session,
      operationName: operation.commandName,
      timeoutContext,
      signal: operation.options.signal
    });
    const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);
    const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);
    const inTransaction = session?.inTransaction() ?? false;
    const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;
    const willRetryWrite = topology.s.options.retryWrites && !inTransaction && (0, utils_1.supportsRetryableWrites)(server) && operation.canRetryWrite;
    const willRetry = operation.hasAspect(operation_1.Aspect.RETRYABLE) && session != null && (hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite);
    if (hasWriteAspect && willRetryWrite && session != null) {
      operation.options.willRetryWrite = true;
      session.incrementTransactionNumber();
    }
    const maxTries = willRetry ? timeoutContext.csotEnabled() ? Infinity : 2 : 1;
    let previousOperationError;
    let previousServer;
    for (let tries = 0;tries < maxTries; tries++) {
      if (previousOperationError) {
        if (hasWriteAspect && previousOperationError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {
          throw new error_1.MongoServerError({
            message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
            errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,
            originalError: previousOperationError
          });
        }
        if (operation.hasAspect(operation_1.Aspect.COMMAND_BATCHING) && !operation.canRetryWrite) {
          throw previousOperationError;
        }
        if (hasWriteAspect && !(0, error_1.isRetryableWriteError)(previousOperationError))
          throw previousOperationError;
        if (hasReadAspect && !(0, error_1.isRetryableReadError)(previousOperationError))
          throw previousOperationError;
        if (previousOperationError instanceof error_1.MongoNetworkError && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING) && session != null && session.isPinned && !session.inTransaction()) {
          session.unpin({ force: true, forceClear: true });
        }
        server = await topology.selectServer(selector, {
          session,
          operationName: operation.commandName,
          previousServer,
          signal: operation.options.signal
        });
        if (hasWriteAspect && !(0, utils_1.supportsRetryableWrites)(server)) {
          throw new error_1.MongoUnexpectedServerResponseError("Selected server does not support retryable writes");
        }
      }
      try {
        if (tries > 0 && operation.hasAspect(operation_1.Aspect.COMMAND_BATCHING)) {
          operation.resetBatch();
        }
        return await operation.execute(server, session, timeoutContext);
      } catch (operationError) {
        if (!(operationError instanceof error_1.MongoError))
          throw operationError;
        if (previousOperationError != null && operationError.hasErrorLabel(error_1.MongoErrorLabel.NoWritesPerformed)) {
          throw previousOperationError;
        }
        previousServer = server.description;
        previousOperationError = operationError;
        timeoutContext.clear();
      }
    }
    throw previousOperationError ?? new error_1.MongoRuntimeError("Tried to propagate retryability error, but no error was found.");
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.executeOperation = executeOperation;
  var error_1 = require_error();
  var read_preference_1 = require_read_preference();
  var server_selection_1 = require_server_selection();
  var timeout_1 = require_timeout();
  var utils_1 = require_utils2();
  var operation_1 = require_operation();
  var MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;
  var MMAPv1_RETRY_WRITES_ERROR_MESSAGE = "This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.";
});

// node_modules/mongodb/lib/mongo_logger.js
var require_mongo_logger = __commonJS((exports) => {
  function parseSeverityFromString(s) {
    const validSeverities = Object.values(exports.SeverityLevel);
    const lowerSeverity = s?.toLowerCase();
    if (lowerSeverity != null && validSeverities.includes(lowerSeverity)) {
      return lowerSeverity;
    }
    return null;
  }
  function createStdioLogger(stream) {
    return {
      write: (0, util_1.promisify)((log2, cb) => {
        const logLine = (0, util_1.inspect)(log2, { compact: true, breakLength: Infinity });
        stream.write(`${logLine}\n`, "utf-8", cb);
        return;
      })
    };
  }
  function resolveLogPath({ MONGODB_LOG_PATH }, { mongodbLogPath }) {
    if (typeof mongodbLogPath === "string" && /^stderr$/i.test(mongodbLogPath)) {
      return { mongodbLogPath: createStdioLogger(process.stderr), mongodbLogPathIsStdErr: true };
    }
    if (typeof mongodbLogPath === "string" && /^stdout$/i.test(mongodbLogPath)) {
      return { mongodbLogPath: createStdioLogger(process.stdout), mongodbLogPathIsStdErr: false };
    }
    if (typeof mongodbLogPath === "object" && typeof mongodbLogPath?.write === "function") {
      return { mongodbLogPath, mongodbLogPathIsStdErr: false };
    }
    if (MONGODB_LOG_PATH && /^stderr$/i.test(MONGODB_LOG_PATH)) {
      return { mongodbLogPath: createStdioLogger(process.stderr), mongodbLogPathIsStdErr: true };
    }
    if (MONGODB_LOG_PATH && /^stdout$/i.test(MONGODB_LOG_PATH)) {
      return { mongodbLogPath: createStdioLogger(process.stdout), mongodbLogPathIsStdErr: false };
    }
    return { mongodbLogPath: createStdioLogger(process.stderr), mongodbLogPathIsStdErr: true };
  }
  function resolveSeverityConfiguration(clientOption, environmentOption, defaultSeverity) {
    return parseSeverityFromString(clientOption) ?? parseSeverityFromString(environmentOption) ?? defaultSeverity;
  }
  function compareSeverity(s0, s1) {
    const s0Num = exports.SEVERITY_LEVEL_MAP.getNumericSeverityLevel(s0);
    const s1Num = exports.SEVERITY_LEVEL_MAP.getNumericSeverityLevel(s1);
    return s0Num < s1Num ? -1 : s0Num > s1Num ? 1 : 0;
  }
  function stringifyWithMaxLen(value, maxDocumentLength, options = {}) {
    let strToTruncate = "";
    let currentLength = 0;
    const maxDocumentLengthEnsurer = function maxDocumentLengthEnsurer(key, value2) {
      if (currentLength >= maxDocumentLength) {
        return;
      }
      if (key === "") {
        currentLength += 1;
        return value2;
      }
      currentLength += key.length + 4;
      if (value2 == null)
        return value2;
      switch (typeof value2) {
        case "string":
          currentLength += value2.length + 2;
          break;
        case "number":
        case "bigint":
          currentLength += String(value2).length;
          break;
        case "boolean":
          currentLength += value2 ? 4 : 5;
          break;
        case "object":
          if ((0, types_1.isUint8Array)(value2)) {
            currentLength += 22 + value2.byteLength + value2.byteLength * 0.33 + 18 | 0;
          } else if ("_bsontype" in value2) {
            const v = value2;
            switch (v._bsontype) {
              case "Int32":
                currentLength += String(v.value).length;
                break;
              case "Double":
                currentLength += (v.value | 0) === v.value ? String(v.value).length + 2 : String(v.value).length;
                break;
              case "Long":
                currentLength += v.toString().length;
                break;
              case "ObjectId":
                currentLength += 35;
                break;
              case "MaxKey":
              case "MinKey":
                currentLength += 13;
                break;
              case "Binary":
                currentLength += 22 + value2.position + value2.position * 0.33 + 18 | 0;
                break;
              case "Timestamp":
                currentLength += 19 + String(v.t).length + 5 + String(v.i).length + 2;
                break;
              case "Code":
                if (v.scope == null) {
                  currentLength += v.code.length + 10 + 2;
                } else {
                  currentLength += v.code.length + 10 + 11;
                }
                break;
              case "BSONRegExp":
                currentLength += 34 + v.pattern.length + 13 + v.options.length + 3;
                break;
            }
          }
      }
      return value2;
    };
    if (typeof value === "string") {
      strToTruncate = value;
    } else if (typeof value === "function") {
      strToTruncate = value.name;
    } else {
      try {
        if (maxDocumentLength !== 0) {
          strToTruncate = bson_1.EJSON.stringify(value, maxDocumentLengthEnsurer, 0, options);
        } else {
          strToTruncate = bson_1.EJSON.stringify(value, options);
        }
      } catch (e) {
        strToTruncate = `Extended JSON serialization failed with: ${e.message}`;
      }
    }
    if (maxDocumentLength !== 0 && strToTruncate.length > maxDocumentLength && strToTruncate.charCodeAt(maxDocumentLength - 1) !== strToTruncate.codePointAt(maxDocumentLength - 1)) {
      maxDocumentLength--;
      if (maxDocumentLength === 0) {
        return "";
      }
    }
    return maxDocumentLength !== 0 && strToTruncate.length > maxDocumentLength ? `${strToTruncate.slice(0, maxDocumentLength)}...` : strToTruncate;
  }
  function isLogConvertible(obj) {
    const objAsLogConvertible = obj;
    return objAsLogConvertible.toLog !== undefined && typeof objAsLogConvertible.toLog === "function";
  }
  function attachServerSelectionFields(log2, serverSelectionEvent, maxDocumentLength = exports.DEFAULT_MAX_DOCUMENT_LENGTH) {
    const { selector, operation, topologyDescription, message } = serverSelectionEvent;
    log2.selector = stringifyWithMaxLen(selector, maxDocumentLength);
    log2.operation = operation;
    log2.topologyDescription = stringifyWithMaxLen(topologyDescription, maxDocumentLength);
    log2.message = message;
    return log2;
  }
  function attachCommandFields(log2, commandEvent) {
    log2.commandName = commandEvent.commandName;
    log2.requestId = commandEvent.requestId;
    log2.driverConnectionId = commandEvent.connectionId;
    const { host, port } = utils_1.HostAddress.fromString(commandEvent.address).toHostPort();
    log2.serverHost = host;
    log2.serverPort = port;
    if (commandEvent?.serviceId) {
      log2.serviceId = commandEvent.serviceId.toHexString();
    }
    log2.databaseName = commandEvent.databaseName;
    log2.serverConnectionId = commandEvent.serverConnectionId;
    return log2;
  }
  function attachConnectionFields(log2, event) {
    const { host, port } = utils_1.HostAddress.fromString(event.address).toHostPort();
    log2.serverHost = host;
    log2.serverPort = port;
    return log2;
  }
  function attachSDAMFields(log2, sdamEvent) {
    log2.topologyId = sdamEvent.topologyId;
    return log2;
  }
  function attachServerHeartbeatFields(log2, serverHeartbeatEvent) {
    const { awaited, connectionId } = serverHeartbeatEvent;
    log2.awaited = awaited;
    log2.driverConnectionId = serverHeartbeatEvent.connectionId;
    const { host, port } = utils_1.HostAddress.fromString(connectionId).toHostPort();
    log2.serverHost = host;
    log2.serverPort = port;
    return log2;
  }
  function defaultLogTransform(logObject, maxDocumentLength = exports.DEFAULT_MAX_DOCUMENT_LENGTH) {
    let log2 = Object.create(null);
    switch (logObject.name) {
      case constants_1.SERVER_SELECTION_STARTED:
        log2 = attachServerSelectionFields(log2, logObject, maxDocumentLength);
        return log2;
      case constants_1.SERVER_SELECTION_FAILED:
        log2 = attachServerSelectionFields(log2, logObject, maxDocumentLength);
        log2.failure = logObject.failure?.message;
        return log2;
      case constants_1.SERVER_SELECTION_SUCCEEDED:
        log2 = attachServerSelectionFields(log2, logObject, maxDocumentLength);
        log2.serverHost = logObject.serverHost;
        log2.serverPort = logObject.serverPort;
        return log2;
      case constants_1.WAITING_FOR_SUITABLE_SERVER:
        log2 = attachServerSelectionFields(log2, logObject, maxDocumentLength);
        log2.remainingTimeMS = logObject.remainingTimeMS;
        return log2;
      case constants_1.COMMAND_STARTED:
        log2 = attachCommandFields(log2, logObject);
        log2.message = "Command started";
        log2.command = stringifyWithMaxLen(logObject.command, maxDocumentLength, { relaxed: true });
        log2.databaseName = logObject.databaseName;
        return log2;
      case constants_1.COMMAND_SUCCEEDED:
        log2 = attachCommandFields(log2, logObject);
        log2.message = "Command succeeded";
        log2.durationMS = logObject.duration;
        log2.reply = stringifyWithMaxLen(logObject.reply, maxDocumentLength, { relaxed: true });
        return log2;
      case constants_1.COMMAND_FAILED:
        log2 = attachCommandFields(log2, logObject);
        log2.message = "Command failed";
        log2.durationMS = logObject.duration;
        log2.failure = logObject.failure?.message ?? "(redacted)";
        return log2;
      case constants_1.CONNECTION_POOL_CREATED:
        log2 = attachConnectionFields(log2, logObject);
        log2.message = "Connection pool created";
        if (logObject.options) {
          const { maxIdleTimeMS, minPoolSize, maxPoolSize, maxConnecting, waitQueueTimeoutMS } = logObject.options;
          log2 = {
            ...log2,
            maxIdleTimeMS,
            minPoolSize,
            maxPoolSize,
            maxConnecting,
            waitQueueTimeoutMS
          };
        }
        return log2;
      case constants_1.CONNECTION_POOL_READY:
        log2 = attachConnectionFields(log2, logObject);
        log2.message = "Connection pool ready";
        return log2;
      case constants_1.CONNECTION_POOL_CLEARED:
        log2 = attachConnectionFields(log2, logObject);
        log2.message = "Connection pool cleared";
        if (logObject.serviceId?._bsontype === "ObjectId") {
          log2.serviceId = logObject.serviceId?.toHexString();
        }
        return log2;
      case constants_1.CONNECTION_POOL_CLOSED:
        log2 = attachConnectionFields(log2, logObject);
        log2.message = "Connection pool closed";
        return log2;
      case constants_1.CONNECTION_CREATED:
        log2 = attachConnectionFields(log2, logObject);
        log2.message = "Connection created";
        log2.driverConnectionId = logObject.connectionId;
        return log2;
      case constants_1.CONNECTION_READY:
        log2 = attachConnectionFields(log2, logObject);
        log2.message = "Connection ready";
        log2.driverConnectionId = logObject.connectionId;
        log2.durationMS = logObject.durationMS;
        return log2;
      case constants_1.CONNECTION_CLOSED:
        log2 = attachConnectionFields(log2, logObject);
        log2.message = "Connection closed";
        log2.driverConnectionId = logObject.connectionId;
        switch (logObject.reason) {
          case "stale":
            log2.reason = "Connection became stale because the pool was cleared";
            break;
          case "idle":
            log2.reason = "Connection has been available but unused for longer than the configured max idle time";
            break;
          case "error":
            log2.reason = "An error occurred while using the connection";
            if (logObject.error) {
              log2.error = logObject.error;
            }
            break;
          case "poolClosed":
            log2.reason = "Connection pool was closed";
            break;
          default:
            log2.reason = `Unknown close reason: ${logObject.reason}`;
        }
        return log2;
      case constants_1.CONNECTION_CHECK_OUT_STARTED:
        log2 = attachConnectionFields(log2, logObject);
        log2.message = "Connection checkout started";
        return log2;
      case constants_1.CONNECTION_CHECK_OUT_FAILED:
        log2 = attachConnectionFields(log2, logObject);
        log2.message = "Connection checkout failed";
        switch (logObject.reason) {
          case "poolClosed":
            log2.reason = "Connection pool was closed";
            break;
          case "timeout":
            log2.reason = "Wait queue timeout elapsed without a connection becoming available";
            break;
          case "connectionError":
            log2.reason = "An error occurred while trying to establish a new connection";
            if (logObject.error) {
              log2.error = logObject.error;
            }
            break;
          default:
            log2.reason = `Unknown close reason: ${logObject.reason}`;
        }
        log2.durationMS = logObject.durationMS;
        return log2;
      case constants_1.CONNECTION_CHECKED_OUT:
        log2 = attachConnectionFields(log2, logObject);
        log2.message = "Connection checked out";
        log2.driverConnectionId = logObject.connectionId;
        log2.durationMS = logObject.durationMS;
        return log2;
      case constants_1.CONNECTION_CHECKED_IN:
        log2 = attachConnectionFields(log2, logObject);
        log2.message = "Connection checked in";
        log2.driverConnectionId = logObject.connectionId;
        return log2;
      case constants_1.SERVER_OPENING:
        log2 = attachSDAMFields(log2, logObject);
        log2 = attachConnectionFields(log2, logObject);
        log2.message = "Starting server monitoring";
        return log2;
      case constants_1.SERVER_CLOSED:
        log2 = attachSDAMFields(log2, logObject);
        log2 = attachConnectionFields(log2, logObject);
        log2.message = "Stopped server monitoring";
        return log2;
      case constants_1.SERVER_HEARTBEAT_STARTED:
        log2 = attachSDAMFields(log2, logObject);
        log2 = attachServerHeartbeatFields(log2, logObject);
        log2.message = "Server heartbeat started";
        return log2;
      case constants_1.SERVER_HEARTBEAT_SUCCEEDED:
        log2 = attachSDAMFields(log2, logObject);
        log2 = attachServerHeartbeatFields(log2, logObject);
        log2.message = "Server heartbeat succeeded";
        log2.durationMS = logObject.duration;
        log2.serverConnectionId = logObject.serverConnectionId;
        log2.reply = stringifyWithMaxLen(logObject.reply, maxDocumentLength, { relaxed: true });
        return log2;
      case constants_1.SERVER_HEARTBEAT_FAILED:
        log2 = attachSDAMFields(log2, logObject);
        log2 = attachServerHeartbeatFields(log2, logObject);
        log2.message = "Server heartbeat failed";
        log2.durationMS = logObject.duration;
        log2.failure = logObject.failure?.message;
        return log2;
      case constants_1.TOPOLOGY_OPENING:
        log2 = attachSDAMFields(log2, logObject);
        log2.message = "Starting topology monitoring";
        return log2;
      case constants_1.TOPOLOGY_CLOSED:
        log2 = attachSDAMFields(log2, logObject);
        log2.message = "Stopped topology monitoring";
        return log2;
      case constants_1.TOPOLOGY_DESCRIPTION_CHANGED:
        log2 = attachSDAMFields(log2, logObject);
        log2.message = "Topology description changed";
        log2.previousDescription = log2.reply = stringifyWithMaxLen(logObject.previousDescription, maxDocumentLength);
        log2.newDescription = log2.reply = stringifyWithMaxLen(logObject.newDescription, maxDocumentLength);
        return log2;
      default:
        for (const [key, value] of Object.entries(logObject)) {
          if (value != null)
            log2[key] = value;
        }
    }
    return log2;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoLogger = exports.MongoLoggableComponent = exports.SEVERITY_LEVEL_MAP = exports.DEFAULT_MAX_DOCUMENT_LENGTH = exports.SeverityLevel = undefined;
  exports.parseSeverityFromString = parseSeverityFromString;
  exports.createStdioLogger = createStdioLogger;
  exports.stringifyWithMaxLen = stringifyWithMaxLen;
  exports.defaultLogTransform = defaultLogTransform;
  var util_1 = import.meta.require("util");
  var types_1 = import.meta.require("util/types");
  var bson_1 = require_bson2();
  var constants_1 = require_constants2();
  var utils_1 = require_utils2();
  exports.SeverityLevel = Object.freeze({
    EMERGENCY: "emergency",
    ALERT: "alert",
    CRITICAL: "critical",
    ERROR: "error",
    WARNING: "warn",
    NOTICE: "notice",
    INFORMATIONAL: "info",
    DEBUG: "debug",
    TRACE: "trace",
    OFF: "off"
  });
  exports.DEFAULT_MAX_DOCUMENT_LENGTH = 1000;

  class SeverityLevelMap extends Map {
    constructor(entries) {
      const newEntries = [];
      for (const [level, value] of entries) {
        newEntries.push([value, level]);
      }
      newEntries.push(...entries);
      super(newEntries);
    }
    getNumericSeverityLevel(severity) {
      return this.get(severity);
    }
    getSeverityLevelName(level) {
      return this.get(level);
    }
  }
  exports.SEVERITY_LEVEL_MAP = new SeverityLevelMap([
    [exports.SeverityLevel.OFF, -Infinity],
    [exports.SeverityLevel.EMERGENCY, 0],
    [exports.SeverityLevel.ALERT, 1],
    [exports.SeverityLevel.CRITICAL, 2],
    [exports.SeverityLevel.ERROR, 3],
    [exports.SeverityLevel.WARNING, 4],
    [exports.SeverityLevel.NOTICE, 5],
    [exports.SeverityLevel.INFORMATIONAL, 6],
    [exports.SeverityLevel.DEBUG, 7],
    [exports.SeverityLevel.TRACE, 8]
  ]);
  exports.MongoLoggableComponent = Object.freeze({
    COMMAND: "command",
    TOPOLOGY: "topology",
    SERVER_SELECTION: "serverSelection",
    CONNECTION: "connection",
    CLIENT: "client"
  });

  class MongoLogger {
    constructor(options) {
      this.pendingLog = null;
      this.error = this.log.bind(this, "error");
      this.warn = this.log.bind(this, "warn");
      this.info = this.log.bind(this, "info");
      this.debug = this.log.bind(this, "debug");
      this.trace = this.log.bind(this, "trace");
      this.componentSeverities = options.componentSeverities;
      this.maxDocumentLength = options.maxDocumentLength;
      this.logDestination = options.logDestination;
      this.logDestinationIsStdErr = options.logDestinationIsStdErr;
      this.severities = this.createLoggingSeverities();
    }
    createLoggingSeverities() {
      const severities = Object();
      for (const component of Object.values(exports.MongoLoggableComponent)) {
        severities[component] = {};
        for (const severityLevel of Object.values(exports.SeverityLevel)) {
          severities[component][severityLevel] = compareSeverity(severityLevel, this.componentSeverities[component]) <= 0;
        }
      }
      return severities;
    }
    turnOffSeverities() {
      for (const component of Object.values(exports.MongoLoggableComponent)) {
        this.componentSeverities[component] = exports.SeverityLevel.OFF;
        for (const severityLevel of Object.values(exports.SeverityLevel)) {
          this.severities[component][severityLevel] = false;
        }
      }
    }
    logWriteFailureHandler(error) {
      if (this.logDestinationIsStdErr) {
        this.turnOffSeverities();
        this.clearPendingLog();
        return;
      }
      this.logDestination = createStdioLogger(process.stderr);
      this.logDestinationIsStdErr = true;
      this.clearPendingLog();
      this.error(exports.MongoLoggableComponent.CLIENT, {
        toLog: function() {
          return {
            message: "User input for mongodbLogPath is now invalid. Logging is halted.",
            error: error.message
          };
        }
      });
      this.turnOffSeverities();
      this.clearPendingLog();
    }
    clearPendingLog() {
      this.pendingLog = null;
    }
    willLog(component, severity) {
      if (severity === exports.SeverityLevel.OFF)
        return false;
      return this.severities[component][severity];
    }
    log(severity, component, message) {
      if (!this.willLog(component, severity))
        return;
      let logMessage = { t: new Date, c: component, s: severity };
      if (typeof message === "string") {
        logMessage.message = message;
      } else if (typeof message === "object") {
        if (isLogConvertible(message)) {
          logMessage = { ...logMessage, ...message.toLog() };
        } else {
          logMessage = { ...logMessage, ...defaultLogTransform(message, this.maxDocumentLength) };
        }
      }
      if ((0, utils_1.isPromiseLike)(this.pendingLog)) {
        this.pendingLog = this.pendingLog.then(() => this.logDestination.write(logMessage)).then(this.clearPendingLog.bind(this), this.logWriteFailureHandler.bind(this));
        return;
      }
      try {
        const logResult = this.logDestination.write(logMessage);
        if ((0, utils_1.isPromiseLike)(logResult)) {
          this.pendingLog = logResult.then(this.clearPendingLog.bind(this), this.logWriteFailureHandler.bind(this));
        }
      } catch (error) {
        this.logWriteFailureHandler(error);
      }
    }
    static resolveOptions(envOptions, clientOptions) {
      const resolvedLogPath = resolveLogPath(envOptions, clientOptions);
      const combinedOptions = {
        ...envOptions,
        ...clientOptions,
        mongodbLogPath: resolvedLogPath.mongodbLogPath,
        mongodbLogPathIsStdErr: resolvedLogPath.mongodbLogPathIsStdErr
      };
      const defaultSeverity = resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.default, combinedOptions.MONGODB_LOG_ALL, exports.SeverityLevel.OFF);
      return {
        componentSeverities: {
          command: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.command, combinedOptions.MONGODB_LOG_COMMAND, defaultSeverity),
          topology: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.topology, combinedOptions.MONGODB_LOG_TOPOLOGY, defaultSeverity),
          serverSelection: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.serverSelection, combinedOptions.MONGODB_LOG_SERVER_SELECTION, defaultSeverity),
          connection: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.connection, combinedOptions.MONGODB_LOG_CONNECTION, defaultSeverity),
          client: resolveSeverityConfiguration(combinedOptions.mongodbLogComponentSeverities?.client, combinedOptions.MONGODB_LOG_CLIENT, defaultSeverity),
          default: defaultSeverity
        },
        maxDocumentLength: combinedOptions.mongodbLogMaxDocumentLength ?? (0, utils_1.parseUnsignedInteger)(combinedOptions.MONGODB_LOG_MAX_DOCUMENT_LENGTH) ?? 1000,
        logDestination: combinedOptions.mongodbLogPath,
        logDestinationIsStdErr: combinedOptions.mongodbLogPathIsStdErr
      };
    }
  }
  exports.MongoLogger = MongoLogger;
});

// node_modules/mongodb/lib/mongo_types.js
var require_mongo_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CancellationToken = exports.TypedEventEmitter = undefined;
  var events_1 = import.meta.require("events");
  var mongo_logger_1 = require_mongo_logger();

  class TypedEventEmitter extends events_1.EventEmitter {
    emitAndLog(event, ...args) {
      this.emit(event, ...args);
      if (this.component)
        this.mongoLogger?.debug(this.component, args[0]);
    }
    emitAndLogHeartbeat(event, topologyId, serverConnectionId, ...args) {
      this.emit(event, ...args);
      if (this.component) {
        const loggableHeartbeatEvent = {
          topologyId,
          serverConnectionId: serverConnectionId ?? null,
          ...args[0]
        };
        this.mongoLogger?.debug(this.component, loggableHeartbeatEvent);
      }
    }
    emitAndLogCommand(monitorCommands, event, databaseName, connectionEstablished, ...args) {
      if (monitorCommands) {
        this.emit(event, ...args);
      }
      if (connectionEstablished) {
        const loggableCommandEvent = {
          databaseName,
          ...args[0]
        };
        this.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.COMMAND, loggableCommandEvent);
      }
    }
  }
  exports.TypedEventEmitter = TypedEventEmitter;

  class CancellationToken extends TypedEventEmitter {
  }
  exports.CancellationToken = CancellationToken;
});

// node_modules/mongodb/lib/operations/get_more.js
var require_get_more = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetMoreOperation = undefined;
  var responses_1 = require_responses();
  var error_1 = require_error();
  var utils_1 = require_utils2();
  var operation_1 = require_operation();

  class GetMoreOperation extends operation_1.AbstractOperation {
    constructor(ns, cursorId, server, options) {
      super(options);
      this.options = options;
      this.ns = ns;
      this.cursorId = cursorId;
      this.server = server;
    }
    get commandName() {
      return "getMore";
    }
    async execute(server, _session, timeoutContext) {
      if (server !== this.server) {
        throw new error_1.MongoRuntimeError("Getmore must run on the same server operation began on");
      }
      if (this.cursorId == null || this.cursorId.isZero()) {
        throw new error_1.MongoRuntimeError("Unable to iterate cursor with no id");
      }
      const collection = this.ns.collection;
      if (collection == null) {
        throw new error_1.MongoRuntimeError("A collection name must be determined before getMore");
      }
      const getMoreCmd = {
        getMore: this.cursorId,
        collection
      };
      if (typeof this.options.batchSize === "number") {
        getMoreCmd.batchSize = Math.abs(this.options.batchSize);
      }
      if (typeof this.options.maxAwaitTimeMS === "number") {
        getMoreCmd.maxTimeMS = this.options.maxAwaitTimeMS;
      }
      if (this.options.comment !== undefined && (0, utils_1.maxWireVersion)(server) >= 9) {
        getMoreCmd.comment = this.options.comment;
      }
      const commandOptions = {
        returnFieldSelector: null,
        documentsReturnedIn: "nextBatch",
        timeoutContext,
        ...this.options
      };
      return await server.command(this.ns, getMoreCmd, commandOptions, responses_1.CursorResponse);
    }
  }
  exports.GetMoreOperation = GetMoreOperation;
  (0, operation_1.defineAspects)(GetMoreOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.MUST_SELECT_SAME_SERVER]);
});

// node_modules/mongodb/lib/operations/kill_cursors.js
var require_kill_cursors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KillCursorsOperation = undefined;
  var error_1 = require_error();
  var utils_1 = require_utils2();
  var operation_1 = require_operation();

  class KillCursorsOperation extends operation_1.AbstractOperation {
    constructor(cursorId, ns, server, options) {
      super(options);
      this.ns = ns;
      this.cursorId = cursorId;
      this.server = server;
    }
    get commandName() {
      return "killCursors";
    }
    async execute(server, session, timeoutContext) {
      if (server !== this.server) {
        throw new error_1.MongoRuntimeError("Killcursor must run on the same server operation began on");
      }
      const killCursors = this.ns.collection;
      if (killCursors == null) {
        throw new error_1.MongoRuntimeError("A collection name must be determined before killCursors");
      }
      const killCursorsCommand = {
        killCursors,
        cursors: [this.cursorId]
      };
      try {
        await server.command(this.ns, killCursorsCommand, {
          session,
          timeoutContext
        });
      } catch (error) {
        (0, utils_1.squashError)(error);
      }
    }
  }
  exports.KillCursorsOperation = KillCursorsOperation;
  (0, operation_1.defineAspects)(KillCursorsOperation, [operation_1.Aspect.MUST_SELECT_SAME_SERVER]);
});

// node_modules/mongodb/lib/operations/delete.js
var require_delete = __commonJS((exports) => {
  function makeDeleteStatement(filter, options) {
    const op = {
      q: filter,
      limit: typeof options.limit === "number" ? options.limit : 0
    };
    if (options.collation) {
      op.collation = options.collation;
    }
    if (options.hint) {
      op.hint = options.hint;
    }
    return op;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DeleteManyOperation = exports.DeleteOneOperation = exports.DeleteOperation = undefined;
  exports.makeDeleteStatement = makeDeleteStatement;
  var error_1 = require_error();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class DeleteOperation extends command_1.CommandOperation {
    constructor(ns, statements, options) {
      super(undefined, options);
      this.options = options;
      this.ns = ns;
      this.statements = statements;
    }
    get commandName() {
      return "delete";
    }
    get canRetryWrite() {
      if (super.canRetryWrite === false) {
        return false;
      }
      return this.statements.every((op) => op.limit != null ? op.limit > 0 : true);
    }
    async execute(server, session, timeoutContext) {
      const options = this.options ?? {};
      const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
      const command = {
        delete: this.ns.collection,
        deletes: this.statements,
        ordered
      };
      if (options.let) {
        command.let = options.let;
      }
      if (options.comment !== undefined) {
        command.comment = options.comment;
      }
      const unacknowledgedWrite = this.writeConcern && this.writeConcern.w === 0;
      if (unacknowledgedWrite) {
        if (this.statements.find((o) => o.hint)) {
          throw new error_1.MongoCompatibilityError(`hint is not supported with unacknowledged writes`);
        }
      }
      const res = await super.executeCommand(server, session, command, timeoutContext);
      return res;
    }
  }
  exports.DeleteOperation = DeleteOperation;

  class DeleteOneOperation extends DeleteOperation {
    constructor(collection, filter, options) {
      super(collection.s.namespace, [makeDeleteStatement(filter, { ...options, limit: 1 })], options);
    }
    async execute(server, session, timeoutContext) {
      const res = await super.execute(server, session, timeoutContext);
      if (this.explain)
        return res;
      if (res.code)
        throw new error_1.MongoServerError(res);
      if (res.writeErrors)
        throw new error_1.MongoServerError(res.writeErrors[0]);
      return {
        acknowledged: this.writeConcern?.w !== 0,
        deletedCount: res.n
      };
    }
  }
  exports.DeleteOneOperation = DeleteOneOperation;

  class DeleteManyOperation extends DeleteOperation {
    constructor(collection, filter, options) {
      super(collection.s.namespace, [makeDeleteStatement(filter, options)], options);
    }
    async execute(server, session, timeoutContext) {
      const res = await super.execute(server, session, timeoutContext);
      if (this.explain)
        return res;
      if (res.code)
        throw new error_1.MongoServerError(res);
      if (res.writeErrors)
        throw new error_1.MongoServerError(res.writeErrors[0]);
      return {
        acknowledged: this.writeConcern?.w !== 0,
        deletedCount: res.n
      };
    }
  }
  exports.DeleteManyOperation = DeleteManyOperation;
  (0, operation_1.defineAspects)(DeleteOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
  (0, operation_1.defineAspects)(DeleteOneOperation, [
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.EXPLAINABLE,
    operation_1.Aspect.SKIP_COLLATION
  ]);
  (0, operation_1.defineAspects)(DeleteManyOperation, [
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.EXPLAINABLE,
    operation_1.Aspect.SKIP_COLLATION
  ]);
});

// node_modules/mongodb/lib/operations/bulk_write.js
var require_bulk_write = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BulkWriteOperation = undefined;
  var operation_1 = require_operation();

  class BulkWriteOperation extends operation_1.AbstractOperation {
    constructor(collection, operations, options) {
      super(options);
      this.options = options;
      this.collection = collection;
      this.operations = operations;
    }
    get commandName() {
      return "bulkWrite";
    }
    async execute(server, session, timeoutContext) {
      const coll = this.collection;
      const operations = this.operations;
      const options = {
        ...this.options,
        ...this.bsonOptions,
        readPreference: this.readPreference,
        timeoutContext
      };
      const bulk = options.ordered === false ? coll.initializeUnorderedBulkOp(options) : coll.initializeOrderedBulkOp(options);
      for (let i = 0;i < operations.length; i++) {
        bulk.raw(operations[i]);
      }
      return await bulk.execute({ ...options, session });
    }
  }
  exports.BulkWriteOperation = BulkWriteOperation;
  (0, operation_1.defineAspects)(BulkWriteOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/operations/insert.js
var require_insert = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InsertManyOperation = exports.InsertOneOperation = exports.InsertOperation = undefined;
  var error_1 = require_error();
  var utils_1 = require_utils2();
  var write_concern_1 = require_write_concern();
  var bulk_write_1 = require_bulk_write();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class InsertOperation extends command_1.CommandOperation {
    constructor(ns, documents, options) {
      super(undefined, options);
      this.options = { ...options, checkKeys: options.checkKeys ?? false };
      this.ns = ns;
      this.documents = documents;
    }
    get commandName() {
      return "insert";
    }
    async execute(server, session, timeoutContext) {
      const options = this.options ?? {};
      const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
      const command = {
        insert: this.ns.collection,
        documents: this.documents,
        ordered
      };
      if (typeof options.bypassDocumentValidation === "boolean") {
        command.bypassDocumentValidation = options.bypassDocumentValidation;
      }
      if (options.comment !== undefined) {
        command.comment = options.comment;
      }
      return await super.executeCommand(server, session, command, timeoutContext);
    }
  }
  exports.InsertOperation = InsertOperation;

  class InsertOneOperation extends InsertOperation {
    constructor(collection, doc, options) {
      super(collection.s.namespace, (0, utils_1.maybeAddIdToDocuments)(collection, [doc], options), options);
    }
    async execute(server, session, timeoutContext) {
      const res = await super.execute(server, session, timeoutContext);
      if (res.code)
        throw new error_1.MongoServerError(res);
      if (res.writeErrors) {
        throw new error_1.MongoServerError(res.writeErrors[0]);
      }
      return {
        acknowledged: this.writeConcern?.w !== 0,
        insertedId: this.documents[0]._id
      };
    }
  }
  exports.InsertOneOperation = InsertOneOperation;

  class InsertManyOperation extends operation_1.AbstractOperation {
    constructor(collection, docs, options) {
      super(options);
      if (!Array.isArray(docs)) {
        throw new error_1.MongoInvalidArgumentError('Argument "docs" must be an array of documents');
      }
      this.options = options;
      this.collection = collection;
      this.docs = docs;
    }
    get commandName() {
      return "insert";
    }
    async execute(server, session, timeoutContext) {
      const coll = this.collection;
      const options = { ...this.options, ...this.bsonOptions, readPreference: this.readPreference };
      const writeConcern = write_concern_1.WriteConcern.fromOptions(options);
      const bulkWriteOperation = new bulk_write_1.BulkWriteOperation(coll, this.docs.map((document2) => ({
        insertOne: { document: document2 }
      })), options);
      try {
        const res = await bulkWriteOperation.execute(server, session, timeoutContext);
        return {
          acknowledged: writeConcern?.w !== 0,
          insertedCount: res.insertedCount,
          insertedIds: res.insertedIds
        };
      } catch (err) {
        if (err && err.message === "Operation must be an object with an operation key") {
          throw new error_1.MongoInvalidArgumentError("Collection.insertMany() cannot be called with an array that has null/undefined values");
        }
        throw err;
      }
    }
  }
  exports.InsertManyOperation = InsertManyOperation;
  (0, operation_1.defineAspects)(InsertOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
  (0, operation_1.defineAspects)(InsertOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);
  (0, operation_1.defineAspects)(InsertManyOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/operations/update.js
var require_update = __commonJS((exports) => {
  function makeUpdateStatement(filter, update, options) {
    if (filter == null || typeof filter !== "object") {
      throw new error_1.MongoInvalidArgumentError("Selector must be a valid JavaScript object");
    }
    if (update == null || typeof update !== "object") {
      throw new error_1.MongoInvalidArgumentError("Document must be a valid JavaScript object");
    }
    const op = { q: filter, u: update };
    if (typeof options.upsert === "boolean") {
      op.upsert = options.upsert;
    }
    if (options.multi) {
      op.multi = options.multi;
    }
    if (options.hint) {
      op.hint = options.hint;
    }
    if (options.arrayFilters) {
      op.arrayFilters = options.arrayFilters;
    }
    if (options.collation) {
      op.collation = options.collation;
    }
    return op;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReplaceOneOperation = exports.UpdateManyOperation = exports.UpdateOneOperation = exports.UpdateOperation = undefined;
  exports.makeUpdateStatement = makeUpdateStatement;
  var error_1 = require_error();
  var utils_1 = require_utils2();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class UpdateOperation extends command_1.CommandOperation {
    constructor(ns, statements, options) {
      super(undefined, options);
      this.options = options;
      this.ns = ns;
      this.statements = statements;
    }
    get commandName() {
      return "update";
    }
    get canRetryWrite() {
      if (super.canRetryWrite === false) {
        return false;
      }
      return this.statements.every((op) => op.multi == null || op.multi === false);
    }
    async execute(server, session, timeoutContext) {
      const options = this.options ?? {};
      const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
      const command = {
        update: this.ns.collection,
        updates: this.statements,
        ordered
      };
      if (typeof options.bypassDocumentValidation === "boolean") {
        command.bypassDocumentValidation = options.bypassDocumentValidation;
      }
      if (options.let) {
        command.let = options.let;
      }
      if (options.comment !== undefined) {
        command.comment = options.comment;
      }
      const unacknowledgedWrite = this.writeConcern && this.writeConcern.w === 0;
      if (unacknowledgedWrite) {
        if (this.statements.find((o) => o.hint)) {
          throw new error_1.MongoCompatibilityError(`hint is not supported with unacknowledged writes`);
        }
      }
      const res = await super.executeCommand(server, session, command, timeoutContext);
      return res;
    }
  }
  exports.UpdateOperation = UpdateOperation;

  class UpdateOneOperation extends UpdateOperation {
    constructor(collection, filter, update, options) {
      super(collection.s.namespace, [makeUpdateStatement(filter, update, { ...options, multi: false })], options);
      if (!(0, utils_1.hasAtomicOperators)(update)) {
        throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
      }
    }
    async execute(server, session, timeoutContext) {
      const res = await super.execute(server, session, timeoutContext);
      if (this.explain != null)
        return res;
      if (res.code)
        throw new error_1.MongoServerError(res);
      if (res.writeErrors)
        throw new error_1.MongoServerError(res.writeErrors[0]);
      return {
        acknowledged: this.writeConcern?.w !== 0,
        modifiedCount: res.nModified ?? res.n,
        upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
        upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
        matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
      };
    }
  }
  exports.UpdateOneOperation = UpdateOneOperation;

  class UpdateManyOperation extends UpdateOperation {
    constructor(collection, filter, update, options) {
      super(collection.s.namespace, [makeUpdateStatement(filter, update, { ...options, multi: true })], options);
      if (!(0, utils_1.hasAtomicOperators)(update)) {
        throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
      }
    }
    async execute(server, session, timeoutContext) {
      const res = await super.execute(server, session, timeoutContext);
      if (this.explain != null)
        return res;
      if (res.code)
        throw new error_1.MongoServerError(res);
      if (res.writeErrors)
        throw new error_1.MongoServerError(res.writeErrors[0]);
      return {
        acknowledged: this.writeConcern?.w !== 0,
        modifiedCount: res.nModified ?? res.n,
        upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
        upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
        matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
      };
    }
  }
  exports.UpdateManyOperation = UpdateManyOperation;

  class ReplaceOneOperation extends UpdateOperation {
    constructor(collection, filter, replacement, options) {
      super(collection.s.namespace, [makeUpdateStatement(filter, replacement, { ...options, multi: false })], options);
      if ((0, utils_1.hasAtomicOperators)(replacement)) {
        throw new error_1.MongoInvalidArgumentError("Replacement document must not contain atomic operators");
      }
    }
    async execute(server, session, timeoutContext) {
      const res = await super.execute(server, session, timeoutContext);
      if (this.explain != null)
        return res;
      if (res.code)
        throw new error_1.MongoServerError(res);
      if (res.writeErrors)
        throw new error_1.MongoServerError(res.writeErrors[0]);
      return {
        acknowledged: this.writeConcern?.w !== 0,
        modifiedCount: res.nModified ?? res.n,
        upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,
        upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,
        matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n
      };
    }
  }
  exports.ReplaceOneOperation = ReplaceOneOperation;
  (0, operation_1.defineAspects)(UpdateOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.SKIP_COLLATION]);
  (0, operation_1.defineAspects)(UpdateOneOperation, [
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.EXPLAINABLE,
    operation_1.Aspect.SKIP_COLLATION
  ]);
  (0, operation_1.defineAspects)(UpdateManyOperation, [
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.EXPLAINABLE,
    operation_1.Aspect.SKIP_COLLATION
  ]);
  (0, operation_1.defineAspects)(ReplaceOneOperation, [
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.SKIP_COLLATION
  ]);
});

// node_modules/mongodb/lib/bulk/common.js
var require_common2 = __commonJS((exports) => {
  function mergeBatchResults(batch, bulkResult, err, result) {
    if (err) {
      result = err;
    } else if (result && result.result) {
      result = result.result;
    }
    if (result == null) {
      return;
    }
    if (result.ok === 0 && bulkResult.ok === 1) {
      bulkResult.ok = 0;
      const writeError = {
        index: 0,
        code: result.code || 0,
        errmsg: result.message,
        errInfo: result.errInfo,
        op: batch.operations[0]
      };
      bulkResult.writeErrors.push(new WriteError(writeError));
      return;
    } else if (result.ok === 0 && bulkResult.ok === 0) {
      return;
    }
    if (isInsertBatch(batch) && result.n) {
      bulkResult.nInserted = bulkResult.nInserted + result.n;
    }
    if (isDeleteBatch(batch) && result.n) {
      bulkResult.nRemoved = bulkResult.nRemoved + result.n;
    }
    let nUpserted = 0;
    if (Array.isArray(result.upserted)) {
      nUpserted = result.upserted.length;
      for (let i = 0;i < result.upserted.length; i++) {
        bulkResult.upserted.push({
          index: result.upserted[i].index + batch.originalZeroIndex,
          _id: result.upserted[i]._id
        });
      }
    } else if (result.upserted) {
      nUpserted = 1;
      bulkResult.upserted.push({
        index: batch.originalZeroIndex,
        _id: result.upserted
      });
    }
    if (isUpdateBatch(batch) && result.n) {
      const nModified = result.nModified;
      bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;
      bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);
      if (typeof nModified === "number") {
        bulkResult.nModified = bulkResult.nModified + nModified;
      } else {
        bulkResult.nModified = 0;
      }
    }
    if (Array.isArray(result.writeErrors)) {
      for (let i = 0;i < result.writeErrors.length; i++) {
        const writeError = {
          index: batch.originalIndexes[result.writeErrors[i].index],
          code: result.writeErrors[i].code,
          errmsg: result.writeErrors[i].errmsg,
          errInfo: result.writeErrors[i].errInfo,
          op: batch.operations[result.writeErrors[i].index]
        };
        bulkResult.writeErrors.push(new WriteError(writeError));
      }
    }
    if (result.writeConcernError) {
      bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));
    }
  }
  async function executeCommands(bulkOperation, options) {
    if (bulkOperation.s.batches.length === 0) {
      return new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered);
    }
    for (const batch of bulkOperation.s.batches) {
      const finalOptions = (0, utils_1.resolveOptions)(bulkOperation, {
        ...options,
        ordered: bulkOperation.isOrdered
      });
      if (finalOptions.bypassDocumentValidation !== true) {
        delete finalOptions.bypassDocumentValidation;
      }
      if (bulkOperation.s.bypassDocumentValidation === true) {
        finalOptions.bypassDocumentValidation = true;
      }
      if (bulkOperation.s.checkKeys === false) {
        finalOptions.checkKeys = false;
      }
      if (finalOptions.retryWrites) {
        if (isUpdateBatch(batch)) {
          finalOptions.retryWrites = finalOptions.retryWrites && !batch.operations.some((op) => op.multi);
        }
        if (isDeleteBatch(batch)) {
          finalOptions.retryWrites = finalOptions.retryWrites && !batch.operations.some((op) => op.limit === 0);
        }
      }
      const operation = isInsertBatch(batch) ? new insert_1.InsertOperation(bulkOperation.s.namespace, batch.operations, finalOptions) : isUpdateBatch(batch) ? new update_1.UpdateOperation(bulkOperation.s.namespace, batch.operations, finalOptions) : isDeleteBatch(batch) ? new delete_1.DeleteOperation(bulkOperation.s.namespace, batch.operations, finalOptions) : null;
      if (operation == null)
        throw new error_1.MongoRuntimeError(`Unknown batchType: ${batch.batchType}`);
      let thrownError = null;
      let result;
      try {
        result = await (0, execute_operation_1.executeOperation)(bulkOperation.s.collection.client, operation, finalOptions.timeoutContext);
      } catch (error) {
        thrownError = error;
      }
      if (thrownError != null) {
        if (thrownError instanceof error_1.MongoWriteConcernError) {
          mergeBatchResults(batch, bulkOperation.s.bulkResult, thrownError, result);
          const writeResult3 = new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered);
          throw new MongoBulkWriteError({
            message: thrownError.result.writeConcernError.errmsg,
            code: thrownError.result.writeConcernError.code
          }, writeResult3);
        } else {
          throw new MongoBulkWriteError(thrownError, new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered));
        }
      }
      mergeBatchResults(batch, bulkOperation.s.bulkResult, thrownError, result);
      const writeResult2 = new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered);
      bulkOperation.handleWriteError(writeResult2);
    }
    bulkOperation.s.batches.length = 0;
    const writeResult = new BulkWriteResult(bulkOperation.s.bulkResult, bulkOperation.isOrdered);
    bulkOperation.handleWriteError(writeResult);
    return writeResult;
  }
  function isInsertBatch(batch) {
    return batch.batchType === exports.BatchType.INSERT;
  }
  function isUpdateBatch(batch) {
    return batch.batchType === exports.BatchType.UPDATE;
  }
  function isDeleteBatch(batch) {
    return batch.batchType === exports.BatchType.DELETE;
  }
  function buildCurrentOp(bulkOp) {
    let { currentOp } = bulkOp.s;
    bulkOp.s.currentOp = undefined;
    if (!currentOp)
      currentOp = {};
    return currentOp;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BulkOperationBase = exports.BulkWriteShimOperation = exports.FindOperators = exports.MongoBulkWriteError = exports.WriteError = exports.WriteConcernError = exports.BulkWriteResult = exports.Batch = exports.BatchType = undefined;
  exports.mergeBatchResults = mergeBatchResults;
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var delete_1 = require_delete();
  var execute_operation_1 = require_execute_operation();
  var insert_1 = require_insert();
  var operation_1 = require_operation();
  var update_1 = require_update();
  var utils_1 = require_utils2();
  var write_concern_1 = require_write_concern();
  exports.BatchType = Object.freeze({
    INSERT: 1,
    UPDATE: 2,
    DELETE: 3
  });

  class Batch {
    constructor(batchType, originalZeroIndex) {
      this.originalZeroIndex = originalZeroIndex;
      this.currentIndex = 0;
      this.originalIndexes = [];
      this.batchType = batchType;
      this.operations = [];
      this.size = 0;
      this.sizeBytes = 0;
    }
  }
  exports.Batch = Batch;

  class BulkWriteResult {
    static generateIdMap(ids) {
      const idMap = {};
      for (const doc of ids) {
        idMap[doc.index] = doc._id;
      }
      return idMap;
    }
    constructor(bulkResult, isOrdered) {
      this.result = bulkResult;
      this.insertedCount = this.result.nInserted ?? 0;
      this.matchedCount = this.result.nMatched ?? 0;
      this.modifiedCount = this.result.nModified ?? 0;
      this.deletedCount = this.result.nRemoved ?? 0;
      this.upsertedCount = this.result.upserted.length ?? 0;
      this.upsertedIds = BulkWriteResult.generateIdMap(this.result.upserted);
      this.insertedIds = BulkWriteResult.generateIdMap(this.getSuccessfullyInsertedIds(bulkResult, isOrdered));
      Object.defineProperty(this, "result", { value: this.result, enumerable: false });
    }
    get ok() {
      return this.result.ok;
    }
    getSuccessfullyInsertedIds(bulkResult, isOrdered) {
      if (bulkResult.writeErrors.length === 0)
        return bulkResult.insertedIds;
      if (isOrdered) {
        return bulkResult.insertedIds.slice(0, bulkResult.writeErrors[0].index);
      }
      return bulkResult.insertedIds.filter(({ index }) => !bulkResult.writeErrors.some((writeError) => index === writeError.index));
    }
    getUpsertedIdAt(index) {
      return this.result.upserted[index];
    }
    getRawResponse() {
      return this.result;
    }
    hasWriteErrors() {
      return this.result.writeErrors.length > 0;
    }
    getWriteErrorCount() {
      return this.result.writeErrors.length;
    }
    getWriteErrorAt(index) {
      return index < this.result.writeErrors.length ? this.result.writeErrors[index] : undefined;
    }
    getWriteErrors() {
      return this.result.writeErrors;
    }
    getWriteConcernError() {
      if (this.result.writeConcernErrors.length === 0) {
        return;
      } else if (this.result.writeConcernErrors.length === 1) {
        return this.result.writeConcernErrors[0];
      } else {
        let errmsg = "";
        for (let i = 0;i < this.result.writeConcernErrors.length; i++) {
          const err = this.result.writeConcernErrors[i];
          errmsg = errmsg + err.errmsg;
          if (i === 0)
            errmsg = errmsg + " and ";
        }
        return new WriteConcernError({ errmsg, code: error_1.MONGODB_ERROR_CODES.WriteConcernFailed });
      }
    }
    toString() {
      return `BulkWriteResult(${bson_1.EJSON.stringify(this.result)})`;
    }
    isOk() {
      return this.result.ok === 1;
    }
  }
  exports.BulkWriteResult = BulkWriteResult;

  class WriteConcernError {
    constructor(error) {
      this.serverError = error;
    }
    get code() {
      return this.serverError.code;
    }
    get errmsg() {
      return this.serverError.errmsg;
    }
    get errInfo() {
      return this.serverError.errInfo;
    }
    toJSON() {
      return this.serverError;
    }
    toString() {
      return `WriteConcernError(${this.errmsg})`;
    }
  }
  exports.WriteConcernError = WriteConcernError;

  class WriteError {
    constructor(err) {
      this.err = err;
    }
    get code() {
      return this.err.code;
    }
    get index() {
      return this.err.index;
    }
    get errmsg() {
      return this.err.errmsg;
    }
    get errInfo() {
      return this.err.errInfo;
    }
    getOperation() {
      return this.err.op;
    }
    toJSON() {
      return { code: this.err.code, index: this.err.index, errmsg: this.err.errmsg, op: this.err.op };
    }
    toString() {
      return `WriteError(${JSON.stringify(this.toJSON())})`;
    }
  }
  exports.WriteError = WriteError;

  class MongoBulkWriteError extends error_1.MongoServerError {
    constructor(error, result) {
      super(error);
      this.writeErrors = [];
      if (error instanceof WriteConcernError)
        this.err = error;
      else if (!(error instanceof Error)) {
        this.message = error.message;
        this.code = error.code;
        this.writeErrors = error.writeErrors ?? [];
      }
      this.result = result;
      Object.assign(this, error);
    }
    get name() {
      return "MongoBulkWriteError";
    }
    get insertedCount() {
      return this.result.insertedCount;
    }
    get matchedCount() {
      return this.result.matchedCount;
    }
    get modifiedCount() {
      return this.result.modifiedCount;
    }
    get deletedCount() {
      return this.result.deletedCount;
    }
    get upsertedCount() {
      return this.result.upsertedCount;
    }
    get insertedIds() {
      return this.result.insertedIds;
    }
    get upsertedIds() {
      return this.result.upsertedIds;
    }
  }
  exports.MongoBulkWriteError = MongoBulkWriteError;

  class FindOperators {
    constructor(bulkOperation) {
      this.bulkOperation = bulkOperation;
    }
    update(updateDocument) {
      const currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, updateDocument, {
        ...currentOp,
        multi: true
      }));
    }
    updateOne(updateDocument) {
      if (!(0, utils_1.hasAtomicOperators)(updateDocument)) {
        throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
      }
      const currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, updateDocument, { ...currentOp, multi: false }));
    }
    replaceOne(replacement) {
      if ((0, utils_1.hasAtomicOperators)(replacement)) {
        throw new error_1.MongoInvalidArgumentError("Replacement document must not use atomic operators");
      }
      const currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, (0, update_1.makeUpdateStatement)(currentOp.selector, replacement, { ...currentOp, multi: false }));
    }
    deleteOne() {
      const currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(currentOp.selector, { ...currentOp, limit: 1 }));
    }
    delete() {
      const currentOp = buildCurrentOp(this.bulkOperation);
      return this.bulkOperation.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(currentOp.selector, { ...currentOp, limit: 0 }));
    }
    upsert() {
      if (!this.bulkOperation.s.currentOp) {
        this.bulkOperation.s.currentOp = {};
      }
      this.bulkOperation.s.currentOp.upsert = true;
      return this;
    }
    collation(collation) {
      if (!this.bulkOperation.s.currentOp) {
        this.bulkOperation.s.currentOp = {};
      }
      this.bulkOperation.s.currentOp.collation = collation;
      return this;
    }
    arrayFilters(arrayFilters) {
      if (!this.bulkOperation.s.currentOp) {
        this.bulkOperation.s.currentOp = {};
      }
      this.bulkOperation.s.currentOp.arrayFilters = arrayFilters;
      return this;
    }
    hint(hint) {
      if (!this.bulkOperation.s.currentOp) {
        this.bulkOperation.s.currentOp = {};
      }
      this.bulkOperation.s.currentOp.hint = hint;
      return this;
    }
  }
  exports.FindOperators = FindOperators;

  class BulkWriteShimOperation extends operation_1.AbstractOperation {
    constructor(bulkOperation, options) {
      super(options);
      this.bulkOperation = bulkOperation;
    }
    get commandName() {
      return "bulkWrite";
    }
    async execute(_server, session, timeoutContext) {
      if (this.options.session == null) {
        this.options.session = session;
      }
      return await executeCommands(this.bulkOperation, { ...this.options, timeoutContext });
    }
  }
  exports.BulkWriteShimOperation = BulkWriteShimOperation;

  class BulkOperationBase {
    constructor(collection, options, isOrdered) {
      this.collection = collection;
      this.isOrdered = isOrdered;
      const topology = (0, utils_1.getTopology)(collection);
      options = options == null ? {} : options;
      const namespace = collection.s.namespace;
      const executed = false;
      const currentOp = undefined;
      const hello = topology.lastHello();
      const usingAutoEncryption = !!(topology.s.options && topology.s.options.autoEncrypter);
      const maxBsonObjectSize = hello && hello.maxBsonObjectSize ? hello.maxBsonObjectSize : 1024 * 1024 * 16;
      const maxBatchSizeBytes = usingAutoEncryption ? 1024 * 1024 * 2 : maxBsonObjectSize;
      const maxWriteBatchSize = hello && hello.maxWriteBatchSize ? hello.maxWriteBatchSize : 1000;
      const maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2;
      let finalOptions = Object.assign({}, options);
      finalOptions = (0, utils_1.applyRetryableWrites)(finalOptions, collection.s.db);
      const bulkResult = {
        ok: 1,
        writeErrors: [],
        writeConcernErrors: [],
        insertedIds: [],
        nInserted: 0,
        nUpserted: 0,
        nMatched: 0,
        nModified: 0,
        nRemoved: 0,
        upserted: []
      };
      this.s = {
        bulkResult,
        currentBatch: undefined,
        currentIndex: 0,
        currentBatchSize: 0,
        currentBatchSizeBytes: 0,
        currentInsertBatch: undefined,
        currentUpdateBatch: undefined,
        currentRemoveBatch: undefined,
        batches: [],
        writeConcern: write_concern_1.WriteConcern.fromOptions(options),
        maxBsonObjectSize,
        maxBatchSizeBytes,
        maxWriteBatchSize,
        maxKeySize,
        namespace,
        topology,
        options: finalOptions,
        bsonOptions: (0, bson_1.resolveBSONOptions)(options),
        currentOp,
        executed,
        collection,
        err: undefined,
        checkKeys: typeof options.checkKeys === "boolean" ? options.checkKeys : false
      };
      if (options.bypassDocumentValidation === true) {
        this.s.bypassDocumentValidation = true;
      }
    }
    insert(document2) {
      (0, utils_1.maybeAddIdToDocuments)(this.collection, document2, {
        forceServerObjectId: this.shouldForceServerObjectId()
      });
      return this.addToOperationsList(exports.BatchType.INSERT, document2);
    }
    find(selector) {
      if (!selector) {
        throw new error_1.MongoInvalidArgumentError("Bulk find operation must specify a selector");
      }
      this.s.currentOp = {
        selector
      };
      return new FindOperators(this);
    }
    raw(op) {
      if (op == null || typeof op !== "object") {
        throw new error_1.MongoInvalidArgumentError("Operation must be an object with an operation key");
      }
      if ("insertOne" in op) {
        const forceServerObjectId = this.shouldForceServerObjectId();
        const document2 = op.insertOne && op.insertOne.document == null ? op.insertOne : op.insertOne.document;
        (0, utils_1.maybeAddIdToDocuments)(this.collection, document2, { forceServerObjectId });
        return this.addToOperationsList(exports.BatchType.INSERT, document2);
      }
      if ("replaceOne" in op || "updateOne" in op || "updateMany" in op) {
        if ("replaceOne" in op) {
          if ("q" in op.replaceOne) {
            throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
          }
          const updateStatement = (0, update_1.makeUpdateStatement)(op.replaceOne.filter, op.replaceOne.replacement, { ...op.replaceOne, multi: false });
          if ((0, utils_1.hasAtomicOperators)(updateStatement.u)) {
            throw new error_1.MongoInvalidArgumentError("Replacement document must not use atomic operators");
          }
          return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);
        }
        if ("updateOne" in op) {
          if ("q" in op.updateOne) {
            throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
          }
          const updateStatement = (0, update_1.makeUpdateStatement)(op.updateOne.filter, op.updateOne.update, {
            ...op.updateOne,
            multi: false
          });
          if (!(0, utils_1.hasAtomicOperators)(updateStatement.u)) {
            throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
          }
          return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);
        }
        if ("updateMany" in op) {
          if ("q" in op.updateMany) {
            throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
          }
          const updateStatement = (0, update_1.makeUpdateStatement)(op.updateMany.filter, op.updateMany.update, {
            ...op.updateMany,
            multi: true
          });
          if (!(0, utils_1.hasAtomicOperators)(updateStatement.u)) {
            throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
          }
          return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);
        }
      }
      if ("deleteOne" in op) {
        if ("q" in op.deleteOne) {
          throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
        }
        return this.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(op.deleteOne.filter, { ...op.deleteOne, limit: 1 }));
      }
      if ("deleteMany" in op) {
        if ("q" in op.deleteMany) {
          throw new error_1.MongoInvalidArgumentError("Raw operations are not allowed");
        }
        return this.addToOperationsList(exports.BatchType.DELETE, (0, delete_1.makeDeleteStatement)(op.deleteMany.filter, { ...op.deleteMany, limit: 0 }));
      }
      throw new error_1.MongoInvalidArgumentError("bulkWrite only supports insertOne, updateOne, updateMany, deleteOne, deleteMany");
    }
    get length() {
      return this.s.currentIndex;
    }
    get bsonOptions() {
      return this.s.bsonOptions;
    }
    get writeConcern() {
      return this.s.writeConcern;
    }
    get batches() {
      const batches = [...this.s.batches];
      if (this.isOrdered) {
        if (this.s.currentBatch)
          batches.push(this.s.currentBatch);
      } else {
        if (this.s.currentInsertBatch)
          batches.push(this.s.currentInsertBatch);
        if (this.s.currentUpdateBatch)
          batches.push(this.s.currentUpdateBatch);
        if (this.s.currentRemoveBatch)
          batches.push(this.s.currentRemoveBatch);
      }
      return batches;
    }
    async execute(options = {}) {
      if (this.s.executed) {
        throw new error_1.MongoBatchReExecutionError;
      }
      const writeConcern = write_concern_1.WriteConcern.fromOptions(options);
      if (writeConcern) {
        this.s.writeConcern = writeConcern;
      }
      if (this.isOrdered) {
        if (this.s.currentBatch)
          this.s.batches.push(this.s.currentBatch);
      } else {
        if (this.s.currentInsertBatch)
          this.s.batches.push(this.s.currentInsertBatch);
        if (this.s.currentUpdateBatch)
          this.s.batches.push(this.s.currentUpdateBatch);
        if (this.s.currentRemoveBatch)
          this.s.batches.push(this.s.currentRemoveBatch);
      }
      if (this.s.batches.length === 0) {
        throw new error_1.MongoInvalidArgumentError("Invalid BulkOperation, Batch cannot be empty");
      }
      this.s.executed = true;
      const finalOptions = { ...this.s.options, ...options };
      const operation = new BulkWriteShimOperation(this, finalOptions);
      return await (0, execute_operation_1.executeOperation)(this.s.collection.client, operation, finalOptions.timeoutContext);
    }
    handleWriteError(writeResult) {
      if (this.s.bulkResult.writeErrors.length > 0) {
        const msg = this.s.bulkResult.writeErrors[0].errmsg ? this.s.bulkResult.writeErrors[0].errmsg : "write operation failed";
        throw new MongoBulkWriteError({
          message: msg,
          code: this.s.bulkResult.writeErrors[0].code,
          writeErrors: this.s.bulkResult.writeErrors
        }, writeResult);
      }
      const writeConcernError = writeResult.getWriteConcernError();
      if (writeConcernError) {
        throw new MongoBulkWriteError(writeConcernError, writeResult);
      }
    }
    shouldForceServerObjectId() {
      return this.s.options.forceServerObjectId === true || this.s.collection.s.db.options?.forceServerObjectId === true;
    }
  }
  exports.BulkOperationBase = BulkOperationBase;
});

// node_modules/mongodb/lib/bulk/ordered.js
var require_ordered = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OrderedBulkOperation = undefined;
  var BSON = require_bson2();
  var error_1 = require_error();
  var common_1 = require_common2();

  class OrderedBulkOperation extends common_1.BulkOperationBase {
    constructor(collection, options) {
      super(collection, options, true);
    }
    addToOperationsList(batchType, document2) {
      const bsonSize = BSON.calculateObjectSize(document2, {
        checkKeys: false,
        ignoreUndefined: false
      });
      if (bsonSize >= this.s.maxBsonObjectSize)
        throw new error_1.MongoInvalidArgumentError(`Document is larger than the maximum size ${this.s.maxBsonObjectSize}`);
      if (this.s.currentBatch == null) {
        this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
      }
      const maxKeySize = this.s.maxKeySize;
      if (this.s.currentBatchSize + 1 >= this.s.maxWriteBatchSize || this.s.currentBatchSize > 0 && this.s.currentBatchSizeBytes + maxKeySize + bsonSize >= this.s.maxBatchSizeBytes || this.s.currentBatch.batchType !== batchType) {
        this.s.batches.push(this.s.currentBatch);
        this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
        this.s.currentBatchSize = 0;
        this.s.currentBatchSizeBytes = 0;
      }
      if (batchType === common_1.BatchType.INSERT) {
        this.s.bulkResult.insertedIds.push({
          index: this.s.currentIndex,
          _id: document2._id
        });
      }
      if (Array.isArray(document2)) {
        throw new error_1.MongoInvalidArgumentError("Operation passed in cannot be an Array");
      }
      this.s.currentBatch.originalIndexes.push(this.s.currentIndex);
      this.s.currentBatch.operations.push(document2);
      this.s.currentBatchSize += 1;
      this.s.currentBatchSizeBytes += maxKeySize + bsonSize;
      this.s.currentIndex += 1;
      return this;
    }
  }
  exports.OrderedBulkOperation = OrderedBulkOperation;
});

// node_modules/mongodb/lib/bulk/unordered.js
var require_unordered = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnorderedBulkOperation = undefined;
  var BSON = require_bson2();
  var error_1 = require_error();
  var common_1 = require_common2();

  class UnorderedBulkOperation extends common_1.BulkOperationBase {
    constructor(collection, options) {
      super(collection, options, false);
    }
    handleWriteError(writeResult) {
      if (this.s.batches.length) {
        return;
      }
      return super.handleWriteError(writeResult);
    }
    addToOperationsList(batchType, document2) {
      const bsonSize = BSON.calculateObjectSize(document2, {
        checkKeys: false,
        ignoreUndefined: false
      });
      if (bsonSize >= this.s.maxBsonObjectSize) {
        throw new error_1.MongoInvalidArgumentError(`Document is larger than the maximum size ${this.s.maxBsonObjectSize}`);
      }
      this.s.currentBatch = undefined;
      if (batchType === common_1.BatchType.INSERT) {
        this.s.currentBatch = this.s.currentInsertBatch;
      } else if (batchType === common_1.BatchType.UPDATE) {
        this.s.currentBatch = this.s.currentUpdateBatch;
      } else if (batchType === common_1.BatchType.DELETE) {
        this.s.currentBatch = this.s.currentRemoveBatch;
      }
      const maxKeySize = this.s.maxKeySize;
      if (this.s.currentBatch == null) {
        this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
      }
      if (this.s.currentBatch.size + 1 >= this.s.maxWriteBatchSize || this.s.currentBatch.size > 0 && this.s.currentBatch.sizeBytes + maxKeySize + bsonSize >= this.s.maxBatchSizeBytes || this.s.currentBatch.batchType !== batchType) {
        this.s.batches.push(this.s.currentBatch);
        this.s.currentBatch = new common_1.Batch(batchType, this.s.currentIndex);
      }
      if (Array.isArray(document2)) {
        throw new error_1.MongoInvalidArgumentError("Operation passed in cannot be an Array");
      }
      this.s.currentBatch.operations.push(document2);
      this.s.currentBatch.originalIndexes.push(this.s.currentIndex);
      this.s.currentIndex = this.s.currentIndex + 1;
      if (batchType === common_1.BatchType.INSERT) {
        this.s.currentInsertBatch = this.s.currentBatch;
        this.s.bulkResult.insertedIds.push({
          index: this.s.bulkResult.insertedIds.length,
          _id: document2._id
        });
      } else if (batchType === common_1.BatchType.UPDATE) {
        this.s.currentUpdateBatch = this.s.currentBatch;
      } else if (batchType === common_1.BatchType.DELETE) {
        this.s.currentRemoveBatch = this.s.currentBatch;
      }
      this.s.currentBatch.size += 1;
      this.s.currentBatch.sizeBytes += maxKeySize + bsonSize;
      return this;
    }
  }
  exports.UnorderedBulkOperation = UnorderedBulkOperation;
});

// node_modules/mongodb/lib/operations/aggregate.js
var require_aggregate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AggregateOperation = exports.DB_AGGREGATE_COLLECTION = undefined;
  var responses_1 = require_responses();
  var error_1 = require_error();
  var utils_1 = require_utils2();
  var write_concern_1 = require_write_concern();
  var command_1 = require_command();
  var operation_1 = require_operation();
  exports.DB_AGGREGATE_COLLECTION = 1;
  var MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;

  class AggregateOperation extends command_1.CommandOperation {
    constructor(ns, pipeline, options) {
      super(undefined, { ...options, dbName: ns.db });
      this.options = { ...options };
      this.target = ns.collection || exports.DB_AGGREGATE_COLLECTION;
      this.pipeline = pipeline;
      this.hasWriteStage = false;
      if (typeof options?.out === "string") {
        this.pipeline = this.pipeline.concat({ $out: options.out });
        this.hasWriteStage = true;
      } else if (pipeline.length > 0) {
        const finalStage = pipeline[pipeline.length - 1];
        if (finalStage.$out || finalStage.$merge) {
          this.hasWriteStage = true;
        }
      }
      if (this.hasWriteStage) {
        this.trySecondaryWrite = true;
      } else {
        delete this.options.writeConcern;
      }
      if (this.explain && this.writeConcern) {
        throw new error_1.MongoInvalidArgumentError('Option "explain" cannot be used on an aggregate call with writeConcern');
      }
      if (options?.cursor != null && typeof options.cursor !== "object") {
        throw new error_1.MongoInvalidArgumentError("Cursor options must be an object");
      }
    }
    get commandName() {
      return "aggregate";
    }
    get canRetryRead() {
      return !this.hasWriteStage;
    }
    addToPipeline(stage) {
      this.pipeline.push(stage);
    }
    async execute(server, session, timeoutContext) {
      const options = this.options;
      const serverWireVersion = (0, utils_1.maxWireVersion)(server);
      const command = { aggregate: this.target, pipeline: this.pipeline };
      if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {
        this.readConcern = undefined;
      }
      if (this.hasWriteStage && this.writeConcern) {
        write_concern_1.WriteConcern.apply(command, this.writeConcern);
      }
      if (options.bypassDocumentValidation === true) {
        command.bypassDocumentValidation = options.bypassDocumentValidation;
      }
      if (typeof options.allowDiskUse === "boolean") {
        command.allowDiskUse = options.allowDiskUse;
      }
      if (options.hint) {
        command.hint = options.hint;
      }
      if (options.let) {
        command.let = options.let;
      }
      if (options.comment !== undefined) {
        command.comment = options.comment;
      }
      command.cursor = options.cursor || {};
      if (options.batchSize && !this.hasWriteStage) {
        command.cursor.batchSize = options.batchSize;
      }
      return await super.executeCommand(server, session, command, timeoutContext, this.explain ? responses_1.ExplainedCursorResponse : responses_1.CursorResponse);
    }
  }
  exports.AggregateOperation = AggregateOperation;
  (0, operation_1.defineAspects)(AggregateOperation, [
    operation_1.Aspect.READ_OPERATION,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.EXPLAINABLE,
    operation_1.Aspect.CURSOR_CREATING
  ]);
});

// node_modules/mongodb/lib/cursor/aggregation_cursor.js
var require_aggregation_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AggregationCursor = undefined;
  var error_1 = require_error();
  var explain_1 = require_explain();
  var aggregate_1 = require_aggregate();
  var execute_operation_1 = require_execute_operation();
  var utils_1 = require_utils2();
  var abstract_cursor_1 = require_abstract_cursor();

  class AggregationCursor extends explain_1.ExplainableCursor {
    constructor(client, namespace, pipeline = [], options = {}) {
      super(client, namespace, options);
      this.pipeline = pipeline;
      this.aggregateOptions = options;
      const lastStage = this.pipeline[this.pipeline.length - 1];
      if (this.cursorOptions.timeoutMS != null && this.cursorOptions.timeoutMode === abstract_cursor_1.CursorTimeoutMode.ITERATION && (lastStage?.$merge != null || lastStage?.$out != null))
        throw new error_1.MongoAPIError("Cannot use $out or $merge stage with ITERATION timeoutMode");
    }
    clone() {
      const clonedOptions = (0, utils_1.mergeOptions)({}, this.aggregateOptions);
      delete clonedOptions.session;
      return new AggregationCursor(this.client, this.namespace, this.pipeline, {
        ...clonedOptions
      });
    }
    map(transform) {
      return super.map(transform);
    }
    async _initialize(session) {
      const options = {
        ...this.aggregateOptions,
        ...this.cursorOptions,
        session,
        signal: this.signal
      };
      if (options.explain) {
        try {
          (0, explain_1.validateExplainTimeoutOptions)(options, explain_1.Explain.fromOptions(options));
        } catch {
          throw new error_1.MongoAPIError("timeoutMS cannot be used with explain when explain is specified in aggregateOptions");
        }
      }
      const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this.pipeline, options);
      const response = await (0, execute_operation_1.executeOperation)(this.client, aggregateOperation, this.timeoutContext);
      return { server: aggregateOperation.server, session, response };
    }
    async explain(verbosity, options) {
      const { explain, timeout } = this.resolveExplainTimeoutOptions(verbosity, options);
      return (await (0, execute_operation_1.executeOperation)(this.client, new aggregate_1.AggregateOperation(this.namespace, this.pipeline, {
        ...this.aggregateOptions,
        ...this.cursorOptions,
        ...timeout,
        explain: explain ?? true
      }))).shift(this.deserializationOptions);
    }
    addStage(stage) {
      this.throwIfInitialized();
      if (this.cursorOptions.timeoutMS != null && this.cursorOptions.timeoutMode === abstract_cursor_1.CursorTimeoutMode.ITERATION && (stage.$out != null || stage.$merge != null)) {
        throw new error_1.MongoAPIError("Cannot use $out or $merge stage with ITERATION timeoutMode");
      }
      this.pipeline.push(stage);
      return this;
    }
    group($group) {
      return this.addStage({ $group });
    }
    limit($limit) {
      return this.addStage({ $limit });
    }
    match($match) {
      return this.addStage({ $match });
    }
    out($out) {
      return this.addStage({ $out });
    }
    project($project) {
      return this.addStage({ $project });
    }
    lookup($lookup) {
      return this.addStage({ $lookup });
    }
    redact($redact) {
      return this.addStage({ $redact });
    }
    skip($skip) {
      return this.addStage({ $skip });
    }
    sort($sort) {
      return this.addStage({ $sort });
    }
    unwind($unwind) {
      return this.addStage({ $unwind });
    }
    geoNear($geoNear) {
      return this.addStage({ $geoNear });
    }
  }
  exports.AggregationCursor = AggregationCursor;
});

// node_modules/mongodb/lib/operations/count.js
var require_count = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CountOperation = undefined;
  var command_1 = require_command();
  var operation_1 = require_operation();

  class CountOperation extends command_1.CommandOperation {
    constructor(namespace, filter, options) {
      super({ s: { namespace } }, options);
      this.options = options;
      this.collectionName = namespace.collection;
      this.query = filter;
    }
    get commandName() {
      return "count";
    }
    async execute(server, session, timeoutContext) {
      const options = this.options;
      const cmd = {
        count: this.collectionName,
        query: this.query
      };
      if (typeof options.limit === "number") {
        cmd.limit = options.limit;
      }
      if (typeof options.skip === "number") {
        cmd.skip = options.skip;
      }
      if (options.hint != null) {
        cmd.hint = options.hint;
      }
      if (typeof options.maxTimeMS === "number") {
        cmd.maxTimeMS = options.maxTimeMS;
      }
      const result = await super.executeCommand(server, session, cmd, timeoutContext);
      return result ? result.n : 0;
    }
  }
  exports.CountOperation = CountOperation;
  (0, operation_1.defineAspects)(CountOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE]);
});

// node_modules/mongodb/lib/sort.js
var require_sort = __commonJS((exports) => {
  function prepareDirection(direction = 1) {
    const value = `${direction}`.toLowerCase();
    if (isMeta(direction))
      return direction;
    switch (value) {
      case "ascending":
      case "asc":
      case "1":
        return 1;
      case "descending":
      case "desc":
      case "-1":
        return -1;
      default:
        throw new error_1.MongoInvalidArgumentError(`Invalid sort direction: ${JSON.stringify(direction)}`);
    }
  }
  function isMeta(t) {
    return typeof t === "object" && t != null && "$meta" in t && typeof t.$meta === "string";
  }
  function isPair(t) {
    if (Array.isArray(t) && t.length === 2) {
      try {
        prepareDirection(t[1]);
        return true;
      } catch {
        return false;
      }
    }
    return false;
  }
  function isDeep(t) {
    return Array.isArray(t) && Array.isArray(t[0]);
  }
  function isMap(t) {
    return t instanceof Map && t.size > 0;
  }
  function pairToMap(v) {
    return new Map([[`${v[0]}`, prepareDirection([v[1]])]]);
  }
  function deepToMap(t) {
    const sortEntries = t.map(([k, v]) => [`${k}`, prepareDirection(v)]);
    return new Map(sortEntries);
  }
  function stringsToMap(t) {
    const sortEntries = t.map((key) => [`${key}`, 1]);
    return new Map(sortEntries);
  }
  function objectToMap(t) {
    const sortEntries = Object.entries(t).map(([k, v]) => [
      `${k}`,
      prepareDirection(v)
    ]);
    return new Map(sortEntries);
  }
  function mapToMap(t) {
    const sortEntries = Array.from(t).map(([k, v]) => [
      `${k}`,
      prepareDirection(v)
    ]);
    return new Map(sortEntries);
  }
  function formatSort(sort, direction) {
    if (sort == null)
      return;
    if (typeof sort === "string")
      return new Map([[sort, prepareDirection(direction)]]);
    if (typeof sort !== "object") {
      throw new error_1.MongoInvalidArgumentError(`Invalid sort format: ${JSON.stringify(sort)} Sort must be a valid object`);
    }
    if (!Array.isArray(sort)) {
      return isMap(sort) ? mapToMap(sort) : Object.keys(sort).length ? objectToMap(sort) : undefined;
    }
    if (!sort.length)
      return;
    if (isDeep(sort))
      return deepToMap(sort);
    if (isPair(sort))
      return pairToMap(sort);
    return stringsToMap(sort);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatSort = formatSort;
  var error_1 = require_error();
});

// node_modules/mongodb/lib/operations/find.js
var require_find = __commonJS((exports) => {
  function makeFindCommand(ns, filter, options) {
    const findCommand = {
      find: ns.collection,
      filter
    };
    if (options.sort) {
      findCommand.sort = (0, sort_1.formatSort)(options.sort);
    }
    if (options.projection) {
      let projection = options.projection;
      if (projection && Array.isArray(projection)) {
        projection = projection.length ? projection.reduce((result, field) => {
          result[field] = 1;
          return result;
        }, {}) : { _id: 1 };
      }
      findCommand.projection = projection;
    }
    if (options.hint) {
      findCommand.hint = (0, utils_1.normalizeHintField)(options.hint);
    }
    if (typeof options.skip === "number") {
      findCommand.skip = options.skip;
    }
    if (typeof options.limit === "number") {
      if (options.limit < 0) {
        findCommand.limit = -options.limit;
        findCommand.singleBatch = true;
      } else {
        findCommand.limit = options.limit;
      }
    }
    if (typeof options.batchSize === "number") {
      if (options.batchSize < 0) {
        if (options.limit && options.limit !== 0 && Math.abs(options.batchSize) < Math.abs(options.limit)) {
          findCommand.limit = -options.batchSize;
        }
        findCommand.singleBatch = true;
      } else {
        findCommand.batchSize = options.batchSize;
      }
    }
    if (typeof options.singleBatch === "boolean") {
      findCommand.singleBatch = options.singleBatch;
    }
    if (options.comment !== undefined) {
      findCommand.comment = options.comment;
    }
    if (typeof options.maxTimeMS === "number") {
      findCommand.maxTimeMS = options.maxTimeMS;
    }
    const readConcern = read_concern_1.ReadConcern.fromOptions(options);
    if (readConcern) {
      findCommand.readConcern = readConcern.toJSON();
    }
    if (options.max) {
      findCommand.max = options.max;
    }
    if (options.min) {
      findCommand.min = options.min;
    }
    if (typeof options.returnKey === "boolean") {
      findCommand.returnKey = options.returnKey;
    }
    if (typeof options.showRecordId === "boolean") {
      findCommand.showRecordId = options.showRecordId;
    }
    if (typeof options.tailable === "boolean") {
      findCommand.tailable = options.tailable;
    }
    if (typeof options.oplogReplay === "boolean") {
      findCommand.oplogReplay = options.oplogReplay;
    }
    if (typeof options.timeout === "boolean") {
      findCommand.noCursorTimeout = !options.timeout;
    } else if (typeof options.noCursorTimeout === "boolean") {
      findCommand.noCursorTimeout = options.noCursorTimeout;
    }
    if (typeof options.awaitData === "boolean") {
      findCommand.awaitData = options.awaitData;
    }
    if (typeof options.allowPartialResults === "boolean") {
      findCommand.allowPartialResults = options.allowPartialResults;
    }
    if (options.collation) {
      findCommand.collation = options.collation;
    }
    if (typeof options.allowDiskUse === "boolean") {
      findCommand.allowDiskUse = options.allowDiskUse;
    }
    if (options.let) {
      findCommand.let = options.let;
    }
    return findCommand;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FindOperation = undefined;
  var responses_1 = require_responses();
  var error_1 = require_error();
  var explain_1 = require_explain();
  var read_concern_1 = require_read_concern();
  var sort_1 = require_sort();
  var utils_1 = require_utils2();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class FindOperation extends command_1.CommandOperation {
    constructor(ns, filter = {}, options = {}) {
      super(undefined, options);
      this.options = { ...options };
      delete this.options.writeConcern;
      this.ns = ns;
      if (typeof filter !== "object" || Array.isArray(filter)) {
        throw new error_1.MongoInvalidArgumentError("Query filter must be a plain object or ObjectId");
      }
      this.filter = filter != null && filter._bsontype === "ObjectId" ? { _id: filter } : filter;
    }
    get commandName() {
      return "find";
    }
    async execute(server, session, timeoutContext) {
      this.server = server;
      const options = this.options;
      let findCommand = makeFindCommand(this.ns, this.filter, options);
      if (this.explain) {
        (0, explain_1.validateExplainTimeoutOptions)(this.options, this.explain);
        findCommand = (0, explain_1.decorateWithExplain)(findCommand, this.explain);
      }
      return await server.command(this.ns, findCommand, {
        ...this.options,
        ...this.bsonOptions,
        documentsReturnedIn: "firstBatch",
        session,
        timeoutContext
      }, this.explain ? responses_1.ExplainedCursorResponse : responses_1.CursorResponse);
    }
  }
  exports.FindOperation = FindOperation;
  (0, operation_1.defineAspects)(FindOperation, [
    operation_1.Aspect.READ_OPERATION,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.EXPLAINABLE,
    operation_1.Aspect.CURSOR_CREATING
  ]);
});

// node_modules/mongodb/lib/cursor/find_cursor.js
var require_find_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FindCursor = exports.FLAGS = undefined;
  var responses_1 = require_responses();
  var error_1 = require_error();
  var explain_1 = require_explain();
  var count_1 = require_count();
  var execute_operation_1 = require_execute_operation();
  var find_1 = require_find();
  var sort_1 = require_sort();
  var utils_1 = require_utils2();
  exports.FLAGS = [
    "tailable",
    "oplogReplay",
    "noCursorTimeout",
    "awaitData",
    "exhaust",
    "partial"
  ];

  class FindCursor extends explain_1.ExplainableCursor {
    constructor(client, namespace, filter = {}, options = {}) {
      super(client, namespace, options);
      this.numReturned = 0;
      this.cursorFilter = filter;
      this.findOptions = options;
      if (options.sort != null) {
        this.findOptions.sort = (0, sort_1.formatSort)(options.sort);
      }
    }
    clone() {
      const clonedOptions = (0, utils_1.mergeOptions)({}, this.findOptions);
      delete clonedOptions.session;
      return new FindCursor(this.client, this.namespace, this.cursorFilter, {
        ...clonedOptions
      });
    }
    map(transform) {
      return super.map(transform);
    }
    async _initialize(session) {
      const options = {
        ...this.findOptions,
        ...this.cursorOptions,
        session,
        signal: this.signal
      };
      if (options.explain) {
        try {
          (0, explain_1.validateExplainTimeoutOptions)(options, explain_1.Explain.fromOptions(options));
        } catch {
          throw new error_1.MongoAPIError("timeoutMS cannot be used with explain when explain is specified in findOptions");
        }
      }
      const findOperation = new find_1.FindOperation(this.namespace, this.cursorFilter, options);
      const response = await (0, execute_operation_1.executeOperation)(this.client, findOperation, this.timeoutContext);
      this.numReturned = response.batchSize;
      return { server: findOperation.server, session, response };
    }
    async getMore(batchSize) {
      const numReturned = this.numReturned;
      if (numReturned) {
        const limit = this.findOptions.limit;
        batchSize = limit && limit > 0 && numReturned + batchSize > limit ? limit - numReturned : batchSize;
        if (batchSize <= 0) {
          try {
            await this.close();
          } catch (error) {
            (0, utils_1.squashError)(error);
          }
          return responses_1.CursorResponse.emptyGetMore;
        }
      }
      const response = await super.getMore(batchSize);
      this.numReturned = this.numReturned + response.batchSize;
      return response;
    }
    async count(options) {
      (0, utils_1.emitWarningOnce)("cursor.count is deprecated and will be removed in the next major version, please use `collection.estimatedDocumentCount` or `collection.countDocuments` instead ");
      if (typeof options === "boolean") {
        throw new error_1.MongoInvalidArgumentError("Invalid first parameter to count");
      }
      return await (0, execute_operation_1.executeOperation)(this.client, new count_1.CountOperation(this.namespace, this.cursorFilter, {
        ...this.findOptions,
        ...this.cursorOptions,
        ...options
      }));
    }
    async explain(verbosity, options) {
      const { explain, timeout } = this.resolveExplainTimeoutOptions(verbosity, options);
      return (await (0, execute_operation_1.executeOperation)(this.client, new find_1.FindOperation(this.namespace, this.cursorFilter, {
        ...this.findOptions,
        ...this.cursorOptions,
        ...timeout,
        explain: explain ?? true
      }))).shift(this.deserializationOptions);
    }
    filter(filter) {
      this.throwIfInitialized();
      this.cursorFilter = filter;
      return this;
    }
    hint(hint) {
      this.throwIfInitialized();
      this.findOptions.hint = hint;
      return this;
    }
    min(min) {
      this.throwIfInitialized();
      this.findOptions.min = min;
      return this;
    }
    max(max) {
      this.throwIfInitialized();
      this.findOptions.max = max;
      return this;
    }
    returnKey(value) {
      this.throwIfInitialized();
      this.findOptions.returnKey = value;
      return this;
    }
    showRecordId(value) {
      this.throwIfInitialized();
      this.findOptions.showRecordId = value;
      return this;
    }
    addQueryModifier(name, value) {
      this.throwIfInitialized();
      if (name[0] !== "$") {
        throw new error_1.MongoInvalidArgumentError(`${name} is not a valid query modifier`);
      }
      const field = name.substr(1);
      switch (field) {
        case "comment":
          this.findOptions.comment = value;
          break;
        case "explain":
          this.findOptions.explain = value;
          break;
        case "hint":
          this.findOptions.hint = value;
          break;
        case "max":
          this.findOptions.max = value;
          break;
        case "maxTimeMS":
          this.findOptions.maxTimeMS = value;
          break;
        case "min":
          this.findOptions.min = value;
          break;
        case "orderby":
          this.findOptions.sort = (0, sort_1.formatSort)(value);
          break;
        case "query":
          this.cursorFilter = value;
          break;
        case "returnKey":
          this.findOptions.returnKey = value;
          break;
        case "showDiskLoc":
          this.findOptions.showRecordId = value;
          break;
        default:
          throw new error_1.MongoInvalidArgumentError(`Invalid query modifier: ${name}`);
      }
      return this;
    }
    comment(value) {
      this.throwIfInitialized();
      this.findOptions.comment = value;
      return this;
    }
    maxAwaitTimeMS(value) {
      this.throwIfInitialized();
      if (typeof value !== "number") {
        throw new error_1.MongoInvalidArgumentError("Argument for maxAwaitTimeMS must be a number");
      }
      this.findOptions.maxAwaitTimeMS = value;
      return this;
    }
    maxTimeMS(value) {
      this.throwIfInitialized();
      if (typeof value !== "number") {
        throw new error_1.MongoInvalidArgumentError("Argument for maxTimeMS must be a number");
      }
      this.findOptions.maxTimeMS = value;
      return this;
    }
    project(value) {
      this.throwIfInitialized();
      this.findOptions.projection = value;
      return this;
    }
    sort(sort, direction) {
      this.throwIfInitialized();
      if (this.findOptions.tailable) {
        throw new error_1.MongoTailableCursorError("Tailable cursor does not support sorting");
      }
      this.findOptions.sort = (0, sort_1.formatSort)(sort, direction);
      return this;
    }
    allowDiskUse(allow = true) {
      this.throwIfInitialized();
      if (!this.findOptions.sort) {
        throw new error_1.MongoInvalidArgumentError('Option "allowDiskUse" requires a sort specification');
      }
      if (!allow) {
        this.findOptions.allowDiskUse = false;
        return this;
      }
      this.findOptions.allowDiskUse = true;
      return this;
    }
    collation(value) {
      this.throwIfInitialized();
      this.findOptions.collation = value;
      return this;
    }
    limit(value) {
      this.throwIfInitialized();
      if (this.findOptions.tailable) {
        throw new error_1.MongoTailableCursorError("Tailable cursor does not support limit");
      }
      if (typeof value !== "number") {
        throw new error_1.MongoInvalidArgumentError('Operation "limit" requires an integer');
      }
      this.findOptions.limit = value;
      return this;
    }
    skip(value) {
      this.throwIfInitialized();
      if (this.findOptions.tailable) {
        throw new error_1.MongoTailableCursorError("Tailable cursor does not support skip");
      }
      if (typeof value !== "number") {
        throw new error_1.MongoInvalidArgumentError('Operation "skip" requires an integer');
      }
      this.findOptions.skip = value;
      return this;
    }
  }
  exports.FindCursor = FindCursor;
});

// node_modules/mongodb/lib/operations/indexes.js
var require_indexes = __commonJS((exports) => {
  function isIndexDirection(x) {
    return typeof x === "number" || x === "2d" || x === "2dsphere" || x === "text" || x === "geoHaystack";
  }
  function isSingleIndexTuple(t) {
    return Array.isArray(t) && t.length === 2 && isIndexDirection(t[1]);
  }
  function constructIndexDescriptionMap(indexSpec) {
    const key = new Map;
    const indexSpecs = !Array.isArray(indexSpec) || isSingleIndexTuple(indexSpec) ? [indexSpec] : indexSpec;
    for (const spec of indexSpecs) {
      if (typeof spec === "string") {
        key.set(spec, 1);
      } else if (Array.isArray(spec)) {
        key.set(spec[0], spec[1] ?? 1);
      } else if (spec instanceof Map) {
        for (const [property, value] of spec) {
          key.set(property, value);
        }
      } else if ((0, utils_1.isObject)(spec)) {
        for (const [property, value] of Object.entries(spec)) {
          key.set(property, value);
        }
      }
    }
    return key;
  }
  function resolveIndexDescription(description) {
    const validProvidedOptions = Object.entries(description).filter(([optionName]) => VALID_INDEX_OPTIONS.has(optionName));
    return Object.fromEntries(validProvidedOptions.map(([name, value]) => name === "version" ? ["v", value] : [name, value]));
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListIndexesOperation = exports.DropIndexOperation = exports.CreateIndexesOperation = undefined;
  var responses_1 = require_responses();
  var error_1 = require_error();
  var utils_1 = require_utils2();
  var command_1 = require_command();
  var operation_1 = require_operation();
  var VALID_INDEX_OPTIONS = new Set([
    "background",
    "unique",
    "name",
    "partialFilterExpression",
    "sparse",
    "hidden",
    "expireAfterSeconds",
    "storageEngine",
    "collation",
    "version",
    "weights",
    "default_language",
    "language_override",
    "textIndexVersion",
    "2dsphereIndexVersion",
    "bits",
    "min",
    "max",
    "bucketSize",
    "wildcardProjection"
  ]);

  class CreateIndexesOperation extends command_1.CommandOperation {
    constructor(parent, collectionName, indexes, options) {
      super(parent, options);
      this.options = options ?? {};
      this.collectionName = collectionName;
      this.indexes = indexes.map((userIndex) => {
        const key = userIndex.key instanceof Map ? userIndex.key : new Map(Object.entries(userIndex.key));
        const name = userIndex.name ?? Array.from(key).flat().join("_");
        const validIndexOptions = resolveIndexDescription(userIndex);
        return {
          ...validIndexOptions,
          name,
          key
        };
      });
    }
    static fromIndexDescriptionArray(parent, collectionName, indexes, options) {
      return new CreateIndexesOperation(parent, collectionName, indexes, options);
    }
    static fromIndexSpecification(parent, collectionName, indexSpec, options = {}) {
      const key = constructIndexDescriptionMap(indexSpec);
      const description = { ...options, key };
      return new CreateIndexesOperation(parent, collectionName, [description], options);
    }
    get commandName() {
      return "createIndexes";
    }
    async execute(server, session, timeoutContext) {
      const options = this.options;
      const indexes = this.indexes;
      const serverWireVersion = (0, utils_1.maxWireVersion)(server);
      const cmd = { createIndexes: this.collectionName, indexes };
      if (options.commitQuorum != null) {
        if (serverWireVersion < 9) {
          throw new error_1.MongoCompatibilityError("Option `commitQuorum` for `createIndexes` not supported on servers < 4.4");
        }
        cmd.commitQuorum = options.commitQuorum;
      }
      this.options.collation = undefined;
      await super.executeCommand(server, session, cmd, timeoutContext);
      const indexNames = indexes.map((index) => index.name || "");
      return indexNames;
    }
  }
  exports.CreateIndexesOperation = CreateIndexesOperation;

  class DropIndexOperation extends command_1.CommandOperation {
    constructor(collection, indexName, options) {
      super(collection, options);
      this.options = options ?? {};
      this.collection = collection;
      this.indexName = indexName;
    }
    get commandName() {
      return "dropIndexes";
    }
    async execute(server, session, timeoutContext) {
      const cmd = { dropIndexes: this.collection.collectionName, index: this.indexName };
      return await super.executeCommand(server, session, cmd, timeoutContext);
    }
  }
  exports.DropIndexOperation = DropIndexOperation;

  class ListIndexesOperation extends command_1.CommandOperation {
    constructor(collection, options) {
      super(collection, options);
      this.options = { ...options };
      delete this.options.writeConcern;
      this.collectionNamespace = collection.s.namespace;
    }
    get commandName() {
      return "listIndexes";
    }
    async execute(server, session, timeoutContext) {
      const serverWireVersion = (0, utils_1.maxWireVersion)(server);
      const cursor = this.options.batchSize ? { batchSize: this.options.batchSize } : {};
      const command = { listIndexes: this.collectionNamespace.collection, cursor };
      if (serverWireVersion >= 9 && this.options.comment !== undefined) {
        command.comment = this.options.comment;
      }
      return await super.executeCommand(server, session, command, timeoutContext, responses_1.CursorResponse);
    }
  }
  exports.ListIndexesOperation = ListIndexesOperation;
  (0, operation_1.defineAspects)(ListIndexesOperation, [
    operation_1.Aspect.READ_OPERATION,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.CURSOR_CREATING
  ]);
  (0, operation_1.defineAspects)(CreateIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);
  (0, operation_1.defineAspects)(DropIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/cursor/list_indexes_cursor.js
var require_list_indexes_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListIndexesCursor = undefined;
  var execute_operation_1 = require_execute_operation();
  var indexes_1 = require_indexes();
  var abstract_cursor_1 = require_abstract_cursor();

  class ListIndexesCursor extends abstract_cursor_1.AbstractCursor {
    constructor(collection, options) {
      super(collection.client, collection.s.namespace, options);
      this.parent = collection;
      this.options = options;
    }
    clone() {
      return new ListIndexesCursor(this.parent, {
        ...this.options,
        ...this.cursorOptions
      });
    }
    async _initialize(session) {
      const operation = new indexes_1.ListIndexesOperation(this.parent, {
        ...this.cursorOptions,
        ...this.options,
        session
      });
      const response = await (0, execute_operation_1.executeOperation)(this.parent.client, operation, this.timeoutContext);
      return { server: operation.server, session, response };
    }
  }
  exports.ListIndexesCursor = ListIndexesCursor;
});

// node_modules/mongodb/lib/cursor/list_search_indexes_cursor.js
var require_list_search_indexes_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListSearchIndexesCursor = undefined;
  var aggregation_cursor_1 = require_aggregation_cursor();

  class ListSearchIndexesCursor extends aggregation_cursor_1.AggregationCursor {
    constructor({ fullNamespace: ns, client }, name, options = {}) {
      const pipeline = name == null ? [{ $listSearchIndexes: {} }] : [{ $listSearchIndexes: { name } }];
      super(client, ns, pipeline, options);
    }
  }
  exports.ListSearchIndexesCursor = ListSearchIndexesCursor;
});

// node_modules/mongodb/lib/operations/distinct.js
var require_distinct = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DistinctOperation = undefined;
  var utils_1 = require_utils2();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class DistinctOperation extends command_1.CommandOperation {
    constructor(collection, key, query, options) {
      super(collection, options);
      this.options = options ?? {};
      this.collection = collection;
      this.key = key;
      this.query = query;
    }
    get commandName() {
      return "distinct";
    }
    async execute(server, session, timeoutContext) {
      const coll = this.collection;
      const key = this.key;
      const query = this.query;
      const options = this.options;
      const cmd = {
        distinct: coll.collectionName,
        key,
        query
      };
      if (typeof options.maxTimeMS === "number") {
        cmd.maxTimeMS = options.maxTimeMS;
      }
      if (typeof options.comment !== "undefined") {
        cmd.comment = options.comment;
      }
      (0, utils_1.decorateWithReadConcern)(cmd, coll, options);
      (0, utils_1.decorateWithCollation)(cmd, coll, options);
      const result = await super.executeCommand(server, session, cmd, timeoutContext);
      return this.explain ? result : result.values;
    }
  }
  exports.DistinctOperation = DistinctOperation;
  (0, operation_1.defineAspects)(DistinctOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE]);
});

// node_modules/mongodb/lib/operations/drop.js
var require_drop = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DropDatabaseOperation = exports.DropCollectionOperation = undefined;
  var error_1 = require_error();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class DropCollectionOperation extends command_1.CommandOperation {
    constructor(db, name, options = {}) {
      super(db, options);
      this.db = db;
      this.options = options;
      this.name = name;
    }
    get commandName() {
      return "drop";
    }
    async execute(server, session, timeoutContext) {
      const db = this.db;
      const options = this.options;
      const name = this.name;
      const encryptedFieldsMap = db.client.s.options.autoEncryption?.encryptedFieldsMap;
      let encryptedFields = options.encryptedFields ?? encryptedFieldsMap?.[`${db.databaseName}.${name}`];
      if (!encryptedFields && encryptedFieldsMap) {
        const listCollectionsResult = await db.listCollections({ name }, { nameOnly: false }).toArray();
        encryptedFields = listCollectionsResult?.[0]?.options?.encryptedFields;
      }
      if (encryptedFields) {
        const escCollection = encryptedFields.escCollection || `enxcol_.${name}.esc`;
        const ecocCollection = encryptedFields.ecocCollection || `enxcol_.${name}.ecoc`;
        for (const collectionName of [escCollection, ecocCollection]) {
          const dropOp = new DropCollectionOperation(db, collectionName);
          try {
            await dropOp.executeWithoutEncryptedFieldsCheck(server, session, timeoutContext);
          } catch (err) {
            if (!(err instanceof error_1.MongoServerError) || err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
              throw err;
            }
          }
        }
      }
      return await this.executeWithoutEncryptedFieldsCheck(server, session, timeoutContext);
    }
    async executeWithoutEncryptedFieldsCheck(server, session, timeoutContext) {
      await super.executeCommand(server, session, { drop: this.name }, timeoutContext);
      return true;
    }
  }
  exports.DropCollectionOperation = DropCollectionOperation;

  class DropDatabaseOperation extends command_1.CommandOperation {
    constructor(db, options) {
      super(db, options);
      this.options = options;
    }
    get commandName() {
      return "dropDatabase";
    }
    async execute(server, session, timeoutContext) {
      await super.executeCommand(server, session, { dropDatabase: 1 }, timeoutContext);
      return true;
    }
  }
  exports.DropDatabaseOperation = DropDatabaseOperation;
  (0, operation_1.defineAspects)(DropCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);
  (0, operation_1.defineAspects)(DropDatabaseOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/operations/estimated_document_count.js
var require_estimated_document_count = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EstimatedDocumentCountOperation = undefined;
  var command_1 = require_command();
  var operation_1 = require_operation();

  class EstimatedDocumentCountOperation extends command_1.CommandOperation {
    constructor(collection, options = {}) {
      super(collection, options);
      this.options = options;
      this.collectionName = collection.collectionName;
    }
    get commandName() {
      return "count";
    }
    async execute(server, session, timeoutContext) {
      const cmd = { count: this.collectionName };
      if (typeof this.options.maxTimeMS === "number") {
        cmd.maxTimeMS = this.options.maxTimeMS;
      }
      if (this.options.comment !== undefined) {
        cmd.comment = this.options.comment;
      }
      const response = await super.executeCommand(server, session, cmd, timeoutContext);
      return response?.n || 0;
    }
  }
  exports.EstimatedDocumentCountOperation = EstimatedDocumentCountOperation;
  (0, operation_1.defineAspects)(EstimatedDocumentCountOperation, [
    operation_1.Aspect.READ_OPERATION,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.CURSOR_CREATING
  ]);
});

// node_modules/mongodb/lib/operations/find_and_modify.js
var require_find_and_modify = __commonJS((exports) => {
  function configureFindAndModifyCmdBaseUpdateOpts(cmdBase, options) {
    cmdBase.new = options.returnDocument === exports.ReturnDocument.AFTER;
    cmdBase.upsert = options.upsert === true;
    if (options.bypassDocumentValidation === true) {
      cmdBase.bypassDocumentValidation = options.bypassDocumentValidation;
    }
    return cmdBase;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FindOneAndUpdateOperation = exports.FindOneAndReplaceOperation = exports.FindOneAndDeleteOperation = exports.FindAndModifyOperation = exports.ReturnDocument = undefined;
  var error_1 = require_error();
  var read_preference_1 = require_read_preference();
  var sort_1 = require_sort();
  var utils_1 = require_utils2();
  var command_1 = require_command();
  var operation_1 = require_operation();
  exports.ReturnDocument = Object.freeze({
    BEFORE: "before",
    AFTER: "after"
  });

  class FindAndModifyOperation extends command_1.CommandOperation {
    constructor(collection, query, options) {
      super(collection, options);
      this.options = options ?? {};
      this.cmdBase = {
        remove: false,
        new: false,
        upsert: false
      };
      options.includeResultMetadata ??= false;
      const sort = (0, sort_1.formatSort)(options.sort);
      if (sort) {
        this.cmdBase.sort = sort;
      }
      if (options.projection) {
        this.cmdBase.fields = options.projection;
      }
      if (options.maxTimeMS) {
        this.cmdBase.maxTimeMS = options.maxTimeMS;
      }
      if (options.writeConcern) {
        this.cmdBase.writeConcern = options.writeConcern;
      }
      if (options.let) {
        this.cmdBase.let = options.let;
      }
      if (options.comment !== undefined) {
        this.cmdBase.comment = options.comment;
      }
      this.readPreference = read_preference_1.ReadPreference.primary;
      this.collection = collection;
      this.query = query;
    }
    get commandName() {
      return "findAndModify";
    }
    async execute(server, session, timeoutContext) {
      const coll = this.collection;
      const query = this.query;
      const options = { ...this.options, ...this.bsonOptions };
      const cmd = {
        findAndModify: coll.collectionName,
        query,
        ...this.cmdBase
      };
      (0, utils_1.decorateWithCollation)(cmd, coll, options);
      if (options.hint) {
        const unacknowledgedWrite = this.writeConcern?.w === 0;
        if (unacknowledgedWrite || (0, utils_1.maxWireVersion)(server) < 8) {
          throw new error_1.MongoCompatibilityError("The current topology does not support a hint on findAndModify commands");
        }
        cmd.hint = options.hint;
      }
      const result = await super.executeCommand(server, session, cmd, timeoutContext);
      return options.includeResultMetadata ? result : result.value ?? null;
    }
  }
  exports.FindAndModifyOperation = FindAndModifyOperation;

  class FindOneAndDeleteOperation extends FindAndModifyOperation {
    constructor(collection, filter, options) {
      if (filter == null || typeof filter !== "object") {
        throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
      }
      super(collection, filter, options);
      this.cmdBase.remove = true;
    }
  }
  exports.FindOneAndDeleteOperation = FindOneAndDeleteOperation;

  class FindOneAndReplaceOperation extends FindAndModifyOperation {
    constructor(collection, filter, replacement, options) {
      if (filter == null || typeof filter !== "object") {
        throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
      }
      if (replacement == null || typeof replacement !== "object") {
        throw new error_1.MongoInvalidArgumentError('Argument "replacement" must be an object');
      }
      if ((0, utils_1.hasAtomicOperators)(replacement)) {
        throw new error_1.MongoInvalidArgumentError("Replacement document must not contain atomic operators");
      }
      super(collection, filter, options);
      this.cmdBase.update = replacement;
      configureFindAndModifyCmdBaseUpdateOpts(this.cmdBase, options);
    }
  }
  exports.FindOneAndReplaceOperation = FindOneAndReplaceOperation;

  class FindOneAndUpdateOperation extends FindAndModifyOperation {
    constructor(collection, filter, update, options) {
      if (filter == null || typeof filter !== "object") {
        throw new error_1.MongoInvalidArgumentError('Argument "filter" must be an object');
      }
      if (update == null || typeof update !== "object") {
        throw new error_1.MongoInvalidArgumentError('Argument "update" must be an object');
      }
      if (!(0, utils_1.hasAtomicOperators)(update)) {
        throw new error_1.MongoInvalidArgumentError("Update document requires atomic operators");
      }
      super(collection, filter, options);
      this.cmdBase.update = update;
      configureFindAndModifyCmdBaseUpdateOpts(this.cmdBase, options);
      if (options.arrayFilters) {
        this.cmdBase.arrayFilters = options.arrayFilters;
      }
    }
  }
  exports.FindOneAndUpdateOperation = FindOneAndUpdateOperation;
  (0, operation_1.defineAspects)(FindAndModifyOperation, [
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.EXPLAINABLE
  ]);
});

// node_modules/mongodb/lib/operations/is_capped.js
var require_is_capped = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IsCappedOperation = undefined;
  var error_1 = require_error();
  var operation_1 = require_operation();

  class IsCappedOperation extends operation_1.AbstractOperation {
    constructor(collection, options) {
      super(options);
      this.options = options;
      this.collection = collection;
    }
    get commandName() {
      return "listCollections";
    }
    async execute(server, session) {
      const coll = this.collection;
      const [collection] = await coll.s.db.listCollections({ name: coll.collectionName }, { ...this.options, nameOnly: false, readPreference: this.readPreference, session }).toArray();
      if (collection == null || collection.options == null) {
        throw new error_1.MongoAPIError(`collection ${coll.namespace} not found`);
      }
      return !!collection.options?.capped;
    }
  }
  exports.IsCappedOperation = IsCappedOperation;
});

// node_modules/mongodb/lib/operations/options_operation.js
var require_options_operation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OptionsOperation = undefined;
  var error_1 = require_error();
  var operation_1 = require_operation();

  class OptionsOperation extends operation_1.AbstractOperation {
    constructor(collection, options) {
      super(options);
      this.options = options;
      this.collection = collection;
    }
    get commandName() {
      return "listCollections";
    }
    async execute(server, session) {
      const coll = this.collection;
      const [collection] = await coll.s.db.listCollections({ name: coll.collectionName }, { ...this.options, nameOnly: false, readPreference: this.readPreference, session }).toArray();
      if (collection == null || collection.options == null) {
        throw new error_1.MongoAPIError(`collection ${coll.namespace} not found`);
      }
      return collection.options;
    }
  }
  exports.OptionsOperation = OptionsOperation;
});

// node_modules/mongodb/lib/operations/rename.js
var require_rename = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RenameOperation = undefined;
  var collection_1 = require_collection2();
  var utils_1 = require_utils2();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class RenameOperation extends command_1.CommandOperation {
    constructor(collection, newName, options) {
      super(collection, options);
      this.collection = collection;
      this.newName = newName;
      this.options = options;
      this.ns = new utils_1.MongoDBNamespace("admin", "$cmd");
    }
    get commandName() {
      return "renameCollection";
    }
    async execute(server, session, timeoutContext) {
      const renameCollection = this.collection.namespace;
      const toCollection = this.collection.s.namespace.withCollection(this.newName).toString();
      const dropTarget = typeof this.options.dropTarget === "boolean" ? this.options.dropTarget : false;
      const command = {
        renameCollection,
        to: toCollection,
        dropTarget
      };
      await super.executeCommand(server, session, command, timeoutContext);
      return new collection_1.Collection(this.collection.s.db, this.newName, this.collection.s.options);
    }
  }
  exports.RenameOperation = RenameOperation;
  (0, operation_1.defineAspects)(RenameOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/operations/search_indexes/create.js
var require_create = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CreateSearchIndexesOperation = undefined;
  var operation_1 = require_operation();

  class CreateSearchIndexesOperation extends operation_1.AbstractOperation {
    constructor(collection, descriptions) {
      super();
      this.collection = collection;
      this.descriptions = descriptions;
    }
    get commandName() {
      return "createSearchIndexes";
    }
    async execute(server, session, timeoutContext) {
      const namespace = this.collection.fullNamespace;
      const command = {
        createSearchIndexes: namespace.collection,
        indexes: this.descriptions
      };
      const res = await server.command(namespace, command, {
        session,
        timeoutContext
      });
      const indexesCreated = res?.indexesCreated ?? [];
      return indexesCreated.map(({ name }) => name);
    }
  }
  exports.CreateSearchIndexesOperation = CreateSearchIndexesOperation;
});

// node_modules/mongodb/lib/operations/search_indexes/drop.js
var require_drop2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DropSearchIndexOperation = undefined;
  var error_1 = require_error();
  var operation_1 = require_operation();

  class DropSearchIndexOperation extends operation_1.AbstractOperation {
    constructor(collection, name) {
      super();
      this.collection = collection;
      this.name = name;
    }
    get commandName() {
      return "dropSearchIndex";
    }
    async execute(server, session, timeoutContext) {
      const namespace = this.collection.fullNamespace;
      const command = {
        dropSearchIndex: namespace.collection
      };
      if (typeof this.name === "string") {
        command.name = this.name;
      }
      try {
        await server.command(namespace, command, { session, timeoutContext });
      } catch (error) {
        const isNamespaceNotFoundError = error instanceof error_1.MongoServerError && error.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound;
        if (!isNamespaceNotFoundError) {
          throw error;
        }
      }
    }
  }
  exports.DropSearchIndexOperation = DropSearchIndexOperation;
});

// node_modules/mongodb/lib/operations/search_indexes/update.js
var require_update2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UpdateSearchIndexOperation = undefined;
  var operation_1 = require_operation();

  class UpdateSearchIndexOperation extends operation_1.AbstractOperation {
    constructor(collection, name, definition) {
      super();
      this.collection = collection;
      this.name = name;
      this.definition = definition;
    }
    get commandName() {
      return "updateSearchIndex";
    }
    async execute(server, session, timeoutContext) {
      const namespace = this.collection.fullNamespace;
      const command = {
        updateSearchIndex: namespace.collection,
        name: this.name,
        definition: this.definition
      };
      await server.command(namespace, command, { session, timeoutContext });
      return;
    }
  }
  exports.UpdateSearchIndexOperation = UpdateSearchIndexOperation;
});

// node_modules/mongodb/lib/collection.js
var require_collection2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Collection = undefined;
  var bson_1 = require_bson2();
  var ordered_1 = require_ordered();
  var unordered_1 = require_unordered();
  var change_stream_1 = require_change_stream();
  var aggregation_cursor_1 = require_aggregation_cursor();
  var find_cursor_1 = require_find_cursor();
  var list_indexes_cursor_1 = require_list_indexes_cursor();
  var list_search_indexes_cursor_1 = require_list_search_indexes_cursor();
  var error_1 = require_error();
  var bulk_write_1 = require_bulk_write();
  var count_1 = require_count();
  var delete_1 = require_delete();
  var distinct_1 = require_distinct();
  var drop_1 = require_drop();
  var estimated_document_count_1 = require_estimated_document_count();
  var execute_operation_1 = require_execute_operation();
  var find_and_modify_1 = require_find_and_modify();
  var indexes_1 = require_indexes();
  var insert_1 = require_insert();
  var is_capped_1 = require_is_capped();
  var options_operation_1 = require_options_operation();
  var rename_1 = require_rename();
  var create_1 = require_create();
  var drop_2 = require_drop2();
  var update_1 = require_update2();
  var update_2 = require_update();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var utils_1 = require_utils2();
  var write_concern_1 = require_write_concern();

  class Collection {
    constructor(db, name, options) {
      this.s = {
        db,
        options,
        namespace: new utils_1.MongoDBCollectionNamespace(db.databaseName, name),
        pkFactory: db.options?.pkFactory ?? utils_1.DEFAULT_PK_FACTORY,
        readPreference: read_preference_1.ReadPreference.fromOptions(options),
        bsonOptions: (0, bson_1.resolveBSONOptions)(options, db),
        readConcern: read_concern_1.ReadConcern.fromOptions(options),
        writeConcern: write_concern_1.WriteConcern.fromOptions(options)
      };
      this.client = db.client;
    }
    get dbName() {
      return this.s.namespace.db;
    }
    get collectionName() {
      return this.s.namespace.collection;
    }
    get namespace() {
      return this.fullNamespace.toString();
    }
    get fullNamespace() {
      return this.s.namespace;
    }
    get readConcern() {
      if (this.s.readConcern == null) {
        return this.s.db.readConcern;
      }
      return this.s.readConcern;
    }
    get readPreference() {
      if (this.s.readPreference == null) {
        return this.s.db.readPreference;
      }
      return this.s.readPreference;
    }
    get bsonOptions() {
      return this.s.bsonOptions;
    }
    get writeConcern() {
      if (this.s.writeConcern == null) {
        return this.s.db.writeConcern;
      }
      return this.s.writeConcern;
    }
    get hint() {
      return this.s.collectionHint;
    }
    set hint(v) {
      this.s.collectionHint = (0, utils_1.normalizeHintField)(v);
    }
    get timeoutMS() {
      return this.s.options.timeoutMS;
    }
    async insertOne(doc, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new insert_1.InsertOneOperation(this, doc, (0, utils_1.resolveOptions)(this, options)));
    }
    async insertMany(docs, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new insert_1.InsertManyOperation(this, docs, (0, utils_1.resolveOptions)(this, options ?? { ordered: true })));
    }
    async bulkWrite(operations, options) {
      if (!Array.isArray(operations)) {
        throw new error_1.MongoInvalidArgumentError('Argument "operations" must be an array of documents');
      }
      return await (0, execute_operation_1.executeOperation)(this.client, new bulk_write_1.BulkWriteOperation(this, operations, (0, utils_1.resolveOptions)(this, options ?? { ordered: true })));
    }
    async updateOne(filter, update, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new update_2.UpdateOneOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)));
    }
    async replaceOne(filter, replacement, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new update_2.ReplaceOneOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)));
    }
    async updateMany(filter, update, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new update_2.UpdateManyOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)));
    }
    async deleteOne(filter = {}, options = {}) {
      return await (0, execute_operation_1.executeOperation)(this.client, new delete_1.DeleteOneOperation(this, filter, (0, utils_1.resolveOptions)(this, options)));
    }
    async deleteMany(filter = {}, options = {}) {
      return await (0, execute_operation_1.executeOperation)(this.client, new delete_1.DeleteManyOperation(this, filter, (0, utils_1.resolveOptions)(this, options)));
    }
    async rename(newName, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new rename_1.RenameOperation(this, newName, (0, utils_1.resolveOptions)(undefined, {
        ...options,
        readPreference: read_preference_1.ReadPreference.PRIMARY
      })));
    }
    async drop(options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropCollectionOperation(this.s.db, this.collectionName, options));
    }
    async findOne(filter = {}, options = {}) {
      const cursor = this.find(filter, options).limit(-1).batchSize(1);
      const res = await cursor.next();
      await cursor.close();
      return res;
    }
    find(filter = {}, options = {}) {
      return new find_cursor_1.FindCursor(this.client, this.s.namespace, filter, (0, utils_1.resolveOptions)(this, options));
    }
    async options(options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new options_operation_1.OptionsOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async isCapped(options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new is_capped_1.IsCappedOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async createIndex(indexSpec, options) {
      const indexes = await (0, execute_operation_1.executeOperation)(this.client, indexes_1.CreateIndexesOperation.fromIndexSpecification(this, this.collectionName, indexSpec, (0, utils_1.resolveOptions)(this, options)));
      return indexes[0];
    }
    async createIndexes(indexSpecs, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, indexes_1.CreateIndexesOperation.fromIndexDescriptionArray(this, this.collectionName, indexSpecs, (0, utils_1.resolveOptions)(this, { ...options, maxTimeMS: undefined })));
    }
    async dropIndex(indexName, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new indexes_1.DropIndexOperation(this, indexName, {
        ...(0, utils_1.resolveOptions)(this, options),
        readPreference: read_preference_1.ReadPreference.primary
      }));
    }
    async dropIndexes(options) {
      try {
        await (0, execute_operation_1.executeOperation)(this.client, new indexes_1.DropIndexOperation(this, "*", (0, utils_1.resolveOptions)(this, options)));
        return true;
      } catch (error) {
        if (error instanceof error_1.MongoOperationTimeoutError)
          throw error;
        return false;
      }
    }
    listIndexes(options) {
      return new list_indexes_cursor_1.ListIndexesCursor(this, (0, utils_1.resolveOptions)(this, options));
    }
    async indexExists(indexes, options) {
      const indexNames = Array.isArray(indexes) ? indexes : [indexes];
      const allIndexes = new Set(await this.listIndexes(options).map(({ name }) => name).toArray());
      return indexNames.every((name) => allIndexes.has(name));
    }
    async indexInformation(options) {
      return await this.indexes({
        ...options,
        full: options?.full ?? false
      });
    }
    async estimatedDocumentCount(options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new estimated_document_count_1.EstimatedDocumentCountOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async countDocuments(filter = {}, options = {}) {
      const pipeline = [];
      pipeline.push({ $match: filter });
      if (typeof options.skip === "number") {
        pipeline.push({ $skip: options.skip });
      }
      if (typeof options.limit === "number") {
        pipeline.push({ $limit: options.limit });
      }
      pipeline.push({ $group: { _id: 1, n: { $sum: 1 } } });
      const cursor = this.aggregate(pipeline, options);
      const doc = await cursor.next();
      await cursor.close();
      return doc?.n ?? 0;
    }
    async distinct(key, filter = {}, options = {}) {
      return await (0, execute_operation_1.executeOperation)(this.client, new distinct_1.DistinctOperation(this, key, filter, (0, utils_1.resolveOptions)(this, options)));
    }
    async indexes(options) {
      const indexes = await this.listIndexes(options).toArray();
      const full = options?.full ?? true;
      if (full) {
        return indexes;
      }
      const object = Object.fromEntries(indexes.map(({ name, key }) => [name, Object.entries(key)]));
      return object;
    }
    async findOneAndDelete(filter, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndDeleteOperation(this, filter, (0, utils_1.resolveOptions)(this, options)));
    }
    async findOneAndReplace(filter, replacement, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndReplaceOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)));
    }
    async findOneAndUpdate(filter, update, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new find_and_modify_1.FindOneAndUpdateOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)));
    }
    aggregate(pipeline = [], options) {
      if (!Array.isArray(pipeline)) {
        throw new error_1.MongoInvalidArgumentError('Argument "pipeline" must be an array of aggregation stages');
      }
      return new aggregation_cursor_1.AggregationCursor(this.client, this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
    watch(pipeline = [], options = {}) {
      if (!Array.isArray(pipeline)) {
        options = pipeline;
        pipeline = [];
      }
      return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
    initializeUnorderedBulkOp(options) {
      return new unordered_1.UnorderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));
    }
    initializeOrderedBulkOp(options) {
      return new ordered_1.OrderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));
    }
    async count(filter = {}, options = {}) {
      return await (0, execute_operation_1.executeOperation)(this.client, new count_1.CountOperation(this.fullNamespace, filter, (0, utils_1.resolveOptions)(this, options)));
    }
    listSearchIndexes(indexNameOrOptions, options) {
      options = typeof indexNameOrOptions === "object" ? indexNameOrOptions : options == null ? {} : options;
      const indexName = indexNameOrOptions == null ? null : typeof indexNameOrOptions === "object" ? null : indexNameOrOptions;
      return new list_search_indexes_cursor_1.ListSearchIndexesCursor(this, indexName, options);
    }
    async createSearchIndex(description) {
      const [index] = await this.createSearchIndexes([description]);
      return index;
    }
    async createSearchIndexes(descriptions) {
      return await (0, execute_operation_1.executeOperation)(this.client, new create_1.CreateSearchIndexesOperation(this, descriptions));
    }
    async dropSearchIndex(name) {
      return await (0, execute_operation_1.executeOperation)(this.client, new drop_2.DropSearchIndexOperation(this, name));
    }
    async updateSearchIndex(name, definition) {
      return await (0, execute_operation_1.executeOperation)(this.client, new update_1.UpdateSearchIndexOperation(this, name, definition));
    }
  }
  exports.Collection = Collection;
});

// node_modules/mongodb/lib/cursor/change_stream_cursor.js
var require_change_stream_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChangeStreamCursor = undefined;
  var change_stream_1 = require_change_stream();
  var constants_1 = require_constants2();
  var aggregate_1 = require_aggregate();
  var execute_operation_1 = require_execute_operation();
  var utils_1 = require_utils2();
  var abstract_cursor_1 = require_abstract_cursor();

  class ChangeStreamCursor extends abstract_cursor_1.AbstractCursor {
    constructor(client, namespace, pipeline = [], options = {}) {
      super(client, namespace, { ...options, tailable: true, awaitData: true });
      this.pipeline = pipeline;
      this.changeStreamCursorOptions = options;
      this._resumeToken = null;
      this.startAtOperationTime = options.startAtOperationTime ?? null;
      if (options.startAfter) {
        this.resumeToken = options.startAfter;
      } else if (options.resumeAfter) {
        this.resumeToken = options.resumeAfter;
      }
    }
    set resumeToken(token) {
      this._resumeToken = token;
      this.emit(change_stream_1.ChangeStream.RESUME_TOKEN_CHANGED, token);
    }
    get resumeToken() {
      return this._resumeToken;
    }
    get resumeOptions() {
      const options = {
        ...this.changeStreamCursorOptions
      };
      for (const key of ["resumeAfter", "startAfter", "startAtOperationTime"]) {
        delete options[key];
      }
      if (this.resumeToken != null) {
        if (this.changeStreamCursorOptions.startAfter && !this.hasReceived) {
          options.startAfter = this.resumeToken;
        } else {
          options.resumeAfter = this.resumeToken;
        }
      } else if (this.startAtOperationTime != null && (0, utils_1.maxWireVersion)(this.server) >= 7) {
        options.startAtOperationTime = this.startAtOperationTime;
      }
      return options;
    }
    cacheResumeToken(resumeToken) {
      if (this.bufferedCount() === 0 && this.postBatchResumeToken) {
        this.resumeToken = this.postBatchResumeToken;
      } else {
        this.resumeToken = resumeToken;
      }
      this.hasReceived = true;
    }
    _processBatch(response) {
      const { postBatchResumeToken } = response;
      if (postBatchResumeToken) {
        this.postBatchResumeToken = postBatchResumeToken;
        if (response.batchSize === 0) {
          this.resumeToken = postBatchResumeToken;
        }
      }
    }
    clone() {
      return new ChangeStreamCursor(this.client, this.namespace, this.pipeline, {
        ...this.cursorOptions
      });
    }
    async _initialize(session) {
      const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this.pipeline, {
        ...this.cursorOptions,
        ...this.changeStreamCursorOptions,
        session
      });
      const response = await (0, execute_operation_1.executeOperation)(session.client, aggregateOperation, this.timeoutContext);
      const server = aggregateOperation.server;
      this.maxWireVersion = (0, utils_1.maxWireVersion)(server);
      if (this.startAtOperationTime == null && this.changeStreamCursorOptions.resumeAfter == null && this.changeStreamCursorOptions.startAfter == null && this.maxWireVersion >= 7) {
        this.startAtOperationTime = response.operationTime;
      }
      this._processBatch(response);
      this.emit(constants_1.INIT, response);
      this.emit(constants_1.RESPONSE);
      return { server, session, response };
    }
    async getMore(batchSize) {
      const response = await super.getMore(batchSize);
      this.maxWireVersion = (0, utils_1.maxWireVersion)(this.server);
      this._processBatch(response);
      this.emit(change_stream_1.ChangeStream.MORE, response);
      this.emit(change_stream_1.ChangeStream.RESPONSE);
      return response;
    }
  }
  exports.ChangeStreamCursor = ChangeStreamCursor;
});

// node_modules/mongodb/lib/operations/list_collections.js
var require_list_collections = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListCollectionsOperation = undefined;
  var responses_1 = require_responses();
  var utils_1 = require_utils2();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class ListCollectionsOperation extends command_1.CommandOperation {
    constructor(db, filter, options) {
      super(db, options);
      this.options = { ...options };
      delete this.options.writeConcern;
      this.db = db;
      this.filter = filter;
      this.nameOnly = !!this.options.nameOnly;
      this.authorizedCollections = !!this.options.authorizedCollections;
      if (typeof this.options.batchSize === "number") {
        this.batchSize = this.options.batchSize;
      }
    }
    get commandName() {
      return "listCollections";
    }
    async execute(server, session, timeoutContext) {
      return await super.executeCommand(server, session, this.generateCommand((0, utils_1.maxWireVersion)(server)), timeoutContext, responses_1.CursorResponse);
    }
    generateCommand(wireVersion) {
      const command = {
        listCollections: 1,
        filter: this.filter,
        cursor: this.batchSize ? { batchSize: this.batchSize } : {},
        nameOnly: this.nameOnly,
        authorizedCollections: this.authorizedCollections
      };
      if (wireVersion >= 9 && this.options.comment !== undefined) {
        command.comment = this.options.comment;
      }
      return command;
    }
  }
  exports.ListCollectionsOperation = ListCollectionsOperation;
  (0, operation_1.defineAspects)(ListCollectionsOperation, [
    operation_1.Aspect.READ_OPERATION,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.CURSOR_CREATING
  ]);
});

// node_modules/mongodb/lib/cursor/list_collections_cursor.js
var require_list_collections_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListCollectionsCursor = undefined;
  var execute_operation_1 = require_execute_operation();
  var list_collections_1 = require_list_collections();
  var abstract_cursor_1 = require_abstract_cursor();

  class ListCollectionsCursor extends abstract_cursor_1.AbstractCursor {
    constructor(db, filter, options) {
      super(db.client, db.s.namespace, options);
      this.parent = db;
      this.filter = filter;
      this.options = options;
    }
    clone() {
      return new ListCollectionsCursor(this.parent, this.filter, {
        ...this.options,
        ...this.cursorOptions
      });
    }
    async _initialize(session) {
      const operation = new list_collections_1.ListCollectionsOperation(this.parent, this.filter, {
        ...this.cursorOptions,
        ...this.options,
        session,
        signal: this.signal
      });
      const response = await (0, execute_operation_1.executeOperation)(this.parent.client, operation, this.timeoutContext);
      return { server: operation.server, session, response };
    }
  }
  exports.ListCollectionsCursor = ListCollectionsCursor;
});

// node_modules/mongodb/lib/operations/run_command.js
var require_run_command = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RunAdminCommandOperation = exports.RunCommandOperation = undefined;
  var utils_1 = require_utils2();
  var operation_1 = require_operation();

  class RunCommandOperation extends operation_1.AbstractOperation {
    constructor(parent, command, options) {
      super(options);
      this.command = command;
      this.options = options;
      this.ns = parent.s.namespace.withCollection("$cmd");
    }
    get commandName() {
      return "runCommand";
    }
    async execute(server, session, timeoutContext) {
      this.server = server;
      const res = await server.command(this.ns, this.command, {
        ...this.options,
        readPreference: this.readPreference,
        session,
        timeoutContext
      }, this.options.responseType);
      return res;
    }
  }
  exports.RunCommandOperation = RunCommandOperation;

  class RunAdminCommandOperation extends operation_1.AbstractOperation {
    constructor(command, options) {
      super(options);
      this.command = command;
      this.options = options;
      this.ns = new utils_1.MongoDBNamespace("admin", "$cmd");
    }
    get commandName() {
      return "runCommand";
    }
    async execute(server, session, timeoutContext) {
      this.server = server;
      const res = await server.command(this.ns, this.command, {
        ...this.options,
        readPreference: this.readPreference,
        session,
        timeoutContext
      });
      return res;
    }
  }
  exports.RunAdminCommandOperation = RunAdminCommandOperation;
});

// node_modules/mongodb/lib/cursor/run_command_cursor.js
var require_run_command_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RunCommandCursor = undefined;
  var responses_1 = require_responses();
  var error_1 = require_error();
  var execute_operation_1 = require_execute_operation();
  var get_more_1 = require_get_more();
  var run_command_1 = require_run_command();
  var utils_1 = require_utils2();
  var abstract_cursor_1 = require_abstract_cursor();

  class RunCommandCursor extends abstract_cursor_1.AbstractCursor {
    setComment(comment) {
      this.getMoreOptions.comment = comment;
      return this;
    }
    setMaxTimeMS(maxTimeMS) {
      this.getMoreOptions.maxAwaitTimeMS = maxTimeMS;
      return this;
    }
    setBatchSize(batchSize) {
      this.getMoreOptions.batchSize = batchSize;
      return this;
    }
    clone() {
      throw new error_1.MongoAPIError("Clone not supported, create a new cursor with db.runCursorCommand");
    }
    withReadConcern(_2) {
      throw new error_1.MongoAPIError("RunCommandCursor does not support readConcern it must be attached to the command being run");
    }
    addCursorFlag(_2, __) {
      throw new error_1.MongoAPIError("RunCommandCursor does not support cursor flags, they must be attached to the command being run");
    }
    maxTimeMS(_2) {
      throw new error_1.MongoAPIError("maxTimeMS must be configured on the command document directly, to configure getMore.maxTimeMS use cursor.setMaxTimeMS()");
    }
    batchSize(_2) {
      throw new error_1.MongoAPIError("batchSize must be configured on the command document directly, to configure getMore.batchSize use cursor.setBatchSize()");
    }
    constructor(db, command, options = {}) {
      super(db.client, (0, utils_1.ns)(db.namespace), options);
      this.getMoreOptions = {};
      this.db = db;
      this.command = Object.freeze({ ...command });
    }
    async _initialize(session) {
      const operation = new run_command_1.RunCommandOperation(this.db, this.command, {
        ...this.cursorOptions,
        session,
        readPreference: this.cursorOptions.readPreference,
        responseType: responses_1.CursorResponse
      });
      const response = await (0, execute_operation_1.executeOperation)(this.client, operation, this.timeoutContext);
      return {
        server: operation.server,
        session,
        response
      };
    }
    async getMore(_batchSize) {
      const getMoreOperation = new get_more_1.GetMoreOperation(this.namespace, this.id, this.server, {
        ...this.cursorOptions,
        session: this.session,
        ...this.getMoreOptions
      });
      return await (0, execute_operation_1.executeOperation)(this.client, getMoreOperation, this.timeoutContext);
    }
  }
  exports.RunCommandCursor = RunCommandCursor;
});

// node_modules/mongodb/lib/operations/collections.js
var require_collections = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CollectionsOperation = undefined;
  var collection_1 = require_collection2();
  var operation_1 = require_operation();

  class CollectionsOperation extends operation_1.AbstractOperation {
    constructor(db, options) {
      super(options);
      this.options = options;
      this.db = db;
    }
    get commandName() {
      return "listCollections";
    }
    async execute(server, session) {
      const documents = await this.db.listCollections({}, { ...this.options, nameOnly: true, readPreference: this.readPreference, session }).toArray();
      const collections = [];
      for (const { name } of documents) {
        if (!name.includes("$")) {
          collections.push(new collection_1.Collection(this.db, name, this.db.s.options));
        }
      }
      return collections;
    }
  }
  exports.CollectionsOperation = CollectionsOperation;
});

// node_modules/mongodb/lib/operations/create_collection.js
var require_create_collection = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CreateCollectionOperation = undefined;
  var constants_1 = require_constants();
  var collection_1 = require_collection2();
  var error_1 = require_error();
  var command_1 = require_command();
  var indexes_1 = require_indexes();
  var operation_1 = require_operation();
  var ILLEGAL_COMMAND_FIELDS = new Set([
    "w",
    "wtimeout",
    "timeoutMS",
    "j",
    "fsync",
    "autoIndexId",
    "pkFactory",
    "raw",
    "readPreference",
    "session",
    "readConcern",
    "writeConcern",
    "raw",
    "fieldsAsRaw",
    "useBigInt64",
    "promoteLongs",
    "promoteValues",
    "promoteBuffers",
    "bsonRegExp",
    "serializeFunctions",
    "ignoreUndefined",
    "enableUtf8Validation"
  ]);
  var INVALID_QE_VERSION = "Driver support of Queryable Encryption is incompatible with server. Upgrade server to use Queryable Encryption.";

  class CreateCollectionOperation extends command_1.CommandOperation {
    constructor(db, name, options = {}) {
      super(db, options);
      this.options = options;
      this.db = db;
      this.name = name;
    }
    get commandName() {
      return "create";
    }
    async execute(server, session, timeoutContext) {
      const db = this.db;
      const name = this.name;
      const options = this.options;
      const encryptedFields = options.encryptedFields ?? db.client.s.options.autoEncryption?.encryptedFieldsMap?.[`${db.databaseName}.${name}`];
      if (encryptedFields) {
        if (!server.loadBalanced && server.description.maxWireVersion < constants_1.MIN_SUPPORTED_QE_WIRE_VERSION) {
          throw new error_1.MongoCompatibilityError(`${INVALID_QE_VERSION} The minimum server version required is ${constants_1.MIN_SUPPORTED_QE_SERVER_VERSION}`);
        }
        const escCollection = encryptedFields.escCollection ?? `enxcol_.${name}.esc`;
        const ecocCollection = encryptedFields.ecocCollection ?? `enxcol_.${name}.ecoc`;
        for (const collectionName of [escCollection, ecocCollection]) {
          const createOp = new CreateCollectionOperation(db, collectionName, {
            clusteredIndex: {
              key: { _id: 1 },
              unique: true
            }
          });
          await createOp.executeWithoutEncryptedFieldsCheck(server, session, timeoutContext);
        }
        if (!options.encryptedFields) {
          this.options = { ...this.options, encryptedFields };
        }
      }
      const coll = await this.executeWithoutEncryptedFieldsCheck(server, session, timeoutContext);
      if (encryptedFields) {
        const createIndexOp = indexes_1.CreateIndexesOperation.fromIndexSpecification(db, name, { __safeContent__: 1 }, {});
        await createIndexOp.execute(server, session, timeoutContext);
      }
      return coll;
    }
    async executeWithoutEncryptedFieldsCheck(server, session, timeoutContext) {
      const db = this.db;
      const name = this.name;
      const options = this.options;
      const cmd = { create: name };
      for (const n in options) {
        if (options[n] != null && typeof options[n] !== "function" && !ILLEGAL_COMMAND_FIELDS.has(n)) {
          cmd[n] = options[n];
        }
      }
      await super.executeCommand(server, session, cmd, timeoutContext);
      return new collection_1.Collection(db, name, options);
    }
  }
  exports.CreateCollectionOperation = CreateCollectionOperation;
  (0, operation_1.defineAspects)(CreateCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/operations/profiling_level.js
var require_profiling_level = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProfilingLevelOperation = undefined;
  var error_1 = require_error();
  var command_1 = require_command();

  class ProfilingLevelOperation extends command_1.CommandOperation {
    constructor(db, options) {
      super(db, options);
      this.options = options;
    }
    get commandName() {
      return "profile";
    }
    async execute(server, session, timeoutContext) {
      const doc = await super.executeCommand(server, session, { profile: -1 }, timeoutContext);
      if (doc.ok === 1) {
        const was = doc.was;
        if (was === 0)
          return "off";
        if (was === 1)
          return "slow_only";
        if (was === 2)
          return "all";
        throw new error_1.MongoUnexpectedServerResponseError(`Illegal profiling level value ${was}`);
      } else {
        throw new error_1.MongoUnexpectedServerResponseError("Error with profile command");
      }
    }
  }
  exports.ProfilingLevelOperation = ProfilingLevelOperation;
});

// node_modules/mongodb/lib/operations/remove_user.js
var require_remove_user = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RemoveUserOperation = undefined;
  var command_1 = require_command();
  var operation_1 = require_operation();

  class RemoveUserOperation extends command_1.CommandOperation {
    constructor(db, username, options) {
      super(db, options);
      this.options = options;
      this.username = username;
    }
    get commandName() {
      return "dropUser";
    }
    async execute(server, session, timeoutContext) {
      await super.executeCommand(server, session, { dropUser: this.username }, timeoutContext);
      return true;
    }
  }
  exports.RemoveUserOperation = RemoveUserOperation;
  (0, operation_1.defineAspects)(RemoveUserOperation, [operation_1.Aspect.WRITE_OPERATION]);
});

// node_modules/mongodb/lib/operations/set_profiling_level.js
var require_set_profiling_level = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SetProfilingLevelOperation = exports.ProfilingLevel = undefined;
  var error_1 = require_error();
  var utils_1 = require_utils2();
  var command_1 = require_command();
  var levelValues = new Set(["off", "slow_only", "all"]);
  exports.ProfilingLevel = Object.freeze({
    off: "off",
    slowOnly: "slow_only",
    all: "all"
  });

  class SetProfilingLevelOperation extends command_1.CommandOperation {
    constructor(db, level, options) {
      super(db, options);
      this.options = options;
      switch (level) {
        case exports.ProfilingLevel.off:
          this.profile = 0;
          break;
        case exports.ProfilingLevel.slowOnly:
          this.profile = 1;
          break;
        case exports.ProfilingLevel.all:
          this.profile = 2;
          break;
        default:
          this.profile = 0;
          break;
      }
      this.level = level;
    }
    get commandName() {
      return "profile";
    }
    async execute(server, session, timeoutContext) {
      const level = this.level;
      if (!levelValues.has(level)) {
        throw new error_1.MongoInvalidArgumentError(`Profiling level must be one of "${(0, utils_1.enumToString)(exports.ProfilingLevel)}"`);
      }
      await super.executeCommand(server, session, { profile: this.profile }, timeoutContext);
      return level;
    }
  }
  exports.SetProfilingLevelOperation = SetProfilingLevelOperation;
});

// node_modules/mongodb/lib/operations/stats.js
var require_stats = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DbStatsOperation = undefined;
  var command_1 = require_command();
  var operation_1 = require_operation();

  class DbStatsOperation extends command_1.CommandOperation {
    constructor(db, options) {
      super(db, options);
      this.options = options;
    }
    get commandName() {
      return "dbStats";
    }
    async execute(server, session, timeoutContext) {
      const command = { dbStats: true };
      if (this.options.scale != null) {
        command.scale = this.options.scale;
      }
      return await super.executeCommand(server, session, command, timeoutContext);
    }
  }
  exports.DbStatsOperation = DbStatsOperation;
  (0, operation_1.defineAspects)(DbStatsOperation, [operation_1.Aspect.READ_OPERATION]);
});

// node_modules/mongodb/lib/db.js
var require_db = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Db = undefined;
  var admin_1 = require_admin();
  var bson_1 = require_bson2();
  var change_stream_1 = require_change_stream();
  var collection_1 = require_collection2();
  var CONSTANTS = require_constants2();
  var aggregation_cursor_1 = require_aggregation_cursor();
  var list_collections_cursor_1 = require_list_collections_cursor();
  var run_command_cursor_1 = require_run_command_cursor();
  var error_1 = require_error();
  var collections_1 = require_collections();
  var create_collection_1 = require_create_collection();
  var drop_1 = require_drop();
  var execute_operation_1 = require_execute_operation();
  var indexes_1 = require_indexes();
  var profiling_level_1 = require_profiling_level();
  var remove_user_1 = require_remove_user();
  var rename_1 = require_rename();
  var run_command_1 = require_run_command();
  var set_profiling_level_1 = require_set_profiling_level();
  var stats_1 = require_stats();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var utils_1 = require_utils2();
  var write_concern_1 = require_write_concern();
  var DB_OPTIONS_ALLOW_LIST = [
    "writeConcern",
    "readPreference",
    "readPreferenceTags",
    "native_parser",
    "forceServerObjectId",
    "pkFactory",
    "serializeFunctions",
    "raw",
    "authSource",
    "ignoreUndefined",
    "readConcern",
    "retryMiliSeconds",
    "numberOfRetries",
    "useBigInt64",
    "promoteBuffers",
    "promoteLongs",
    "bsonRegExp",
    "enableUtf8Validation",
    "promoteValues",
    "compression",
    "retryWrites",
    "timeoutMS"
  ];

  class Db {
    constructor(client, databaseName, options) {
      options = options ?? {};
      options = (0, utils_1.filterOptions)(options, DB_OPTIONS_ALLOW_LIST);
      if (typeof databaseName === "string" && databaseName.includes(".")) {
        throw new error_1.MongoInvalidArgumentError(`Database names cannot contain the character '.'`);
      }
      this.s = {
        options,
        readPreference: read_preference_1.ReadPreference.fromOptions(options),
        bsonOptions: (0, bson_1.resolveBSONOptions)(options, client),
        pkFactory: options?.pkFactory ?? utils_1.DEFAULT_PK_FACTORY,
        readConcern: read_concern_1.ReadConcern.fromOptions(options),
        writeConcern: write_concern_1.WriteConcern.fromOptions(options),
        namespace: new utils_1.MongoDBNamespace(databaseName)
      };
      this.client = client;
    }
    get databaseName() {
      return this.s.namespace.db;
    }
    get options() {
      return this.s.options;
    }
    get secondaryOk() {
      return this.s.readPreference?.preference !== "primary" || false;
    }
    get readConcern() {
      return this.s.readConcern;
    }
    get readPreference() {
      if (this.s.readPreference == null) {
        return this.client.readPreference;
      }
      return this.s.readPreference;
    }
    get bsonOptions() {
      return this.s.bsonOptions;
    }
    get writeConcern() {
      return this.s.writeConcern;
    }
    get namespace() {
      return this.s.namespace.toString();
    }
    get timeoutMS() {
      return this.s.options?.timeoutMS;
    }
    async createCollection(name, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new create_collection_1.CreateCollectionOperation(this, name, (0, utils_1.resolveOptions)(this, options)));
    }
    async command(command, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new run_command_1.RunCommandOperation(this, command, (0, utils_1.resolveOptions)(undefined, {
        ...(0, bson_1.resolveBSONOptions)(options),
        timeoutMS: options?.timeoutMS ?? this.timeoutMS,
        session: options?.session,
        readPreference: options?.readPreference,
        signal: options?.signal
      })));
    }
    aggregate(pipeline = [], options) {
      return new aggregation_cursor_1.AggregationCursor(this.client, this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
    admin() {
      return new admin_1.Admin(this);
    }
    collection(name, options = {}) {
      if (typeof options === "function") {
        throw new error_1.MongoInvalidArgumentError("The callback form of this helper has been removed.");
      }
      return new collection_1.Collection(this, name, (0, utils_1.resolveOptions)(this, options));
    }
    async stats(options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new stats_1.DbStatsOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    listCollections(filter = {}, options = {}) {
      return new list_collections_cursor_1.ListCollectionsCursor(this, filter, (0, utils_1.resolveOptions)(this, options));
    }
    async renameCollection(fromCollection, toCollection, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new rename_1.RenameOperation(this.collection(fromCollection), toCollection, (0, utils_1.resolveOptions)(undefined, {
        ...options,
        new_collection: true,
        readPreference: read_preference_1.ReadPreference.primary
      })));
    }
    async dropCollection(name, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropCollectionOperation(this, name, (0, utils_1.resolveOptions)(this, options)));
    }
    async dropDatabase(options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new drop_1.DropDatabaseOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async collections(options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new collections_1.CollectionsOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async createIndex(name, indexSpec, options) {
      const indexes = await (0, execute_operation_1.executeOperation)(this.client, indexes_1.CreateIndexesOperation.fromIndexSpecification(this, name, indexSpec, options));
      return indexes[0];
    }
    async removeUser(username, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new remove_user_1.RemoveUserOperation(this, username, (0, utils_1.resolveOptions)(this, options)));
    }
    async setProfilingLevel(level, options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new set_profiling_level_1.SetProfilingLevelOperation(this, level, (0, utils_1.resolveOptions)(this, options)));
    }
    async profilingLevel(options) {
      return await (0, execute_operation_1.executeOperation)(this.client, new profiling_level_1.ProfilingLevelOperation(this, (0, utils_1.resolveOptions)(this, options)));
    }
    async indexInformation(name, options) {
      return await this.collection(name).indexInformation((0, utils_1.resolveOptions)(this, options));
    }
    watch(pipeline = [], options = {}) {
      if (!Array.isArray(pipeline)) {
        options = pipeline;
        pipeline = [];
      }
      return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
    runCursorCommand(command, options) {
      return new run_command_cursor_1.RunCommandCursor(this, command, options);
    }
  }
  exports.Db = Db;
  Db.SYSTEM_NAMESPACE_COLLECTION = CONSTANTS.SYSTEM_NAMESPACE_COLLECTION;
  Db.SYSTEM_INDEX_COLLECTION = CONSTANTS.SYSTEM_INDEX_COLLECTION;
  Db.SYSTEM_PROFILE_COLLECTION = CONSTANTS.SYSTEM_PROFILE_COLLECTION;
  Db.SYSTEM_USER_COLLECTION = CONSTANTS.SYSTEM_USER_COLLECTION;
  Db.SYSTEM_COMMAND_COLLECTION = CONSTANTS.SYSTEM_COMMAND_COLLECTION;
  Db.SYSTEM_JS_COLLECTION = CONSTANTS.SYSTEM_JS_COLLECTION;
});

// node_modules/mongodb/lib/change_stream.js
var require_change_stream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChangeStream = undefined;
  var collection_1 = require_collection2();
  var constants_1 = require_constants2();
  var abstract_cursor_1 = require_abstract_cursor();
  var change_stream_cursor_1 = require_change_stream_cursor();
  var db_1 = require_db();
  var error_1 = require_error();
  var mongo_client_1 = require_mongo_client();
  var mongo_types_1 = require_mongo_types();
  var resource_management_1 = require_resource_management();
  var timeout_1 = require_timeout();
  var utils_1 = require_utils2();
  var CHANGE_STREAM_OPTIONS = [
    "resumeAfter",
    "startAfter",
    "startAtOperationTime",
    "fullDocument",
    "fullDocumentBeforeChange",
    "showExpandedEvents"
  ];
  var CHANGE_DOMAIN_TYPES = {
    COLLECTION: Symbol("Collection"),
    DATABASE: Symbol("Database"),
    CLUSTER: Symbol("Cluster")
  };
  var CHANGE_STREAM_EVENTS = [constants_1.RESUME_TOKEN_CHANGED, constants_1.END, constants_1.CLOSE];
  var NO_RESUME_TOKEN_ERROR = "A change stream document has been received that lacks a resume token (_id).";
  var CHANGESTREAM_CLOSED_ERROR = "ChangeStream is closed";

  class ChangeStream extends mongo_types_1.TypedEventEmitter {
    async asyncDispose() {
      await this.close();
    }
    constructor(parent, pipeline = [], options = {}) {
      super();
      this.pipeline = pipeline;
      this.options = { ...options };
      let serverSelectionTimeoutMS;
      delete this.options.writeConcern;
      if (parent instanceof collection_1.Collection) {
        this.type = CHANGE_DOMAIN_TYPES.COLLECTION;
        serverSelectionTimeoutMS = parent.s.db.client.options.serverSelectionTimeoutMS;
      } else if (parent instanceof db_1.Db) {
        this.type = CHANGE_DOMAIN_TYPES.DATABASE;
        serverSelectionTimeoutMS = parent.client.options.serverSelectionTimeoutMS;
      } else if (parent instanceof mongo_client_1.MongoClient) {
        this.type = CHANGE_DOMAIN_TYPES.CLUSTER;
        serverSelectionTimeoutMS = parent.options.serverSelectionTimeoutMS;
      } else {
        throw new error_1.MongoChangeStreamError("Parent provided to ChangeStream constructor must be an instance of Collection, Db, or MongoClient");
      }
      this.contextOwner = Symbol();
      this.parent = parent;
      this.namespace = parent.s.namespace;
      if (!this.options.readPreference && parent.readPreference) {
        this.options.readPreference = parent.readPreference;
      }
      this.cursor = this._createChangeStreamCursor(options);
      this.isClosed = false;
      this.mode = false;
      this.on("newListener", (eventName) => {
        if (eventName === "change" && this.cursor && this.listenerCount("change") === 0) {
          this._streamEvents(this.cursor);
        }
      });
      this.on("removeListener", (eventName) => {
        if (eventName === "change" && this.listenerCount("change") === 0 && this.cursor) {
          this.cursorStream?.removeAllListeners("data");
        }
      });
      if (this.options.timeoutMS != null) {
        this.timeoutContext = new timeout_1.CSOTTimeoutContext({
          timeoutMS: this.options.timeoutMS,
          serverSelectionTimeoutMS
        });
      }
    }
    get resumeToken() {
      return this.cursor?.resumeToken;
    }
    async hasNext() {
      this._setIsIterator();
      this.timeoutContext?.refresh();
      try {
        while (true) {
          try {
            const hasNext = await this.cursor.hasNext();
            return hasNext;
          } catch (error) {
            try {
              await this._processErrorIteratorMode(error, this.cursor.id != null);
            } catch (error2) {
              if (error2 instanceof error_1.MongoOperationTimeoutError && this.cursor.id == null) {
                throw error2;
              }
              try {
                await this.close();
              } catch (error3) {
                (0, utils_1.squashError)(error3);
              }
              throw error2;
            }
          }
        }
      } finally {
        this.timeoutContext?.clear();
      }
    }
    async next() {
      this._setIsIterator();
      this.timeoutContext?.refresh();
      try {
        while (true) {
          try {
            const change = await this.cursor.next();
            const processedChange = this._processChange(change ?? null);
            return processedChange;
          } catch (error) {
            try {
              await this._processErrorIteratorMode(error, this.cursor.id != null);
            } catch (error2) {
              if (error2 instanceof error_1.MongoOperationTimeoutError && this.cursor.id == null) {
                throw error2;
              }
              try {
                await this.close();
              } catch (error3) {
                (0, utils_1.squashError)(error3);
              }
              throw error2;
            }
          }
        }
      } finally {
        this.timeoutContext?.clear();
      }
    }
    async tryNext() {
      this._setIsIterator();
      this.timeoutContext?.refresh();
      try {
        while (true) {
          try {
            const change = await this.cursor.tryNext();
            return change ?? null;
          } catch (error) {
            try {
              await this._processErrorIteratorMode(error, this.cursor.id != null);
            } catch (error2) {
              if (error2 instanceof error_1.MongoOperationTimeoutError && this.cursor.id == null)
                throw error2;
              try {
                await this.close();
              } catch (error3) {
                (0, utils_1.squashError)(error3);
              }
              throw error2;
            }
          }
        }
      } finally {
        this.timeoutContext?.clear();
      }
    }
    async* [Symbol.asyncIterator]() {
      if (this.closed) {
        return;
      }
      try {
        while (true) {
          yield await this.next();
        }
      } finally {
        try {
          await this.close();
        } catch (error) {
          (0, utils_1.squashError)(error);
        }
      }
    }
    get closed() {
      return this.isClosed || this.cursor.closed;
    }
    async close() {
      this.timeoutContext?.clear();
      this.timeoutContext = undefined;
      this.isClosed = true;
      const cursor = this.cursor;
      try {
        await cursor.close();
      } finally {
        this._endStream();
      }
    }
    stream(options) {
      if (this.closed) {
        throw new error_1.MongoChangeStreamError(CHANGESTREAM_CLOSED_ERROR);
      }
      this.streamOptions = options;
      return this.cursor.stream(options);
    }
    _setIsEmitter() {
      if (this.mode === "iterator") {
        throw new error_1.MongoAPIError("ChangeStream cannot be used as an EventEmitter after being used as an iterator");
      }
      this.mode = "emitter";
    }
    _setIsIterator() {
      if (this.mode === "emitter") {
        throw new error_1.MongoAPIError("ChangeStream cannot be used as an iterator after being used as an EventEmitter");
      }
      this.mode = "iterator";
    }
    _createChangeStreamCursor(options) {
      const changeStreamStageOptions = (0, utils_1.filterOptions)(options, CHANGE_STREAM_OPTIONS);
      if (this.type === CHANGE_DOMAIN_TYPES.CLUSTER) {
        changeStreamStageOptions.allChangesForCluster = true;
      }
      const pipeline = [{ $changeStream: changeStreamStageOptions }, ...this.pipeline];
      const client = this.type === CHANGE_DOMAIN_TYPES.CLUSTER ? this.parent : this.type === CHANGE_DOMAIN_TYPES.DATABASE ? this.parent.client : this.type === CHANGE_DOMAIN_TYPES.COLLECTION ? this.parent.client : null;
      if (client == null) {
        throw new error_1.MongoRuntimeError(`Changestream type should only be one of cluster, database, collection. Found ${this.type.toString()}`);
      }
      const changeStreamCursor = new change_stream_cursor_1.ChangeStreamCursor(client, this.namespace, pipeline, {
        ...options,
        timeoutContext: this.timeoutContext ? new abstract_cursor_1.CursorTimeoutContext(this.timeoutContext, this.contextOwner) : undefined
      });
      for (const event of CHANGE_STREAM_EVENTS) {
        changeStreamCursor.on(event, (e) => this.emit(event, e));
      }
      if (this.listenerCount(ChangeStream.CHANGE) > 0) {
        this._streamEvents(changeStreamCursor);
      }
      return changeStreamCursor;
    }
    _closeEmitterModeWithError(error) {
      this.emit(ChangeStream.ERROR, error);
      this.close().then(undefined, utils_1.squashError);
    }
    _streamEvents(cursor) {
      this._setIsEmitter();
      const stream = this.cursorStream ?? cursor.stream();
      this.cursorStream = stream;
      stream.on("data", (change) => {
        try {
          const processedChange = this._processChange(change);
          this.emit(ChangeStream.CHANGE, processedChange);
        } catch (error) {
          this.emit(ChangeStream.ERROR, error);
        }
        this.timeoutContext?.refresh();
      });
      stream.on("error", (error) => this._processErrorStreamMode(error, this.cursor.id != null));
    }
    _endStream() {
      const cursorStream = this.cursorStream;
      if (cursorStream) {
        ["data", "close", "end", "error"].forEach((event) => cursorStream.removeAllListeners(event));
        cursorStream.destroy();
      }
      this.cursorStream = undefined;
    }
    _processChange(change) {
      if (this.isClosed) {
        throw new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR);
      }
      if (change == null) {
        throw new error_1.MongoRuntimeError(CHANGESTREAM_CLOSED_ERROR);
      }
      if (change && !change._id) {
        throw new error_1.MongoChangeStreamError(NO_RESUME_TOKEN_ERROR);
      }
      this.cursor.cacheResumeToken(change._id);
      this.options.startAtOperationTime = undefined;
      return change;
    }
    _processErrorStreamMode(changeStreamError, cursorInitialized) {
      if (this.isClosed)
        return;
      if (cursorInitialized && ((0, error_1.isResumableError)(changeStreamError, this.cursor.maxWireVersion) || changeStreamError instanceof error_1.MongoOperationTimeoutError)) {
        this._endStream();
        this.cursor.close().then(() => this._resume(changeStreamError), (e) => {
          (0, utils_1.squashError)(e);
          return this._resume(changeStreamError);
        }).then(() => {
          if (changeStreamError instanceof error_1.MongoOperationTimeoutError)
            this.emit(ChangeStream.ERROR, changeStreamError);
        }, () => this._closeEmitterModeWithError(changeStreamError));
      } else {
        this._closeEmitterModeWithError(changeStreamError);
      }
    }
    async _processErrorIteratorMode(changeStreamError, cursorInitialized) {
      if (this.isClosed) {
        throw new error_1.MongoAPIError(CHANGESTREAM_CLOSED_ERROR);
      }
      if (cursorInitialized && ((0, error_1.isResumableError)(changeStreamError, this.cursor.maxWireVersion) || changeStreamError instanceof error_1.MongoOperationTimeoutError)) {
        try {
          await this.cursor.close();
        } catch (error) {
          (0, utils_1.squashError)(error);
        }
        await this._resume(changeStreamError);
        if (changeStreamError instanceof error_1.MongoOperationTimeoutError)
          throw changeStreamError;
      } else {
        try {
          await this.close();
        } catch (error) {
          (0, utils_1.squashError)(error);
        }
        throw changeStreamError;
      }
    }
    async _resume(changeStreamError) {
      this.timeoutContext?.refresh();
      const topology = (0, utils_1.getTopology)(this.parent);
      try {
        await topology.selectServer(this.cursor.readPreference, {
          operationName: "reconnect topology in change stream",
          timeoutContext: this.timeoutContext
        });
        this.cursor = this._createChangeStreamCursor(this.cursor.resumeOptions);
      } catch {
        await this.close();
        throw changeStreamError;
      }
    }
  }
  exports.ChangeStream = ChangeStream;
  ChangeStream.RESPONSE = constants_1.RESPONSE;
  ChangeStream.MORE = constants_1.MORE;
  ChangeStream.INIT = constants_1.INIT;
  ChangeStream.CLOSE = constants_1.CLOSE;
  ChangeStream.CHANGE = constants_1.CHANGE;
  ChangeStream.END = constants_1.END;
  ChangeStream.ERROR = constants_1.ERROR;
  ChangeStream.RESUME_TOKEN_CHANGED = constants_1.RESUME_TOKEN_CHANGED;
  (0, resource_management_1.configureResourceManagement)(ChangeStream.prototype);
});

// node_modules/mongodb/lib/deps.js
var require_deps = __commonJS((exports) => {
  function makeErrorModule(error) {
    const props = error ? { kModuleError: error } : {};
    return new Proxy(props, {
      get: (_2, key) => {
        if (key === "kModuleError") {
          return error;
        }
        throw error;
      },
      set: () => {
        throw error;
      }
    });
  }
  function getKerberos() {
    let kerberos;
    try {
      kerberos = (()=>{throw new Error(`Cannot require module "kerberos"`);})();
    } catch (error) {
      kerberos = makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `kerberos` not found. Please install it to enable kerberos authentication", { cause: error, dependencyName: "kerberos" }));
    }
    return kerberos;
  }
  function getZstdLibrary() {
    let ZStandard;
    try {
      ZStandard = (()=>{throw new Error(`Cannot require module "@mongodb-js/zstd"`);})();
    } catch (error) {
      ZStandard = makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `@mongodb-js/zstd` not found. Please install it to enable zstd compression", { cause: error, dependencyName: "zstd" }));
    }
    return ZStandard;
  }
  function getAwsCredentialProvider() {
    try {
      const credentialProvider = (()=>{throw new Error(`Cannot require module "@aws-sdk/credential-providers"`);})();
      return credentialProvider;
    } catch (error) {
      return makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `@aws-sdk/credential-providers` not found." + " Please install it to enable getting aws credentials via the official sdk.", { cause: error, dependencyName: "@aws-sdk/credential-providers" }));
    }
  }
  function getGcpMetadata() {
    try {
      const credentialProvider = (()=>{throw new Error(`Cannot require module "gcp-metadata"`);})();
      return credentialProvider;
    } catch (error) {
      return makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `gcp-metadata` not found." + " Please install it to enable getting gcp credentials via the official sdk.", { cause: error, dependencyName: "gcp-metadata" }));
    }
  }
  function getSnappy() {
    try {
      const value = (()=>{throw new Error(`Cannot require module "snappy"`);})();
      return value;
    } catch (error) {
      const kModuleError = new error_1.MongoMissingDependencyError("Optional module `snappy` not found. Please install it to enable snappy compression", { cause: error, dependencyName: "snappy" });
      return { kModuleError };
    }
  }
  function getSocks() {
    try {
      const value = (()=>{throw new Error(`Cannot require module "socks"`);})();
      return value;
    } catch (error) {
      const kModuleError = new error_1.MongoMissingDependencyError("Optional module `socks` not found. Please install it to connections over a SOCKS5 proxy", { cause: error, dependencyName: "socks" });
      return { kModuleError };
    }
  }
  function loadAws4() {
    let aws4;
    try {
      aws4 = (()=>{throw new Error(`Cannot require module "aws4"`);})();
    } catch (error) {
      aws4 = makeErrorModule(new error_1.MongoMissingDependencyError("Optional module `aws4` not found. Please install it to enable AWS authentication", { cause: error, dependencyName: "aws4" }));
    }
    return aws4;
  }
  function getMongoDBClientEncryption() {
    let mongodbClientEncryption = null;
    try {
      mongodbClientEncryption = (()=>{throw new Error(`Cannot require module "mongodb-client-encryption"`);})();
    } catch (error) {
      const kModuleError = new error_1.MongoMissingDependencyError("Optional module `mongodb-client-encryption` not found. Please install it to use auto encryption or ClientEncryption.", { cause: error, dependencyName: "mongodb-client-encryption" });
      return { kModuleError };
    }
    return mongodbClientEncryption;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.aws4 = undefined;
  exports.getKerberos = getKerberos;
  exports.getZstdLibrary = getZstdLibrary;
  exports.getAwsCredentialProvider = getAwsCredentialProvider;
  exports.getGcpMetadata = getGcpMetadata;
  exports.getSnappy = getSnappy;
  exports.getSocks = getSocks;
  exports.getMongoDBClientEncryption = getMongoDBClientEncryption;
  var error_1 = require_error();
  exports.aws4 = loadAws4();
});

// node_modules/mongodb/lib/cmap/auth/auth_provider.js
var require_auth_provider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AuthProvider = exports.AuthContext = undefined;
  var error_1 = require_error();

  class AuthContext {
    constructor(connection, credentials, options) {
      this.reauthenticating = false;
      this.connection = connection;
      this.credentials = credentials;
      this.options = options;
    }
  }
  exports.AuthContext = AuthContext;

  class AuthProvider {
    async prepare(handshakeDoc, _authContext) {
      return handshakeDoc;
    }
    async reauth(context) {
      if (context.reauthenticating) {
        throw new error_1.MongoRuntimeError("Reauthentication already in progress.");
      }
      try {
        context.reauthenticating = true;
        await this.auth(context);
      } finally {
        context.reauthenticating = false;
      }
    }
  }
  exports.AuthProvider = AuthProvider;
});

// node_modules/mongodb/lib/cmap/auth/gssapi.js
var require_gssapi = __commonJS((exports) => {
  async function externalCommand(connection, command) {
    const response = await connection.command((0, utils_1.ns)("$external.$cmd"), command);
    return response;
  }
  async function makeKerberosClient(authContext) {
    const { hostAddress } = authContext.options;
    const { credentials } = authContext;
    if (!hostAddress || typeof hostAddress.host !== "string" || !credentials) {
      throw new error_1.MongoInvalidArgumentError("Connection must have host and port and credentials defined.");
    }
    loadKrb();
    if ("kModuleError" in krb) {
      throw krb["kModuleError"];
    }
    const { initializeClient } = krb;
    const { username, password } = credentials;
    const mechanismProperties = credentials.mechanismProperties;
    const serviceName = mechanismProperties.SERVICE_NAME ?? "mongodb";
    const host = await performGSSAPICanonicalizeHostName(hostAddress.host, mechanismProperties);
    const initOptions = {};
    if (password != null) {
      Object.assign(initOptions, { user: username, password });
    }
    const spnHost = mechanismProperties.SERVICE_HOST ?? host;
    let spn = `${serviceName}${process.platform === "win32" ? "/" : "@"}${spnHost}`;
    if ("SERVICE_REALM" in mechanismProperties) {
      spn = `${spn}@${mechanismProperties.SERVICE_REALM}`;
    }
    return await initializeClient(spn, initOptions);
  }
  function saslStart(payload) {
    return {
      saslStart: 1,
      mechanism: "GSSAPI",
      payload,
      autoAuthorize: 1
    };
  }
  function saslContinue(payload, conversationId) {
    return {
      saslContinue: 1,
      conversationId,
      payload
    };
  }
  async function negotiate(client, retries, payload) {
    try {
      const response = await client.step(payload);
      return response || "";
    } catch (error) {
      if (retries === 0) {
        throw error;
      }
      return await negotiate(client, retries - 1, payload);
    }
  }
  async function finalize(client, user, payload) {
    const response = await client.unwrap(payload);
    return await client.wrap(response || "", { user });
  }
  async function performGSSAPICanonicalizeHostName(host, mechanismProperties) {
    const mode = mechanismProperties.CANONICALIZE_HOST_NAME;
    if (!mode || mode === exports.GSSAPICanonicalizationValue.none) {
      return host;
    }
    if (mode === exports.GSSAPICanonicalizationValue.on || mode === exports.GSSAPICanonicalizationValue.forwardAndReverse) {
      const { address } = await dns.promises.lookup(host);
      try {
        const results = await dns.promises.resolvePtr(address);
        return results.length > 0 ? results[0] : host;
      } catch {
        return await resolveCname(host);
      }
    } else {
      return await resolveCname(host);
    }
  }
  async function resolveCname(host) {
    try {
      const results = await dns.promises.resolveCname(host);
      return results.length > 0 ? results[0] : host;
    } catch {
      return host;
    }
  }
  function loadKrb() {
    if (!krb) {
      krb = (0, deps_1.getKerberos)();
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GSSAPI = exports.GSSAPICanonicalizationValue = undefined;
  exports.performGSSAPICanonicalizeHostName = performGSSAPICanonicalizeHostName;
  exports.resolveCname = resolveCname;
  var dns = import.meta.require("dns");
  var deps_1 = require_deps();
  var error_1 = require_error();
  var utils_1 = require_utils2();
  var auth_provider_1 = require_auth_provider();
  exports.GSSAPICanonicalizationValue = Object.freeze({
    on: true,
    off: false,
    none: "none",
    forward: "forward",
    forwardAndReverse: "forwardAndReverse"
  });
  var krb;

  class GSSAPI extends auth_provider_1.AuthProvider {
    async auth(authContext) {
      const { connection, credentials } = authContext;
      if (credentials == null) {
        throw new error_1.MongoMissingCredentialsError("Credentials required for GSSAPI authentication");
      }
      const { username } = credentials;
      const client = await makeKerberosClient(authContext);
      const payload = await client.step("");
      const saslStartResponse = await externalCommand(connection, saslStart(payload));
      const negotiatedPayload = await negotiate(client, 10, saslStartResponse.payload);
      const saslContinueResponse = await externalCommand(connection, saslContinue(negotiatedPayload, saslStartResponse.conversationId));
      const finalizePayload = await finalize(client, username, saslContinueResponse.payload);
      await externalCommand(connection, {
        saslContinue: 1,
        conversationId: saslContinueResponse.conversationId,
        payload: finalizePayload
      });
    }
  }
  exports.GSSAPI = GSSAPI;
});

// node_modules/mongodb/lib/cmap/auth/providers.js
var require_providers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AUTH_MECHS_AUTH_SRC_EXTERNAL = exports.AuthMechanism = undefined;
  exports.AuthMechanism = Object.freeze({
    MONGODB_AWS: "MONGODB-AWS",
    MONGODB_CR: "MONGODB-CR",
    MONGODB_DEFAULT: "DEFAULT",
    MONGODB_GSSAPI: "GSSAPI",
    MONGODB_PLAIN: "PLAIN",
    MONGODB_SCRAM_SHA1: "SCRAM-SHA-1",
    MONGODB_SCRAM_SHA256: "SCRAM-SHA-256",
    MONGODB_X509: "MONGODB-X509",
    MONGODB_OIDC: "MONGODB-OIDC"
  });
  exports.AUTH_MECHS_AUTH_SRC_EXTERNAL = new Set([
    exports.AuthMechanism.MONGODB_GSSAPI,
    exports.AuthMechanism.MONGODB_AWS,
    exports.AuthMechanism.MONGODB_OIDC,
    exports.AuthMechanism.MONGODB_X509
  ]);
});

// node_modules/mongodb/lib/cmap/auth/mongo_credentials.js
var require_mongo_credentials = __commonJS((exports) => {
  function getDefaultAuthMechanism(hello) {
    if (hello) {
      if (Array.isArray(hello.saslSupportedMechs)) {
        return hello.saslSupportedMechs.includes(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256) ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA256 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA1;
      }
    }
    return providers_1.AuthMechanism.MONGODB_SCRAM_SHA256;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoCredentials = exports.DEFAULT_ALLOWED_HOSTS = undefined;
  var error_1 = require_error();
  var gssapi_1 = require_gssapi();
  var providers_1 = require_providers();
  var ALLOWED_ENVIRONMENT_NAMES = [
    "test",
    "azure",
    "gcp",
    "k8s"
  ];
  var ALLOWED_HOSTS_ERROR = "Auth mechanism property ALLOWED_HOSTS must be an array of strings.";
  exports.DEFAULT_ALLOWED_HOSTS = [
    "*.mongodb.net",
    "*.mongodb-qa.net",
    "*.mongodb-dev.net",
    "*.mongodbgov.net",
    "localhost",
    "127.0.0.1",
    "::1"
  ];
  var TOKEN_RESOURCE_MISSING_ERROR = "TOKEN_RESOURCE must be set in the auth mechanism properties when ENVIRONMENT is azure or gcp.";

  class MongoCredentials {
    constructor(options) {
      this.username = options.username ?? "";
      this.password = options.password;
      this.source = options.source;
      if (!this.source && options.db) {
        this.source = options.db;
      }
      this.mechanism = options.mechanism || providers_1.AuthMechanism.MONGODB_DEFAULT;
      this.mechanismProperties = options.mechanismProperties || {};
      if (this.mechanism.match(/MONGODB-AWS/i)) {
        if (!this.username && process.env.AWS_ACCESS_KEY_ID) {
          this.username = process.env.AWS_ACCESS_KEY_ID;
        }
        if (!this.password && process.env.AWS_SECRET_ACCESS_KEY) {
          this.password = process.env.AWS_SECRET_ACCESS_KEY;
        }
        if (this.mechanismProperties.AWS_SESSION_TOKEN == null && process.env.AWS_SESSION_TOKEN != null) {
          this.mechanismProperties = {
            ...this.mechanismProperties,
            AWS_SESSION_TOKEN: process.env.AWS_SESSION_TOKEN
          };
        }
      }
      if (this.mechanism === providers_1.AuthMechanism.MONGODB_OIDC && !this.mechanismProperties.ALLOWED_HOSTS) {
        this.mechanismProperties = {
          ...this.mechanismProperties,
          ALLOWED_HOSTS: exports.DEFAULT_ALLOWED_HOSTS
        };
      }
      Object.freeze(this.mechanismProperties);
      Object.freeze(this);
    }
    equals(other) {
      return this.mechanism === other.mechanism && this.username === other.username && this.password === other.password && this.source === other.source;
    }
    resolveAuthMechanism(hello) {
      if (this.mechanism.match(/DEFAULT/i)) {
        return new MongoCredentials({
          username: this.username,
          password: this.password,
          source: this.source,
          mechanism: getDefaultAuthMechanism(hello),
          mechanismProperties: this.mechanismProperties
        });
      }
      return this;
    }
    validate() {
      if ((this.mechanism === providers_1.AuthMechanism.MONGODB_GSSAPI || this.mechanism === providers_1.AuthMechanism.MONGODB_PLAIN || this.mechanism === providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 || this.mechanism === providers_1.AuthMechanism.MONGODB_SCRAM_SHA256) && !this.username) {
        throw new error_1.MongoMissingCredentialsError(`Username required for mechanism '${this.mechanism}'`);
      }
      if (this.mechanism === providers_1.AuthMechanism.MONGODB_OIDC) {
        if (this.username && this.mechanismProperties.ENVIRONMENT && this.mechanismProperties.ENVIRONMENT !== "azure") {
          throw new error_1.MongoInvalidArgumentError(`username and ENVIRONMENT '${this.mechanismProperties.ENVIRONMENT}' may not be used together for mechanism '${this.mechanism}'.`);
        }
        if (this.username && this.password) {
          throw new error_1.MongoInvalidArgumentError(`No password is allowed in ENVIRONMENT '${this.mechanismProperties.ENVIRONMENT}' for '${this.mechanism}'.`);
        }
        if ((this.mechanismProperties.ENVIRONMENT === "azure" || this.mechanismProperties.ENVIRONMENT === "gcp") && !this.mechanismProperties.TOKEN_RESOURCE) {
          throw new error_1.MongoInvalidArgumentError(TOKEN_RESOURCE_MISSING_ERROR);
        }
        if (this.mechanismProperties.ENVIRONMENT && !ALLOWED_ENVIRONMENT_NAMES.includes(this.mechanismProperties.ENVIRONMENT)) {
          throw new error_1.MongoInvalidArgumentError(`Currently only a ENVIRONMENT in ${ALLOWED_ENVIRONMENT_NAMES.join(",")} is supported for mechanism '${this.mechanism}'.`);
        }
        if (!this.mechanismProperties.ENVIRONMENT && !this.mechanismProperties.OIDC_CALLBACK && !this.mechanismProperties.OIDC_HUMAN_CALLBACK) {
          throw new error_1.MongoInvalidArgumentError(`Either a ENVIRONMENT, OIDC_CALLBACK, or OIDC_HUMAN_CALLBACK must be specified for mechanism '${this.mechanism}'.`);
        }
        if (this.mechanismProperties.ALLOWED_HOSTS) {
          const hosts = this.mechanismProperties.ALLOWED_HOSTS;
          if (!Array.isArray(hosts)) {
            throw new error_1.MongoInvalidArgumentError(ALLOWED_HOSTS_ERROR);
          }
          for (const host of hosts) {
            if (typeof host !== "string") {
              throw new error_1.MongoInvalidArgumentError(ALLOWED_HOSTS_ERROR);
            }
          }
        }
      }
      if (providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(this.mechanism)) {
        if (this.source != null && this.source !== "$external") {
          throw new error_1.MongoAPIError(`Invalid source '${this.source}' for mechanism '${this.mechanism}' specified.`);
        }
      }
      if (this.mechanism === providers_1.AuthMechanism.MONGODB_PLAIN && this.source == null) {
        throw new error_1.MongoAPIError("PLAIN Authentication Mechanism needs an auth source");
      }
      if (this.mechanism === providers_1.AuthMechanism.MONGODB_X509 && this.password != null) {
        if (this.password === "") {
          Reflect.set(this, "password", undefined);
          return;
        }
        throw new error_1.MongoAPIError(`Password not allowed for mechanism MONGODB-X509`);
      }
      const canonicalization = this.mechanismProperties.CANONICALIZE_HOST_NAME ?? false;
      if (!Object.values(gssapi_1.GSSAPICanonicalizationValue).includes(canonicalization)) {
        throw new error_1.MongoAPIError(`Invalid CANONICALIZE_HOST_NAME value: ${canonicalization}`);
      }
    }
    static merge(creds, options) {
      return new MongoCredentials({
        username: options.username ?? creds?.username ?? "",
        password: options.password ?? creds?.password ?? "",
        mechanism: options.mechanism ?? creds?.mechanism ?? providers_1.AuthMechanism.MONGODB_DEFAULT,
        mechanismProperties: options.mechanismProperties ?? creds?.mechanismProperties ?? {},
        source: options.source ?? options.db ?? creds?.source ?? "admin"
      });
    }
  }
  exports.MongoCredentials = MongoCredentials;
});

// node_modules/webidl-conversions/lib/index.js
var require_lib = __commonJS((exports) => {
  function makeException(ErrorType, message, options) {
    if (options.globals) {
      ErrorType = options.globals[ErrorType.name];
    }
    return new ErrorType(`${options.context ? options.context : "Value"} ${message}.`);
  }
  function toNumber(value, options) {
    if (typeof value === "bigint") {
      throw makeException(TypeError, "is a BigInt which cannot be converted to a number", options);
    }
    if (!options.globals) {
      return Number(value);
    }
    return options.globals.Number(value);
  }
  function evenRound(x) {
    if (x > 0 && x % 1 === 0.5 && (x & 1) === 0 || x < 0 && x % 1 === -0.5 && (x & 1) === 1) {
      return censorNegativeZero(Math.floor(x));
    }
    return censorNegativeZero(Math.round(x));
  }
  function integerPart(n) {
    return censorNegativeZero(Math.trunc(n));
  }
  function sign(x) {
    return x < 0 ? -1 : 1;
  }
  function modulo(x, y) {
    const signMightNotMatch = x % y;
    if (sign(y) !== sign(signMightNotMatch)) {
      return signMightNotMatch + y;
    }
    return signMightNotMatch;
  }
  function censorNegativeZero(x) {
    return x === 0 ? 0 : x;
  }
  function createIntegerConversion(bitLength, { unsigned }) {
    let lowerBound, upperBound;
    if (unsigned) {
      lowerBound = 0;
      upperBound = 2 ** bitLength - 1;
    } else {
      lowerBound = -(2 ** (bitLength - 1));
      upperBound = 2 ** (bitLength - 1) - 1;
    }
    const twoToTheBitLength = 2 ** bitLength;
    const twoToOneLessThanTheBitLength = 2 ** (bitLength - 1);
    return (value, options = {}) => {
      let x = toNumber(value, options);
      x = censorNegativeZero(x);
      if (options.enforceRange) {
        if (!Number.isFinite(x)) {
          throw makeException(TypeError, "is not a finite number", options);
        }
        x = integerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw makeException(TypeError, `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`, options);
        }
        return x;
      }
      if (!Number.isNaN(x) && options.clamp) {
        x = Math.min(Math.max(x, lowerBound), upperBound);
        x = evenRound(x);
        return x;
      }
      if (!Number.isFinite(x) || x === 0) {
        return 0;
      }
      x = integerPart(x);
      if (x >= lowerBound && x <= upperBound) {
        return x;
      }
      x = modulo(x, twoToTheBitLength);
      if (!unsigned && x >= twoToOneLessThanTheBitLength) {
        return x - twoToTheBitLength;
      }
      return x;
    };
  }
  function createLongLongConversion(bitLength, { unsigned }) {
    const upperBound = Number.MAX_SAFE_INTEGER;
    const lowerBound = unsigned ? 0 : Number.MIN_SAFE_INTEGER;
    const asBigIntN = unsigned ? BigInt.asUintN : BigInt.asIntN;
    return (value, options = {}) => {
      let x = toNumber(value, options);
      x = censorNegativeZero(x);
      if (options.enforceRange) {
        if (!Number.isFinite(x)) {
          throw makeException(TypeError, "is not a finite number", options);
        }
        x = integerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw makeException(TypeError, `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`, options);
        }
        return x;
      }
      if (!Number.isNaN(x) && options.clamp) {
        x = Math.min(Math.max(x, lowerBound), upperBound);
        x = evenRound(x);
        return x;
      }
      if (!Number.isFinite(x) || x === 0) {
        return 0;
      }
      let xBigInt = BigInt(integerPart(x));
      xBigInt = asBigIntN(bitLength, xBigInt);
      return Number(xBigInt);
    };
  }
  function isNonSharedArrayBuffer(value) {
    try {
      abByteLengthGetter.call(value);
      return true;
    } catch {
      return false;
    }
  }
  function isSharedArrayBuffer(value) {
    try {
      sabByteLengthGetter.call(value);
      return true;
    } catch {
      return false;
    }
  }
  function isArrayBufferDetached(value) {
    try {
      new Uint8Array(value);
      return false;
    } catch {
      return true;
    }
  }
  exports.any = (value) => {
    return value;
  };
  exports.undefined = () => {
    return;
  };
  exports.boolean = (value) => {
    return Boolean(value);
  };
  exports.byte = createIntegerConversion(8, { unsigned: false });
  exports.octet = createIntegerConversion(8, { unsigned: true });
  exports.short = createIntegerConversion(16, { unsigned: false });
  exports["unsigned short"] = createIntegerConversion(16, { unsigned: true });
  exports.long = createIntegerConversion(32, { unsigned: false });
  exports["unsigned long"] = createIntegerConversion(32, { unsigned: true });
  exports["long long"] = createLongLongConversion(64, { unsigned: false });
  exports["unsigned long long"] = createLongLongConversion(64, { unsigned: true });
  exports.double = (value, options = {}) => {
    const x = toNumber(value, options);
    if (!Number.isFinite(x)) {
      throw makeException(TypeError, "is not a finite floating-point value", options);
    }
    return x;
  };
  exports["unrestricted double"] = (value, options = {}) => {
    const x = toNumber(value, options);
    return x;
  };
  exports.float = (value, options = {}) => {
    const x = toNumber(value, options);
    if (!Number.isFinite(x)) {
      throw makeException(TypeError, "is not a finite floating-point value", options);
    }
    if (Object.is(x, -0)) {
      return x;
    }
    const y = Math.fround(x);
    if (!Number.isFinite(y)) {
      throw makeException(TypeError, "is outside the range of a single-precision floating-point value", options);
    }
    return y;
  };
  exports["unrestricted float"] = (value, options = {}) => {
    const x = toNumber(value, options);
    if (isNaN(x)) {
      return x;
    }
    if (Object.is(x, -0)) {
      return x;
    }
    return Math.fround(x);
  };
  exports.DOMString = (value, options = {}) => {
    if (options.treatNullAsEmptyString && value === null) {
      return "";
    }
    if (typeof value === "symbol") {
      throw makeException(TypeError, "is a symbol, which cannot be converted to a string", options);
    }
    const StringCtor = options.globals ? options.globals.String : String;
    return StringCtor(value);
  };
  exports.ByteString = (value, options = {}) => {
    const x = exports.DOMString(value, options);
    let c;
    for (let i = 0;(c = x.codePointAt(i)) !== undefined; ++i) {
      if (c > 255) {
        throw makeException(TypeError, "is not a valid ByteString", options);
      }
    }
    return x;
  };
  exports.USVString = (value, options = {}) => {
    const S = exports.DOMString(value, options);
    const n = S.length;
    const U = [];
    for (let i = 0;i < n; ++i) {
      const c = S.charCodeAt(i);
      if (c < 55296 || c > 57343) {
        U.push(String.fromCodePoint(c));
      } else if (56320 <= c && c <= 57343) {
        U.push(String.fromCodePoint(65533));
      } else if (i === n - 1) {
        U.push(String.fromCodePoint(65533));
      } else {
        const d = S.charCodeAt(i + 1);
        if (56320 <= d && d <= 57343) {
          const a = c & 1023;
          const b = d & 1023;
          U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
          ++i;
        } else {
          U.push(String.fromCodePoint(65533));
        }
      }
    }
    return U.join("");
  };
  exports.object = (value, options = {}) => {
    if (value === null || typeof value !== "object" && typeof value !== "function") {
      throw makeException(TypeError, "is not an object", options);
    }
    return value;
  };
  var abByteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
  var sabByteLengthGetter = typeof SharedArrayBuffer === "function" ? Object.getOwnPropertyDescriptor(SharedArrayBuffer.prototype, "byteLength").get : null;
  exports.ArrayBuffer = (value, options = {}) => {
    if (!isNonSharedArrayBuffer(value)) {
      if (options.allowShared && !isSharedArrayBuffer(value)) {
        throw makeException(TypeError, "is not an ArrayBuffer or SharedArrayBuffer", options);
      }
      throw makeException(TypeError, "is not an ArrayBuffer", options);
    }
    if (isArrayBufferDetached(value)) {
      throw makeException(TypeError, "is a detached ArrayBuffer", options);
    }
    return value;
  };
  var dvByteLengthGetter = Object.getOwnPropertyDescriptor(DataView.prototype, "byteLength").get;
  exports.DataView = (value, options = {}) => {
    try {
      dvByteLengthGetter.call(value);
    } catch (e) {
      throw makeException(TypeError, "is not a DataView", options);
    }
    if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
      throw makeException(TypeError, "is backed by a SharedArrayBuffer, which is not allowed", options);
    }
    if (isArrayBufferDetached(value.buffer)) {
      throw makeException(TypeError, "is backed by a detached ArrayBuffer", options);
    }
    return value;
  };
  var typedArrayNameGetter = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array).prototype, Symbol.toStringTag).get;
  [
    Int8Array,
    Int16Array,
    Int32Array,
    Uint8Array,
    Uint16Array,
    Uint32Array,
    Uint8ClampedArray,
    Float32Array,
    Float64Array
  ].forEach((func) => {
    const { name } = func;
    const article = /^[AEIOU]/u.test(name) ? "an" : "a";
    exports[name] = (value, options = {}) => {
      if (!ArrayBuffer.isView(value) || typedArrayNameGetter.call(value) !== name) {
        throw makeException(TypeError, `is not ${article} ${name} object`, options);
      }
      if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
        throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
      }
      if (isArrayBufferDetached(value.buffer)) {
        throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
      }
      return value;
    };
  });
  exports.ArrayBufferView = (value, options = {}) => {
    if (!ArrayBuffer.isView(value)) {
      throw makeException(TypeError, "is not a view on an ArrayBuffer or SharedArrayBuffer", options);
    }
    if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
      throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
    }
    if (isArrayBufferDetached(value.buffer)) {
      throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
    }
    return value;
  };
  exports.BufferSource = (value, options = {}) => {
    if (ArrayBuffer.isView(value)) {
      if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {
        throw makeException(TypeError, "is a view on a SharedArrayBuffer, which is not allowed", options);
      }
      if (isArrayBufferDetached(value.buffer)) {
        throw makeException(TypeError, "is a view on a detached ArrayBuffer", options);
      }
      return value;
    }
    if (!options.allowShared && !isNonSharedArrayBuffer(value)) {
      throw makeException(TypeError, "is not an ArrayBuffer or a view on one", options);
    }
    if (options.allowShared && !isSharedArrayBuffer(value) && !isNonSharedArrayBuffer(value)) {
      throw makeException(TypeError, "is not an ArrayBuffer, SharedArrayBuffer, or a view on one", options);
    }
    if (isArrayBufferDetached(value)) {
      throw makeException(TypeError, "is a detached ArrayBuffer", options);
    }
    return value;
  };
  exports.DOMTimeStamp = exports["unsigned long long"];
});

// node_modules/whatwg-url/lib/utils.js
var require_utils3 = __commonJS((exports, module) => {
  function isObject(value) {
    return typeof value === "object" && value !== null || typeof value === "function";
  }
  function define2(target, source) {
    for (const key of Reflect.ownKeys(source)) {
      const descriptor = Reflect.getOwnPropertyDescriptor(source, key);
      if (descriptor && !Reflect.defineProperty(target, key, descriptor)) {
        throw new TypeError(`Cannot redefine property: ${String(key)}`);
      }
    }
  }
  function newObjectInRealm(globalObject, object) {
    const ctorRegistry = initCtorRegistry(globalObject);
    return Object.defineProperties(Object.create(ctorRegistry["%Object.prototype%"]), Object.getOwnPropertyDescriptors(object));
  }
  function initCtorRegistry(globalObject) {
    if (hasOwn(globalObject, ctorRegistrySymbol)) {
      return globalObject[ctorRegistrySymbol];
    }
    const ctorRegistry = Object.create(null);
    ctorRegistry["%Object.prototype%"] = globalObject.Object.prototype;
    ctorRegistry["%IteratorPrototype%"] = Object.getPrototypeOf(Object.getPrototypeOf(new globalObject.Array()[Symbol.iterator]()));
    try {
      ctorRegistry["%AsyncIteratorPrototype%"] = Object.getPrototypeOf(Object.getPrototypeOf(globalObject.eval("(async function* () {})").prototype));
    } catch {
      ctorRegistry["%AsyncIteratorPrototype%"] = AsyncIteratorPrototype;
    }
    globalObject[ctorRegistrySymbol] = ctorRegistry;
    return ctorRegistry;
  }
  function getSameObject(wrapper, prop, creator) {
    if (!wrapper[sameObjectCaches]) {
      wrapper[sameObjectCaches] = Object.create(null);
    }
    if (prop in wrapper[sameObjectCaches]) {
      return wrapper[sameObjectCaches][prop];
    }
    wrapper[sameObjectCaches][prop] = creator();
    return wrapper[sameObjectCaches][prop];
  }
  function wrapperForImpl(impl) {
    return impl ? impl[wrapperSymbol] : null;
  }
  function implForWrapper(wrapper) {
    return wrapper ? wrapper[implSymbol] : null;
  }
  function tryWrapperForImpl(impl) {
    const wrapper = wrapperForImpl(impl);
    return wrapper ? wrapper : impl;
  }
  function tryImplForWrapper(wrapper) {
    const impl = implForWrapper(wrapper);
    return impl ? impl : wrapper;
  }
  function isArrayIndexPropName(P) {
    if (typeof P !== "string") {
      return false;
    }
    const i = P >>> 0;
    if (i === 2 ** 32 - 1) {
      return false;
    }
    const s = `${i}`;
    if (P !== s) {
      return false;
    }
    return true;
  }
  function isArrayBuffer(value) {
    try {
      byteLengthGetter.call(value);
      return true;
    } catch (e) {
      return false;
    }
  }
  function iteratorResult([key, value], kind) {
    let result;
    switch (kind) {
      case "key":
        result = key;
        break;
      case "value":
        result = value;
        break;
      case "key+value":
        result = [key, value];
        break;
    }
    return { value: result, done: false };
  }
  var hasOwn = Function.prototype.call.bind(Object.prototype.hasOwnProperty);
  var wrapperSymbol = Symbol("wrapper");
  var implSymbol = Symbol("impl");
  var sameObjectCaches = Symbol("SameObject caches");
  var ctorRegistrySymbol = Symbol.for("[webidl2js] constructor registry");
  var AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
  }).prototype);
  var iterInternalSymbol = Symbol("internal");
  var byteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
  var supportsPropertyIndex = Symbol("supports property index");
  var supportedPropertyIndices = Symbol("supported property indices");
  var supportsPropertyName = Symbol("supports property name");
  var supportedPropertyNames = Symbol("supported property names");
  var indexedGet = Symbol("indexed property get");
  var indexedSetNew = Symbol("indexed property set new");
  var indexedSetExisting = Symbol("indexed property set existing");
  var namedGet = Symbol("named property get");
  var namedSetNew = Symbol("named property set new");
  var namedSetExisting = Symbol("named property set existing");
  var namedDelete = Symbol("named property delete");
  var asyncIteratorNext = Symbol("async iterator get the next iteration result");
  var asyncIteratorReturn = Symbol("async iterator return steps");
  var asyncIteratorInit = Symbol("async iterator initialization steps");
  var asyncIteratorEOI = Symbol("async iterator end of iteration");
  module.exports = exports = {
    isObject,
    hasOwn,
    define: define2,
    newObjectInRealm,
    wrapperSymbol,
    implSymbol,
    getSameObject,
    ctorRegistrySymbol,
    initCtorRegistry,
    wrapperForImpl,
    implForWrapper,
    tryWrapperForImpl,
    tryImplForWrapper,
    iterInternalSymbol,
    isArrayBuffer,
    isArrayIndexPropName,
    supportsPropertyIndex,
    supportedPropertyIndices,
    supportsPropertyName,
    supportedPropertyNames,
    indexedGet,
    indexedSetNew,
    indexedSetExisting,
    namedGet,
    namedSetNew,
    namedSetExisting,
    namedDelete,
    asyncIteratorNext,
    asyncIteratorReturn,
    asyncIteratorInit,
    asyncIteratorEOI,
    iteratorResult
  };
});

// node_modules/punycode/punycode.js
var require_punycode = __commonJS((exports, module) => {
  function error(type) {
    throw new RangeError(errors[type]);
  }
  function map(array, callback) {
    const result = [];
    let length = array.length;
    while (length--) {
      result[length] = callback(array[length]);
    }
    return result;
  }
  function mapDomain(domain, callback) {
    const parts = domain.split("@");
    let result = "";
    if (parts.length > 1) {
      result = parts[0] + "@";
      domain = parts[1];
    }
    domain = domain.replace(regexSeparators, ".");
    const labels = domain.split(".");
    const encoded = map(labels, callback).join(".");
    return result + encoded;
  }
  function ucs2decode(string) {
    const output = [];
    let counter = 0;
    const length = string.length;
    while (counter < length) {
      const value = string.charCodeAt(counter++);
      if (value >= 55296 && value <= 56319 && counter < length) {
        const extra = string.charCodeAt(counter++);
        if ((extra & 64512) == 56320) {
          output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  }
  var maxInt = 2147483647;
  var base = 36;
  var tMin = 1;
  var tMax = 26;
  var skew = 38;
  var damp = 700;
  var initialBias = 72;
  var initialN = 128;
  var delimiter = "-";
  var regexPunycode = /^xn--/;
  var regexNonASCII = /[^\0-\x7F]/;
  var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
  var errors = {
    overflow: "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
  };
  var baseMinusTMin = base - tMin;
  var floor = Math.floor;
  var stringFromCharCode = String.fromCharCode;
  var ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
  var basicToDigit = function(codePoint) {
    if (codePoint >= 48 && codePoint < 58) {
      return 26 + (codePoint - 48);
    }
    if (codePoint >= 65 && codePoint < 91) {
      return codePoint - 65;
    }
    if (codePoint >= 97 && codePoint < 123) {
      return codePoint - 97;
    }
    return base;
  };
  var digitToBasic = function(digit, flag) {
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  };
  var adapt = function(delta, numPoints, firstTime) {
    let k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    for (;delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }
    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  };
  var decode = function(input) {
    const output = [];
    const inputLength = input.length;
    let i = 0;
    let n = initialN;
    let bias = initialBias;
    let basic = input.lastIndexOf(delimiter);
    if (basic < 0) {
      basic = 0;
    }
    for (let j = 0;j < basic; ++j) {
      if (input.charCodeAt(j) >= 128) {
        error("not-basic");
      }
      output.push(input.charCodeAt(j));
    }
    for (let index = basic > 0 ? basic + 1 : 0;index < inputLength; ) {
      const oldi = i;
      for (let w = 1, k = base;; k += base) {
        if (index >= inputLength) {
          error("invalid-input");
        }
        const digit = basicToDigit(input.charCodeAt(index++));
        if (digit >= base) {
          error("invalid-input");
        }
        if (digit > floor((maxInt - i) / w)) {
          error("overflow");
        }
        i += digit * w;
        const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
        if (digit < t) {
          break;
        }
        const baseMinusT = base - t;
        if (w > floor(maxInt / baseMinusT)) {
          error("overflow");
        }
        w *= baseMinusT;
      }
      const out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0);
      if (floor(i / out) > maxInt - n) {
        error("overflow");
      }
      n += floor(i / out);
      i %= out;
      output.splice(i++, 0, n);
    }
    return String.fromCodePoint(...output);
  };
  var encode = function(input) {
    const output = [];
    input = ucs2decode(input);
    const inputLength = input.length;
    let n = initialN;
    let delta = 0;
    let bias = initialBias;
    for (const currentValue of input) {
      if (currentValue < 128) {
        output.push(stringFromCharCode(currentValue));
      }
    }
    const basicLength = output.length;
    let handledCPCount = basicLength;
    if (basicLength) {
      output.push(delimiter);
    }
    while (handledCPCount < inputLength) {
      let m = maxInt;
      for (const currentValue of input) {
        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      }
      const handledCPCountPlusOne = handledCPCount + 1;
      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error("overflow");
      }
      delta += (m - n) * handledCPCountPlusOne;
      n = m;
      for (const currentValue of input) {
        if (currentValue < n && ++delta > maxInt) {
          error("overflow");
        }
        if (currentValue === n) {
          let q = delta;
          for (let k = base;; k += base) {
            const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (q < t) {
              break;
            }
            const qMinusT = q - t;
            const baseMinusT = base - t;
            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
            q = floor(qMinusT / baseMinusT);
          }
          output.push(stringFromCharCode(digitToBasic(q, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }
      ++delta;
      ++n;
    }
    return output.join("");
  };
  var toUnicode = function(input) {
    return mapDomain(input, function(string) {
      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
  };
  var toASCII = function(input) {
    return mapDomain(input, function(string) {
      return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
    });
  };
  var punycode = {
    version: "2.3.1",
    ucs2: {
      decode: ucs2decode,
      encode: ucs2encode
    },
    decode,
    encode,
    toASCII,
    toUnicode
  };
  module.exports = punycode;
});

// node_modules/tr46/lib/regexes.js
var require_regexes = __commonJS((exports, module) => {
  var combiningMarks = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{11002}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11082}\u{110B0}-\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{11134}\u{11145}\u{11146}\u{11173}\u{11180}-\u{11182}\u{111B3}-\u{111C0}\u{111C9}-\u{111CC}\u{111CE}\u{111CF}\u{1122C}-\u{11237}\u{1123E}\u{11241}\u{112DF}-\u{112EA}\u{11300}-\u{11303}\u{1133B}\u{1133C}\u{1133E}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11357}\u{11362}\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11435}-\u{11446}\u{1145E}\u{114B0}-\u{114C3}\u{115AF}-\u{115B5}\u{115B8}-\u{115C0}\u{115DC}\u{115DD}\u{11630}-\u{11640}\u{116AB}-\u{116B7}\u{1171D}-\u{1172B}\u{1182C}-\u{1183A}\u{11930}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{1193E}\u{11940}\u{11942}\u{11943}\u{119D1}-\u{119D7}\u{119DA}-\u{119E0}\u{119E4}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A39}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A5B}\u{11A8A}-\u{11A99}\u{11C2F}-\u{11C36}\u{11C38}-\u{11C3F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D8A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D97}\u{11EF3}-\u{11EF6}\u{11F00}\u{11F01}\u{11F03}\u{11F34}-\u{11F3A}\u{11F3E}-\u{11F42}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F51}-\u{16F87}\u{16F8F}-\u{16F92}\u{16FE4}\u{16FF0}\u{16FF1}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D165}-\u{1D169}\u{1D16D}-\u{1D172}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]/u;
  var combiningClassVirama = /[\u094D\u09CD\u0A4D\u0ACD\u0B4D\u0BCD\u0C4D\u0CCD\u0D3B\u0D3C\u0D4D\u0DCA\u0E3A\u0EBA\u0F84\u1039\u103A\u1714\u1715\u1734\u17D2\u1A60\u1B44\u1BAA\u1BAB\u1BF2\u1BF3\u2D7F\uA806\uA82C\uA8C4\uA953\uA9C0\uAAF6\uABED\u{10A3F}\u{11046}\u{11070}\u{1107F}\u{110B9}\u{11133}\u{11134}\u{111C0}\u{11235}\u{112EA}\u{1134D}\u{11442}\u{114C2}\u{115BF}\u{1163F}\u{116B6}\u{1172B}\u{11839}\u{1193D}\u{1193E}\u{119E0}\u{11A34}\u{11A47}\u{11A99}\u{11C3F}\u{11D44}\u{11D45}\u{11D97}\u{11F41}\u{11F42}]/u;
  var validZWNJ = /[\u0620\u0626\u0628\u062A-\u062E\u0633-\u063F\u0641-\u0647\u0649\u064A\u066E\u066F\u0678-\u0687\u069A-\u06BF\u06C1\u06C2\u06CC\u06CE\u06D0\u06D1\u06FA-\u06FC\u06FF\u0712-\u0714\u071A-\u071D\u071F-\u0727\u0729\u072B\u072D\u072E\u074E-\u0758\u075C-\u076A\u076D-\u0770\u0772\u0775-\u0777\u077A-\u077F\u07CA-\u07EA\u0841-\u0845\u0848\u084A-\u0853\u0855\u0860\u0862-\u0865\u0868\u0886\u0889-\u088D\u08A0-\u08A9\u08AF\u08B0\u08B3-\u08B8\u08BA-\u08C8\u1807\u1820-\u1878\u1887-\u18A8\u18AA\uA840-\uA872\u{10AC0}-\u{10AC4}\u{10ACD}\u{10AD3}-\u{10ADC}\u{10ADE}-\u{10AE0}\u{10AEB}-\u{10AEE}\u{10B80}\u{10B82}\u{10B86}-\u{10B88}\u{10B8A}\u{10B8B}\u{10B8D}\u{10B90}\u{10BAD}\u{10BAE}\u{10D00}-\u{10D21}\u{10D23}\u{10F30}-\u{10F32}\u{10F34}-\u{10F44}\u{10F51}-\u{10F53}\u{10F70}-\u{10F73}\u{10F76}-\u{10F81}\u{10FB0}\u{10FB2}\u{10FB3}\u{10FB8}\u{10FBB}\u{10FBC}\u{10FBE}\u{10FBF}\u{10FC1}\u{10FC4}\u{10FCA}\u{10FCB}\u{1E900}-\u{1E943}][\xAD\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u061C\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u070F\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200B\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFEFF\uFFF9-\uFFFB\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C3F}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{13430}-\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94B}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*\u200C[\xAD\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u061C\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u070F\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200B\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFEFF\uFFF9-\uFFFB\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C3F}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{13430}-\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94B}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*[\u0620\u0622-\u063F\u0641-\u064A\u066E\u066F\u0671-\u0673\u0675-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u077F\u07CA-\u07EA\u0840-\u0858\u0860\u0862-\u0865\u0867-\u086A\u0870-\u0882\u0886\u0889-\u088E\u08A0-\u08AC\u08AE-\u08C8\u1807\u1820-\u1878\u1887-\u18A8\u18AA\uA840-\uA871\u{10AC0}-\u{10AC5}\u{10AC7}\u{10AC9}\u{10ACA}\u{10ACE}-\u{10AD6}\u{10AD8}-\u{10AE1}\u{10AE4}\u{10AEB}-\u{10AEF}\u{10B80}-\u{10B91}\u{10BA9}-\u{10BAE}\u{10D01}-\u{10D23}\u{10F30}-\u{10F44}\u{10F51}-\u{10F54}\u{10F70}-\u{10F81}\u{10FB0}\u{10FB2}-\u{10FB6}\u{10FB8}-\u{10FBF}\u{10FC1}-\u{10FC4}\u{10FC9}\u{10FCA}\u{1E900}-\u{1E943}]/u;
  var bidiDomain = /[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0600-\u0605\u0608\u060B\u060D\u061B-\u064A\u0660-\u0669\u066B-\u066F\u0671-\u06D5\u06DD\u06E5\u06E6\u06EE\u06EF\u06FA-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u08A0-\u08C9\u08E2\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}]/u;
  var bidiS1LTR = /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0482\u048A-\u052F\u0531-\u0556\u0559-\u0589\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u0980\u0982\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C0\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u09FC\u09FD\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A76\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC0\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0\u0AE1\u0AE6-\u0AF0\u0AF9\u0B02\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C77\u0C7F\u0C80\u0C82-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D02-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D4F\u0D54-\u0D61\u0D66-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E4F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FDA\u1000-\u102C\u1031\u1038\u103B\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083\u1084\u1087-\u108C\u108E-\u109C\u109E-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u167F\u1681-\u169A\u16A0-\u16F8\u1700-\u1711\u1715\u171F-\u1731\u1734-\u1736\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5\u17C7\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A19\u1A1A\u1A1E-\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B4C\u1B50-\u1B6A\u1B74-\u1B7E\u1B82-\u1BA1\u1BA6\u1BA7\u1BAA\u1BAE-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1BFC-\u1C2B\u1C34\u1C35\u1C3B-\u1C49\u1C4D-\u1C88\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2188\u2336-\u237A\u2395\u249C-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u302E\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31BF\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA62B\uA640-\uA66E\uA680-\uA69D\uA6A0-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA8FE\uA900-\uA925\uA92E-\uA946\uA952\uA953\uA95F-\uA97C\uA983-\uA9B2\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA2F\uAA30\uAA33\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA7B\uAA7D-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAAEB\uAAEE-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB69\uAB70-\uABE4\uABE6\uABE7\uABE9-\uABEC\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1013F}\u{1018D}\u{1018E}\u{101D0}-\u{101FC}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{11000}\u{11002}-\u{11037}\u{11047}-\u{1104D}\u{11066}-\u{1106F}\u{11071}\u{11072}\u{11075}\u{11082}-\u{110B2}\u{110B7}\u{110B8}\u{110BB}-\u{110C1}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11103}-\u{11126}\u{1112C}\u{11136}-\u{11147}\u{11150}-\u{11172}\u{11174}-\u{11176}\u{11182}-\u{111B5}\u{111BF}-\u{111C8}\u{111CD}\u{111CE}\u{111D0}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1122E}\u{11232}\u{11233}\u{11235}\u{11238}-\u{1123D}\u{1123F}\u{11240}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112DE}\u{112E0}-\u{112E2}\u{112F0}-\u{112F9}\u{11302}\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}-\u{1133F}\u{11341}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11400}-\u{11437}\u{11440}\u{11441}\u{11445}\u{11447}-\u{1145B}\u{1145D}\u{1145F}-\u{11461}\u{11480}-\u{114B2}\u{114B9}\u{114BB}-\u{114BE}\u{114C1}\u{114C4}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B1}\u{115B8}-\u{115BB}\u{115BE}\u{115C1}-\u{115DB}\u{11600}-\u{11632}\u{1163B}\u{1163C}\u{1163E}\u{11641}-\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116AA}\u{116AC}\u{116AE}\u{116AF}\u{116B6}\u{116B8}\u{116B9}\u{116C0}-\u{116C9}\u{11700}-\u{1171A}\u{11720}\u{11721}\u{11726}\u{11730}-\u{11746}\u{11800}-\u{1182E}\u{11838}\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193D}\u{1193F}-\u{11942}\u{11944}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D3}\u{119DC}-\u{119DF}\u{119E1}-\u{119E4}\u{11A00}\u{11A07}\u{11A08}\u{11A0B}-\u{11A32}\u{11A39}\u{11A3A}\u{11A3F}-\u{11A46}\u{11A50}\u{11A57}\u{11A58}\u{11A5C}-\u{11A89}\u{11A97}\u{11A9A}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2F}\u{11C3E}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11CA9}\u{11CB1}\u{11CB4}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D93}\u{11D94}\u{11D96}\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF2}\u{11EF5}-\u{11EF8}\u{11F02}-\u{11F10}\u{11F12}-\u{11F35}\u{11F3E}\u{11F3F}\u{11F41}\u{11F43}-\u{11F59}\u{11FB0}\u{11FC0}-\u{11FD4}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{1343F}\u{13441}-\u{13446}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF5}\u{16B00}-\u{16B2F}\u{16B37}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F50}-\u{16F87}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18D00}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}\u{1BC9F}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D166}\u{1D16A}-\u{1D172}\u{1D183}\u{1D184}\u{1D18C}-\u{1D1A9}\u{1D1AE}-\u{1D1E8}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6DA}\u{1D6DC}-\u{1D714}\u{1D716}-\u{1D74E}\u{1D750}-\u{1D788}\u{1D78A}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1D800}-\u{1D9FF}\u{1DA37}-\u{1DA3A}\u{1DA6D}-\u{1DA74}\u{1DA76}-\u{1DA83}\u{1DA85}-\u{1DA8B}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E030}-\u{1E06D}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E2F0}-\u{1E2F9}\u{1E4D0}-\u{1E4EB}\u{1E4F0}-\u{1E4F9}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1F110}-\u{1F12E}\u{1F130}-\u{1F169}\u{1F170}-\u{1F1AC}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2EBF0}-\u{2EE5D}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}]/u;
  var bidiS1RTL = /[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}]/u;
  var bidiS2 = /^[\0-\x08\x0E-\x1B!-@\[-`\{-\x84\x86-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02B9\u02BA\u02C2-\u02CF\u02D2-\u02DF\u02E5-\u02ED\u02EF-\u036F\u0374\u0375\u037E\u0384\u0385\u0387\u03F6\u0483-\u0489\u058A\u058D-\u058F\u0591-\u05C7\u05D0-\u05EA\u05EF-\u05F4\u0600-\u070D\u070F-\u074A\u074D-\u07B1\u07C0-\u07FA\u07FD-\u082D\u0830-\u083E\u0840-\u085B\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u0898-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09F2\u09F3\u09FB\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AF1\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0BF3-\u0BFA\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C78-\u0C7E\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E3F\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39-\u0F3D\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1390-\u1399\u1400\u169B\u169C\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DB\u17DD\u17F0-\u17F9\u1800-\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1940\u1944\u1945\u19DE-\u19FF\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u200B-\u200D\u200F-\u2027\u202F-\u205E\u2060-\u2064\u206A-\u2070\u2074-\u207E\u2080-\u208E\u20A0-\u20C0\u20D0-\u20F0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u2150-\u215F\u2189-\u218B\u2190-\u2335\u237B-\u2394\u2396-\u2426\u2440-\u244A\u2460-\u249B\u24EA-\u26AB\u26AD-\u27FF\u2900-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2CEF-\u2CF1\u2CF9-\u2CFF\u2D7F\u2DE0-\u2E5D\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3001-\u3004\u3008-\u3020\u302A-\u302D\u3030\u3036\u3037\u303D-\u303F\u3099-\u309C\u30A0\u30FB\u31C0-\u31E3\u31EF\u321D\u321E\u3250-\u325F\u327C-\u327E\u32B1-\u32BF\u32CC-\u32CF\u3377-\u337A\u33DE\u33DF\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA60D-\uA60F\uA66F-\uA67F\uA69E\uA69F\uA6F0\uA6F1\uA700-\uA721\uA788\uA802\uA806\uA80B\uA825\uA826\uA828-\uA82C\uA838\uA839\uA874-\uA877\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uAB6A\uAB6B\uABE5\uABE8\uABED\uFB1D-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD8F\uFD92-\uFDC7\uFDCF\uFDF0-\uFE19\uFE20-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFE70-\uFE74\uFE76-\uFEFC\uFEFF\uFF01-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD\u{10101}\u{10140}-\u{1018C}\u{10190}-\u{1019C}\u{101A0}\u{101FD}\u{102E0}-\u{102FB}\u{10376}-\u{1037A}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{1091F}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A38}-\u{10A3A}\u{10A3F}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE6}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B39}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D27}\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAB}-\u{10EAD}\u{10EB0}\u{10EB1}\u{10EFD}-\u{10F27}\u{10F30}-\u{10F59}\u{10F70}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{11001}\u{11038}-\u{11046}\u{11052}-\u{11065}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{11660}-\u{1166C}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{11FD5}-\u{11FF1}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE2}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D1E9}\u{1D1EA}\u{1D200}-\u{1D245}\u{1D300}-\u{1D356}\u{1D6DB}\u{1D715}\u{1D74F}\u{1D789}\u{1D7C3}\u{1D7CE}-\u{1D7FF}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E2FF}\u{1E4EC}-\u{1E4EF}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8D6}\u{1E900}-\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{1EEF0}\u{1EEF1}\u{1F000}-\u{1F02B}\u{1F030}-\u{1F093}\u{1F0A0}-\u{1F0AE}\u{1F0B1}-\u{1F0BF}\u{1F0C1}-\u{1F0CF}\u{1F0D1}-\u{1F0F5}\u{1F100}-\u{1F10F}\u{1F12F}\u{1F16A}-\u{1F16F}\u{1F1AD}\u{1F260}-\u{1F265}\u{1F300}-\u{1F6D7}\u{1F6DC}-\u{1F6EC}\u{1F6F0}-\u{1F6FC}\u{1F700}-\u{1F776}\u{1F77B}-\u{1F7D9}\u{1F7E0}-\u{1F7EB}\u{1F7F0}\u{1F800}-\u{1F80B}\u{1F810}-\u{1F847}\u{1F850}-\u{1F859}\u{1F860}-\u{1F887}\u{1F890}-\u{1F8AD}\u{1F8B0}\u{1F8B1}\u{1F900}-\u{1FA53}\u{1FA60}-\u{1FA6D}\u{1FA70}-\u{1FA7C}\u{1FA80}-\u{1FA88}\u{1FA90}-\u{1FABD}\u{1FABF}-\u{1FAC5}\u{1FACE}-\u{1FADB}\u{1FAE0}-\u{1FAE8}\u{1FAF0}-\u{1FAF8}\u{1FB00}-\u{1FB92}\u{1FB94}-\u{1FBCA}\u{1FBF0}-\u{1FBF9}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*$/u;
  var bidiS3 = /[0-9\xB2\xB3\xB9\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05EF-\u05F4\u0600-\u0605\u0608\u060B\u060D\u061B-\u064A\u0660-\u0669\u066B-\u066F\u0671-\u06D5\u06DD\u06E5\u06E6\u06EE-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u0870-\u088E\u0890\u0891\u08A0-\u08C9\u08E2\u200F\u2070\u2074-\u2079\u2080-\u2089\u2488-\u249B\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC2\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\u{102E1}-\u{102FB}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A35}\u{10A40}-\u{10A48}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10D23}\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}\u{10E80}-\u{10EA9}\u{10EAD}\u{10EB0}\u{10EB1}\u{10F00}-\u{10F27}\u{10F30}-\u{10F45}\u{10F51}-\u{10F59}\u{10F70}-\u{10F81}\u{10F86}-\u{10F89}\u{10FB0}-\u{10FCB}\u{10FE0}-\u{10FF6}\u{1D7CE}-\u{1D7FF}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E94B}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EC71}-\u{1ECB4}\u{1ED01}-\u{1ED3D}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{1F100}-\u{1F10A}\u{1FBF0}-\u{1FBF9}][\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*$/u;
  var bidiS4EN = /[0-9\xB2\xB3\xB9\u06F0-\u06F9\u2070\u2074-\u2079\u2080-\u2089\u2488-\u249B\uFF10-\uFF19\u{102E1}-\u{102FB}\u{1D7CE}-\u{1D7FF}\u{1F100}-\u{1F10A}\u{1FBF0}-\u{1FBF9}]/u;
  var bidiS4AN = /[\u0600-\u0605\u0660-\u0669\u066B\u066C\u06DD\u0890\u0891\u08E2\u{10D30}-\u{10D39}\u{10E60}-\u{10E7E}]/u;
  var bidiS5 = /^[\0-\x08\x0E-\x1B!-\x84\x86-\u0377\u037A-\u037F\u0384-\u038A\u038C\u038E-\u03A1\u03A3-\u052F\u0531-\u0556\u0559-\u058A\u058D-\u058F\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0606\u0607\u0609\u060A\u060C\u060E-\u061A\u064B-\u065F\u066A\u0670\u06D6-\u06DC\u06DE-\u06E4\u06E7-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07F6-\u07F9\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A76\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AF1\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B77\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BFA\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3C-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C5D\u0C60-\u0C63\u0C66-\u0C6F\u0C77-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D00-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4F\u0D54-\u0D63\u0D66-\u0D7F\u0D81-\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E3A\u0E3F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECE\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F47\u0F49-\u0F6C\u0F71-\u0F97\u0F99-\u0FBC\u0FBE-\u0FCC\u0FCE-\u0FDA\u1000-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u137C\u1380-\u1399\u13A0-\u13F5\u13F8-\u13FD\u1400-\u167F\u1681-\u169C\u16A0-\u16F8\u1700-\u1715\u171F-\u1736\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17DD\u17E0-\u17E9\u17F0-\u17F9\u1800-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1940\u1944-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u19DE-\u1A1B\u1A1E-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1AB0-\u1ACE\u1B00-\u1B4C\u1B50-\u1B7E\u1B80-\u1BF3\u1BFC-\u1C37\u1C3B-\u1C49\u1C4D-\u1C88\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD0-\u1CFA\u1D00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u200B-\u200E\u2010-\u2027\u202F-\u205E\u2060-\u2064\u206A-\u2071\u2074-\u208E\u2090-\u209C\u20A0-\u20C0\u20D0-\u20F0\u2100-\u218B\u2190-\u2426\u2440-\u244A\u2460-\u2B73\u2B76-\u2B95\u2B97-\u2CF3\u2CF9-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2E5D\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3001-\u303F\u3041-\u3096\u3099-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31E3\u31EF-\u321E\u3220-\uA48C\uA490-\uA4C6\uA4D0-\uA62B\uA640-\uA6F7\uA700-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA82C\uA830-\uA839\uA840-\uA877\uA880-\uA8C5\uA8CE-\uA8D9\uA8E0-\uA953\uA95F-\uA97C\uA980-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA5C-\uAAC2\uAADB-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB6B\uAB70-\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1E\uFB29\uFD3E-\uFD4F\uFDCF\uFDFD-\uFE19\uFE20-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFEFF\uFF01-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}-\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1018E}\u{10190}-\u{1019C}\u{101A0}\u{101D0}-\u{101FD}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{102E0}-\u{102FB}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{1037A}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{1091F}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10B39}-\u{10B3F}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11000}-\u{1104D}\u{11052}-\u{11075}\u{1107F}-\u{110C2}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11100}-\u{11134}\u{11136}-\u{11147}\u{11150}-\u{11176}\u{11180}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{11241}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112EA}\u{112F0}-\u{112F9}\u{11300}-\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133B}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11400}-\u{1145B}\u{1145D}-\u{11461}\u{11480}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B5}\u{115B8}-\u{115DD}\u{11600}-\u{11644}\u{11650}-\u{11659}\u{11660}-\u{1166C}\u{11680}-\u{116B9}\u{116C0}-\u{116C9}\u{11700}-\u{1171A}\u{1171D}-\u{1172B}\u{11730}-\u{11746}\u{11800}-\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193B}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D7}\u{119DA}-\u{119E4}\u{11A00}-\u{11A47}\u{11A50}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C36}\u{11C38}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D47}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D90}\u{11D91}\u{11D93}-\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF8}\u{11F00}-\u{11F10}\u{11F12}-\u{11F3A}\u{11F3E}-\u{11F59}\u{11FB0}\u{11FC0}-\u{11FF1}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{13455}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF0}-\u{16AF5}\u{16B00}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F4F}-\u{16F87}\u{16F8F}-\u{16F9F}\u{16FE0}-\u{16FE4}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18D00}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}-\u{1BCA3}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D1EA}\u{1D200}-\u{1D245}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D300}-\u{1D356}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D7CB}\u{1D7CE}-\u{1DA8B}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E030}-\u{1E06D}\u{1E08F}\u{1E100}-\u{1E12C}\u{1E130}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AE}\u{1E2C0}-\u{1E2F9}\u{1E2FF}\u{1E4D0}-\u{1E4F9}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{1EEF0}\u{1EEF1}\u{1F000}-\u{1F02B}\u{1F030}-\u{1F093}\u{1F0A0}-\u{1F0AE}\u{1F0B1}-\u{1F0BF}\u{1F0C1}-\u{1F0CF}\u{1F0D1}-\u{1F0F5}\u{1F100}-\u{1F1AD}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{1F260}-\u{1F265}\u{1F300}-\u{1F6D7}\u{1F6DC}-\u{1F6EC}\u{1F6F0}-\u{1F6FC}\u{1F700}-\u{1F776}\u{1F77B}-\u{1F7D9}\u{1F7E0}-\u{1F7EB}\u{1F7F0}\u{1F800}-\u{1F80B}\u{1F810}-\u{1F847}\u{1F850}-\u{1F859}\u{1F860}-\u{1F887}\u{1F890}-\u{1F8AD}\u{1F8B0}\u{1F8B1}\u{1F900}-\u{1FA53}\u{1FA60}-\u{1FA6D}\u{1FA70}-\u{1FA7C}\u{1FA80}-\u{1FA88}\u{1FA90}-\u{1FABD}\u{1FABF}-\u{1FAC5}\u{1FACE}-\u{1FADB}\u{1FAE0}-\u{1FAE8}\u{1FAF0}-\u{1FAF8}\u{1FB00}-\u{1FB92}\u{1FB94}-\u{1FBCA}\u{1FBF0}-\u{1FBF9}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2EBF0}-\u{2EE5D}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}]*$/u;
  var bidiS6 = /[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0482\u048A-\u052F\u0531-\u0556\u0559-\u0589\u06F0-\u06F9\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u0980\u0982\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C0\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u09FC\u09FD\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A76\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC0\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0\u0AE1\u0AE6-\u0AF0\u0AF9\u0B02\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C77\u0C7F\u0C80\u0C82-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1-\u0CF3\u0D02-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D4F\u0D54-\u0D61\u0D66-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E4F-\u0E5B\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FDA\u1000-\u102C\u1031\u1038\u103B\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083\u1084\u1087-\u108C\u108E-\u109C\u109E-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u167F\u1681-\u169A\u16A0-\u16F8\u1700-\u1711\u1715\u171F-\u1731\u1734-\u1736\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5\u17C7\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A19\u1A1A\u1A1E-\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B4C\u1B50-\u1B6A\u1B74-\u1B7E\u1B82-\u1BA1\u1BA6\u1BA7\u1BAA\u1BAE-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1BFC-\u1C2B\u1C34\u1C35\u1C3B-\u1C49\u1C4D-\u1C88\u1C90-\u1CBA\u1CBD-\u1CC7\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2188\u2336-\u237A\u2395\u2488-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u302E\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3190-\u31BF\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA60C\uA610-\uA62B\uA640-\uA66E\uA680-\uA69D\uA6A0-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA8FE\uA900-\uA925\uA92E-\uA946\uA952\uA953\uA95F-\uA97C\uA983-\uA9B2\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA2F\uAA30\uAA33\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA7B\uAA7D-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAAEB\uAAEE-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB69\uAB70-\uABE4\uABE6\uABE7\uABE9-\uABEC\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1013F}\u{1018D}\u{1018E}\u{101D0}-\u{101FC}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{102E1}-\u{102FB}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}-\u{1057A}\u{1057C}-\u{1058A}\u{1058C}-\u{10592}\u{10594}\u{10595}\u{10597}-\u{105A1}\u{105A3}-\u{105B1}\u{105B3}-\u{105B9}\u{105BB}\u{105BC}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{10780}-\u{10785}\u{10787}-\u{107B0}\u{107B2}-\u{107BA}\u{11000}\u{11002}-\u{11037}\u{11047}-\u{1104D}\u{11066}-\u{1106F}\u{11071}\u{11072}\u{11075}\u{11082}-\u{110B2}\u{110B7}\u{110B8}\u{110BB}-\u{110C1}\u{110CD}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11103}-\u{11126}\u{1112C}\u{11136}-\u{11147}\u{11150}-\u{11172}\u{11174}-\u{11176}\u{11182}-\u{111B5}\u{111BF}-\u{111C8}\u{111CD}\u{111CE}\u{111D0}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1122E}\u{11232}\u{11233}\u{11235}\u{11238}-\u{1123D}\u{1123F}\u{11240}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112DE}\u{112E0}-\u{112E2}\u{112F0}-\u{112F9}\u{11302}\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}-\u{1133F}\u{11341}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11400}-\u{11437}\u{11440}\u{11441}\u{11445}\u{11447}-\u{1145B}\u{1145D}\u{1145F}-\u{11461}\u{11480}-\u{114B2}\u{114B9}\u{114BB}-\u{114BE}\u{114C1}\u{114C4}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B1}\u{115B8}-\u{115BB}\u{115BE}\u{115C1}-\u{115DB}\u{11600}-\u{11632}\u{1163B}\u{1163C}\u{1163E}\u{11641}-\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116AA}\u{116AC}\u{116AE}\u{116AF}\u{116B6}\u{116B8}\u{116B9}\u{116C0}-\u{116C9}\u{11700}-\u{1171A}\u{11720}\u{11721}\u{11726}\u{11730}-\u{11746}\u{11800}-\u{1182E}\u{11838}\u{1183B}\u{118A0}-\u{118F2}\u{118FF}-\u{11906}\u{11909}\u{1190C}-\u{11913}\u{11915}\u{11916}\u{11918}-\u{11935}\u{11937}\u{11938}\u{1193D}\u{1193F}-\u{11942}\u{11944}-\u{11946}\u{11950}-\u{11959}\u{119A0}-\u{119A7}\u{119AA}-\u{119D3}\u{119DC}-\u{119DF}\u{119E1}-\u{119E4}\u{11A00}\u{11A07}\u{11A08}\u{11A0B}-\u{11A32}\u{11A39}\u{11A3A}\u{11A3F}-\u{11A46}\u{11A50}\u{11A57}\u{11A58}\u{11A5C}-\u{11A89}\u{11A97}\u{11A9A}-\u{11AA2}\u{11AB0}-\u{11AF8}\u{11B00}-\u{11B09}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2F}\u{11C3E}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11CA9}\u{11CB1}\u{11CB4}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D50}-\u{11D59}\u{11D60}-\u{11D65}\u{11D67}\u{11D68}\u{11D6A}-\u{11D8E}\u{11D93}\u{11D94}\u{11D96}\u{11D98}\u{11DA0}-\u{11DA9}\u{11EE0}-\u{11EF2}\u{11EF5}-\u{11EF8}\u{11F02}-\u{11F10}\u{11F12}-\u{11F35}\u{11F3E}\u{11F3F}\u{11F41}\u{11F43}-\u{11F59}\u{11FB0}\u{11FC0}-\u{11FD4}\u{11FFF}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{12F90}-\u{12FF2}\u{13000}-\u{1343F}\u{13441}-\u{13446}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}-\u{16ABE}\u{16AC0}-\u{16AC9}\u{16AD0}-\u{16AED}\u{16AF5}\u{16B00}-\u{16B2F}\u{16B37}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16E40}-\u{16E9A}\u{16F00}-\u{16F4A}\u{16F50}-\u{16F87}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{16FE3}\u{16FF0}\u{16FF1}\u{17000}-\u{187F7}\u{18800}-\u{18CD5}\u{18D00}-\u{18D08}\u{1AFF0}-\u{1AFF3}\u{1AFF5}-\u{1AFFB}\u{1AFFD}\u{1AFFE}\u{1B000}-\u{1B122}\u{1B132}\u{1B150}-\u{1B152}\u{1B155}\u{1B164}-\u{1B167}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}\u{1BC9F}\u{1CF50}-\u{1CFC3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D166}\u{1D16A}-\u{1D172}\u{1D183}\u{1D184}\u{1D18C}-\u{1D1A9}\u{1D1AE}-\u{1D1E8}\u{1D2C0}-\u{1D2D3}\u{1D2E0}-\u{1D2F3}\u{1D360}-\u{1D378}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6DA}\u{1D6DC}-\u{1D714}\u{1D716}-\u{1D74E}\u{1D750}-\u{1D788}\u{1D78A}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1D7CE}-\u{1D9FF}\u{1DA37}-\u{1DA3A}\u{1DA6D}-\u{1DA74}\u{1DA76}-\u{1DA83}\u{1DA85}-\u{1DA8B}\u{1DF00}-\u{1DF1E}\u{1DF25}-\u{1DF2A}\u{1E030}-\u{1E06D}\u{1E100}-\u{1E12C}\u{1E137}-\u{1E13D}\u{1E140}-\u{1E149}\u{1E14E}\u{1E14F}\u{1E290}-\u{1E2AD}\u{1E2C0}-\u{1E2EB}\u{1E2F0}-\u{1E2F9}\u{1E4D0}-\u{1E4EB}\u{1E4F0}-\u{1E4F9}\u{1E7E0}-\u{1E7E6}\u{1E7E8}-\u{1E7EB}\u{1E7ED}\u{1E7EE}\u{1E7F0}-\u{1E7FE}\u{1F100}-\u{1F10A}\u{1F110}-\u{1F12E}\u{1F130}-\u{1F169}\u{1F170}-\u{1F1AC}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{1FBF0}-\u{1FBF9}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B739}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2EBF0}-\u{2EE5D}\u{2F800}-\u{2FA1D}\u{30000}-\u{3134A}\u{31350}-\u{323AF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}][\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B55\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0D81\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10D24}-\u{10D27}\u{10EAB}\u{10EAC}\u{10EFD}-\u{10EFF}\u{10F46}-\u{10F50}\u{10F82}-\u{10F85}\u{11001}\u{11038}-\u{11046}\u{11070}\u{11073}\u{11074}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110C2}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111C9}-\u{111CC}\u{111CF}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{11241}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133B}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{1145E}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{1182F}-\u{11837}\u{11839}\u{1183A}\u{1193B}\u{1193C}\u{1193E}\u{11943}\u{119D4}-\u{119D7}\u{119DA}\u{119DB}\u{119E0}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{11D90}\u{11D91}\u{11D95}\u{11D97}\u{11EF3}\u{11EF4}\u{11F00}\u{11F01}\u{11F36}-\u{11F3A}\u{11F40}\u{11F42}\u{13440}\u{13447}-\u{13455}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F4F}\u{16F8F}-\u{16F92}\u{16FE4}\u{1BC9D}\u{1BC9E}\u{1CF00}-\u{1CF2D}\u{1CF30}-\u{1CF46}\u{1D167}-\u{1D169}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E08F}\u{1E130}-\u{1E136}\u{1E2AE}\u{1E2EC}-\u{1E2EF}\u{1E4EC}-\u{1E4EF}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*$/u;
  module.exports = {
    combiningMarks,
    combiningClassVirama,
    validZWNJ,
    bidiDomain,
    bidiS1LTR,
    bidiS1RTL,
    bidiS2,
    bidiS3,
    bidiS4EN,
    bidiS4AN,
    bidiS5,
    bidiS6
  };
});

// node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS((exports, module) => {
  module.exports = [[[0, 44], 4], [[45, 46], 2], [47, 4], [[48, 57], 2], [[58, 64], 4], [65, 1, "a"], [66, 1, "b"], [67, 1, "c"], [68, 1, "d"], [69, 1, "e"], [70, 1, "f"], [71, 1, "g"], [72, 1, "h"], [73, 1, "i"], [74, 1, "j"], [75, 1, "k"], [76, 1, "l"], [77, 1, "m"], [78, 1, "n"], [79, 1, "o"], [80, 1, "p"], [81, 1, "q"], [82, 1, "r"], [83, 1, "s"], [84, 1, "t"], [85, 1, "u"], [86, 1, "v"], [87, 1, "w"], [88, 1, "x"], [89, 1, "y"], [90, 1, "z"], [[91, 96], 4], [[97, 122], 2], [[123, 127], 4], [[128, 159], 3], [160, 5, " "], [[161, 167], 2], [168, 5, " "], [169, 2], [170, 1, "a"], [[171, 172], 2], [173, 7], [174, 2], [175, 5, " "], [[176, 177], 2], [178, 1, "2"], [179, 1, "3"], [180, 5, " "], [181, 1, ""], [182, 2], [183, 2], [184, 5, " "], [185, 1, "1"], [186, 1, "o"], [187, 2], [188, 1, "14"], [189, 1, "12"], [190, 1, "34"], [191, 2], [192, 1, ""], [193, 1, ""], [194, 1, ""], [195, 1, ""], [196, 1, ""], [197, 1, ""], [198, 1, ""], [199, 1, ""], [200, 1, ""], [201, 1, ""], [202, 1, ""], [203, 1, ""], [204, 1, ""], [205, 1, ""], [206, 1, ""], [207, 1, ""], [208, 1, ""], [209, 1, ""], [210, 1, ""], [211, 1, ""], [212, 1, ""], [213, 1, ""], [214, 1, ""], [215, 2], [216, 1, ""], [217, 1, ""], [218, 1, ""], [219, 1, ""], [220, 1, ""], [221, 1, ""], [222, 1, ""], [223, 6, "ss"], [[224, 246], 2], [247, 2], [[248, 255], 2], [256, 1, ""], [257, 2], [258, 1, ""], [259, 2], [260, 1, ""], [261, 2], [262, 1, ""], [263, 2], [264, 1, ""], [265, 2], [266, 1, ""], [267, 2], [268, 1, ""], [269, 2], [270, 1, ""], [271, 2], [272, 1, ""], [273, 2], [274, 1, ""], [275, 2], [276, 1, ""], [277, 2], [278, 1, ""], [279, 2], [280, 1, ""], [281, 2], [282, 1, ""], [283, 2], [284, 1, ""], [285, 2], [286, 1, ""], [287, 2], [288, 1, ""], [289, 2], [290, 1, ""], [291, 2], [292, 1, ""], [293, 2], [294, 1, ""], [295, 2], [296, 1, ""], [297, 2], [298, 1, ""], [299, 2], [300, 1, ""], [301, 2], [302, 1, ""], [303, 2], [304, 1, "i"], [305, 2], [[306, 307], 1, "ij"], [308, 1, ""], [309, 2], [310, 1, ""], [[311, 312], 2], [313, 1, ""], [314, 2], [315, 1, ""], [316, 2], [317, 1, ""], [318, 2], [[319, 320], 1, "l"], [321, 1, ""], [322, 2], [323, 1, ""], [324, 2], [325, 1, ""], [326, 2], [327, 1, ""], [328, 2], [329, 1, "n"], [330, 1, ""], [331, 2], [332, 1, ""], [333, 2], [334, 1, ""], [335, 2], [336, 1, ""], [337, 2], [338, 1, ""], [339, 2], [340, 1, ""], [341, 2], [342, 1, ""], [343, 2], [344, 1, ""], [345, 2], [346, 1, ""], [347, 2], [348, 1, ""], [349, 2], [350, 1, ""], [351, 2], [352, 1, ""], [353, 2], [354, 1, ""], [355, 2], [356, 1, ""], [357, 2], [358, 1, ""], [359, 2], [360, 1, ""], [361, 2], [362, 1, ""], [363, 2], [364, 1, ""], [365, 2], [366, 1, ""], [367, 2], [368, 1, ""], [369, 2], [370, 1, ""], [371, 2], [372, 1, ""], [373, 2], [374, 1, ""], [375, 2], [376, 1, ""], [377, 1, ""], [378, 2], [379, 1, ""], [380, 2], [381, 1, ""], [382, 2], [383, 1, "s"], [384, 2], [385, 1, ""], [386, 1, ""], [387, 2], [388, 1, ""], [389, 2], [390, 1, ""], [391, 1, ""], [392, 2], [393, 1, ""], [394, 1, ""], [395, 1, ""], [[396, 397], 2], [398, 1, ""], [399, 1, ""], [400, 1, ""], [401, 1, ""], [402, 2], [403, 1, ""], [404, 1, ""], [405, 2], [406, 1, ""], [407, 1, ""], [408, 1, ""], [[409, 411], 2], [412, 1, ""], [413, 1, ""], [414, 2], [415, 1, ""], [416, 1, ""], [417, 2], [418, 1, ""], [419, 2], [420, 1, ""], [421, 2], [422, 1, ""], [423, 1, ""], [424, 2], [425, 1, ""], [[426, 427], 2], [428, 1, ""], [429, 2], [430, 1, ""], [431, 1, ""], [432, 2], [433, 1, ""], [434, 1, ""], [435, 1, ""], [436, 2], [437, 1, ""], [438, 2], [439, 1, ""], [440, 1, ""], [[441, 443], 2], [444, 1, ""], [[445, 451], 2], [[452, 454], 1, "d"], [[455, 457], 1, "lj"], [[458, 460], 1, "nj"], [461, 1, ""], [462, 2], [463, 1, ""], [464, 2], [465, 1, ""], [466, 2], [467, 1, ""], [468, 2], [469, 1, ""], [470, 2], [471, 1, ""], [472, 2], [473, 1, ""], [474, 2], [475, 1, ""], [[476, 477], 2], [478, 1, ""], [479, 2], [480, 1, ""], [481, 2], [482, 1, ""], [483, 2], [484, 1, ""], [485, 2], [486, 1, ""], [487, 2], [488, 1, ""], [489, 2], [490, 1, ""], [491, 2], [492, 1, ""], [493, 2], [494, 1, ""], [[495, 496], 2], [[497, 499], 1, "dz"], [500, 1, ""], [501, 2], [502, 1, ""], [503, 1, ""], [504, 1, ""], [505, 2], [506, 1, ""], [507, 2], [508, 1, ""], [509, 2], [510, 1, ""], [511, 2], [512, 1, ""], [513, 2], [514, 1, ""], [515, 2], [516, 1, ""], [517, 2], [518, 1, ""], [519, 2], [520, 1, ""], [521, 2], [522, 1, ""], [523, 2], [524, 1, ""], [525, 2], [526, 1, ""], [527, 2], [528, 1, ""], [529, 2], [530, 1, ""], [531, 2], [532, 1, ""], [533, 2], [534, 1, ""], [535, 2], [536, 1, ""], [537, 2], [538, 1, ""], [539, 2], [540, 1, ""], [541, 2], [542, 1, ""], [543, 2], [544, 1, ""], [545, 2], [546, 1, ""], [547, 2], [548, 1, ""], [549, 2], [550, 1, ""], [551, 2], [552, 1, ""], [553, 2], [554, 1, ""], [555, 2], [556, 1, ""], [557, 2], [558, 1, ""], [559, 2], [560, 1, ""], [561, 2], [562, 1, ""], [563, 2], [[564, 566], 2], [[567, 569], 2], [570, 1, ""], [571, 1, ""], [572, 2], [573, 1, ""], [574, 1, ""], [[575, 576], 2], [577, 1, ""], [578, 2], [579, 1, ""], [580, 1, ""], [581, 1, ""], [582, 1, ""], [583, 2], [584, 1, ""], [585, 2], [586, 1, ""], [587, 2], [588, 1, ""], [589, 2], [590, 1, ""], [591, 2], [[592, 680], 2], [[681, 685], 2], [[686, 687], 2], [688, 1, "h"], [689, 1, ""], [690, 1, "j"], [691, 1, "r"], [692, 1, ""], [693, 1, ""], [694, 1, ""], [695, 1, "w"], [696, 1, "y"], [[697, 705], 2], [[706, 709], 2], [[710, 721], 2], [[722, 727], 2], [728, 5, " "], [729, 5, " "], [730, 5, " "], [731, 5, " "], [732, 5, " "], [733, 5, " "], [734, 2], [735, 2], [736, 1, ""], [737, 1, "l"], [738, 1, "s"], [739, 1, "x"], [740, 1, ""], [[741, 745], 2], [[746, 747], 2], [748, 2], [749, 2], [750, 2], [[751, 767], 2], [[768, 831], 2], [832, 1, ""], [833, 1, ""], [834, 2], [835, 1, ""], [836, 1, ""], [837, 1, ""], [[838, 846], 2], [847, 7], [[848, 855], 2], [[856, 860], 2], [[861, 863], 2], [[864, 865], 2], [866, 2], [[867, 879], 2], [880, 1, ""], [881, 2], [882, 1, ""], [883, 2], [884, 1, ""], [885, 2], [886, 1, ""], [887, 2], [[888, 889], 3], [890, 5, " "], [[891, 893], 2], [894, 5, ";"], [895, 1, ""], [[896, 899], 3], [900, 5, " "], [901, 5, " "], [902, 1, ""], [903, 1, ""], [904, 1, ""], [905, 1, ""], [906, 1, ""], [907, 3], [908, 1, ""], [909, 3], [910, 1, ""], [911, 1, ""], [912, 2], [913, 1, ""], [914, 1, ""], [915, 1, ""], [916, 1, ""], [917, 1, ""], [918, 1, ""], [919, 1, ""], [920, 1, ""], [921, 1, ""], [922, 1, ""], [923, 1, ""], [924, 1, ""], [925, 1, ""], [926, 1, ""], [927, 1, ""], [928, 1, ""], [929, 1, ""], [930, 3], [931, 1, ""], [932, 1, ""], [933, 1, ""], [934, 1, ""], [935, 1, ""], [936, 1, ""], [937, 1, ""], [938, 1, ""], [939, 1, ""], [[940, 961], 2], [962, 6, ""], [[963, 974], 2], [975, 1, ""], [976, 1, ""], [977, 1, ""], [978, 1, ""], [979, 1, ""], [980, 1, ""], [981, 1, ""], [982, 1, ""], [983, 2], [984, 1, ""], [985, 2], [986, 1, ""], [987, 2], [988, 1, ""], [989, 2], [990, 1, ""], [991, 2], [992, 1, ""], [993, 2], [994, 1, ""], [995, 2], [996, 1, ""], [997, 2], [998, 1, ""], [999, 2], [1000, 1, ""], [1001, 2], [1002, 1, ""], [1003, 2], [1004, 1, ""], [1005, 2], [1006, 1, ""], [1007, 2], [1008, 1, ""], [1009, 1, ""], [1010, 1, ""], [1011, 2], [1012, 1, ""], [1013, 1, ""], [1014, 2], [1015, 1, ""], [1016, 2], [1017, 1, ""], [1018, 1, ""], [1019, 2], [1020, 2], [1021, 1, ""], [1022, 1, ""], [1023, 1, ""], [1024, 1, ""], [1025, 1, ""], [1026, 1, ""], [1027, 1, ""], [1028, 1, ""], [1029, 1, ""], [1030, 1, ""], [1031, 1, ""], [1032, 1, ""], [1033, 1, ""], [1034, 1, ""], [1035, 1, ""], [1036, 1, ""], [1037, 1, ""], [1038, 1, ""], [1039, 1, ""], [1040, 1, ""], [1041, 1, ""], [1042, 1, ""], [1043, 1, ""], [1044, 1, ""], [1045, 1, ""], [1046, 1, ""], [1047, 1, ""], [1048, 1, ""], [1049, 1, ""], [1050, 1, ""], [1051, 1, ""], [1052, 1, ""], [1053, 1, ""], [1054, 1, ""], [1055, 1, ""], [1056, 1, ""], [1057, 1, ""], [1058, 1, ""], [1059, 1, ""], [1060, 1, ""], [1061, 1, ""], [1062, 1, ""], [1063, 1, ""], [1064, 1, ""], [1065, 1, ""], [1066, 1, ""], [1067, 1, ""], [1068, 1, ""], [1069, 1, ""], [1070, 1, ""], [1071, 1, ""], [[1072, 1103], 2], [1104, 2], [[1105, 1116], 2], [1117, 2], [[1118, 1119], 2], [1120, 1, ""], [1121, 2], [1122, 1, ""], [1123, 2], [1124, 1, ""], [1125, 2], [1126, 1, ""], [1127, 2], [1128, 1, ""], [1129, 2], [1130, 1, ""], [1131, 2], [1132, 1, ""], [1133, 2], [1134, 1, ""], [1135, 2], [1136, 1, ""], [1137, 2], [1138, 1, ""], [1139, 2], [1140, 1, ""], [1141, 2], [1142, 1, ""], [1143, 2], [1144, 1, ""], [1145, 2], [1146, 1, ""], [1147, 2], [1148, 1, ""], [1149, 2], [1150, 1, ""], [1151, 2], [1152, 1, ""], [1153, 2], [1154, 2], [[1155, 1158], 2], [1159, 2], [[1160, 1161], 2], [1162, 1, ""], [1163, 2], [1164, 1, ""], [1165, 2], [1166, 1, ""], [1167, 2], [1168, 1, ""], [1169, 2], [1170, 1, ""], [1171, 2], [1172, 1, ""], [1173, 2], [1174, 1, ""], [1175, 2], [1176, 1, ""], [1177, 2], [1178, 1, ""], [1179, 2], [1180, 1, ""], [1181, 2], [1182, 1, ""], [1183, 2], [1184, 1, ""], [1185, 2], [1186, 1, ""], [1187, 2], [1188, 1, ""], [1189, 2], [1190, 1, ""], [1191, 2], [1192, 1, ""], [1193, 2], [1194, 1, ""], [1195, 2], [1196, 1, ""], [1197, 2], [1198, 1, ""], [1199, 2], [1200, 1, ""], [1201, 2], [1202, 1, ""], [1203, 2], [1204, 1, ""], [1205, 2], [1206, 1, ""], [1207, 2], [1208, 1, ""], [1209, 2], [1210, 1, ""], [1211, 2], [1212, 1, ""], [1213, 2], [1214, 1, ""], [1215, 2], [1216, 3], [1217, 1, ""], [1218, 2], [1219, 1, ""], [1220, 2], [1221, 1, ""], [1222, 2], [1223, 1, ""], [1224, 2], [1225, 1, ""], [1226, 2], [1227, 1, ""], [1228, 2], [1229, 1, ""], [1230, 2], [1231, 2], [1232, 1, ""], [1233, 2], [1234, 1, ""], [1235, 2], [1236, 1, ""], [1237, 2], [1238, 1, ""], [1239, 2], [1240, 1, ""], [1241, 2], [1242, 1, ""], [1243, 2], [1244, 1, ""], [1245, 2], [1246, 1, ""], [1247, 2], [1248, 1, ""], [1249, 2], [1250, 1, ""], [1251, 2], [1252, 1, ""], [1253, 2], [1254, 1, ""], [1255, 2], [1256, 1, ""], [1257, 2], [1258, 1, ""], [1259, 2], [1260, 1, ""], [1261, 2], [1262, 1, ""], [1263, 2], [1264, 1, ""], [1265, 2], [1266, 1, ""], [1267, 2], [1268, 1, ""], [1269, 2], [1270, 1, ""], [1271, 2], [1272, 1, ""], [1273, 2], [1274, 1, ""], [1275, 2], [1276, 1, ""], [1277, 2], [1278, 1, ""], [1279, 2], [1280, 1, ""], [1281, 2], [1282, 1, ""], [1283, 2], [1284, 1, ""], [1285, 2], [1286, 1, ""], [1287, 2], [1288, 1, ""], [1289, 2], [1290, 1, ""], [1291, 2], [1292, 1, ""], [1293, 2], [1294, 1, ""], [1295, 2], [1296, 1, ""], [1297, 2], [1298, 1, ""], [1299, 2], [1300, 1, ""], [1301, 2], [1302, 1, ""], [1303, 2], [1304, 1, ""], [1305, 2], [1306, 1, ""], [1307, 2], [1308, 1, ""], [1309, 2], [1310, 1, ""], [1311, 2], [1312, 1, ""], [1313, 2], [1314, 1, ""], [1315, 2], [1316, 1, ""], [1317, 2], [1318, 1, ""], [1319, 2], [1320, 1, ""], [1321, 2], [1322, 1, ""], [1323, 2], [1324, 1, ""], [1325, 2], [1326, 1, ""], [1327, 2], [1328, 3], [1329, 1, ""], [1330, 1, ""], [1331, 1, ""], [1332, 1, ""], [1333, 1, ""], [1334, 1, ""], [1335, 1, ""], [1336, 1, ""], [1337, 1, ""], [1338, 1, ""], [1339, 1, ""], [1340, 1, ""], [1341, 1, ""], [1342, 1, ""], [1343, 1, ""], [1344, 1, ""], [1345, 1, ""], [1346, 1, ""], [1347, 1, ""], [1348, 1, ""], [1349, 1, ""], [1350, 1, ""], [1351, 1, ""], [1352, 1, ""], [1353, 1, ""], [1354, 1, ""], [1355, 1, ""], [1356, 1, ""], [1357, 1, ""], [1358, 1, ""], [1359, 1, ""], [1360, 1, ""], [1361, 1, ""], [1362, 1, ""], [1363, 1, ""], [1364, 1, ""], [1365, 1, ""], [1366, 1, ""], [[1367, 1368], 3], [1369, 2], [[1370, 1375], 2], [1376, 2], [[1377, 1414], 2], [1415, 1, ""], [1416, 2], [1417, 2], [1418, 2], [[1419, 1420], 3], [[1421, 1422], 2], [1423, 2], [1424, 3], [[1425, 1441], 2], [1442, 2], [[1443, 1455], 2], [[1456, 1465], 2], [1466, 2], [[1467, 1469], 2], [1470, 2], [1471, 2], [1472, 2], [[1473, 1474], 2], [1475, 2], [1476, 2], [1477, 2], [1478, 2], [1479, 2], [[1480, 1487], 3], [[1488, 1514], 2], [[1515, 1518], 3], [1519, 2], [[1520, 1524], 2], [[1525, 1535], 3], [[1536, 1539], 3], [1540, 3], [1541, 3], [[1542, 1546], 2], [1547, 2], [1548, 2], [[1549, 1551], 2], [[1552, 1557], 2], [[1558, 1562], 2], [1563, 2], [1564, 3], [1565, 2], [1566, 2], [1567, 2], [1568, 2], [[1569, 1594], 2], [[1595, 1599], 2], [1600, 2], [[1601, 1618], 2], [[1619, 1621], 2], [[1622, 1624], 2], [[1625, 1630], 2], [1631, 2], [[1632, 1641], 2], [[1642, 1645], 2], [[1646, 1647], 2], [[1648, 1652], 2], [1653, 1, ""], [1654, 1, ""], [1655, 1, ""], [1656, 1, ""], [[1657, 1719], 2], [[1720, 1721], 2], [[1722, 1726], 2], [1727, 2], [[1728, 1742], 2], [1743, 2], [[1744, 1747], 2], [1748, 2], [[1749, 1756], 2], [1757, 3], [1758, 2], [[1759, 1768], 2], [1769, 2], [[1770, 1773], 2], [[1774, 1775], 2], [[1776, 1785], 2], [[1786, 1790], 2], [1791, 2], [[1792, 1805], 2], [1806, 3], [1807, 3], [[1808, 1836], 2], [[1837, 1839], 2], [[1840, 1866], 2], [[1867, 1868], 3], [[1869, 1871], 2], [[1872, 1901], 2], [[1902, 1919], 2], [[1920, 1968], 2], [1969, 2], [[1970, 1983], 3], [[1984, 2037], 2], [[2038, 2042], 2], [[2043, 2044], 3], [2045, 2], [[2046, 2047], 2], [[2048, 2093], 2], [[2094, 2095], 3], [[2096, 2110], 2], [2111, 3], [[2112, 2139], 2], [[2140, 2141], 3], [2142, 2], [2143, 3], [[2144, 2154], 2], [[2155, 2159], 3], [[2160, 2183], 2], [2184, 2], [[2185, 2190], 2], [2191, 3], [[2192, 2193], 3], [[2194, 2199], 3], [[2200, 2207], 2], [2208, 2], [2209, 2], [[2210, 2220], 2], [[2221, 2226], 2], [[2227, 2228], 2], [2229, 2], [[2230, 2237], 2], [[2238, 2247], 2], [[2248, 2258], 2], [2259, 2], [[2260, 2273], 2], [2274, 3], [2275, 2], [[2276, 2302], 2], [2303, 2], [2304, 2], [[2305, 2307], 2], [2308, 2], [[2309, 2361], 2], [[2362, 2363], 2], [[2364, 2381], 2], [2382, 2], [2383, 2], [[2384, 2388], 2], [2389, 2], [[2390, 2391], 2], [2392, 1, ""], [2393, 1, ""], [2394, 1, ""], [2395, 1, ""], [2396, 1, ""], [2397, 1, ""], [2398, 1, ""], [2399, 1, ""], [[2400, 2403], 2], [[2404, 2405], 2], [[2406, 2415], 2], [2416, 2], [[2417, 2418], 2], [[2419, 2423], 2], [2424, 2], [[2425, 2426], 2], [[2427, 2428], 2], [2429, 2], [[2430, 2431], 2], [2432, 2], [[2433, 2435], 2], [2436, 3], [[2437, 2444], 2], [[2445, 2446], 3], [[2447, 2448], 2], [[2449, 2450], 3], [[2451, 2472], 2], [2473, 3], [[2474, 2480], 2], [2481, 3], [2482, 2], [[2483, 2485], 3], [[2486, 2489], 2], [[2490, 2491], 3], [2492, 2], [2493, 2], [[2494, 2500], 2], [[2501, 2502], 3], [[2503, 2504], 2], [[2505, 2506], 3], [[2507, 2509], 2], [2510, 2], [[2511, 2518], 3], [2519, 2], [[2520, 2523], 3], [2524, 1, ""], [2525, 1, ""], [2526, 3], [2527, 1, ""], [[2528, 2531], 2], [[2532, 2533], 3], [[2534, 2545], 2], [[2546, 2554], 2], [2555, 2], [2556, 2], [2557, 2], [2558, 2], [[2559, 2560], 3], [2561, 2], [2562, 2], [2563, 2], [2564, 3], [[2565, 2570], 2], [[2571, 2574], 3], [[2575, 2576], 2], [[2577, 2578], 3], [[2579, 2600], 2], [2601, 3], [[2602, 2608], 2], [2609, 3], [2610, 2], [2611, 1, ""], [2612, 3], [2613, 2], [2614, 1, ""], [2615, 3], [[2616, 2617], 2], [[2618, 2619], 3], [2620, 2], [2621, 3], [[2622, 2626], 2], [[2627, 2630], 3], [[2631, 2632], 2], [[2633, 2634], 3], [[2635, 2637], 2], [[2638, 2640], 3], [2641, 2], [[2642, 2648], 3], [2649, 1, ""], [2650, 1, ""], [2651, 1, ""], [2652, 2], [2653, 3], [2654, 1, ""], [[2655, 2661], 3], [[2662, 2676], 2], [2677, 2], [2678, 2], [[2679, 2688], 3], [[2689, 2691], 2], [2692, 3], [[2693, 2699], 2], [2700, 2], [2701, 2], [2702, 3], [[2703, 2705], 2], [2706, 3], [[2707, 2728], 2], [2729, 3], [[2730, 2736], 2], [2737, 3], [[2738, 2739], 2], [2740, 3], [[2741, 2745], 2], [[2746, 2747], 3], [[2748, 2757], 2], [2758, 3], [[2759, 2761], 2], [2762, 3], [[2763, 2765], 2], [[2766, 2767], 3], [2768, 2], [[2769, 2783], 3], [2784, 2], [[2785, 2787], 2], [[2788, 2789], 3], [[2790, 2799], 2], [2800, 2], [2801, 2], [[2802, 2808], 3], [2809, 2], [[2810, 2815], 2], [2816, 3], [[2817, 2819], 2], [2820, 3], [[2821, 2828], 2], [[2829, 2830], 3], [[2831, 2832], 2], [[2833, 2834], 3], [[2835, 2856], 2], [2857, 3], [[2858, 2864], 2], [2865, 3], [[2866, 2867], 2], [2868, 3], [2869, 2], [[2870, 2873], 2], [[2874, 2875], 3], [[2876, 2883], 2], [2884, 2], [[2885, 2886], 3], [[2887, 2888], 2], [[2889, 2890], 3], [[2891, 2893], 2], [[2894, 2900], 3], [2901, 2], [[2902, 2903], 2], [[2904, 2907], 3], [2908, 1, ""], [2909, 1, ""], [2910, 3], [[2911, 2913], 2], [[2914, 2915], 2], [[2916, 2917], 3], [[2918, 2927], 2], [2928, 2], [2929, 2], [[2930, 2935], 2], [[2936, 2945], 3], [[2946, 2947], 2], [2948, 3], [[2949, 2954], 2], [[2955, 2957], 3], [[2958, 2960], 2], [2961, 3], [[2962, 2965], 2], [[2966, 2968], 3], [[2969, 2970], 2], [2971, 3], [2972, 2], [2973, 3], [[2974, 2975], 2], [[2976, 2978], 3], [[2979, 2980], 2], [[2981, 2983], 3], [[2984, 2986], 2], [[2987, 2989], 3], [[2990, 2997], 2], [2998, 2], [[2999, 3001], 2], [[3002, 3005], 3], [[3006, 3010], 2], [[3011, 3013], 3], [[3014, 3016], 2], [3017, 3], [[3018, 3021], 2], [[3022, 3023], 3], [3024, 2], [[3025, 3030], 3], [3031, 2], [[3032, 3045], 3], [3046, 2], [[3047, 3055], 2], [[3056, 3058], 2], [[3059, 3066], 2], [[3067, 3071], 3], [3072, 2], [[3073, 3075], 2], [3076, 2], [[3077, 3084], 2], [3085, 3], [[3086, 3088], 2], [3089, 3], [[3090, 3112], 2], [3113, 3], [[3114, 3123], 2], [3124, 2], [[3125, 3129], 2], [[3130, 3131], 3], [3132, 2], [3133, 2], [[3134, 3140], 2], [3141, 3], [[3142, 3144], 2], [3145, 3], [[3146, 3149], 2], [[3150, 3156], 3], [[3157, 3158], 2], [3159, 3], [[3160, 3161], 2], [3162, 2], [[3163, 3164], 3], [3165, 2], [[3166, 3167], 3], [[3168, 3169], 2], [[3170, 3171], 2], [[3172, 3173], 3], [[3174, 3183], 2], [[3184, 3190], 3], [3191, 2], [[3192, 3199], 2], [3200, 2], [3201, 2], [[3202, 3203], 2], [3204, 2], [[3205, 3212], 2], [3213, 3], [[3214, 3216], 2], [3217, 3], [[3218, 3240], 2], [3241, 3], [[3242, 3251], 2], [3252, 3], [[3253, 3257], 2], [[3258, 3259], 3], [[3260, 3261], 2], [[3262, 3268], 2], [3269, 3], [[3270, 3272], 2], [3273, 3], [[3274, 3277], 2], [[3278, 3284], 3], [[3285, 3286], 2], [[3287, 3292], 3], [3293, 2], [3294, 2], [3295, 3], [[3296, 3297], 2], [[3298, 3299], 2], [[3300, 3301], 3], [[3302, 3311], 2], [3312, 3], [[3313, 3314], 2], [3315, 2], [[3316, 3327], 3], [3328, 2], [3329, 2], [[3330, 3331], 2], [3332, 2], [[3333, 3340], 2], [3341, 3], [[3342, 3344], 2], [3345, 3], [[3346, 3368], 2], [3369, 2], [[3370, 3385], 2], [3386, 2], [[3387, 3388], 2], [3389, 2], [[3390, 3395], 2], [3396, 2], [3397, 3], [[3398, 3400], 2], [3401, 3], [[3402, 3405], 2], [3406, 2], [3407, 2], [[3408, 3411], 3], [[3412, 3414], 2], [3415, 2], [[3416, 3422], 2], [3423, 2], [[3424, 3425], 2], [[3426, 3427], 2], [[3428, 3429], 3], [[3430, 3439], 2], [[3440, 3445], 2], [[3446, 3448], 2], [3449, 2], [[3450, 3455], 2], [3456, 3], [3457, 2], [[3458, 3459], 2], [3460, 3], [[3461, 3478], 2], [[3479, 3481], 3], [[3482, 3505], 2], [3506, 3], [[3507, 3515], 2], [3516, 3], [3517, 2], [[3518, 3519], 3], [[3520, 3526], 2], [[3527, 3529], 3], [3530, 2], [[3531, 3534], 3], [[3535, 3540], 2], [3541, 3], [3542, 2], [3543, 3], [[3544, 3551], 2], [[3552, 3557], 3], [[3558, 3567], 2], [[3568, 3569], 3], [[3570, 3571], 2], [3572, 2], [[3573, 3584], 3], [[3585, 3634], 2], [3635, 1, ""], [[3636, 3642], 2], [[3643, 3646], 3], [3647, 2], [[3648, 3662], 2], [3663, 2], [[3664, 3673], 2], [[3674, 3675], 2], [[3676, 3712], 3], [[3713, 3714], 2], [3715, 3], [3716, 2], [3717, 3], [3718, 2], [[3719, 3720], 2], [3721, 2], [3722, 2], [3723, 3], [3724, 2], [3725, 2], [[3726, 3731], 2], [[3732, 3735], 2], [3736, 2], [[3737, 3743], 2], [3744, 2], [[3745, 3747], 2], [3748, 3], [3749, 2], [3750, 3], [3751, 2], [[3752, 3753], 2], [[3754, 3755], 2], [3756, 2], [[3757, 3762], 2], [3763, 1, ""], [[3764, 3769], 2], [3770, 2], [[3771, 3773], 2], [[3774, 3775], 3], [[3776, 3780], 2], [3781, 3], [3782, 2], [3783, 3], [[3784, 3789], 2], [3790, 2], [3791, 3], [[3792, 3801], 2], [[3802, 3803], 3], [3804, 1, ""], [3805, 1, ""], [[3806, 3807], 2], [[3808, 3839], 3], [3840, 2], [[3841, 3850], 2], [3851, 2], [3852, 1, ""], [[3853, 3863], 2], [[3864, 3865], 2], [[3866, 3871], 2], [[3872, 3881], 2], [[3882, 3892], 2], [3893, 2], [3894, 2], [3895, 2], [3896, 2], [3897, 2], [[3898, 3901], 2], [[3902, 3906], 2], [3907, 1, ""], [[3908, 3911], 2], [3912, 3], [[3913, 3916], 2], [3917, 1, ""], [[3918, 3921], 2], [3922, 1, ""], [[3923, 3926], 2], [3927, 1, ""], [[3928, 3931], 2], [3932, 1, ""], [[3933, 3944], 2], [3945, 1, ""], [3946, 2], [[3947, 3948], 2], [[3949, 3952], 3], [[3953, 3954], 2], [3955, 1, ""], [3956, 2], [3957, 1, ""], [3958, 1, ""], [3959, 1, ""], [3960, 1, ""], [3961, 1, ""], [[3962, 3968], 2], [3969, 1, ""], [[3970, 3972], 2], [3973, 2], [[3974, 3979], 2], [[3980, 3983], 2], [[3984, 3986], 2], [3987, 1, ""], [[3988, 3989], 2], [3990, 2], [3991, 2], [3992, 3], [[3993, 3996], 2], [3997, 1, ""], [[3998, 4001], 2], [4002, 1, ""], [[4003, 4006], 2], [4007, 1, ""], [[4008, 4011], 2], [4012, 1, ""], [4013, 2], [[4014, 4016], 2], [[4017, 4023], 2], [4024, 2], [4025, 1, ""], [[4026, 4028], 2], [4029, 3], [[4030, 4037], 2], [4038, 2], [[4039, 4044], 2], [4045, 3], [4046, 2], [4047, 2], [[4048, 4049], 2], [[4050, 4052], 2], [[4053, 4056], 2], [[4057, 4058], 2], [[4059, 4095], 3], [[4096, 4129], 2], [4130, 2], [[4131, 4135], 2], [4136, 2], [[4137, 4138], 2], [4139, 2], [[4140, 4146], 2], [[4147, 4149], 2], [[4150, 4153], 2], [[4154, 4159], 2], [[4160, 4169], 2], [[4170, 4175], 2], [[4176, 4185], 2], [[4186, 4249], 2], [[4250, 4253], 2], [[4254, 4255], 2], [[4256, 4293], 3], [4294, 3], [4295, 1, ""], [[4296, 4300], 3], [4301, 1, ""], [[4302, 4303], 3], [[4304, 4342], 2], [[4343, 4344], 2], [[4345, 4346], 2], [4347, 2], [4348, 1, ""], [[4349, 4351], 2], [[4352, 4441], 2], [[4442, 4446], 2], [[4447, 4448], 3], [[4449, 4514], 2], [[4515, 4519], 2], [[4520, 4601], 2], [[4602, 4607], 2], [[4608, 4614], 2], [4615, 2], [[4616, 4678], 2], [4679, 2], [4680, 2], [4681, 3], [[4682, 4685], 2], [[4686, 4687], 3], [[4688, 4694], 2], [4695, 3], [4696, 2], [4697, 3], [[4698, 4701], 2], [[4702, 4703], 3], [[4704, 4742], 2], [4743, 2], [4744, 2], [4745, 3], [[4746, 4749], 2], [[4750, 4751], 3], [[4752, 4782], 2], [4783, 2], [4784, 2], [4785, 3], [[4786, 4789], 2], [[4790, 4791], 3], [[4792, 4798], 2], [4799, 3], [4800, 2], [4801, 3], [[4802, 4805], 2], [[4806, 4807], 3], [[4808, 4814], 2], [4815, 2], [[4816, 4822], 2], [4823, 3], [[4824, 4846], 2], [4847, 2], [[4848, 4878], 2], [4879, 2], [4880, 2], [4881, 3], [[4882, 4885], 2], [[4886, 4887], 3], [[4888, 4894], 2], [4895, 2], [[4896, 4934], 2], [4935, 2], [[4936, 4954], 2], [[4955, 4956], 3], [[4957, 4958], 2], [4959, 2], [4960, 2], [[4961, 4988], 2], [[4989, 4991], 3], [[4992, 5007], 2], [[5008, 5017], 2], [[5018, 5023], 3], [[5024, 5108], 2], [5109, 2], [[5110, 5111], 3], [5112, 1, ""], [5113, 1, ""], [5114, 1, ""], [5115, 1, ""], [5116, 1, ""], [5117, 1, ""], [[5118, 5119], 3], [5120, 2], [[5121, 5740], 2], [[5741, 5742], 2], [[5743, 5750], 2], [[5751, 5759], 2], [5760, 3], [[5761, 5786], 2], [[5787, 5788], 2], [[5789, 5791], 3], [[5792, 5866], 2], [[5867, 5872], 2], [[5873, 5880], 2], [[5881, 5887], 3], [[5888, 5900], 2], [5901, 2], [[5902, 5908], 2], [5909, 2], [[5910, 5918], 3], [5919, 2], [[5920, 5940], 2], [[5941, 5942], 2], [[5943, 5951], 3], [[5952, 5971], 2], [[5972, 5983], 3], [[5984, 5996], 2], [5997, 3], [[5998, 6000], 2], [6001, 3], [[6002, 6003], 2], [[6004, 6015], 3], [[6016, 6067], 2], [[6068, 6069], 3], [[6070, 6099], 2], [[6100, 6102], 2], [6103, 2], [[6104, 6107], 2], [6108, 2], [6109, 2], [[6110, 6111], 3], [[6112, 6121], 2], [[6122, 6127], 3], [[6128, 6137], 2], [[6138, 6143], 3], [[6144, 6149], 2], [6150, 3], [[6151, 6154], 2], [[6155, 6157], 7], [6158, 3], [6159, 7], [[6160, 6169], 2], [[6170, 6175], 3], [[6176, 6263], 2], [6264, 2], [[6265, 6271], 3], [[6272, 6313], 2], [6314, 2], [[6315, 6319], 3], [[6320, 6389], 2], [[6390, 6399], 3], [[6400, 6428], 2], [[6429, 6430], 2], [6431, 3], [[6432, 6443], 2], [[6444, 6447], 3], [[6448, 6459], 2], [[6460, 6463], 3], [6464, 2], [[6465, 6467], 3], [[6468, 6469], 2], [[6470, 6509], 2], [[6510, 6511], 3], [[6512, 6516], 2], [[6517, 6527], 3], [[6528, 6569], 2], [[6570, 6571], 2], [[6572, 6575], 3], [[6576, 6601], 2], [[6602, 6607], 3], [[6608, 6617], 2], [6618, 2], [[6619, 6621], 3], [[6622, 6623], 2], [[6624, 6655], 2], [[6656, 6683], 2], [[6684, 6685], 3], [[6686, 6687], 2], [[6688, 6750], 2], [6751, 3], [[6752, 6780], 2], [[6781, 6782], 3], [[6783, 6793], 2], [[6794, 6799], 3], [[6800, 6809], 2], [[6810, 6815], 3], [[6816, 6822], 2], [6823, 2], [[6824, 6829], 2], [[6830, 6831], 3], [[6832, 6845], 2], [6846, 2], [[6847, 6848], 2], [[6849, 6862], 2], [[6863, 6911], 3], [[6912, 6987], 2], [6988, 2], [[6989, 6991], 3], [[6992, 7001], 2], [[7002, 7018], 2], [[7019, 7027], 2], [[7028, 7036], 2], [[7037, 7038], 2], [7039, 3], [[7040, 7082], 2], [[7083, 7085], 2], [[7086, 7097], 2], [[7098, 7103], 2], [[7104, 7155], 2], [[7156, 7163], 3], [[7164, 7167], 2], [[7168, 7223], 2], [[7224, 7226], 3], [[7227, 7231], 2], [[7232, 7241], 2], [[7242, 7244], 3], [[7245, 7293], 2], [[7294, 7295], 2], [7296, 1, ""], [7297, 1, ""], [7298, 1, ""], [7299, 1, ""], [[7300, 7301], 1, ""], [7302, 1, ""], [7303, 1, ""], [7304, 1, ""], [[7305, 7311], 3], [7312, 1, ""], [7313, 1, ""], [7314, 1, ""], [7315, 1, ""], [7316, 1, ""], [7317, 1, ""], [7318, 1, ""], [7319, 1, ""], [7320, 1, ""], [7321, 1, ""], [7322, 1, ""], [7323, 1, ""], [7324, 1, ""], [7325, 1, ""], [7326, 1, ""], [7327, 1, ""], [7328, 1, ""], [7329, 1, ""], [7330, 1, ""], [7331, 1, ""], [7332, 1, ""], [7333, 1, ""], [7334, 1, ""], [7335, 1, ""], [7336, 1, ""], [7337, 1, ""], [7338, 1, ""], [7339, 1, ""], [7340, 1, ""], [7341, 1, ""], [7342, 1, ""], [7343, 1, ""], [7344, 1, ""], [7345, 1, ""], [7346, 1, ""], [7347, 1, ""], [7348, 1, ""], [7349, 1, ""], [7350, 1, ""], [7351, 1, ""], [7352, 1, ""], [7353, 1, ""], [7354, 1, ""], [[7355, 7356], 3], [7357, 1, ""], [7358, 1, ""], [7359, 1, ""], [[7360, 7367], 2], [[7368, 7375], 3], [[7376, 7378], 2], [7379, 2], [[7380, 7410], 2], [[7411, 7414], 2], [7415, 2], [[7416, 7417], 2], [7418, 2], [[7419, 7423], 3], [[7424, 7467], 2], [7468, 1, "a"], [7469, 1, ""], [7470, 1, "b"], [7471, 2], [7472, 1, "d"], [7473, 1, "e"], [7474, 1, ""], [7475, 1, "g"], [7476, 1, "h"], [7477, 1, "i"], [7478, 1, "j"], [7479, 1, "k"], [7480, 1, "l"], [7481, 1, "m"], [7482, 1, "n"], [7483, 2], [7484, 1, "o"], [7485, 1, ""], [7486, 1, "p"], [7487, 1, "r"], [7488, 1, "t"], [7489, 1, "u"], [7490, 1, "w"], [7491, 1, "a"], [7492, 1, ""], [7493, 1, ""], [7494, 1, ""], [7495, 1, "b"], [7496, 1, "d"], [7497, 1, "e"], [7498, 1, ""], [7499, 1, ""], [7500, 1, ""], [7501, 1, "g"], [7502, 2], [7503, 1, "k"], [7504, 1, "m"], [7505, 1, ""], [7506, 1, "o"], [7507, 1, ""], [7508, 1, ""], [7509, 1, ""], [7510, 1, "p"], [7511, 1, "t"], [7512, 1, "u"], [7513, 1, ""], [7514, 1, ""], [7515, 1, "v"], [7516, 1, ""], [7517, 1, ""], [7518, 1, ""], [7519, 1, ""], [7520, 1, ""], [7521, 1, ""], [7522, 1, "i"], [7523, 1, "r"], [7524, 1, "u"], [7525, 1, "v"], [7526, 1, ""], [7527, 1, ""], [7528, 1, ""], [7529, 1, ""], [7530, 1, ""], [7531, 2], [[7532, 7543], 2], [7544, 1, ""], [[7545, 7578], 2], [7579, 1, ""], [7580, 1, "c"], [7581, 1, ""], [7582, 1, ""], [7583, 1, ""], [7584, 1, "f"], [7585, 1, ""], [7586, 1, ""], [7587, 1, ""], [7588, 1, ""], [7589, 1, ""], [7590, 1, ""], [7591, 1, ""], [7592, 1, ""], [7593, 1, ""], [7594, 1, ""], [7595, 1, ""], [7596, 1, ""], [7597, 1, ""], [7598, 1, ""], [7599, 1, ""], [7600, 1, ""], [7601, 1, ""], [7602, 1, ""], [7603, 1, ""], [7604, 1, ""], [7605, 1, ""], [7606, 1, ""], [7607, 1, ""], [7608, 1, ""], [7609, 1, ""], [7610, 1, ""], [7611, 1, "z"], [7612, 1, ""], [7613, 1, ""], [7614, 1, ""], [7615, 1, ""], [[7616, 7619], 2], [[7620, 7626], 2], [[7627, 7654], 2], [[7655, 7669], 2], [[7670, 7673], 2], [7674, 2], [7675, 2], [7676, 2], [7677, 2], [[7678, 7679], 2], [7680, 1, ""], [7681, 2], [7682, 1, ""], [7683, 2], [7684, 1, ""], [7685, 2], [7686, 1, ""], [7687, 2], [7688, 1, ""], [7689, 2], [7690, 1, ""], [7691, 2], [7692, 1, ""], [7693, 2], [7694, 1, ""], [7695, 2], [7696, 1, ""], [7697, 2], [7698, 1, ""], [7699, 2], [7700, 1, ""], [7701, 2], [7702, 1, ""], [7703, 2], [7704, 1, ""], [7705, 2], [7706, 1, ""], [7707, 2], [7708, 1, ""], [7709, 2], [7710, 1, ""], [7711, 2], [7712, 1, ""], [7713, 2], [7714, 1, ""], [7715, 2], [7716, 1, ""], [7717, 2], [7718, 1, ""], [7719, 2], [7720, 1, ""], [7721, 2], [7722, 1, ""], [7723, 2], [7724, 1, ""], [7725, 2], [7726, 1, ""], [7727, 2], [7728, 1, ""], [7729, 2], [7730, 1, ""], [7731, 2], [7732, 1, ""], [7733, 2], [7734, 1, ""], [7735, 2], [7736, 1, ""], [7737, 2], [7738, 1, ""], [7739, 2], [7740, 1, ""], [7741, 2], [7742, 1, ""], [7743, 2], [7744, 1, ""], [7745, 2], [7746, 1, ""], [7747, 2], [7748, 1, ""], [7749, 2], [7750, 1, ""], [7751, 2], [7752, 1, ""], [7753, 2], [7754, 1, ""], [7755, 2], [7756, 1, ""], [7757, 2], [7758, 1, ""], [7759, 2], [7760, 1, ""], [7761, 2], [7762, 1, ""], [7763, 2], [7764, 1, ""], [7765, 2], [7766, 1, ""], [7767, 2], [7768, 1, ""], [7769, 2], [7770, 1, ""], [7771, 2], [7772, 1, ""], [7773, 2], [7774, 1, ""], [7775, 2], [7776, 1, ""], [7777, 2], [7778, 1, ""], [7779, 2], [7780, 1, ""], [7781, 2], [7782, 1, ""], [7783, 2], [7784, 1, ""], [7785, 2], [7786, 1, ""], [7787, 2], [7788, 1, ""], [7789, 2], [7790, 1, ""], [7791, 2], [7792, 1, ""], [7793, 2], [7794, 1, ""], [7795, 2], [7796, 1, ""], [7797, 2], [7798, 1, ""], [7799, 2], [7800, 1, ""], [7801, 2], [7802, 1, ""], [7803, 2], [7804, 1, ""], [7805, 2], [7806, 1, ""], [7807, 2], [7808, 1, ""], [7809, 2], [7810, 1, ""], [7811, 2], [7812, 1, ""], [7813, 2], [7814, 1, ""], [7815, 2], [7816, 1, ""], [7817, 2], [7818, 1, ""], [7819, 2], [7820, 1, ""], [7821, 2], [7822, 1, ""], [7823, 2], [7824, 1, ""], [7825, 2], [7826, 1, ""], [7827, 2], [7828, 1, ""], [[7829, 7833], 2], [7834, 1, "a"], [7835, 1, ""], [[7836, 7837], 2], [7838, 1, ""], [7839, 2], [7840, 1, ""], [7841, 2], [7842, 1, ""], [7843, 2], [7844, 1, ""], [7845, 2], [7846, 1, ""], [7847, 2], [7848, 1, ""], [7849, 2], [7850, 1, ""], [7851, 2], [7852, 1, ""], [7853, 2], [7854, 1, ""], [7855, 2], [7856, 1, ""], [7857, 2], [7858, 1, ""], [7859, 2], [7860, 1, ""], [7861, 2], [7862, 1, ""], [7863, 2], [7864, 1, ""], [7865, 2], [7866, 1, ""], [7867, 2], [7868, 1, ""], [7869, 2], [7870, 1, ""], [7871, 2], [7872, 1, ""], [7873, 2], [7874, 1, ""], [7875, 2], [7876, 1, ""], [7877, 2], [7878, 1, ""], [7879, 2], [7880, 1, ""], [7881, 2], [7882, 1, ""], [7883, 2], [7884, 1, ""], [7885, 2], [7886, 1, ""], [7887, 2], [7888, 1, ""], [7889, 2], [7890, 1, ""], [7891, 2], [7892, 1, ""], [7893, 2], [7894, 1, ""], [7895, 2], [7896, 1, ""], [7897, 2], [7898, 1, ""], [7899, 2], [7900, 1, ""], [7901, 2], [7902, 1, ""], [7903, 2], [7904, 1, ""], [7905, 2], [7906, 1, ""], [7907, 2], [7908, 1, ""], [7909, 2], [7910, 1, ""], [7911, 2], [7912, 1, ""], [7913, 2], [7914, 1, ""], [7915, 2], [7916, 1, ""], [7917, 2], [7918, 1, ""], [7919, 2], [7920, 1, ""], [7921, 2], [7922, 1, ""], [7923, 2], [7924, 1, ""], [7925, 2], [7926, 1, ""], [7927, 2], [7928, 1, ""], [7929, 2], [7930, 1, ""], [7931, 2], [7932, 1, ""], [7933, 2], [7934, 1, ""], [7935, 2], [[7936, 7943], 2], [7944, 1, ""], [7945, 1, ""], [7946, 1, ""], [7947, 1, ""], [7948, 1, ""], [7949, 1, ""], [7950, 1, ""], [7951, 1, ""], [[7952, 7957], 2], [[7958, 7959], 3], [7960, 1, ""], [7961, 1, ""], [7962, 1, ""], [7963, 1, ""], [7964, 1, ""], [7965, 1, ""], [[7966, 7967], 3], [[7968, 7975], 2], [7976, 1, ""], [7977, 1, ""], [7978, 1, ""], [7979, 1, ""], [7980, 1, ""], [7981, 1, ""], [7982, 1, ""], [7983, 1, ""], [[7984, 7991], 2], [7992, 1, ""], [7993, 1, ""], [7994, 1, ""], [7995, 1, ""], [7996, 1, ""], [7997, 1, ""], [7998, 1, ""], [7999, 1, ""], [[8000, 8005], 2], [[8006, 8007], 3], [8008, 1, ""], [8009, 1, ""], [8010, 1, ""], [8011, 1, ""], [8012, 1, ""], [8013, 1, ""], [[8014, 8015], 3], [[8016, 8023], 2], [8024, 3], [8025, 1, ""], [8026, 3], [8027, 1, ""], [8028, 3], [8029, 1, ""], [8030, 3], [8031, 1, ""], [[8032, 8039], 2], [8040, 1, ""], [8041, 1, ""], [8042, 1, ""], [8043, 1, ""], [8044, 1, ""], [8045, 1, ""], [8046, 1, ""], [8047, 1, ""], [8048, 2], [8049, 1, ""], [8050, 2], [8051, 1, ""], [8052, 2], [8053, 1, ""], [8054, 2], [8055, 1, ""], [8056, 2], [8057, 1, ""], [8058, 2], [8059, 1, ""], [8060, 2], [8061, 1, ""], [[8062, 8063], 3], [8064, 1, ""], [8065, 1, ""], [8066, 1, ""], [8067, 1, ""], [8068, 1, ""], [8069, 1, ""], [8070, 1, ""], [8071, 1, ""], [8072, 1, ""], [8073, 1, ""], [8074, 1, ""], [8075, 1, ""], [8076, 1, ""], [8077, 1, ""], [8078, 1, ""], [8079, 1, ""], [8080, 1, ""], [8081, 1, ""], [8082, 1, ""], [8083, 1, ""], [8084, 1, ""], [8085, 1, ""], [8086, 1, ""], [8087, 1, ""], [8088, 1, ""], [8089, 1, ""], [8090, 1, ""], [8091, 1, ""], [8092, 1, ""], [8093, 1, ""], [8094, 1, ""], [8095, 1, ""], [8096, 1, ""], [8097, 1, ""], [8098, 1, ""], [8099, 1, ""], [8100, 1, ""], [8101, 1, ""], [8102, 1, ""], [8103, 1, ""], [8104, 1, ""], [8105, 1, ""], [8106, 1, ""], [8107, 1, ""], [8108, 1, ""], [8109, 1, ""], [8110, 1, ""], [8111, 1, ""], [[8112, 8113], 2], [8114, 1, ""], [8115, 1, ""], [8116, 1, ""], [8117, 3], [8118, 2], [8119, 1, ""], [8120, 1, ""], [8121, 1, ""], [8122, 1, ""], [8123, 1, ""], [8124, 1, ""], [8125, 5, " "], [8126, 1, ""], [8127, 5, " "], [8128, 5, " "], [8129, 5, " "], [8130, 1, ""], [8131, 1, ""], [8132, 1, ""], [8133, 3], [8134, 2], [8135, 1, ""], [8136, 1, ""], [8137, 1, ""], [8138, 1, ""], [8139, 1, ""], [8140, 1, ""], [8141, 5, " "], [8142, 5, " "], [8143, 5, " "], [[8144, 8146], 2], [8147, 1, ""], [[8148, 8149], 3], [[8150, 8151], 2], [8152, 1, ""], [8153, 1, ""], [8154, 1, ""], [8155, 1, ""], [8156, 3], [8157, 5, " "], [8158, 5, " "], [8159, 5, " "], [[8160, 8162], 2], [8163, 1, ""], [[8164, 8167], 2], [8168, 1, ""], [8169, 1, ""], [8170, 1, ""], [8171, 1, ""], [8172, 1, ""], [8173, 5, " "], [8174, 5, " "], [8175, 5, "`"], [[8176, 8177], 3], [8178, 1, ""], [8179, 1, ""], [8180, 1, ""], [8181, 3], [8182, 2], [8183, 1, ""], [8184, 1, ""], [8185, 1, ""], [8186, 1, ""], [8187, 1, ""], [8188, 1, ""], [8189, 5, " "], [8190, 5, " "], [8191, 3], [[8192, 8202], 5, " "], [8203, 7], [[8204, 8205], 6, ""], [[8206, 8207], 3], [8208, 2], [8209, 1, ""], [[8210, 8214], 2], [8215, 5, " "], [[8216, 8227], 2], [[8228, 8230], 3], [8231, 2], [[8232, 8238], 3], [8239, 5, " "], [[8240, 8242], 2], [8243, 1, ""], [8244, 1, ""], [8245, 2], [8246, 1, ""], [8247, 1, ""], [[8248, 8251], 2], [8252, 5, "!!"], [8253, 2], [8254, 5, " "], [[8255, 8262], 2], [8263, 5, "??"], [8264, 5, "?!"], [8265, 5, "!?"], [[8266, 8269], 2], [[8270, 8274], 2], [[8275, 8276], 2], [[8277, 8278], 2], [8279, 1, ""], [[8280, 8286], 2], [8287, 5, " "], [8288, 7], [[8289, 8291], 3], [8292, 7], [8293, 3], [[8294, 8297], 3], [[8298, 8303], 3], [8304, 1, "0"], [8305, 1, "i"], [[8306, 8307], 3], [8308, 1, "4"], [8309, 1, "5"], [8310, 1, "6"], [8311, 1, "7"], [8312, 1, "8"], [8313, 1, "9"], [8314, 5, "+"], [8315, 1, ""], [8316, 5, "="], [8317, 5, "("], [8318, 5, ")"], [8319, 1, "n"], [8320, 1, "0"], [8321, 1, "1"], [8322, 1, "2"], [8323, 1, "3"], [8324, 1, "4"], [8325, 1, "5"], [8326, 1, "6"], [8327, 1, "7"], [8328, 1, "8"], [8329, 1, "9"], [8330, 5, "+"], [8331, 1, ""], [8332, 5, "="], [8333, 5, "("], [8334, 5, ")"], [8335, 3], [8336, 1, "a"], [8337, 1, "e"], [8338, 1, "o"], [8339, 1, "x"], [8340, 1, ""], [8341, 1, "h"], [8342, 1, "k"], [8343, 1, "l"], [8344, 1, "m"], [8345, 1, "n"], [8346, 1, "p"], [8347, 1, "s"], [8348, 1, "t"], [[8349, 8351], 3], [[8352, 8359], 2], [8360, 1, "rs"], [[8361, 8362], 2], [8363, 2], [8364, 2], [[8365, 8367], 2], [[8368, 8369], 2], [[8370, 8373], 2], [[8374, 8376], 2], [8377, 2], [8378, 2], [[8379, 8381], 2], [8382, 2], [8383, 2], [8384, 2], [[8385, 8399], 3], [[8400, 8417], 2], [[8418, 8419], 2], [[8420, 8426], 2], [8427, 2], [[8428, 8431], 2], [8432, 2], [[8433, 8447], 3], [8448, 5, "a/c"], [8449, 5, "a/s"], [8450, 1, "c"], [8451, 1, "c"], [8452, 2], [8453, 5, "c/o"], [8454, 5, "c/u"], [8455, 1, ""], [8456, 2], [8457, 1, "f"], [8458, 1, "g"], [[8459, 8462], 1, "h"], [8463, 1, ""], [[8464, 8465], 1, "i"], [[8466, 8467], 1, "l"], [8468, 2], [8469, 1, "n"], [8470, 1, "no"], [[8471, 8472], 2], [8473, 1, "p"], [8474, 1, "q"], [[8475, 8477], 1, "r"], [[8478, 8479], 2], [8480, 1, "sm"], [8481, 1, "tel"], [8482, 1, "tm"], [8483, 2], [8484, 1, "z"], [8485, 2], [8486, 1, ""], [8487, 2], [8488, 1, "z"], [8489, 2], [8490, 1, "k"], [8491, 1, ""], [8492, 1, "b"], [8493, 1, "c"], [8494, 2], [[8495, 8496], 1, "e"], [8497, 1, "f"], [8498, 3], [8499, 1, "m"], [8500, 1, "o"], [8501, 1, ""], [8502, 1, ""], [8503, 1, ""], [8504, 1, ""], [8505, 1, "i"], [8506, 2], [8507, 1, "fax"], [8508, 1, ""], [[8509, 8510], 1, ""], [8511, 1, ""], [8512, 1, ""], [[8513, 8516], 2], [[8517, 8518], 1, "d"], [8519, 1, "e"], [8520, 1, "i"], [8521, 1, "j"], [[8522, 8523], 2], [8524, 2], [8525, 2], [8526, 2], [8527, 2], [8528, 1, "17"], [8529, 1, "19"], [8530, 1, "110"], [8531, 1, "13"], [8532, 1, "23"], [8533, 1, "15"], [8534, 1, "25"], [8535, 1, "35"], [8536, 1, "45"], [8537, 1, "16"], [8538, 1, "56"], [8539, 1, "18"], [8540, 1, "38"], [8541, 1, "58"], [8542, 1, "78"], [8543, 1, "1"], [8544, 1, "i"], [8545, 1, "ii"], [8546, 1, "iii"], [8547, 1, "iv"], [8548, 1, "v"], [8549, 1, "vi"], [8550, 1, "vii"], [8551, 1, "viii"], [8552, 1, "ix"], [8553, 1, "x"], [8554, 1, "xi"], [8555, 1, "xii"], [8556, 1, "l"], [8557, 1, "c"], [8558, 1, "d"], [8559, 1, "m"], [8560, 1, "i"], [8561, 1, "ii"], [8562, 1, "iii"], [8563, 1, "iv"], [8564, 1, "v"], [8565, 1, "vi"], [8566, 1, "vii"], [8567, 1, "viii"], [8568, 1, "ix"], [8569, 1, "x"], [8570, 1, "xi"], [8571, 1, "xii"], [8572, 1, "l"], [8573, 1, "c"], [8574, 1, "d"], [8575, 1, "m"], [[8576, 8578], 2], [8579, 3], [8580, 2], [[8581, 8584], 2], [8585, 1, "03"], [[8586, 8587], 2], [[8588, 8591], 3], [[8592, 8682], 2], [[8683, 8691], 2], [[8692, 8703], 2], [[8704, 8747], 2], [8748, 1, ""], [8749, 1, ""], [8750, 2], [8751, 1, ""], [8752, 1, ""], [[8753, 8945], 2], [[8946, 8959], 2], [8960, 2], [8961, 2], [[8962, 9000], 2], [9001, 1, ""], [9002, 1, ""], [[9003, 9082], 2], [9083, 2], [9084, 2], [[9085, 9114], 2], [[9115, 9166], 2], [[9167, 9168], 2], [[9169, 9179], 2], [[9180, 9191], 2], [9192, 2], [[9193, 9203], 2], [[9204, 9210], 2], [[9211, 9214], 2], [9215, 2], [[9216, 9252], 2], [[9253, 9254], 2], [[9255, 9279], 3], [[9280, 9290], 2], [[9291, 9311], 3], [9312, 1, "1"], [9313, 1, "2"], [9314, 1, "3"], [9315, 1, "4"], [9316, 1, "5"], [9317, 1, "6"], [9318, 1, "7"], [9319, 1, "8"], [9320, 1, "9"], [9321, 1, "10"], [9322, 1, "11"], [9323, 1, "12"], [9324, 1, "13"], [9325, 1, "14"], [9326, 1, "15"], [9327, 1, "16"], [9328, 1, "17"], [9329, 1, "18"], [9330, 1, "19"], [9331, 1, "20"], [9332, 5, "(1)"], [9333, 5, "(2)"], [9334, 5, "(3)"], [9335, 5, "(4)"], [9336, 5, "(5)"], [9337, 5, "(6)"], [9338, 5, "(7)"], [9339, 5, "(8)"], [9340, 5, "(9)"], [9341, 5, "(10)"], [9342, 5, "(11)"], [9343, 5, "(12)"], [9344, 5, "(13)"], [9345, 5, "(14)"], [9346, 5, "(15)"], [9347, 5, "(16)"], [9348, 5, "(17)"], [9349, 5, "(18)"], [9350, 5, "(19)"], [9351, 5, "(20)"], [[9352, 9371], 3], [9372, 5, "(a)"], [9373, 5, "(b)"], [9374, 5, "(c)"], [9375, 5, "(d)"], [9376, 5, "(e)"], [9377, 5, "(f)"], [9378, 5, "(g)"], [9379, 5, "(h)"], [9380, 5, "(i)"], [9381, 5, "(j)"], [9382, 5, "(k)"], [9383, 5, "(l)"], [9384, 5, "(m)"], [9385, 5, "(n)"], [9386, 5, "(o)"], [9387, 5, "(p)"], [9388, 5, "(q)"], [9389, 5, "(r)"], [9390, 5, "(s)"], [9391, 5, "(t)"], [9392, 5, "(u)"], [9393, 5, "(v)"], [9394, 5, "(w)"], [9395, 5, "(x)"], [9396, 5, "(y)"], [9397, 5, "(z)"], [9398, 1, "a"], [9399, 1, "b"], [9400, 1, "c"], [9401, 1, "d"], [9402, 1, "e"], [9403, 1, "f"], [9404, 1, "g"], [9405, 1, "h"], [9406, 1, "i"], [9407, 1, "j"], [9408, 1, "k"], [9409, 1, "l"], [9410, 1, "m"], [9411, 1, "n"], [9412, 1, "o"], [9413, 1, "p"], [9414, 1, "q"], [9415, 1, "r"], [9416, 1, "s"], [9417, 1, "t"], [9418, 1, "u"], [9419, 1, "v"], [9420, 1, "w"], [9421, 1, "x"], [9422, 1, "y"], [9423, 1, "z"], [9424, 1, "a"], [9425, 1, "b"], [9426, 1, "c"], [9427, 1, "d"], [9428, 1, "e"], [9429, 1, "f"], [9430, 1, "g"], [9431, 1, "h"], [9432, 1, "i"], [9433, 1, "j"], [9434, 1, "k"], [9435, 1, "l"], [9436, 1, "m"], [9437, 1, "n"], [9438, 1, "o"], [9439, 1, "p"], [9440, 1, "q"], [9441, 1, "r"], [9442, 1, "s"], [9443, 1, "t"], [9444, 1, "u"], [9445, 1, "v"], [9446, 1, "w"], [9447, 1, "x"], [9448, 1, "y"], [9449, 1, "z"], [9450, 1, "0"], [[9451, 9470], 2], [9471, 2], [[9472, 9621], 2], [[9622, 9631], 2], [[9632, 9711], 2], [[9712, 9719], 2], [[9720, 9727], 2], [[9728, 9747], 2], [[9748, 9749], 2], [[9750, 9751], 2], [9752, 2], [9753, 2], [[9754, 9839], 2], [[9840, 9841], 2], [[9842, 9853], 2], [[9854, 9855], 2], [[9856, 9865], 2], [[9866, 9873], 2], [[9874, 9884], 2], [9885, 2], [[9886, 9887], 2], [[9888, 9889], 2], [[9890, 9905], 2], [9906, 2], [[9907, 9916], 2], [[9917, 9919], 2], [[9920, 9923], 2], [[9924, 9933], 2], [9934, 2], [[9935, 9953], 2], [9954, 2], [9955, 2], [[9956, 9959], 2], [[9960, 9983], 2], [9984, 2], [[9985, 9988], 2], [9989, 2], [[9990, 9993], 2], [[9994, 9995], 2], [[9996, 10023], 2], [10024, 2], [[10025, 10059], 2], [10060, 2], [10061, 2], [10062, 2], [[10063, 10066], 2], [[10067, 10069], 2], [10070, 2], [10071, 2], [[10072, 10078], 2], [[10079, 10080], 2], [[10081, 10087], 2], [[10088, 10101], 2], [[10102, 10132], 2], [[10133, 10135], 2], [[10136, 10159], 2], [10160, 2], [[10161, 10174], 2], [10175, 2], [[10176, 10182], 2], [[10183, 10186], 2], [10187, 2], [10188, 2], [10189, 2], [[10190, 10191], 2], [[10192, 10219], 2], [[10220, 10223], 2], [[10224, 10239], 2], [[10240, 10495], 2], [[10496, 10763], 2], [10764, 1, ""], [[10765, 10867], 2], [10868, 5, "::="], [10869, 5, "=="], [10870, 5, "==="], [[10871, 10971], 2], [10972, 1, ""], [[10973, 11007], 2], [[11008, 11021], 2], [[11022, 11027], 2], [[11028, 11034], 2], [[11035, 11039], 2], [[11040, 11043], 2], [[11044, 11084], 2], [[11085, 11087], 2], [[11088, 11092], 2], [[11093, 11097], 2], [[11098, 11123], 2], [[11124, 11125], 3], [[11126, 11157], 2], [11158, 3], [11159, 2], [[11160, 11193], 2], [[11194, 11196], 2], [[11197, 11208], 2], [11209, 2], [[11210, 11217], 2], [11218, 2], [[11219, 11243], 2], [[11244, 11247], 2], [[11248, 11262], 2], [11263, 2], [11264, 1, ""], [11265, 1, ""], [11266, 1, ""], [11267, 1, ""], [11268, 1, ""], [11269, 1, ""], [11270, 1, ""], [11271, 1, ""], [11272, 1, ""], [11273, 1, ""], [11274, 1, ""], [11275, 1, ""], [11276, 1, ""], [11277, 1, ""], [11278, 1, ""], [11279, 1, ""], [11280, 1, ""], [11281, 1, ""], [11282, 1, ""], [11283, 1, ""], [11284, 1, ""], [11285, 1, ""], [11286, 1, ""], [11287, 1, ""], [11288, 1, ""], [11289, 1, ""], [11290, 1, ""], [11291, 1, ""], [11292, 1, ""], [11293, 1, ""], [11294, 1, ""], [11295, 1, ""], [11296, 1, ""], [11297, 1, ""], [11298, 1, ""], [11299, 1, ""], [11300, 1, ""], [11301, 1, ""], [11302, 1, ""], [11303, 1, ""], [11304, 1, ""], [11305, 1, ""], [11306, 1, ""], [11307, 1, ""], [11308, 1, ""], [11309, 1, ""], [11310, 1, ""], [11311, 1, ""], [[11312, 11358], 2], [11359, 2], [11360, 1, ""], [11361, 2], [11362, 1, ""], [11363, 1, ""], [11364, 1, ""], [[11365, 11366], 2], [11367, 1, ""], [11368, 2], [11369, 1, ""], [11370, 2], [11371, 1, ""], [11372, 2], [11373, 1, ""], [11374, 1, ""], [11375, 1, ""], [11376, 1, ""], [11377, 2], [11378, 1, ""], [11379, 2], [11380, 2], [11381, 1, ""], [[11382, 11383], 2], [[11384, 11387], 2], [11388, 1, "j"], [11389, 1, "v"], [11390, 1, ""], [11391, 1, ""], [11392, 1, ""], [11393, 2], [11394, 1, ""], [11395, 2], [11396, 1, ""], [11397, 2], [11398, 1, ""], [11399, 2], [11400, 1, ""], [11401, 2], [11402, 1, ""], [11403, 2], [11404, 1, ""], [11405, 2], [11406, 1, ""], [11407, 2], [11408, 1, ""], [11409, 2], [11410, 1, ""], [11411, 2], [11412, 1, ""], [11413, 2], [11414, 1, ""], [11415, 2], [11416, 1, ""], [11417, 2], [11418, 1, ""], [11419, 2], [11420, 1, ""], [11421, 2], [11422, 1, ""], [11423, 2], [11424, 1, ""], [11425, 2], [11426, 1, ""], [11427, 2], [11428, 1, ""], [11429, 2], [11430, 1, ""], [11431, 2], [11432, 1, ""], [11433, 2], [11434, 1, ""], [11435, 2], [11436, 1, ""], [11437, 2], [11438, 1, ""], [11439, 2], [11440, 1, ""], [11441, 2], [11442, 1, ""], [11443, 2], [11444, 1, ""], [11445, 2], [11446, 1, ""], [11447, 2], [11448, 1, ""], [11449, 2], [11450, 1, ""], [11451, 2], [11452, 1, ""], [11453, 2], [11454, 1, ""], [11455, 2], [11456, 1, ""], [11457, 2], [11458, 1, ""], [11459, 2], [11460, 1, ""], [11461, 2], [11462, 1, ""], [11463, 2], [11464, 1, ""], [11465, 2], [11466, 1, ""], [11467, 2], [11468, 1, ""], [11469, 2], [11470, 1, ""], [11471, 2], [11472, 1, ""], [11473, 2], [11474, 1, ""], [11475, 2], [11476, 1, ""], [11477, 2], [11478, 1, ""], [11479, 2], [11480, 1, ""], [11481, 2], [11482, 1, ""], [11483, 2], [11484, 1, ""], [11485, 2], [11486, 1, ""], [11487, 2], [11488, 1, ""], [11489, 2], [11490, 1, ""], [[11491, 11492], 2], [[11493, 11498], 2], [11499, 1, ""], [11500, 2], [11501, 1, ""], [[11502, 11505], 2], [11506, 1, ""], [11507, 2], [[11508, 11512], 3], [[11513, 11519], 2], [[11520, 11557], 2], [11558, 3], [11559, 2], [[11560, 11564], 3], [11565, 2], [[11566, 11567], 3], [[11568, 11621], 2], [[11622, 11623], 2], [[11624, 11630], 3], [11631, 1, ""], [11632, 2], [[11633, 11646], 3], [11647, 2], [[11648, 11670], 2], [[11671, 11679], 3], [[11680, 11686], 2], [11687, 3], [[11688, 11694], 2], [11695, 3], [[11696, 11702], 2], [11703, 3], [[11704, 11710], 2], [11711, 3], [[11712, 11718], 2], [11719, 3], [[11720, 11726], 2], [11727, 3], [[11728, 11734], 2], [11735, 3], [[11736, 11742], 2], [11743, 3], [[11744, 11775], 2], [[11776, 11799], 2], [[11800, 11803], 2], [[11804, 11805], 2], [[11806, 11822], 2], [11823, 2], [11824, 2], [11825, 2], [[11826, 11835], 2], [[11836, 11842], 2], [[11843, 11844], 2], [[11845, 11849], 2], [[11850, 11854], 2], [11855, 2], [[11856, 11858], 2], [[11859, 11869], 2], [[11870, 11903], 3], [[11904, 11929], 2], [11930, 3], [[11931, 11934], 2], [11935, 1, ""], [[11936, 12018], 2], [12019, 1, ""], [[12020, 12031], 3], [12032, 1, ""], [12033, 1, ""], [12034, 1, ""], [12035, 1, ""], [12036, 1, ""], [12037, 1, ""], [12038, 1, ""], [12039, 1, ""], [12040, 1, ""], [12041, 1, ""], [12042, 1, ""], [12043, 1, ""], [12044, 1, ""], [12045, 1, ""], [12046, 1, ""], [12047, 1, ""], [12048, 1, ""], [12049, 1, ""], [12050, 1, ""], [12051, 1, ""], [12052, 1, ""], [12053, 1, ""], [12054, 1, ""], [12055, 1, ""], [12056, 1, ""], [12057, 1, ""], [12058, 1, ""], [12059, 1, ""], [12060, 1, ""], [12061, 1, ""], [12062, 1, ""], [12063, 1, ""], [12064, 1, ""], [12065, 1, ""], [12066, 1, ""], [12067, 1, ""], [12068, 1, ""], [12069, 1, ""], [12070, 1, ""], [12071, 1, ""], [12072, 1, ""], [12073, 1, ""], [12074, 1, ""], [12075, 1, ""], [12076, 1, ""], [12077, 1, ""], [12078, 1, ""], [12079, 1, ""], [12080, 1, ""], [12081, 1, ""], [12082, 1, ""], [12083, 1, ""], [12084, 1, ""], [12085, 1, ""], [12086, 1, ""], [12087, 1, ""], [12088, 1, ""], [12089, 1, ""], [12090, 1, ""], [12091, 1, ""], [12092, 1, ""], [12093, 1, ""], [12094, 1, ""], [12095, 1, ""], [12096, 1, ""], [12097, 1, ""], [12098, 1, ""], [12099, 1, ""], [12100, 1, ""], [12101, 1, ""], [12102, 1, ""], [12103, 1, ""], [12104, 1, ""], [12105, 1, ""], [12106, 1, ""], [12107, 1, ""], [12108, 1, ""], [12109, 1, ""], [12110, 1, ""], [12111, 1, ""], [12112, 1, ""], [12113, 1, ""], [12114, 1, ""], [12115, 1, ""], [12116, 1, ""], [12117, 1, ""], [12118, 1, ""], [12119, 1, ""], [12120, 1, ""], [12121, 1, ""], [12122, 1, ""], [12123, 1, ""], [12124, 1, ""], [12125, 1, ""], [12126, 1, ""], [12127, 1, ""], [12128, 1, ""], [12129, 1, ""], [12130, 1, ""], [12131, 1, ""], [12132, 1, ""], [12133, 1, ""], [12134, 1, ""], [12135, 1, ""], [12136, 1, ""], [12137, 1, ""], [12138, 1, ""], [12139, 1, ""], [12140, 1, ""], [12141, 1, ""], [12142, 1, ""], [12143, 1, ""], [12144, 1, ""], [12145, 1, ""], [12146, 1, ""], [12147, 1, ""], [12148, 1, ""], [12149, 1, ""], [12150, 1, ""], [12151, 1, ""], [12152, 1, ""], [12153, 1, ""], [12154, 1, ""], [12155, 1, ""], [12156, 1, ""], [12157, 1, ""], [12158, 1, ""], [12159, 1, ""], [12160, 1, ""], [12161, 1, ""], [12162, 1, ""], [12163, 1, ""], [12164, 1, ""], [12165, 1, ""], [12166, 1, ""], [12167, 1, ""], [12168, 1, ""], [12169, 1, ""], [12170, 1, ""], [12171, 1, ""], [12172, 1, ""], [12173, 1, ""], [12174, 1, ""], [12175, 1, ""], [12176, 1, ""], [12177, 1, ""], [12178, 1, ""], [12179, 1, ""], [12180, 1, ""], [12181, 1, ""], [12182, 1, ""], [12183, 1, ""], [12184, 1, ""], [12185, 1, ""], [12186, 1, ""], [12187, 1, ""], [12188, 1, ""], [12189, 1, ""], [12190, 1, ""], [12191, 1, ""], [12192, 1, ""], [12193, 1, ""], [12194, 1, ""], [12195, 1, ""], [12196, 1, ""], [12197, 1, ""], [12198, 1, ""], [12199, 1, ""], [12200, 1, ""], [12201, 1, ""], [12202, 1, ""], [12203, 1, ""], [12204, 1, ""], [12205, 1, ""], [12206, 1, ""], [12207, 1, ""], [12208, 1, ""], [12209, 1, ""], [12210, 1, ""], [12211, 1, ""], [12212, 1, ""], [12213, 1, ""], [12214, 1, ""], [12215, 1, ""], [12216, 1, ""], [12217, 1, ""], [12218, 1, ""], [12219, 1, ""], [12220, 1, ""], [12221, 1, ""], [12222, 1, ""], [12223, 1, ""], [12224, 1, ""], [12225, 1, ""], [12226, 1, ""], [12227, 1, ""], [12228, 1, ""], [12229, 1, ""], [12230, 1, ""], [12231, 1, ""], [12232, 1, ""], [12233, 1, ""], [12234, 1, ""], [12235, 1, ""], [12236, 1, ""], [12237, 1, ""], [12238, 1, ""], [12239, 1, ""], [12240, 1, ""], [12241, 1, ""], [12242, 1, ""], [12243, 1, ""], [12244, 1, ""], [12245, 1, ""], [[12246, 12271], 3], [[12272, 12283], 3], [[12284, 12287], 3], [12288, 5, " "], [12289, 2], [12290, 1, "."], [[12291, 12292], 2], [[12293, 12295], 2], [[12296, 12329], 2], [[12330, 12333], 2], [[12334, 12341], 2], [12342, 1, ""], [12343, 2], [12344, 1, ""], [12345, 1, ""], [12346, 1, ""], [12347, 2], [12348, 2], [12349, 2], [12350, 2], [12351, 2], [12352, 3], [[12353, 12436], 2], [[12437, 12438], 2], [[12439, 12440], 3], [[12441, 12442], 2], [12443, 5, " "], [12444, 5, " "], [[12445, 12446], 2], [12447, 1, ""], [12448, 2], [[12449, 12542], 2], [12543, 1, ""], [[12544, 12548], 3], [[12549, 12588], 2], [12589, 2], [12590, 2], [12591, 2], [12592, 3], [12593, 1, ""], [12594, 1, ""], [12595, 1, ""], [12596, 1, ""], [12597, 1, ""], [12598, 1, ""], [12599, 1, ""], [12600, 1, ""], [12601, 1, ""], [12602, 1, ""], [12603, 1, ""], [12604, 1, ""], [12605, 1, ""], [12606, 1, ""], [12607, 1, ""], [12608, 1, ""], [12609, 1, ""], [12610, 1, ""], [12611, 1, ""], [12612, 1, ""], [12613, 1, ""], [12614, 1, ""], [12615, 1, ""], [12616, 1, ""], [12617, 1, ""], [12618, 1, ""], [12619, 1, ""], [12620, 1, ""], [12621, 1, ""], [12622, 1, ""], [12623, 1, ""], [12624, 1, ""], [12625, 1, ""], [12626, 1, ""], [12627, 1, ""], [12628, 1, ""], [12629, 1, ""], [12630, 1, ""], [12631, 1, ""], [12632, 1, ""], [12633, 1, ""], [12634, 1, ""], [12635, 1, ""], [12636, 1, ""], [12637, 1, ""], [12638, 1, ""], [12639, 1, ""], [12640, 1, ""], [12641, 1, ""], [12642, 1, ""], [12643, 1, ""], [12644, 3], [12645, 1, ""], [12646, 1, ""], [12647, 1, ""], [12648, 1, ""], [12649, 1, ""], [12650, 1, ""], [12651, 1, ""], [12652, 1, ""], [12653, 1, ""], [12654, 1, ""], [12655, 1, ""], [12656, 1, ""], [12657, 1, ""], [12658, 1, ""], [12659, 1, ""], [12660, 1, ""], [12661, 1, ""], [12662, 1, ""], [12663, 1, ""], [12664, 1, ""], [12665, 1, ""], [12666, 1, ""], [12667, 1, ""], [12668, 1, ""], [12669, 1, ""], [12670, 1, ""], [12671, 1, ""], [12672, 1, ""], [12673, 1, ""], [12674, 1, ""], [12675, 1, ""], [12676, 1, ""], [12677, 1, ""], [12678, 1, ""], [12679, 1, ""], [12680, 1, ""], [12681, 1, ""], [12682, 1, ""], [12683, 1, ""], [12684, 1, ""], [12685, 1, ""], [12686, 1, ""], [12687, 3], [[12688, 12689], 2], [12690, 1, ""], [12691, 1, ""], [12692, 1, ""], [12693, 1, ""], [12694, 1, ""], [12695, 1, ""], [12696, 1, ""], [12697, 1, ""], [12698, 1, ""], [12699, 1, ""], [12700, 1, ""], [12701, 1, ""], [12702, 1, ""], [12703, 1, ""], [[12704, 12727], 2], [[12728, 12730], 2], [[12731, 12735], 2], [[12736, 12751], 2], [[12752, 12771], 2], [[12772, 12782], 3], [12783, 3], [[12784, 12799], 2], [12800, 5, "()"], [12801, 5, "()"], [12802, 5, "()"], [12803, 5, "()"], [12804, 5, "()"], [12805, 5, "()"], [12806, 5, "()"], [12807, 5, "()"], [12808, 5, "()"], [12809, 5, "()"], [12810, 5, "()"], [12811, 5, "()"], [12812, 5, "()"], [12813, 5, "()"], [12814, 5, "()"], [12815, 5, "()"], [12816, 5, "()"], [12817, 5, "()"], [12818, 5, "()"], [12819, 5, "()"], [12820, 5, "()"], [12821, 5, "()"], [12822, 5, "()"], [12823, 5, "()"], [12824, 5, "()"], [12825, 5, "()"], [12826, 5, "()"], [12827, 5, "()"], [12828, 5, "()"], [12829, 5, "()"], [12830, 5, "()"], [12831, 3], [12832, 5, "()"], [12833, 5, "()"], [12834, 5, "()"], [12835, 5, "()"], [12836, 5, "()"], [12837, 5, "()"], [12838, 5, "()"], [12839, 5, "()"], [12840, 5, "()"], [12841, 5, "()"], [12842, 5, "()"], [12843, 5, "()"], [12844, 5, "()"], [12845, 5, "()"], [12846, 5, "()"], [12847, 5, "()"], [12848, 5, "()"], [12849, 5, "()"], [12850, 5, "()"], [12851, 5, "()"], [12852, 5, "()"], [12853, 5, "()"], [12854, 5, "()"], [12855, 5, "()"], [12856, 5, "()"], [12857, 5, "()"], [12858, 5, "()"], [12859, 5, "()"], [12860, 5, "()"], [12861, 5, "()"], [12862, 5, "()"], [12863, 5, "()"], [12864, 5, "()"], [12865, 5, "()"], [12866, 5, "()"], [12867, 5, "()"], [12868, 1, ""], [12869, 1, ""], [12870, 1, ""], [12871, 1, ""], [[12872, 12879], 2], [12880, 1, "pte"], [12881, 1, "21"], [12882, 1, "22"], [12883, 1, "23"], [12884, 1, "24"], [12885, 1, "25"], [12886, 1, "26"], [12887, 1, "27"], [12888, 1, "28"], [12889, 1, "29"], [12890, 1, "30"], [12891, 1, "31"], [12892, 1, "32"], [12893, 1, "33"], [12894, 1, "34"], [12895, 1, "35"], [12896, 1, ""], [12897, 1, ""], [12898, 1, ""], [12899, 1, ""], [12900, 1, ""], [12901, 1, ""], [12902, 1, ""], [12903, 1, ""], [12904, 1, ""], [12905, 1, ""], [12906, 1, ""], [12907, 1, ""], [12908, 1, ""], [12909, 1, ""], [12910, 1, ""], [12911, 1, ""], [12912, 1, ""], [12913, 1, ""], [12914, 1, ""], [12915, 1, ""], [12916, 1, ""], [12917, 1, ""], [12918, 1, ""], [12919, 1, ""], [12920, 1, ""], [12921, 1, ""], [12922, 1, ""], [12923, 1, ""], [12924, 1, ""], [12925, 1, ""], [12926, 1, ""], [12927, 2], [12928, 1, ""], [12929, 1, ""], [12930, 1, ""], [12931, 1, ""], [12932, 1, ""], [12933, 1, ""], [12934, 1, ""], [12935, 1, ""], [12936, 1, ""], [12937, 1, ""], [12938, 1, ""], [12939, 1, ""], [12940, 1, ""], [12941, 1, ""], [12942, 1, ""], [12943, 1, ""], [12944, 1, ""], [12945, 1, ""], [12946, 1, ""], [12947, 1, ""], [12948, 1, ""], [12949, 1, ""], [12950, 1, ""], [12951, 1, ""], [12952, 1, ""], [12953, 1, ""], [12954, 1, ""], [12955, 1, ""], [12956, 1, ""], [12957, 1, ""], [12958, 1, ""], [12959, 1, ""], [12960, 1, ""], [12961, 1, ""], [12962, 1, ""], [12963, 1, ""], [12964, 1, ""], [12965, 1, ""], [12966, 1, ""], [12967, 1, ""], [12968, 1, ""], [12969, 1, ""], [12970, 1, ""], [12971, 1, ""], [12972, 1, ""], [12973, 1, ""], [12974, 1, ""], [12975, 1, ""], [12976, 1, ""], [12977, 1, "36"], [12978, 1, "37"], [12979, 1, "38"], [12980, 1, "39"], [12981, 1, "40"], [12982, 1, "41"], [12983, 1, "42"], [12984, 1, "43"], [12985, 1, "44"], [12986, 1, "45"], [12987, 1, "46"], [12988, 1, "47"], [12989, 1, "48"], [12990, 1, "49"], [12991, 1, "50"], [12992, 1, "1"], [12993, 1, "2"], [12994, 1, "3"], [12995, 1, "4"], [12996, 1, "5"], [12997, 1, "6"], [12998, 1, "7"], [12999, 1, "8"], [13000, 1, "9"], [13001, 1, "10"], [13002, 1, "11"], [13003, 1, "12"], [13004, 1, "hg"], [13005, 1, "erg"], [13006, 1, "ev"], [13007, 1, "ltd"], [13008, 1, ""], [13009, 1, ""], [13010, 1, ""], [13011, 1, ""], [13012, 1, ""], [13013, 1, ""], [13014, 1, ""], [13015, 1, ""], [13016, 1, ""], [13017, 1, ""], [13018, 1, ""], [13019, 1, ""], [13020, 1, ""], [13021, 1, ""], [13022, 1, ""], [13023, 1, ""], [13024, 1, ""], [13025, 1, ""], [13026, 1, ""], [13027, 1, ""], [13028, 1, ""], [13029, 1, ""], [13030, 1, ""], [13031, 1, ""], [13032, 1, ""], [13033, 1, ""], [13034, 1, ""], [13035, 1, ""], [13036, 1, ""], [13037, 1, ""], [13038, 1, ""], [13039, 1, ""], [13040, 1, ""], [13041, 1, ""], [13042, 1, ""], [13043, 1, ""], [13044, 1, ""], [13045, 1, ""], [13046, 1, ""], [13047, 1, ""], [13048, 1, ""], [13049, 1, ""], [13050, 1, ""], [13051, 1, ""], [13052, 1, ""], [13053, 1, ""], [13054, 1, ""], [13055, 1, ""], [13056, 1, ""], [13057, 1, ""], [13058, 1, ""], [13059, 1, ""], [13060, 1, ""], [13061, 1, ""], [13062, 1, ""], [13063, 1, ""], [13064, 1, ""], [13065, 1, ""], [13066, 1, ""], [13067, 1, ""], [13068, 1, ""], [13069, 1, ""], [13070, 1, ""], [13071, 1, ""], [13072, 1, ""], [13073, 1, ""], [13074, 1, ""], [13075, 1, ""], [13076, 1, ""], [13077, 1, ""], [13078, 1, ""], [13079, 1, ""], [13080, 1, ""], [13081, 1, ""], [13082, 1, ""], [13083, 1, ""], [13084, 1, ""], [13085, 1, ""], [13086, 1, ""], [13087, 1, ""], [13088, 1, ""], [13089, 1, ""], [13090, 1, ""], [13091, 1, ""], [13092, 1, ""], [13093, 1, ""], [13094, 1, ""], [13095, 1, ""], [13096, 1, ""], [13097, 1, ""], [13098, 1, ""], [13099, 1, ""], [13100, 1, ""], [13101, 1, ""], [13102, 1, ""], [13103, 1, ""], [13104, 1, ""], [13105, 1, ""], [13106, 1, ""], [13107, 1, ""], [13108, 1, ""], [13109, 1, ""], [13110, 1, ""], [13111, 1, ""], [13112, 1, ""], [13113, 1, ""], [13114, 1, ""], [13115, 1, ""], [13116, 1, ""], [13117, 1, ""], [13118, 1, ""], [13119, 1, ""], [13120, 1, ""], [13121, 1, ""], [13122, 1, ""], [13123, 1, ""], [13124, 1, ""], [13125, 1, ""], [13126, 1, ""], [13127, 1, ""], [13128, 1, ""], [13129, 1, ""], [13130, 1, ""], [13131, 1, ""], [13132, 1, ""], [13133, 1, ""], [13134, 1, ""], [13135, 1, ""], [13136, 1, ""], [13137, 1, ""], [13138, 1, ""], [13139, 1, ""], [13140, 1, ""], [13141, 1, ""], [13142, 1, ""], [13143, 1, ""], [13144, 1, "0"], [13145, 1, "1"], [13146, 1, "2"], [13147, 1, "3"], [13148, 1, "4"], [13149, 1, "5"], [13150, 1, "6"], [13151, 1, "7"], [13152, 1, "8"], [13153, 1, "9"], [13154, 1, "10"], [13155, 1, "11"], [13156, 1, "12"], [13157, 1, "13"], [13158, 1, "14"], [13159, 1, "15"], [13160, 1, "16"], [13161, 1, "17"], [13162, 1, "18"], [13163, 1, "19"], [13164, 1, "20"], [13165, 1, "21"], [13166, 1, "22"], [13167, 1, "23"], [13168, 1, "24"], [13169, 1, "hpa"], [13170, 1, "da"], [13171, 1, "au"], [13172, 1, "bar"], [13173, 1, "ov"], [13174, 1, "pc"], [13175, 1, "dm"], [13176, 1, "dm2"], [13177, 1, "dm3"], [13178, 1, "iu"], [13179, 1, ""], [13180, 1, ""], [13181, 1, ""], [13182, 1, ""], [13183, 1, ""], [13184, 1, "pa"], [13185, 1, "na"], [13186, 1, "a"], [13187, 1, "ma"], [13188, 1, "ka"], [13189, 1, "kb"], [13190, 1, "mb"], [13191, 1, "gb"], [13192, 1, "cal"], [13193, 1, "kcal"], [13194, 1, "pf"], [13195, 1, "nf"], [13196, 1, "f"], [13197, 1, "g"], [13198, 1, "mg"], [13199, 1, "kg"], [13200, 1, "hz"], [13201, 1, "khz"], [13202, 1, "mhz"], [13203, 1, "ghz"], [13204, 1, "thz"], [13205, 1, "l"], [13206, 1, "ml"], [13207, 1, "dl"], [13208, 1, "kl"], [13209, 1, "fm"], [13210, 1, "nm"], [13211, 1, "m"], [13212, 1, "mm"], [13213, 1, "cm"], [13214, 1, "km"], [13215, 1, "mm2"], [13216, 1, "cm2"], [13217, 1, "m2"], [13218, 1, "km2"], [13219, 1, "mm3"], [13220, 1, "cm3"], [13221, 1, "m3"], [13222, 1, "km3"], [13223, 1, "ms"], [13224, 1, "ms2"], [13225, 1, "pa"], [13226, 1, "kpa"], [13227, 1, "mpa"], [13228, 1, "gpa"], [13229, 1, "rad"], [13230, 1, "rads"], [13231, 1, "rads2"], [13232, 1, "ps"], [13233, 1, "ns"], [13234, 1, "s"], [13235, 1, "ms"], [13236, 1, "pv"], [13237, 1, "nv"], [13238, 1, "v"], [13239, 1, "mv"], [13240, 1, "kv"], [13241, 1, "mv"], [13242, 1, "pw"], [13243, 1, "nw"], [13244, 1, "w"], [13245, 1, "mw"], [13246, 1, "kw"], [13247, 1, "mw"], [13248, 1, "k"], [13249, 1, "m"], [13250, 3], [13251, 1, "bq"], [13252, 1, "cc"], [13253, 1, "cd"], [13254, 1, "ckg"], [13255, 3], [13256, 1, "db"], [13257, 1, "gy"], [13258, 1, "ha"], [13259, 1, "hp"], [13260, 1, "in"], [13261, 1, "kk"], [13262, 1, "km"], [13263, 1, "kt"], [13264, 1, "lm"], [13265, 1, "ln"], [13266, 1, "log"], [13267, 1, "lx"], [13268, 1, "mb"], [13269, 1, "mil"], [13270, 1, "mol"], [13271, 1, "ph"], [13272, 3], [13273, 1, "ppm"], [13274, 1, "pr"], [13275, 1, "sr"], [13276, 1, "sv"], [13277, 1, "wb"], [13278, 1, "vm"], [13279, 1, "am"], [13280, 1, "1"], [13281, 1, "2"], [13282, 1, "3"], [13283, 1, "4"], [13284, 1, "5"], [13285, 1, "6"], [13286, 1, "7"], [13287, 1, "8"], [13288, 1, "9"], [13289, 1, "10"], [13290, 1, "11"], [13291, 1, "12"], [13292, 1, "13"], [13293, 1, "14"], [13294, 1, "15"], [13295, 1, "16"], [13296, 1, "17"], [13297, 1, "18"], [13298, 1, "19"], [13299, 1, "20"], [13300, 1, "21"], [13301, 1, "22"], [13302, 1, "23"], [13303, 1, "24"], [13304, 1, "25"], [13305, 1, "26"], [13306, 1, "27"], [13307, 1, "28"], [13308, 1, "29"], [13309, 1, "30"], [13310, 1, "31"], [13311, 1, "gal"], [[13312, 19893], 2], [[19894, 19903], 2], [[19904, 19967], 2], [[19968, 40869], 2], [[40870, 40891], 2], [[40892, 40899], 2], [[40900, 40907], 2], [40908, 2], [[40909, 40917], 2], [[40918, 40938], 2], [[40939, 40943], 2], [[40944, 40956], 2], [[40957, 40959], 2], [[40960, 42124], 2], [[42125, 42127], 3], [[42128, 42145], 2], [[42146, 42147], 2], [[42148, 42163], 2], [42164, 2], [[42165, 42176], 2], [42177, 2], [[42178, 42180], 2], [42181, 2], [42182, 2], [[42183, 42191], 3], [[42192, 42237], 2], [[42238, 42239], 2], [[42240, 42508], 2], [[42509, 42511], 2], [[42512, 42539], 2], [[42540, 42559], 3], [42560, 1, ""], [42561, 2], [42562, 1, ""], [42563, 2], [42564, 1, ""], [42565, 2], [42566, 1, ""], [42567, 2], [42568, 1, ""], [42569, 2], [42570, 1, ""], [42571, 2], [42572, 1, ""], [42573, 2], [42574, 1, ""], [42575, 2], [42576, 1, ""], [42577, 2], [42578, 1, ""], [42579, 2], [42580, 1, ""], [42581, 2], [42582, 1, ""], [42583, 2], [42584, 1, ""], [42585, 2], [42586, 1, ""], [42587, 2], [42588, 1, ""], [42589, 2], [42590, 1, ""], [42591, 2], [42592, 1, ""], [42593, 2], [42594, 1, ""], [42595, 2], [42596, 1, ""], [42597, 2], [42598, 1, ""], [42599, 2], [42600, 1, ""], [42601, 2], [42602, 1, ""], [42603, 2], [42604, 1, ""], [[42605, 42607], 2], [[42608, 42611], 2], [[42612, 42619], 2], [[42620, 42621], 2], [42622, 2], [42623, 2], [42624, 1, ""], [42625, 2], [42626, 1, ""], [42627, 2], [42628, 1, ""], [42629, 2], [42630, 1, ""], [42631, 2], [42632, 1, ""], [42633, 2], [42634, 1, ""], [42635, 2], [42636, 1, ""], [42637, 2], [42638, 1, ""], [42639, 2], [42640, 1, ""], [42641, 2], [42642, 1, ""], [42643, 2], [42644, 1, ""], [42645, 2], [42646, 1, ""], [42647, 2], [42648, 1, ""], [42649, 2], [42650, 1, ""], [42651, 2], [42652, 1, ""], [42653, 1, ""], [42654, 2], [42655, 2], [[42656, 42725], 2], [[42726, 42735], 2], [[42736, 42737], 2], [[42738, 42743], 2], [[42744, 42751], 3], [[42752, 42774], 2], [[42775, 42778], 2], [[42779, 42783], 2], [[42784, 42785], 2], [42786, 1, ""], [42787, 2], [42788, 1, ""], [42789, 2], [42790, 1, ""], [42791, 2], [42792, 1, ""], [42793, 2], [42794, 1, ""], [42795, 2], [42796, 1, ""], [42797, 2], [42798, 1, ""], [[42799, 42801], 2], [42802, 1, ""], [42803, 2], [42804, 1, ""], [42805, 2], [42806, 1, ""], [42807, 2], [42808, 1, ""], [42809, 2], [42810, 1, ""], [42811, 2], [42812, 1, ""], [42813, 2], [42814, 1, ""], [42815, 2], [42816, 1, ""], [42817, 2], [42818, 1, ""], [42819, 2], [42820, 1, ""], [42821, 2], [42822, 1, ""], [42823, 2], [42824, 1, ""], [42825, 2], [42826, 1, ""], [42827, 2], [42828, 1, ""], [42829, 2], [42830, 1, ""], [42831, 2], [42832, 1, ""], [42833, 2], [42834, 1, ""], [42835, 2], [42836, 1, ""], [42837, 2], [42838, 1, ""], [42839, 2], [42840, 1, ""], [42841, 2], [42842, 1, ""], [42843, 2], [42844, 1, ""], [42845, 2], [42846, 1, ""], [42847, 2], [42848, 1, ""], [42849, 2], [42850, 1, ""], [42851, 2], [42852, 1, ""], [42853, 2], [42854, 1, ""], [42855, 2], [42856, 1, ""], [42857, 2], [42858, 1, ""], [42859, 2], [42860, 1, ""], [42861, 2], [42862, 1, ""], [42863, 2], [42864, 1, ""], [[42865, 42872], 2], [42873, 1, ""], [42874, 2], [42875, 1, ""], [42876, 2], [42877, 1, ""], [42878, 1, ""], [42879, 2], [42880, 1, ""], [42881, 2], [42882, 1, ""], [42883, 2], [42884, 1, ""], [42885, 2], [42886, 1, ""], [[42887, 42888], 2], [[42889, 42890], 2], [42891, 1, ""], [42892, 2], [42893, 1, ""], [42894, 2], [42895, 2], [42896, 1, ""], [42897, 2], [42898, 1, ""], [42899, 2], [[42900, 42901], 2], [42902, 1, ""], [42903, 2], [42904, 1, ""], [42905, 2], [42906, 1, ""], [42907, 2], [42908, 1, ""], [42909, 2], [42910, 1, ""], [42911, 2], [42912, 1, ""], [42913, 2], [42914, 1, ""], [42915, 2], [42916, 1, ""], [42917, 2], [42918, 1, ""], [42919, 2], [42920, 1, ""], [42921, 2], [42922, 1, ""], [42923, 1, ""], [42924, 1, ""], [42925, 1, ""], [42926, 1, ""], [42927, 2], [42928, 1, ""], [42929, 1, ""], [42930, 1, ""], [42931, 1, ""], [42932, 1, ""], [42933, 2], [42934, 1, ""], [42935, 2], [42936, 1, ""], [42937, 2], [42938, 1, ""], [42939, 2], [42940, 1, ""], [42941, 2], [42942, 1, ""], [42943, 2], [42944, 1, ""], [42945, 2], [42946, 1, ""], [42947, 2], [42948, 1, ""], [42949, 1, ""], [42950, 1, ""], [42951, 1, ""], [42952, 2], [42953, 1, ""], [42954, 2], [[42955, 42959], 3], [42960, 1, ""], [42961, 2], [42962, 3], [42963, 2], [42964, 3], [42965, 2], [42966, 1, ""], [42967, 2], [42968, 1, ""], [42969, 2], [[42970, 42993], 3], [42994, 1, "c"], [42995, 1, "f"], [42996, 1, "q"], [42997, 1, ""], [42998, 2], [42999, 2], [43000, 1, ""], [43001, 1, ""], [43002, 2], [[43003, 43007], 2], [[43008, 43047], 2], [[43048, 43051], 2], [43052, 2], [[43053, 43055], 3], [[43056, 43065], 2], [[43066, 43071], 3], [[43072, 43123], 2], [[43124, 43127], 2], [[43128, 43135], 3], [[43136, 43204], 2], [43205, 2], [[43206, 43213], 3], [[43214, 43215], 2], [[43216, 43225], 2], [[43226, 43231], 3], [[43232, 43255], 2], [[43256, 43258], 2], [43259, 2], [43260, 2], [43261, 2], [[43262, 43263], 2], [[43264, 43309], 2], [[43310, 43311], 2], [[43312, 43347], 2], [[43348, 43358], 3], [43359, 2], [[43360, 43388], 2], [[43389, 43391], 3], [[43392, 43456], 2], [[43457, 43469], 2], [43470, 3], [[43471, 43481], 2], [[43482, 43485], 3], [[43486, 43487], 2], [[43488, 43518], 2], [43519, 3], [[43520, 43574], 2], [[43575, 43583], 3], [[43584, 43597], 2], [[43598, 43599], 3], [[43600, 43609], 2], [[43610, 43611], 3], [[43612, 43615], 2], [[43616, 43638], 2], [[43639, 43641], 2], [[43642, 43643], 2], [[43644, 43647], 2], [[43648, 43714], 2], [[43715, 43738], 3], [[43739, 43741], 2], [[43742, 43743], 2], [[43744, 43759], 2], [[43760, 43761], 2], [[43762, 43766], 2], [[43767, 43776], 3], [[43777, 43782], 2], [[43783, 43784], 3], [[43785, 43790], 2], [[43791, 43792], 3], [[43793, 43798], 2], [[43799, 43807], 3], [[43808, 43814], 2], [43815, 3], [[43816, 43822], 2], [43823, 3], [[43824, 43866], 2], [43867, 2], [43868, 1, ""], [43869, 1, ""], [43870, 1, ""], [43871, 1, ""], [[43872, 43875], 2], [[43876, 43877], 2], [[43878, 43879], 2], [43880, 2], [43881, 1, ""], [[43882, 43883], 2], [[43884, 43887], 3], [43888, 1, ""], [43889, 1, ""], [43890, 1, ""], [43891, 1, ""], [43892, 1, ""], [43893, 1, ""], [43894, 1, ""], [43895, 1, ""], [43896, 1, ""], [43897, 1, ""], [43898, 1, ""], [43899, 1, ""], [43900, 1, ""], [43901, 1, ""], [43902, 1, ""], [43903, 1, ""], [43904, 1, ""], [43905, 1, ""], [43906, 1, ""], [43907, 1, ""], [43908, 1, ""], [43909, 1, ""], [43910, 1, ""], [43911, 1, ""], [43912, 1, ""], [43913, 1, ""], [43914, 1, ""], [43915, 1, ""], [43916, 1, ""], [43917, 1, ""], [43918, 1, ""], [43919, 1, ""], [43920, 1, ""], [43921, 1, ""], [43922, 1, ""], [43923, 1, ""], [43924, 1, ""], [43925, 1, ""], [43926, 1, ""], [43927, 1, ""], [43928, 1, ""], [43929, 1, ""], [43930, 1, ""], [43931, 1, ""], [43932, 1, ""], [43933, 1, ""], [43934, 1, ""], [43935, 1, ""], [43936, 1, ""], [43937, 1, ""], [43938, 1, ""], [43939, 1, ""], [43940, 1, ""], [43941, 1, ""], [43942, 1, ""], [43943, 1, ""], [43944, 1, ""], [43945, 1, ""], [43946, 1, ""], [43947, 1, ""], [43948, 1, ""], [43949, 1, ""], [43950, 1, ""], [43951, 1, ""], [43952, 1, ""], [43953, 1, ""], [43954, 1, ""], [43955, 1, ""], [43956, 1, ""], [43957, 1, ""], [43958, 1, ""], [43959, 1, ""], [43960, 1, ""], [43961, 1, ""], [43962, 1, ""], [43963, 1, ""], [43964, 1, ""], [43965, 1, ""], [43966, 1, ""], [43967, 1, ""], [[43968, 44010], 2], [44011, 2], [[44012, 44013], 2], [[44014, 44015], 3], [[44016, 44025], 2], [[44026, 44031], 3], [[44032, 55203], 2], [[55204, 55215], 3], [[55216, 55238], 2], [[55239, 55242], 3], [[55243, 55291], 2], [[55292, 55295], 3], [[55296, 57343], 3], [[57344, 63743], 3], [63744, 1, ""], [63745, 1, ""], [63746, 1, ""], [63747, 1, ""], [63748, 1, ""], [63749, 1, ""], [63750, 1, ""], [[63751, 63752], 1, ""], [63753, 1, ""], [63754, 1, ""], [63755, 1, ""], [63756, 1, ""], [63757, 1, ""], [63758, 1, ""], [63759, 1, ""], [63760, 1, ""], [63761, 1, ""], [63762, 1, ""], [63763, 1, ""], [63764, 1, ""], [63765, 1, ""], [63766, 1, ""], [63767, 1, ""], [63768, 1, ""], [63769, 1, ""], [63770, 1, ""], [63771, 1, ""], [63772, 1, ""], [63773, 1, ""], [63774, 1, ""], [63775, 1, ""], [63776, 1, ""], [63777, 1, ""], [63778, 1, ""], [63779, 1, ""], [63780, 1, ""], [63781, 1, ""], [63782, 1, ""], [63783, 1, ""], [63784, 1, ""], [63785, 1, ""], [63786, 1, ""], [63787, 1, ""], [63788, 1, ""], [63789, 1, ""], [63790, 1, ""], [63791, 1, ""], [63792, 1, ""], [63793, 1, ""], [63794, 1, ""], [63795, 1, ""], [63796, 1, ""], [63797, 1, ""], [63798, 1, ""], [63799, 1, ""], [63800, 1, ""], [63801, 1, ""], [63802, 1, ""], [63803, 1, ""], [63804, 1, ""], [63805, 1, ""], [63806, 1, ""], [63807, 1, ""], [63808, 1, ""], [63809, 1, ""], [63810, 1, ""], [63811, 1, ""], [63812, 1, ""], [63813, 1, ""], [63814, 1, ""], [63815, 1, ""], [63816, 1, ""], [63817, 1, ""], [63818, 1, ""], [63819, 1, ""], [63820, 1, ""], [63821, 1, ""], [63822, 1, ""], [63823, 1, ""], [63824, 1, ""], [63825, 1, ""], [63826, 1, ""], [63827, 1, ""], [63828, 1, ""], [63829, 1, ""], [63830, 1, ""], [63831, 1, ""], [63832, 1, ""], [63833, 1, ""], [63834, 1, ""], [63835, 1, ""], [63836, 1, ""], [63837, 1, ""], [63838, 1, ""], [63839, 1, ""], [63840, 1, ""], [63841, 1, ""], [63842, 1, ""], [63843, 1, ""], [63844, 1, ""], [63845, 1, ""], [63846, 1, ""], [63847, 1, ""], [63848, 1, ""], [63849, 1, ""], [63850, 1, ""], [63851, 1, ""], [63852, 1, ""], [63853, 1, ""], [63854, 1, ""], [63855, 1, ""], [63856, 1, ""], [63857, 1, ""], [63858, 1, ""], [63859, 1, ""], [63860, 1, ""], [63861, 1, ""], [63862, 1, ""], [63863, 1, ""], [63864, 1, ""], [63865, 1, ""], [63866, 1, ""], [63867, 1, ""], [63868, 1, ""], [63869, 1, ""], [63870, 1, ""], [63871, 1, ""], [63872, 1, ""], [63873, 1, ""], [63874, 1, ""], [63875, 1, ""], [63876, 1, ""], [63877, 1, ""], [63878, 1, ""], [63879, 1, ""], [63880, 1, ""], [63881, 1, ""], [63882, 1, ""], [63883, 1, ""], [63884, 1, ""], [63885, 1, ""], [63886, 1, ""], [63887, 1, ""], [63888, 1, ""], [63889, 1, ""], [63890, 1, ""], [63891, 1, ""], [63892, 1, ""], [63893, 1, ""], [63894, 1, ""], [63895, 1, ""], [63896, 1, ""], [63897, 1, ""], [63898, 1, ""], [63899, 1, ""], [63900, 1, ""], [63901, 1, ""], [63902, 1, ""], [63903, 1, ""], [63904, 1, ""], [63905, 1, ""], [63906, 1, ""], [63907, 1, ""], [63908, 1, ""], [63909, 1, ""], [63910, 1, ""], [63911, 1, ""], [63912, 1, ""], [63913, 1, ""], [63914, 1, ""], [63915, 1, ""], [63916, 1, ""], [63917, 1, ""], [63918, 1, ""], [63919, 1, ""], [63920, 1, ""], [63921, 1, ""], [63922, 1, ""], [63923, 1, ""], [63924, 1, ""], [63925, 1, ""], [63926, 1, ""], [63927, 1, ""], [63928, 1, ""], [63929, 1, ""], [63930, 1, ""], [63931, 1, ""], [63932, 1, ""], [63933, 1, ""], [63934, 1, ""], [63935, 1, ""], [63936, 1, ""], [63937, 1, ""], [63938, 1, ""], [63939, 1, ""], [63940, 1, ""], [63941, 1, ""], [63942, 1, ""], [63943, 1, ""], [63944, 1, ""], [63945, 1, ""], [63946, 1, ""], [63947, 1, ""], [63948, 1, ""], [63949, 1, ""], [63950, 1, ""], [63951, 1, ""], [63952, 1, ""], [63953, 1, ""], [63954, 1, ""], [63955, 1, ""], [63956, 1, ""], [63957, 1, ""], [63958, 1, ""], [63959, 1, ""], [63960, 1, ""], [63961, 1, ""], [63962, 1, ""], [63963, 1, ""], [63964, 1, ""], [63965, 1, ""], [63966, 1, ""], [63967, 1, ""], [63968, 1, ""], [63969, 1, ""], [63970, 1, ""], [63971, 1, ""], [63972, 1, ""], [63973, 1, ""], [63974, 1, ""], [63975, 1, ""], [63976, 1, ""], [63977, 1, ""], [63978, 1, ""], [63979, 1, ""], [63980, 1, ""], [63981, 1, ""], [63982, 1, ""], [63983, 1, ""], [63984, 1, ""], [63985, 1, ""], [63986, 1, ""], [63987, 1, ""], [63988, 1, ""], [63989, 1, ""], [63990, 1, ""], [63991, 1, ""], [63992, 1, ""], [63993, 1, ""], [63994, 1, ""], [63995, 1, ""], [63996, 1, ""], [63997, 1, ""], [63998, 1, ""], [63999, 1, ""], [64000, 1, ""], [64001, 1, ""], [64002, 1, ""], [64003, 1, ""], [64004, 1, ""], [64005, 1, ""], [64006, 1, ""], [64007, 1, ""], [64008, 1, ""], [64009, 1, ""], [64010, 1, ""], [64011, 1, ""], [64012, 1, ""], [64013, 1, ""], [[64014, 64015], 2], [64016, 1, ""], [64017, 2], [64018, 1, ""], [[64019, 64020], 2], [64021, 1, ""], [64022, 1, ""], [64023, 1, ""], [64024, 1, ""], [64025, 1, ""], [64026, 1, ""], [64027, 1, ""], [64028, 1, ""], [64029, 1, ""], [64030, 1, ""], [64031, 2], [64032, 1, ""], [64033, 2], [64034, 1, ""], [[64035, 64036], 2], [64037, 1, ""], [64038, 1, ""], [[64039, 64041], 2], [64042, 1, ""], [64043, 1, ""], [64044, 1, ""], [64045, 1, ""], [64046, 1, ""], [64047, 1, ""], [64048, 1, ""], [64049, 1, ""], [64050, 1, ""], [64051, 1, ""], [64052, 1, ""], [64053, 1, ""], [64054, 1, ""], [64055, 1, ""], [64056, 1, ""], [64057, 1, ""], [64058, 1, ""], [64059, 1, ""], [64060, 1, ""], [64061, 1, ""], [64062, 1, ""], [64063, 1, ""], [64064, 1, ""], [64065, 1, ""], [64066, 1, ""], [64067, 1, ""], [64068, 1, ""], [64069, 1, ""], [64070, 1, ""], [64071, 1, ""], [64072, 1, ""], [64073, 1, ""], [64074, 1, ""], [64075, 1, ""], [64076, 1, ""], [64077, 1, ""], [64078, 1, ""], [64079, 1, ""], [64080, 1, ""], [64081, 1, ""], [64082, 1, ""], [64083, 1, ""], [64084, 1, ""], [64085, 1, ""], [64086, 1, ""], [64087, 1, ""], [64088, 1, ""], [64089, 1, ""], [64090, 1, ""], [64091, 1, ""], [64092, 1, ""], [[64093, 64094], 1, ""], [64095, 1, ""], [64096, 1, ""], [64097, 1, ""], [64098, 1, ""], [64099, 1, ""], [64100, 1, ""], [64101, 1, ""], [64102, 1, ""], [64103, 1, ""], [64104, 1, ""], [64105, 1, ""], [64106, 1, ""], [64107, 1, ""], [64108, 1, ""], [64109, 1, ""], [[64110, 64111], 3], [64112, 1, ""], [64113, 1, ""], [64114, 1, ""], [64115, 1, ""], [64116, 1, ""], [64117, 1, ""], [64118, 1, ""], [64119, 1, ""], [64120, 1, ""], [64121, 1, ""], [64122, 1, ""], [64123, 1, ""], [64124, 1, ""], [64125, 1, ""], [64126, 1, ""], [64127, 1, ""], [64128, 1, ""], [64129, 1, ""], [64130, 1, ""], [64131, 1, ""], [64132, 1, ""], [64133, 1, ""], [64134, 1, ""], [64135, 1, ""], [64136, 1, ""], [64137, 1, ""], [64138, 1, ""], [64139, 1, ""], [64140, 1, ""], [64141, 1, ""], [64142, 1, ""], [64143, 1, ""], [64144, 1, ""], [64145, 1, ""], [64146, 1, ""], [64147, 1, ""], [64148, 1, ""], [64149, 1, ""], [64150, 1, ""], [64151, 1, ""], [64152, 1, ""], [64153, 1, ""], [64154, 1, ""], [64155, 1, ""], [64156, 1, ""], [64157, 1, ""], [64158, 1, ""], [64159, 1, ""], [64160, 1, ""], [64161, 1, ""], [64162, 1, ""], [64163, 1, ""], [64164, 1, ""], [64165, 1, ""], [64166, 1, ""], [64167, 1, ""], [64168, 1, ""], [64169, 1, ""], [64170, 1, ""], [64171, 1, ""], [64172, 1, ""], [64173, 1, ""], [64174, 1, ""], [64175, 1, ""], [64176, 1, ""], [64177, 1, ""], [64178, 1, ""], [64179, 1, ""], [64180, 1, ""], [64181, 1, ""], [64182, 1, ""], [64183, 1, ""], [64184, 1, ""], [64185, 1, ""], [64186, 1, ""], [64187, 1, ""], [64188, 1, ""], [64189, 1, ""], [64190, 1, ""], [64191, 1, ""], [64192, 1, ""], [64193, 1, ""], [64194, 1, ""], [64195, 1, ""], [64196, 1, ""], [64197, 1, ""], [64198, 1, ""], [64199, 1, ""], [64200, 1, ""], [64201, 1, ""], [64202, 1, ""], [64203, 1, ""], [64204, 1, ""], [64205, 1, ""], [64206, 1, ""], [64207, 1, ""], [64208, 1, ""], [64209, 1, ""], [64210, 1, ""], [64211, 1, ""], [64212, 1, ""], [64213, 1, ""], [64214, 1, ""], [64215, 1, ""], [64216, 1, ""], [64217, 1, ""], [[64218, 64255], 3], [64256, 1, "ff"], [64257, 1, "fi"], [64258, 1, "fl"], [64259, 1, "ffi"], [64260, 1, "ffl"], [[64261, 64262], 1, "st"], [[64263, 64274], 3], [64275, 1, ""], [64276, 1, ""], [64277, 1, ""], [64278, 1, ""], [64279, 1, ""], [[64280, 64284], 3], [64285, 1, ""], [64286, 2], [64287, 1, ""], [64288, 1, ""], [64289, 1, ""], [64290, 1, ""], [64291, 1, ""], [64292, 1, ""], [64293, 1, ""], [64294, 1, ""], [64295, 1, ""], [64296, 1, ""], [64297, 5, "+"], [64298, 1, ""], [64299, 1, ""], [64300, 1, ""], [64301, 1, ""], [64302, 1, ""], [64303, 1, ""], [64304, 1, ""], [64305, 1, ""], [64306, 1, ""], [64307, 1, ""], [64308, 1, ""], [64309, 1, ""], [64310, 1, ""], [64311, 3], [64312, 1, ""], [64313, 1, ""], [64314, 1, ""], [64315, 1, ""], [64316, 1, ""], [64317, 3], [64318, 1, ""], [64319, 3], [64320, 1, ""], [64321, 1, ""], [64322, 3], [64323, 1, ""], [64324, 1, ""], [64325, 3], [64326, 1, ""], [64327, 1, ""], [64328, 1, ""], [64329, 1, ""], [64330, 1, ""], [64331, 1, ""], [64332, 1, ""], [64333, 1, ""], [64334, 1, ""], [64335, 1, ""], [[64336, 64337], 1, ""], [[64338, 64341], 1, ""], [[64342, 64345], 1, ""], [[64346, 64349], 1, ""], [[64350, 64353], 1, ""], [[64354, 64357], 1, ""], [[64358, 64361], 1, ""], [[64362, 64365], 1, ""], [[64366, 64369], 1, ""], [[64370, 64373], 1, ""], [[64374, 64377], 1, ""], [[64378, 64381], 1, ""], [[64382, 64385], 1, ""], [[64386, 64387], 1, ""], [[64388, 64389], 1, ""], [[64390, 64391], 1, ""], [[64392, 64393], 1, ""], [[64394, 64395], 1, ""], [[64396, 64397], 1, ""], [[64398, 64401], 1, ""], [[64402, 64405], 1, ""], [[64406, 64409], 1, ""], [[64410, 64413], 1, ""], [[64414, 64415], 1, ""], [[64416, 64419], 1, ""], [[64420, 64421], 1, ""], [[64422, 64425], 1, ""], [[64426, 64429], 1, ""], [[64430, 64431], 1, ""], [[64432, 64433], 1, ""], [[64434, 64449], 2], [64450, 2], [[64451, 64466], 3], [[64467, 64470], 1, ""], [[64471, 64472], 1, ""], [[64473, 64474], 1, ""], [[64475, 64476], 1, ""], [64477, 1, ""], [[64478, 64479], 1, ""], [[64480, 64481], 1, ""], [[64482, 64483], 1, ""], [[64484, 64487], 1, ""], [[64488, 64489], 1, ""], [[64490, 64491], 1, ""], [[64492, 64493], 1, ""], [[64494, 64495], 1, ""], [[64496, 64497], 1, ""], [[64498, 64499], 1, ""], [[64500, 64501], 1, ""], [[64502, 64504], 1, ""], [[64505, 64507], 1, ""], [[64508, 64511], 1, ""], [64512, 1, ""], [64513, 1, ""], [64514, 1, ""], [64515, 1, ""], [64516, 1, ""], [64517, 1, ""], [64518, 1, ""], [64519, 1, ""], [64520, 1, ""], [64521, 1, ""], [64522, 1, ""], [64523, 1, ""], [64524, 1, ""], [64525, 1, ""], [64526, 1, ""], [64527, 1, ""], [64528, 1, ""], [64529, 1, ""], [64530, 1, ""], [64531, 1, ""], [64532, 1, ""], [64533, 1, ""], [64534, 1, ""], [64535, 1, ""], [64536, 1, ""], [64537, 1, ""], [64538, 1, ""], [64539, 1, ""], [64540, 1, ""], [64541, 1, ""], [64542, 1, ""], [64543, 1, ""], [64544, 1, ""], [64545, 1, ""], [64546, 1, ""], [64547, 1, ""], [64548, 1, ""], [64549, 1, ""], [64550, 1, ""], [64551, 1, ""], [64552, 1, ""], [64553, 1, ""], [64554, 1, ""], [64555, 1, ""], [64556, 1, ""], [64557, 1, ""], [64558, 1, ""], [64559, 1, ""], [64560, 1, ""], [64561, 1, ""], [64562, 1, ""], [64563, 1, ""], [64564, 1, ""], [64565, 1, ""], [64566, 1, ""], [64567, 1, ""], [64568, 1, ""], [64569, 1, ""], [64570, 1, ""], [64571, 1, ""], [64572, 1, ""], [64573, 1, ""], [64574, 1, ""], [64575, 1, ""], [64576, 1, ""], [64577, 1, ""], [64578, 1, ""], [64579, 1, ""], [64580, 1, ""], [64581, 1, ""], [64582, 1, ""], [64583, 1, ""], [64584, 1, ""], [64585, 1, ""], [64586, 1, ""], [64587, 1, ""], [64588, 1, ""], [64589, 1, ""], [64590, 1, ""], [64591, 1, ""], [64592, 1, ""], [64593, 1, ""], [64594, 1, ""], [64595, 1, ""], [64596, 1, ""], [64597, 1, ""], [64598, 1, ""], [64599, 1, ""], [64600, 1, ""], [64601, 1, ""], [64602, 1, ""], [64603, 1, ""], [64604, 1, ""], [64605, 1, ""], [64606, 5, " "], [64607, 5, " "], [64608, 5, " "], [64609, 5, " "], [64610, 5, " "], [64611, 5, " "], [64612, 1, ""], [64613, 1, ""], [64614, 1, ""], [64615, 1, ""], [64616, 1, ""], [64617, 1, ""], [64618, 1, ""], [64619, 1, ""], [64620, 1, ""], [64621, 1, ""], [64622, 1, ""], [64623, 1, ""], [64624, 1, ""], [64625, 1, ""], [64626, 1, ""], [64627, 1, ""], [64628, 1, ""], [64629, 1, ""], [64630, 1, ""], [64631, 1, ""], [64632, 1, ""], [64633, 1, ""], [64634, 1, ""], [64635, 1, ""], [64636, 1, ""], [64637, 1, ""], [64638, 1, ""], [64639, 1, ""], [64640, 1, ""], [64641, 1, ""], [64642, 1, ""], [64643, 1, ""], [64644, 1, ""], [64645, 1, ""], [64646, 1, ""], [64647, 1, ""], [64648, 1, ""], [64649, 1, ""], [64650, 1, ""], [64651, 1, ""], [64652, 1, ""], [64653, 1, ""], [64654, 1, ""], [64655, 1, ""], [64656, 1, ""], [64657, 1, ""], [64658, 1, ""], [64659, 1, ""], [64660, 1, ""], [64661, 1, ""], [64662, 1, ""], [64663, 1, ""], [64664, 1, ""], [64665, 1, ""], [64666, 1, ""], [64667, 1, ""], [64668, 1, ""], [64669, 1, ""], [64670, 1, ""], [64671, 1, ""], [64672, 1, ""], [64673, 1, ""], [64674, 1, ""], [64675, 1, ""], [64676, 1, ""], [64677, 1, ""], [64678, 1, ""], [64679, 1, ""], [64680, 1, ""], [64681, 1, ""], [64682, 1, ""], [64683, 1, ""], [64684, 1, ""], [64685, 1, ""], [64686, 1, ""], [64687, 1, ""], [64688, 1, ""], [64689, 1, ""], [64690, 1, ""], [64691, 1, ""], [64692, 1, ""], [64693, 1, ""], [64694, 1, ""], [64695, 1, ""], [64696, 1, ""], [64697, 1, ""], [64698, 1, ""], [64699, 1, ""], [64700, 1, ""], [64701, 1, ""], [64702, 1, ""], [64703, 1, ""], [64704, 1, ""], [64705, 1, ""], [64706, 1, ""], [64707, 1, ""], [64708, 1, ""], [64709, 1, ""], [64710, 1, ""], [64711, 1, ""], [64712, 1, ""], [64713, 1, ""], [64714, 1, ""], [64715, 1, ""], [64716, 1, ""], [64717, 1, ""], [64718, 1, ""], [64719, 1, ""], [64720, 1, ""], [64721, 1, ""], [64722, 1, ""], [64723, 1, ""], [64724, 1, ""], [64725, 1, ""], [64726, 1, ""], [64727, 1, ""], [64728, 1, ""], [64729, 1, ""], [64730, 1, ""], [64731, 1, ""], [64732, 1, ""], [64733, 1, ""], [64734, 1, ""], [64735, 1, ""], [64736, 1, ""], [64737, 1, ""], [64738, 1, ""], [64739, 1, ""], [64740, 1, ""], [64741, 1, ""], [64742, 1, ""], [64743, 1, ""], [64744, 1, ""], [64745, 1, ""], [64746, 1, ""], [64747, 1, ""], [64748, 1, ""], [64749, 1, ""], [64750, 1, ""], [64751, 1, ""], [64752, 1, ""], [64753, 1, ""], [64754, 1, ""], [64755, 1, ""], [64756, 1, ""], [64757, 1, ""], [64758, 1, ""], [64759, 1, ""], [64760, 1, ""], [64761, 1, ""], [64762, 1, ""], [64763, 1, ""], [64764, 1, ""], [64765, 1, ""], [64766, 1, ""], [64767, 1, ""], [64768, 1, ""], [64769, 1, ""], [64770, 1, ""], [64771, 1, ""], [64772, 1, ""], [64773, 1, ""], [64774, 1, ""], [64775, 1, ""], [64776, 1, ""], [64777, 1, ""], [64778, 1, ""], [64779, 1, ""], [64780, 1, ""], [64781, 1, ""], [64782, 1, ""], [64783, 1, ""], [64784, 1, ""], [64785, 1, ""], [64786, 1, ""], [64787, 1, ""], [64788, 1, ""], [64789, 1, ""], [64790, 1, ""], [64791, 1, ""], [64792, 1, ""], [64793, 1, ""], [64794, 1, ""], [64795, 1, ""], [64796, 1, ""], [64797, 1, ""], [64798, 1, ""], [64799, 1, ""], [64800, 1, ""], [64801, 1, ""], [64802, 1, ""], [64803, 1, ""], [64804, 1, ""], [64805, 1, ""], [64806, 1, ""], [64807, 1, ""], [64808, 1, ""], [64809, 1, ""], [64810, 1, ""], [64811, 1, ""], [64812, 1, ""], [64813, 1, ""], [64814, 1, ""], [64815, 1, ""], [64816, 1, ""], [64817, 1, ""], [64818, 1, ""], [64819, 1, ""], [64820, 1, ""], [64821, 1, ""], [64822, 1, ""], [64823, 1, ""], [64824, 1, ""], [64825, 1, ""], [64826, 1, ""], [64827, 1, ""], [[64828, 64829], 1, ""], [[64830, 64831], 2], [[64832, 64847], 2], [64848, 1, ""], [[64849, 64850], 1, ""], [64851, 1, ""], [64852, 1, ""], [64853, 1, ""], [64854, 1, ""], [64855, 1, ""], [[64856, 64857], 1, ""], [64858, 1, ""], [64859, 1, ""], [64860, 1, ""], [64861, 1, ""], [64862, 1, ""], [[64863, 64864], 1, ""], [64865, 1, ""], [[64866, 64867], 1, ""], [[64868, 64869], 1, ""], [64870, 1, ""], [[64871, 64872], 1, ""], [64873, 1, ""], [[64874, 64875], 1, ""], [[64876, 64877], 1, ""], [64878, 1, ""], [[64879, 64880], 1, ""], [[64881, 64882], 1, ""], [64883, 1, ""], [64884, 1, ""], [64885, 1, ""], [[64886, 64887], 1, ""], [64888, 1, ""], [64889, 1, ""], [64890, 1, ""], [64891, 1, ""], [[64892, 64893], 1, ""], [64894, 1, ""], [64895, 1, ""], [64896, 1, ""], [64897, 1, ""], [64898, 1, ""], [[64899, 64900], 1, ""], [[64901, 64902], 1, ""], [[64903, 64904], 1, ""], [64905, 1, ""], [64906, 1, ""], [64907, 1, ""], [64908, 1, ""], [64909, 1, ""], [64910, 1, ""], [64911, 1, ""], [[64912, 64913], 3], [64914, 1, ""], [64915, 1, ""], [64916, 1, ""], [64917, 1, ""], [64918, 1, ""], [[64919, 64920], 1, ""], [64921, 1, ""], [64922, 1, ""], [64923, 1, ""], [[64924, 64925], 1, ""], [64926, 1, ""], [64927, 1, ""], [64928, 1, ""], [64929, 1, ""], [64930, 1, ""], [64931, 1, ""], [64932, 1, ""], [64933, 1, ""], [64934, 1, ""], [64935, 1, ""], [64936, 1, ""], [64937, 1, ""], [64938, 1, ""], [64939, 1, ""], [64940, 1, ""], [64941, 1, ""], [64942, 1, ""], [64943, 1, ""], [64944, 1, ""], [64945, 1, ""], [64946, 1, ""], [64947, 1, ""], [64948, 1, ""], [64949, 1, ""], [64950, 1, ""], [64951, 1, ""], [64952, 1, ""], [64953, 1, ""], [64954, 1, ""], [64955, 1, ""], [64956, 1, ""], [64957, 1, ""], [64958, 1, ""], [64959, 1, ""], [64960, 1, ""], [64961, 1, ""], [64962, 1, ""], [64963, 1, ""], [64964, 1, ""], [64965, 1, ""], [64966, 1, ""], [64967, 1, ""], [[64968, 64974], 3], [64975, 2], [[64976, 65007], 3], [65008, 1, ""], [65009, 1, ""], [65010, 1, ""], [65011, 1, ""], [65012, 1, ""], [65013, 1, ""], [65014, 1, ""], [65015, 1, ""], [65016, 1, ""], [65017, 1, ""], [65018, 5, "   "], [65019, 5, " "], [65020, 1, ""], [65021, 2], [[65022, 65023], 2], [[65024, 65039], 7], [65040, 5, ","], [65041, 1, ""], [65042, 3], [65043, 5, ":"], [65044, 5, ";"], [65045, 5, "!"], [65046, 5, "?"], [65047, 1, ""], [65048, 1, ""], [65049, 3], [[65050, 65055], 3], [[65056, 65059], 2], [[65060, 65062], 2], [[65063, 65069], 2], [[65070, 65071], 2], [65072, 3], [65073, 1, ""], [65074, 1, ""], [[65075, 65076], 5, "_"], [65077, 5, "("], [65078, 5, ")"], [65079, 5, "{"], [65080, 5, "}"], [65081, 1, ""], [65082, 1, ""], [65083, 1, ""], [65084, 1, ""], [65085, 1, ""], [65086, 1, ""], [65087, 1, ""], [65088, 1, ""], [65089, 1, ""], [65090, 1, ""], [65091, 1, ""], [65092, 1, ""], [[65093, 65094], 2], [65095, 5, "["], [65096, 5, "]"], [[65097, 65100], 5, " "], [[65101, 65103], 5, "_"], [65104, 5, ","], [65105, 1, ""], [65106, 3], [65107, 3], [65108, 5, ";"], [65109, 5, ":"], [65110, 5, "?"], [65111, 5, "!"], [65112, 1, ""], [65113, 5, "("], [65114, 5, ")"], [65115, 5, "{"], [65116, 5, "}"], [65117, 1, ""], [65118, 1, ""], [65119, 5, "#"], [65120, 5, "&"], [65121, 5, "*"], [65122, 5, "+"], [65123, 1, "-"], [65124, 5, "<"], [65125, 5, ">"], [65126, 5, "="], [65127, 3], [65128, 5, "\\"], [65129, 5, "$"], [65130, 5, "%"], [65131, 5, "@"], [[65132, 65135], 3], [65136, 5, " "], [65137, 1, ""], [65138, 5, " "], [65139, 2], [65140, 5, " "], [65141, 3], [65142, 5, " "], [65143, 1, ""], [65144, 5, " "], [65145, 1, ""], [65146, 5, " "], [65147, 1, ""], [65148, 5, " "], [65149, 1, ""], [65150, 5, " "], [65151, 1, ""], [65152, 1, ""], [[65153, 65154], 1, ""], [[65155, 65156], 1, ""], [[65157, 65158], 1, ""], [[65159, 65160], 1, ""], [[65161, 65164], 1, ""], [[65165, 65166], 1, ""], [[65167, 65170], 1, ""], [[65171, 65172], 1, ""], [[65173, 65176], 1, ""], [[65177, 65180], 1, ""], [[65181, 65184], 1, ""], [[65185, 65188], 1, ""], [[65189, 65192], 1, ""], [[65193, 65194], 1, ""], [[65195, 65196], 1, ""], [[65197, 65198], 1, ""], [[65199, 65200], 1, ""], [[65201, 65204], 1, ""], [[65205, 65208], 1, ""], [[65209, 65212], 1, ""], [[65213, 65216], 1, ""], [[65217, 65220], 1, ""], [[65221, 65224], 1, ""], [[65225, 65228], 1, ""], [[65229, 65232], 1, ""], [[65233, 65236], 1, ""], [[65237, 65240], 1, ""], [[65241, 65244], 1, ""], [[65245, 65248], 1, ""], [[65249, 65252], 1, ""], [[65253, 65256], 1, ""], [[65257, 65260], 1, ""], [[65261, 65262], 1, ""], [[65263, 65264], 1, ""], [[65265, 65268], 1, ""], [[65269, 65270], 1, ""], [[65271, 65272], 1, ""], [[65273, 65274], 1, ""], [[65275, 65276], 1, ""], [[65277, 65278], 3], [65279, 7], [65280, 3], [65281, 5, "!"], [65282, 5, "\""], [65283, 5, "#"], [65284, 5, "$"], [65285, 5, "%"], [65286, 5, "&"], [65287, 5, "'"], [65288, 5, "("], [65289, 5, ")"], [65290, 5, "*"], [65291, 5, "+"], [65292, 5, ","], [65293, 1, "-"], [65294, 1, "."], [65295, 5, "/"], [65296, 1, "0"], [65297, 1, "1"], [65298, 1, "2"], [65299, 1, "3"], [65300, 1, "4"], [65301, 1, "5"], [65302, 1, "6"], [65303, 1, "7"], [65304, 1, "8"], [65305, 1, "9"], [65306, 5, ":"], [65307, 5, ";"], [65308, 5, "<"], [65309, 5, "="], [65310, 5, ">"], [65311, 5, "?"], [65312, 5, "@"], [65313, 1, "a"], [65314, 1, "b"], [65315, 1, "c"], [65316, 1, "d"], [65317, 1, "e"], [65318, 1, "f"], [65319, 1, "g"], [65320, 1, "h"], [65321, 1, "i"], [65322, 1, "j"], [65323, 1, "k"], [65324, 1, "l"], [65325, 1, "m"], [65326, 1, "n"], [65327, 1, "o"], [65328, 1, "p"], [65329, 1, "q"], [65330, 1, "r"], [65331, 1, "s"], [65332, 1, "t"], [65333, 1, "u"], [65334, 1, "v"], [65335, 1, "w"], [65336, 1, "x"], [65337, 1, "y"], [65338, 1, "z"], [65339, 5, "["], [65340, 5, "\\"], [65341, 5, "]"], [65342, 5, "^"], [65343, 5, "_"], [65344, 5, "`"], [65345, 1, "a"], [65346, 1, "b"], [65347, 1, "c"], [65348, 1, "d"], [65349, 1, "e"], [65350, 1, "f"], [65351, 1, "g"], [65352, 1, "h"], [65353, 1, "i"], [65354, 1, "j"], [65355, 1, "k"], [65356, 1, "l"], [65357, 1, "m"], [65358, 1, "n"], [65359, 1, "o"], [65360, 1, "p"], [65361, 1, "q"], [65362, 1, "r"], [65363, 1, "s"], [65364, 1, "t"], [65365, 1, "u"], [65366, 1, "v"], [65367, 1, "w"], [65368, 1, "x"], [65369, 1, "y"], [65370, 1, "z"], [65371, 5, "{"], [65372, 5, "|"], [65373, 5, "}"], [65374, 5, "~"], [65375, 1, ""], [65376, 1, ""], [65377, 1, "."], [65378, 1, ""], [65379, 1, ""], [65380, 1, ""], [65381, 1, ""], [65382, 1, ""], [65383, 1, ""], [65384, 1, ""], [65385, 1, ""], [65386, 1, ""], [65387, 1, ""], [65388, 1, ""], [65389, 1, ""], [65390, 1, ""], [65391, 1, ""], [65392, 1, ""], [65393, 1, ""], [65394, 1, ""], [65395, 1, ""], [65396, 1, ""], [65397, 1, ""], [65398, 1, ""], [65399, 1, ""], [65400, 1, ""], [65401, 1, ""], [65402, 1, ""], [65403, 1, ""], [65404, 1, ""], [65405, 1, ""], [65406, 1, ""], [65407, 1, ""], [65408, 1, ""], [65409, 1, ""], [65410, 1, ""], [65411, 1, ""], [65412, 1, ""], [65413, 1, ""], [65414, 1, ""], [65415, 1, ""], [65416, 1, ""], [65417, 1, ""], [65418, 1, ""], [65419, 1, ""], [65420, 1, ""], [65421, 1, ""], [65422, 1, ""], [65423, 1, ""], [65424, 1, ""], [65425, 1, ""], [65426, 1, ""], [65427, 1, ""], [65428, 1, ""], [65429, 1, ""], [65430, 1, ""], [65431, 1, ""], [65432, 1, ""], [65433, 1, ""], [65434, 1, ""], [65435, 1, ""], [65436, 1, ""], [65437, 1, ""], [65438, 1, ""], [65439, 1, ""], [65440, 3], [65441, 1, ""], [65442, 1, ""], [65443, 1, ""], [65444, 1, ""], [65445, 1, ""], [65446, 1, ""], [65447, 1, ""], [65448, 1, ""], [65449, 1, ""], [65450, 1, ""], [65451, 1, ""], [65452, 1, ""], [65453, 1, ""], [65454, 1, ""], [65455, 1, ""], [65456, 1, ""], [65457, 1, ""], [65458, 1, ""], [65459, 1, ""], [65460, 1, ""], [65461, 1, ""], [65462, 1, ""], [65463, 1, ""], [65464, 1, ""], [65465, 1, ""], [65466, 1, ""], [65467, 1, ""], [65468, 1, ""], [65469, 1, ""], [65470, 1, ""], [[65471, 65473], 3], [65474, 1, ""], [65475, 1, ""], [65476, 1, ""], [65477, 1, ""], [65478, 1, ""], [65479, 1, ""], [[65480, 65481], 3], [65482, 1, ""], [65483, 1, ""], [65484, 1, ""], [65485, 1, ""], [65486, 1, ""], [65487, 1, ""], [[65488, 65489], 3], [65490, 1, ""], [65491, 1, ""], [65492, 1, ""], [65493, 1, ""], [65494, 1, ""], [65495, 1, ""], [[65496, 65497], 3], [65498, 1, ""], [65499, 1, ""], [65500, 1, ""], [[65501, 65503], 3], [65504, 1, ""], [65505, 1, ""], [65506, 1, ""], [65507, 5, " "], [65508, 1, ""], [65509, 1, ""], [65510, 1, ""], [65511, 3], [65512, 1, ""], [65513, 1, ""], [65514, 1, ""], [65515, 1, ""], [65516, 1, ""], [65517, 1, ""], [65518, 1, ""], [[65519, 65528], 3], [[65529, 65531], 3], [65532, 3], [65533, 3], [[65534, 65535], 3], [[65536, 65547], 2], [65548, 3], [[65549, 65574], 2], [65575, 3], [[65576, 65594], 2], [65595, 3], [[65596, 65597], 2], [65598, 3], [[65599, 65613], 2], [[65614, 65615], 3], [[65616, 65629], 2], [[65630, 65663], 3], [[65664, 65786], 2], [[65787, 65791], 3], [[65792, 65794], 2], [[65795, 65798], 3], [[65799, 65843], 2], [[65844, 65846], 3], [[65847, 65855], 2], [[65856, 65930], 2], [[65931, 65932], 2], [[65933, 65934], 2], [65935, 3], [[65936, 65947], 2], [65948, 2], [[65949, 65951], 3], [65952, 2], [[65953, 65999], 3], [[66000, 66044], 2], [66045, 2], [[66046, 66175], 3], [[66176, 66204], 2], [[66205, 66207], 3], [[66208, 66256], 2], [[66257, 66271], 3], [66272, 2], [[66273, 66299], 2], [[66300, 66303], 3], [[66304, 66334], 2], [66335, 2], [[66336, 66339], 2], [[66340, 66348], 3], [[66349, 66351], 2], [[66352, 66368], 2], [66369, 2], [[66370, 66377], 2], [66378, 2], [[66379, 66383], 3], [[66384, 66426], 2], [[66427, 66431], 3], [[66432, 66461], 2], [66462, 3], [66463, 2], [[66464, 66499], 2], [[66500, 66503], 3], [[66504, 66511], 2], [[66512, 66517], 2], [[66518, 66559], 3], [66560, 1, ""], [66561, 1, ""], [66562, 1, ""], [66563, 1, ""], [66564, 1, ""], [66565, 1, ""], [66566, 1, ""], [66567, 1, ""], [66568, 1, ""], [66569, 1, ""], [66570, 1, ""], [66571, 1, ""], [66572, 1, ""], [66573, 1, ""], [66574, 1, ""], [66575, 1, ""], [66576, 1, ""], [66577, 1, ""], [66578, 1, ""], [66579, 1, ""], [66580, 1, ""], [66581, 1, ""], [66582, 1, ""], [66583, 1, ""], [66584, 1, ""], [66585, 1, ""], [66586, 1, ""], [66587, 1, ""], [66588, 1, ""], [66589, 1, ""], [66590, 1, ""], [66591, 1, ""], [66592, 1, ""], [66593, 1, ""], [66594, 1, ""], [66595, 1, ""], [66596, 1, ""], [66597, 1, ""], [66598, 1, ""], [66599, 1, ""], [[66600, 66637], 2], [[66638, 66717], 2], [[66718, 66719], 3], [[66720, 66729], 2], [[66730, 66735], 3], [66736, 1, ""], [66737, 1, ""], [66738, 1, ""], [66739, 1, ""], [66740, 1, ""], [66741, 1, ""], [66742, 1, ""], [66743, 1, ""], [66744, 1, ""], [66745, 1, ""], [66746, 1, ""], [66747, 1, ""], [66748, 1, ""], [66749, 1, ""], [66750, 1, ""], [66751, 1, ""], [66752, 1, ""], [66753, 1, ""], [66754, 1, ""], [66755, 1, ""], [66756, 1, ""], [66757, 1, ""], [66758, 1, ""], [66759, 1, ""], [66760, 1, ""], [66761, 1, ""], [66762, 1, ""], [66763, 1, ""], [66764, 1, ""], [66765, 1, ""], [66766, 1, ""], [66767, 1, ""], [66768, 1, ""], [66769, 1, ""], [66770, 1, ""], [66771, 1, ""], [[66772, 66775], 3], [[66776, 66811], 2], [[66812, 66815], 3], [[66816, 66855], 2], [[66856, 66863], 3], [[66864, 66915], 2], [[66916, 66926], 3], [66927, 2], [66928, 1, ""], [66929, 1, ""], [66930, 1, ""], [66931, 1, ""], [66932, 1, ""], [66933, 1, ""], [66934, 1, ""], [66935, 1, ""], [66936, 1, ""], [66937, 1, ""], [66938, 1, ""], [66939, 3], [66940, 1, ""], [66941, 1, ""], [66942, 1, ""], [66943, 1, ""], [66944, 1, ""], [66945, 1, ""], [66946, 1, ""], [66947, 1, ""], [66948, 1, ""], [66949, 1, ""], [66950, 1, ""], [66951, 1, ""], [66952, 1, ""], [66953, 1, ""], [66954, 1, ""], [66955, 3], [66956, 1, ""], [66957, 1, ""], [66958, 1, ""], [66959, 1, ""], [66960, 1, ""], [66961, 1, ""], [66962, 1, ""], [66963, 3], [66964, 1, ""], [66965, 1, ""], [66966, 3], [[66967, 66977], 2], [66978, 3], [[66979, 66993], 2], [66994, 3], [[66995, 67001], 2], [67002, 3], [[67003, 67004], 2], [[67005, 67071], 3], [[67072, 67382], 2], [[67383, 67391], 3], [[67392, 67413], 2], [[67414, 67423], 3], [[67424, 67431], 2], [[67432, 67455], 3], [67456, 2], [67457, 1, ""], [67458, 1, ""], [67459, 1, ""], [67460, 1, ""], [67461, 1, ""], [67462, 3], [67463, 1, ""], [67464, 1, ""], [67465, 1, ""], [67466, 1, ""], [67467, 1, ""], [67468, 1, ""], [67469, 1, ""], [67470, 1, ""], [67471, 1, ""], [67472, 1, ""], [67473, 1, ""], [67474, 1, ""], [67475, 1, ""], [67476, 1, ""], [67477, 1, ""], [67478, 1, ""], [67479, 1, ""], [67480, 1, ""], [67481, 1, ""], [67482, 1, ""], [67483, 1, ""], [67484, 1, ""], [67485, 1, ""], [67486, 1, ""], [67487, 1, ""], [67488, 1, ""], [67489, 1, ""], [67490, 1, ""], [67491, 1, ""], [67492, 1, ""], [67493, 1, "q"], [67494, 1, ""], [67495, 1, ""], [67496, 1, ""], [67497, 1, ""], [67498, 1, ""], [67499, 1, ""], [67500, 1, ""], [67501, 1, ""], [67502, 1, ""], [67503, 1, ""], [67504, 1, ""], [67505, 3], [67506, 1, ""], [67507, 1, ""], [67508, 1, ""], [67509, 1, ""], [67510, 1, ""], [67511, 1, ""], [67512, 1, ""], [67513, 1, ""], [67514, 1, ""], [[67515, 67583], 3], [[67584, 67589], 2], [[67590, 67591], 3], [67592, 2], [67593, 3], [[67594, 67637], 2], [67638, 3], [[67639, 67640], 2], [[67641, 67643], 3], [67644, 2], [[67645, 67646], 3], [67647, 2], [[67648, 67669], 2], [67670, 3], [[67671, 67679], 2], [[67680, 67702], 2], [[67703, 67711], 2], [[67712, 67742], 2], [[67743, 67750], 3], [[67751, 67759], 2], [[67760, 67807], 3], [[67808, 67826], 2], [67827, 3], [[67828, 67829], 2], [[67830, 67834], 3], [[67835, 67839], 2], [[67840, 67861], 2], [[67862, 67865], 2], [[67866, 67867], 2], [[67868, 67870], 3], [67871, 2], [[67872, 67897], 2], [[67898, 67902], 3], [67903, 2], [[67904, 67967], 3], [[67968, 68023], 2], [[68024, 68027], 3], [[68028, 68029], 2], [[68030, 68031], 2], [[68032, 68047], 2], [[68048, 68049], 3], [[68050, 68095], 2], [[68096, 68099], 2], [68100, 3], [[68101, 68102], 2], [[68103, 68107], 3], [[68108, 68115], 2], [68116, 3], [[68117, 68119], 2], [68120, 3], [[68121, 68147], 2], [[68148, 68149], 2], [[68150, 68151], 3], [[68152, 68154], 2], [[68155, 68158], 3], [68159, 2], [[68160, 68167], 2], [68168, 2], [[68169, 68175], 3], [[68176, 68184], 2], [[68185, 68191], 3], [[68192, 68220], 2], [[68221, 68223], 2], [[68224, 68252], 2], [[68253, 68255], 2], [[68256, 68287], 3], [[68288, 68295], 2], [68296, 2], [[68297, 68326], 2], [[68327, 68330], 3], [[68331, 68342], 2], [[68343, 68351], 3], [[68352, 68405], 2], [[68406, 68408], 3], [[68409, 68415], 2], [[68416, 68437], 2], [[68438, 68439], 3], [[68440, 68447], 2], [[68448, 68466], 2], [[68467, 68471], 3], [[68472, 68479], 2], [[68480, 68497], 2], [[68498, 68504], 3], [[68505, 68508], 2], [[68509, 68520], 3], [[68521, 68527], 2], [[68528, 68607], 3], [[68608, 68680], 2], [[68681, 68735], 3], [68736, 1, ""], [68737, 1, ""], [68738, 1, ""], [68739, 1, ""], [68740, 1, ""], [68741, 1, ""], [68742, 1, ""], [68743, 1, ""], [68744, 1, ""], [68745, 1, ""], [68746, 1, ""], [68747, 1, ""], [68748, 1, ""], [68749, 1, ""], [68750, 1, ""], [68751, 1, ""], [68752, 1, ""], [68753, 1, ""], [68754, 1, ""], [68755, 1, ""], [68756, 1, ""], [68757, 1, ""], [68758, 1, ""], [68759, 1, ""], [68760, 1, ""], [68761, 1, ""], [68762, 1, ""], [68763, 1, ""], [68764, 1, ""], [68765, 1, ""], [68766, 1, ""], [68767, 1, ""], [68768, 1, ""], [68769, 1, ""], [68770, 1, ""], [68771, 1, ""], [68772, 1, ""], [68773, 1, ""], [68774, 1, ""], [68775, 1, ""], [68776, 1, ""], [68777, 1, ""], [68778, 1, ""], [68779, 1, ""], [68780, 1, ""], [68781, 1, ""], [68782, 1, ""], [68783, 1, ""], [68784, 1, ""], [68785, 1, ""], [68786, 1, ""], [[68787, 68799], 3], [[68800, 68850], 2], [[68851, 68857], 3], [[68858, 68863], 2], [[68864, 68903], 2], [[68904, 68911], 3], [[68912, 68921], 2], [[68922, 69215], 3], [[69216, 69246], 2], [69247, 3], [[69248, 69289], 2], [69290, 3], [[69291, 69292], 2], [69293, 2], [[69294, 69295], 3], [[69296, 69297], 2], [[69298, 69372], 3], [[69373, 69375], 2], [[69376, 69404], 2], [[69405, 69414], 2], [69415, 2], [[69416, 69423], 3], [[69424, 69456], 2], [[69457, 69465], 2], [[69466, 69487], 3], [[69488, 69509], 2], [[69510, 69513], 2], [[69514, 69551], 3], [[69552, 69572], 2], [[69573, 69579], 2], [[69580, 69599], 3], [[69600, 69622], 2], [[69623, 69631], 3], [[69632, 69702], 2], [[69703, 69709], 2], [[69710, 69713], 3], [[69714, 69733], 2], [[69734, 69743], 2], [[69744, 69749], 2], [[69750, 69758], 3], [69759, 2], [[69760, 69818], 2], [[69819, 69820], 2], [69821, 3], [[69822, 69825], 2], [69826, 2], [[69827, 69836], 3], [69837, 3], [[69838, 69839], 3], [[69840, 69864], 2], [[69865, 69871], 3], [[69872, 69881], 2], [[69882, 69887], 3], [[69888, 69940], 2], [69941, 3], [[69942, 69951], 2], [[69952, 69955], 2], [[69956, 69958], 2], [69959, 2], [[69960, 69967], 3], [[69968, 70003], 2], [[70004, 70005], 2], [70006, 2], [[70007, 70015], 3], [[70016, 70084], 2], [[70085, 70088], 2], [[70089, 70092], 2], [70093, 2], [[70094, 70095], 2], [[70096, 70105], 2], [70106, 2], [70107, 2], [70108, 2], [[70109, 70111], 2], [70112, 3], [[70113, 70132], 2], [[70133, 70143], 3], [[70144, 70161], 2], [70162, 3], [[70163, 70199], 2], [[70200, 70205], 2], [70206, 2], [[70207, 70209], 2], [[70210, 70271], 3], [[70272, 70278], 2], [70279, 3], [70280, 2], [70281, 3], [[70282, 70285], 2], [70286, 3], [[70287, 70301], 2], [70302, 3], [[70303, 70312], 2], [70313, 2], [[70314, 70319], 3], [[70320, 70378], 2], [[70379, 70383], 3], [[70384, 70393], 2], [[70394, 70399], 3], [70400, 2], [[70401, 70403], 2], [70404, 3], [[70405, 70412], 2], [[70413, 70414], 3], [[70415, 70416], 2], [[70417, 70418], 3], [[70419, 70440], 2], [70441, 3], [[70442, 70448], 2], [70449, 3], [[70450, 70451], 2], [70452, 3], [[70453, 70457], 2], [70458, 3], [70459, 2], [[70460, 70468], 2], [[70469, 70470], 3], [[70471, 70472], 2], [[70473, 70474], 3], [[70475, 70477], 2], [[70478, 70479], 3], [70480, 2], [[70481, 70486], 3], [70487, 2], [[70488, 70492], 3], [[70493, 70499], 2], [[70500, 70501], 3], [[70502, 70508], 2], [[70509, 70511], 3], [[70512, 70516], 2], [[70517, 70655], 3], [[70656, 70730], 2], [[70731, 70735], 2], [[70736, 70745], 2], [70746, 2], [70747, 2], [70748, 3], [70749, 2], [70750, 2], [70751, 2], [[70752, 70753], 2], [[70754, 70783], 3], [[70784, 70853], 2], [70854, 2], [70855, 2], [[70856, 70863], 3], [[70864, 70873], 2], [[70874, 71039], 3], [[71040, 71093], 2], [[71094, 71095], 3], [[71096, 71104], 2], [[71105, 71113], 2], [[71114, 71127], 2], [[71128, 71133], 2], [[71134, 71167], 3], [[71168, 71232], 2], [[71233, 71235], 2], [71236, 2], [[71237, 71247], 3], [[71248, 71257], 2], [[71258, 71263], 3], [[71264, 71276], 2], [[71277, 71295], 3], [[71296, 71351], 2], [71352, 2], [71353, 2], [[71354, 71359], 3], [[71360, 71369], 2], [[71370, 71423], 3], [[71424, 71449], 2], [71450, 2], [[71451, 71452], 3], [[71453, 71467], 2], [[71468, 71471], 3], [[71472, 71481], 2], [[71482, 71487], 2], [[71488, 71494], 2], [[71495, 71679], 3], [[71680, 71738], 2], [71739, 2], [[71740, 71839], 3], [71840, 1, ""], [71841, 1, ""], [71842, 1, ""], [71843, 1, ""], [71844, 1, ""], [71845, 1, ""], [71846, 1, ""], [71847, 1, ""], [71848, 1, ""], [71849, 1, ""], [71850, 1, ""], [71851, 1, ""], [71852, 1, ""], [71853, 1, ""], [71854, 1, ""], [71855, 1, ""], [71856, 1, ""], [71857, 1, ""], [71858, 1, ""], [71859, 1, ""], [71860, 1, ""], [71861, 1, ""], [71862, 1, ""], [71863, 1, ""], [71864, 1, ""], [71865, 1, ""], [71866, 1, ""], [71867, 1, ""], [71868, 1, ""], [71869, 1, ""], [71870, 1, ""], [71871, 1, ""], [[71872, 71913], 2], [[71914, 71922], 2], [[71923, 71934], 3], [71935, 2], [[71936, 71942], 2], [[71943, 71944], 3], [71945, 2], [[71946, 71947], 3], [[71948, 71955], 2], [71956, 3], [[71957, 71958], 2], [71959, 3], [[71960, 71989], 2], [71990, 3], [[71991, 71992], 2], [[71993, 71994], 3], [[71995, 72003], 2], [[72004, 72006], 2], [[72007, 72015], 3], [[72016, 72025], 2], [[72026, 72095], 3], [[72096, 72103], 2], [[72104, 72105], 3], [[72106, 72151], 2], [[72152, 72153], 3], [[72154, 72161], 2], [72162, 2], [[72163, 72164], 2], [[72165, 72191], 3], [[72192, 72254], 2], [[72255, 72262], 2], [72263, 2], [[72264, 72271], 3], [[72272, 72323], 2], [[72324, 72325], 2], [[72326, 72345], 2], [[72346, 72348], 2], [72349, 2], [[72350, 72354], 2], [[72355, 72367], 3], [[72368, 72383], 2], [[72384, 72440], 2], [[72441, 72447], 3], [[72448, 72457], 2], [[72458, 72703], 3], [[72704, 72712], 2], [72713, 3], [[72714, 72758], 2], [72759, 3], [[72760, 72768], 2], [[72769, 72773], 2], [[72774, 72783], 3], [[72784, 72793], 2], [[72794, 72812], 2], [[72813, 72815], 3], [[72816, 72817], 2], [[72818, 72847], 2], [[72848, 72849], 3], [[72850, 72871], 2], [72872, 3], [[72873, 72886], 2], [[72887, 72959], 3], [[72960, 72966], 2], [72967, 3], [[72968, 72969], 2], [72970, 3], [[72971, 73014], 2], [[73015, 73017], 3], [73018, 2], [73019, 3], [[73020, 73021], 2], [73022, 3], [[73023, 73031], 2], [[73032, 73039], 3], [[73040, 73049], 2], [[73050, 73055], 3], [[73056, 73061], 2], [73062, 3], [[73063, 73064], 2], [73065, 3], [[73066, 73102], 2], [73103, 3], [[73104, 73105], 2], [73106, 3], [[73107, 73112], 2], [[73113, 73119], 3], [[73120, 73129], 2], [[73130, 73439], 3], [[73440, 73462], 2], [[73463, 73464], 2], [[73465, 73471], 3], [[73472, 73488], 2], [73489, 3], [[73490, 73530], 2], [[73531, 73533], 3], [[73534, 73538], 2], [[73539, 73551], 2], [[73552, 73561], 2], [[73562, 73647], 3], [73648, 2], [[73649, 73663], 3], [[73664, 73713], 2], [[73714, 73726], 3], [73727, 2], [[73728, 74606], 2], [[74607, 74648], 2], [74649, 2], [[74650, 74751], 3], [[74752, 74850], 2], [[74851, 74862], 2], [74863, 3], [[74864, 74867], 2], [74868, 2], [[74869, 74879], 3], [[74880, 75075], 2], [[75076, 77711], 3], [[77712, 77808], 2], [[77809, 77810], 2], [[77811, 77823], 3], [[77824, 78894], 2], [78895, 2], [[78896, 78904], 3], [[78905, 78911], 3], [[78912, 78933], 2], [[78934, 82943], 3], [[82944, 83526], 2], [[83527, 92159], 3], [[92160, 92728], 2], [[92729, 92735], 3], [[92736, 92766], 2], [92767, 3], [[92768, 92777], 2], [[92778, 92781], 3], [[92782, 92783], 2], [[92784, 92862], 2], [92863, 3], [[92864, 92873], 2], [[92874, 92879], 3], [[92880, 92909], 2], [[92910, 92911], 3], [[92912, 92916], 2], [92917, 2], [[92918, 92927], 3], [[92928, 92982], 2], [[92983, 92991], 2], [[92992, 92995], 2], [[92996, 92997], 2], [[92998, 93007], 3], [[93008, 93017], 2], [93018, 3], [[93019, 93025], 2], [93026, 3], [[93027, 93047], 2], [[93048, 93052], 3], [[93053, 93071], 2], [[93072, 93759], 3], [93760, 1, ""], [93761, 1, ""], [93762, 1, ""], [93763, 1, ""], [93764, 1, ""], [93765, 1, ""], [93766, 1, ""], [93767, 1, ""], [93768, 1, ""], [93769, 1, ""], [93770, 1, ""], [93771, 1, ""], [93772, 1, ""], [93773, 1, ""], [93774, 1, ""], [93775, 1, ""], [93776, 1, ""], [93777, 1, ""], [93778, 1, ""], [93779, 1, ""], [93780, 1, ""], [93781, 1, ""], [93782, 1, ""], [93783, 1, ""], [93784, 1, ""], [93785, 1, ""], [93786, 1, ""], [93787, 1, ""], [93788, 1, ""], [93789, 1, ""], [93790, 1, ""], [93791, 1, ""], [[93792, 93823], 2], [[93824, 93850], 2], [[93851, 93951], 3], [[93952, 94020], 2], [[94021, 94026], 2], [[94027, 94030], 3], [94031, 2], [[94032, 94078], 2], [[94079, 94087], 2], [[94088, 94094], 3], [[94095, 94111], 2], [[94112, 94175], 3], [94176, 2], [94177, 2], [94178, 2], [94179, 2], [94180, 2], [[94181, 94191], 3], [[94192, 94193], 2], [[94194, 94207], 3], [[94208, 100332], 2], [[100333, 100337], 2], [[100338, 100343], 2], [[100344, 100351], 3], [[100352, 101106], 2], [[101107, 101589], 2], [[101590, 101631], 3], [[101632, 101640], 2], [[101641, 110575], 3], [[110576, 110579], 2], [110580, 3], [[110581, 110587], 2], [110588, 3], [[110589, 110590], 2], [110591, 3], [[110592, 110593], 2], [[110594, 110878], 2], [[110879, 110882], 2], [[110883, 110897], 3], [110898, 2], [[110899, 110927], 3], [[110928, 110930], 2], [[110931, 110932], 3], [110933, 2], [[110934, 110947], 3], [[110948, 110951], 2], [[110952, 110959], 3], [[110960, 111355], 2], [[111356, 113663], 3], [[113664, 113770], 2], [[113771, 113775], 3], [[113776, 113788], 2], [[113789, 113791], 3], [[113792, 113800], 2], [[113801, 113807], 3], [[113808, 113817], 2], [[113818, 113819], 3], [113820, 2], [[113821, 113822], 2], [113823, 2], [[113824, 113827], 7], [[113828, 118527], 3], [[118528, 118573], 2], [[118574, 118575], 3], [[118576, 118598], 2], [[118599, 118607], 3], [[118608, 118723], 2], [[118724, 118783], 3], [[118784, 119029], 2], [[119030, 119039], 3], [[119040, 119078], 2], [[119079, 119080], 3], [119081, 2], [[119082, 119133], 2], [119134, 1, ""], [119135, 1, ""], [119136, 1, ""], [119137, 1, ""], [119138, 1, ""], [119139, 1, ""], [119140, 1, ""], [[119141, 119154], 2], [[119155, 119162], 3], [[119163, 119226], 2], [119227, 1, ""], [119228, 1, ""], [119229, 1, ""], [119230, 1, ""], [119231, 1, ""], [119232, 1, ""], [[119233, 119261], 2], [[119262, 119272], 2], [[119273, 119274], 2], [[119275, 119295], 3], [[119296, 119365], 2], [[119366, 119487], 3], [[119488, 119507], 2], [[119508, 119519], 3], [[119520, 119539], 2], [[119540, 119551], 3], [[119552, 119638], 2], [[119639, 119647], 3], [[119648, 119665], 2], [[119666, 119672], 2], [[119673, 119807], 3], [119808, 1, "a"], [119809, 1, "b"], [119810, 1, "c"], [119811, 1, "d"], [119812, 1, "e"], [119813, 1, "f"], [119814, 1, "g"], [119815, 1, "h"], [119816, 1, "i"], [119817, 1, "j"], [119818, 1, "k"], [119819, 1, "l"], [119820, 1, "m"], [119821, 1, "n"], [119822, 1, "o"], [119823, 1, "p"], [119824, 1, "q"], [119825, 1, "r"], [119826, 1, "s"], [119827, 1, "t"], [119828, 1, "u"], [119829, 1, "v"], [119830, 1, "w"], [119831, 1, "x"], [119832, 1, "y"], [119833, 1, "z"], [119834, 1, "a"], [119835, 1, "b"], [119836, 1, "c"], [119837, 1, "d"], [119838, 1, "e"], [119839, 1, "f"], [119840, 1, "g"], [119841, 1, "h"], [119842, 1, "i"], [119843, 1, "j"], [119844, 1, "k"], [119845, 1, "l"], [119846, 1, "m"], [119847, 1, "n"], [119848, 1, "o"], [119849, 1, "p"], [119850, 1, "q"], [119851, 1, "r"], [119852, 1, "s"], [119853, 1, "t"], [119854, 1, "u"], [119855, 1, "v"], [119856, 1, "w"], [119857, 1, "x"], [119858, 1, "y"], [119859, 1, "z"], [119860, 1, "a"], [119861, 1, "b"], [119862, 1, "c"], [119863, 1, "d"], [119864, 1, "e"], [119865, 1, "f"], [119866, 1, "g"], [119867, 1, "h"], [119868, 1, "i"], [119869, 1, "j"], [119870, 1, "k"], [119871, 1, "l"], [119872, 1, "m"], [119873, 1, "n"], [119874, 1, "o"], [119875, 1, "p"], [119876, 1, "q"], [119877, 1, "r"], [119878, 1, "s"], [119879, 1, "t"], [119880, 1, "u"], [119881, 1, "v"], [119882, 1, "w"], [119883, 1, "x"], [119884, 1, "y"], [119885, 1, "z"], [119886, 1, "a"], [119887, 1, "b"], [119888, 1, "c"], [119889, 1, "d"], [119890, 1, "e"], [119891, 1, "f"], [119892, 1, "g"], [119893, 3], [119894, 1, "i"], [119895, 1, "j"], [119896, 1, "k"], [119897, 1, "l"], [119898, 1, "m"], [119899, 1, "n"], [119900, 1, "o"], [119901, 1, "p"], [119902, 1, "q"], [119903, 1, "r"], [119904, 1, "s"], [119905, 1, "t"], [119906, 1, "u"], [119907, 1, "v"], [119908, 1, "w"], [119909, 1, "x"], [119910, 1, "y"], [119911, 1, "z"], [119912, 1, "a"], [119913, 1, "b"], [119914, 1, "c"], [119915, 1, "d"], [119916, 1, "e"], [119917, 1, "f"], [119918, 1, "g"], [119919, 1, "h"], [119920, 1, "i"], [119921, 1, "j"], [119922, 1, "k"], [119923, 1, "l"], [119924, 1, "m"], [119925, 1, "n"], [119926, 1, "o"], [119927, 1, "p"], [119928, 1, "q"], [119929, 1, "r"], [119930, 1, "s"], [119931, 1, "t"], [119932, 1, "u"], [119933, 1, "v"], [119934, 1, "w"], [119935, 1, "x"], [119936, 1, "y"], [119937, 1, "z"], [119938, 1, "a"], [119939, 1, "b"], [119940, 1, "c"], [119941, 1, "d"], [119942, 1, "e"], [119943, 1, "f"], [119944, 1, "g"], [119945, 1, "h"], [119946, 1, "i"], [119947, 1, "j"], [119948, 1, "k"], [119949, 1, "l"], [119950, 1, "m"], [119951, 1, "n"], [119952, 1, "o"], [119953, 1, "p"], [119954, 1, "q"], [119955, 1, "r"], [119956, 1, "s"], [119957, 1, "t"], [119958, 1, "u"], [119959, 1, "v"], [119960, 1, "w"], [119961, 1, "x"], [119962, 1, "y"], [119963, 1, "z"], [119964, 1, "a"], [119965, 3], [119966, 1, "c"], [119967, 1, "d"], [[119968, 119969], 3], [119970, 1, "g"], [[119971, 119972], 3], [119973, 1, "j"], [119974, 1, "k"], [[119975, 119976], 3], [119977, 1, "n"], [119978, 1, "o"], [119979, 1, "p"], [119980, 1, "q"], [119981, 3], [119982, 1, "s"], [119983, 1, "t"], [119984, 1, "u"], [119985, 1, "v"], [119986, 1, "w"], [119987, 1, "x"], [119988, 1, "y"], [119989, 1, "z"], [119990, 1, "a"], [119991, 1, "b"], [119992, 1, "c"], [119993, 1, "d"], [119994, 3], [119995, 1, "f"], [119996, 3], [119997, 1, "h"], [119998, 1, "i"], [119999, 1, "j"], [120000, 1, "k"], [120001, 1, "l"], [120002, 1, "m"], [120003, 1, "n"], [120004, 3], [120005, 1, "p"], [120006, 1, "q"], [120007, 1, "r"], [120008, 1, "s"], [120009, 1, "t"], [120010, 1, "u"], [120011, 1, "v"], [120012, 1, "w"], [120013, 1, "x"], [120014, 1, "y"], [120015, 1, "z"], [120016, 1, "a"], [120017, 1, "b"], [120018, 1, "c"], [120019, 1, "d"], [120020, 1, "e"], [120021, 1, "f"], [120022, 1, "g"], [120023, 1, "h"], [120024, 1, "i"], [120025, 1, "j"], [120026, 1, "k"], [120027, 1, "l"], [120028, 1, "m"], [120029, 1, "n"], [120030, 1, "o"], [120031, 1, "p"], [120032, 1, "q"], [120033, 1, "r"], [120034, 1, "s"], [120035, 1, "t"], [120036, 1, "u"], [120037, 1, "v"], [120038, 1, "w"], [120039, 1, "x"], [120040, 1, "y"], [120041, 1, "z"], [120042, 1, "a"], [120043, 1, "b"], [120044, 1, "c"], [120045, 1, "d"], [120046, 1, "e"], [120047, 1, "f"], [120048, 1, "g"], [120049, 1, "h"], [120050, 1, "i"], [120051, 1, "j"], [120052, 1, "k"], [120053, 1, "l"], [120054, 1, "m"], [120055, 1, "n"], [120056, 1, "o"], [120057, 1, "p"], [120058, 1, "q"], [120059, 1, "r"], [120060, 1, "s"], [120061, 1, "t"], [120062, 1, "u"], [120063, 1, "v"], [120064, 1, "w"], [120065, 1, "x"], [120066, 1, "y"], [120067, 1, "z"], [120068, 1, "a"], [120069, 1, "b"], [120070, 3], [120071, 1, "d"], [120072, 1, "e"], [120073, 1, "f"], [120074, 1, "g"], [[120075, 120076], 3], [120077, 1, "j"], [120078, 1, "k"], [120079, 1, "l"], [120080, 1, "m"], [120081, 1, "n"], [120082, 1, "o"], [120083, 1, "p"], [120084, 1, "q"], [120085, 3], [120086, 1, "s"], [120087, 1, "t"], [120088, 1, "u"], [120089, 1, "v"], [120090, 1, "w"], [120091, 1, "x"], [120092, 1, "y"], [120093, 3], [120094, 1, "a"], [120095, 1, "b"], [120096, 1, "c"], [120097, 1, "d"], [120098, 1, "e"], [120099, 1, "f"], [120100, 1, "g"], [120101, 1, "h"], [120102, 1, "i"], [120103, 1, "j"], [120104, 1, "k"], [120105, 1, "l"], [120106, 1, "m"], [120107, 1, "n"], [120108, 1, "o"], [120109, 1, "p"], [120110, 1, "q"], [120111, 1, "r"], [120112, 1, "s"], [120113, 1, "t"], [120114, 1, "u"], [120115, 1, "v"], [120116, 1, "w"], [120117, 1, "x"], [120118, 1, "y"], [120119, 1, "z"], [120120, 1, "a"], [120121, 1, "b"], [120122, 3], [120123, 1, "d"], [120124, 1, "e"], [120125, 1, "f"], [120126, 1, "g"], [120127, 3], [120128, 1, "i"], [120129, 1, "j"], [120130, 1, "k"], [120131, 1, "l"], [120132, 1, "m"], [120133, 3], [120134, 1, "o"], [[120135, 120137], 3], [120138, 1, "s"], [120139, 1, "t"], [120140, 1, "u"], [120141, 1, "v"], [120142, 1, "w"], [120143, 1, "x"], [120144, 1, "y"], [120145, 3], [120146, 1, "a"], [120147, 1, "b"], [120148, 1, "c"], [120149, 1, "d"], [120150, 1, "e"], [120151, 1, "f"], [120152, 1, "g"], [120153, 1, "h"], [120154, 1, "i"], [120155, 1, "j"], [120156, 1, "k"], [120157, 1, "l"], [120158, 1, "m"], [120159, 1, "n"], [120160, 1, "o"], [120161, 1, "p"], [120162, 1, "q"], [120163, 1, "r"], [120164, 1, "s"], [120165, 1, "t"], [120166, 1, "u"], [120167, 1, "v"], [120168, 1, "w"], [120169, 1, "x"], [120170, 1, "y"], [120171, 1, "z"], [120172, 1, "a"], [120173, 1, "b"], [120174, 1, "c"], [120175, 1, "d"], [120176, 1, "e"], [120177, 1, "f"], [120178, 1, "g"], [120179, 1, "h"], [120180, 1, "i"], [120181, 1, "j"], [120182, 1, "k"], [120183, 1, "l"], [120184, 1, "m"], [120185, 1, "n"], [120186, 1, "o"], [120187, 1, "p"], [120188, 1, "q"], [120189, 1, "r"], [120190, 1, "s"], [120191, 1, "t"], [120192, 1, "u"], [120193, 1, "v"], [120194, 1, "w"], [120195, 1, "x"], [120196, 1, "y"], [120197, 1, "z"], [120198, 1, "a"], [120199, 1, "b"], [120200, 1, "c"], [120201, 1, "d"], [120202, 1, "e"], [120203, 1, "f"], [120204, 1, "g"], [120205, 1, "h"], [120206, 1, "i"], [120207, 1, "j"], [120208, 1, "k"], [120209, 1, "l"], [120210, 1, "m"], [120211, 1, "n"], [120212, 1, "o"], [120213, 1, "p"], [120214, 1, "q"], [120215, 1, "r"], [120216, 1, "s"], [120217, 1, "t"], [120218, 1, "u"], [120219, 1, "v"], [120220, 1, "w"], [120221, 1, "x"], [120222, 1, "y"], [120223, 1, "z"], [120224, 1, "a"], [120225, 1, "b"], [120226, 1, "c"], [120227, 1, "d"], [120228, 1, "e"], [120229, 1, "f"], [120230, 1, "g"], [120231, 1, "h"], [120232, 1, "i"], [120233, 1, "j"], [120234, 1, "k"], [120235, 1, "l"], [120236, 1, "m"], [120237, 1, "n"], [120238, 1, "o"], [120239, 1, "p"], [120240, 1, "q"], [120241, 1, "r"], [120242, 1, "s"], [120243, 1, "t"], [120244, 1, "u"], [120245, 1, "v"], [120246, 1, "w"], [120247, 1, "x"], [120248, 1, "y"], [120249, 1, "z"], [120250, 1, "a"], [120251, 1, "b"], [120252, 1, "c"], [120253, 1, "d"], [120254, 1, "e"], [120255, 1, "f"], [120256, 1, "g"], [120257, 1, "h"], [120258, 1, "i"], [120259, 1, "j"], [120260, 1, "k"], [120261, 1, "l"], [120262, 1, "m"], [120263, 1, "n"], [120264, 1, "o"], [120265, 1, "p"], [120266, 1, "q"], [120267, 1, "r"], [120268, 1, "s"], [120269, 1, "t"], [120270, 1, "u"], [120271, 1, "v"], [120272, 1, "w"], [120273, 1, "x"], [120274, 1, "y"], [120275, 1, "z"], [120276, 1, "a"], [120277, 1, "b"], [120278, 1, "c"], [120279, 1, "d"], [120280, 1, "e"], [120281, 1, "f"], [120282, 1, "g"], [120283, 1, "h"], [120284, 1, "i"], [120285, 1, "j"], [120286, 1, "k"], [120287, 1, "l"], [120288, 1, "m"], [120289, 1, "n"], [120290, 1, "o"], [120291, 1, "p"], [120292, 1, "q"], [120293, 1, "r"], [120294, 1, "s"], [120295, 1, "t"], [120296, 1, "u"], [120297, 1, "v"], [120298, 1, "w"], [120299, 1, "x"], [120300, 1, "y"], [120301, 1, "z"], [120302, 1, "a"], [120303, 1, "b"], [120304, 1, "c"], [120305, 1, "d"], [120306, 1, "e"], [120307, 1, "f"], [120308, 1, "g"], [120309, 1, "h"], [120310, 1, "i"], [120311, 1, "j"], [120312, 1, "k"], [120313, 1, "l"], [120314, 1, "m"], [120315, 1, "n"], [120316, 1, "o"], [120317, 1, "p"], [120318, 1, "q"], [120319, 1, "r"], [120320, 1, "s"], [120321, 1, "t"], [120322, 1, "u"], [120323, 1, "v"], [120324, 1, "w"], [120325, 1, "x"], [120326, 1, "y"], [120327, 1, "z"], [120328, 1, "a"], [120329, 1, "b"], [120330, 1, "c"], [120331, 1, "d"], [120332, 1, "e"], [120333, 1, "f"], [120334, 1, "g"], [120335, 1, "h"], [120336, 1, "i"], [120337, 1, "j"], [120338, 1, "k"], [120339, 1, "l"], [120340, 1, "m"], [120341, 1, "n"], [120342, 1, "o"], [120343, 1, "p"], [120344, 1, "q"], [120345, 1, "r"], [120346, 1, "s"], [120347, 1, "t"], [120348, 1, "u"], [120349, 1, "v"], [120350, 1, "w"], [120351, 1, "x"], [120352, 1, "y"], [120353, 1, "z"], [120354, 1, "a"], [120355, 1, "b"], [120356, 1, "c"], [120357, 1, "d"], [120358, 1, "e"], [120359, 1, "f"], [120360, 1, "g"], [120361, 1, "h"], [120362, 1, "i"], [120363, 1, "j"], [120364, 1, "k"], [120365, 1, "l"], [120366, 1, "m"], [120367, 1, "n"], [120368, 1, "o"], [120369, 1, "p"], [120370, 1, "q"], [120371, 1, "r"], [120372, 1, "s"], [120373, 1, "t"], [120374, 1, "u"], [120375, 1, "v"], [120376, 1, "w"], [120377, 1, "x"], [120378, 1, "y"], [120379, 1, "z"], [120380, 1, "a"], [120381, 1, "b"], [120382, 1, "c"], [120383, 1, "d"], [120384, 1, "e"], [120385, 1, "f"], [120386, 1, "g"], [120387, 1, "h"], [120388, 1, "i"], [120389, 1, "j"], [120390, 1, "k"], [120391, 1, "l"], [120392, 1, "m"], [120393, 1, "n"], [120394, 1, "o"], [120395, 1, "p"], [120396, 1, "q"], [120397, 1, "r"], [120398, 1, "s"], [120399, 1, "t"], [120400, 1, "u"], [120401, 1, "v"], [120402, 1, "w"], [120403, 1, "x"], [120404, 1, "y"], [120405, 1, "z"], [120406, 1, "a"], [120407, 1, "b"], [120408, 1, "c"], [120409, 1, "d"], [120410, 1, "e"], [120411, 1, "f"], [120412, 1, "g"], [120413, 1, "h"], [120414, 1, "i"], [120415, 1, "j"], [120416, 1, "k"], [120417, 1, "l"], [120418, 1, "m"], [120419, 1, "n"], [120420, 1, "o"], [120421, 1, "p"], [120422, 1, "q"], [120423, 1, "r"], [120424, 1, "s"], [120425, 1, "t"], [120426, 1, "u"], [120427, 1, "v"], [120428, 1, "w"], [120429, 1, "x"], [120430, 1, "y"], [120431, 1, "z"], [120432, 1, "a"], [120433, 1, "b"], [120434, 1, "c"], [120435, 1, "d"], [120436, 1, "e"], [120437, 1, "f"], [120438, 1, "g"], [120439, 1, "h"], [120440, 1, "i"], [120441, 1, "j"], [120442, 1, "k"], [120443, 1, "l"], [120444, 1, "m"], [120445, 1, "n"], [120446, 1, "o"], [120447, 1, "p"], [120448, 1, "q"], [120449, 1, "r"], [120450, 1, "s"], [120451, 1, "t"], [120452, 1, "u"], [120453, 1, "v"], [120454, 1, "w"], [120455, 1, "x"], [120456, 1, "y"], [120457, 1, "z"], [120458, 1, "a"], [120459, 1, "b"], [120460, 1, "c"], [120461, 1, "d"], [120462, 1, "e"], [120463, 1, "f"], [120464, 1, "g"], [120465, 1, "h"], [120466, 1, "i"], [120467, 1, "j"], [120468, 1, "k"], [120469, 1, "l"], [120470, 1, "m"], [120471, 1, "n"], [120472, 1, "o"], [120473, 1, "p"], [120474, 1, "q"], [120475, 1, "r"], [120476, 1, "s"], [120477, 1, "t"], [120478, 1, "u"], [120479, 1, "v"], [120480, 1, "w"], [120481, 1, "x"], [120482, 1, "y"], [120483, 1, "z"], [120484, 1, ""], [120485, 1, ""], [[120486, 120487], 3], [120488, 1, ""], [120489, 1, ""], [120490, 1, ""], [120491, 1, ""], [120492, 1, ""], [120493, 1, ""], [120494, 1, ""], [120495, 1, ""], [120496, 1, ""], [120497, 1, ""], [120498, 1, ""], [120499, 1, ""], [120500, 1, ""], [120501, 1, ""], [120502, 1, ""], [120503, 1, ""], [120504, 1, ""], [120505, 1, ""], [120506, 1, ""], [120507, 1, ""], [120508, 1, ""], [120509, 1, ""], [120510, 1, ""], [120511, 1, ""], [120512, 1, ""], [120513, 1, ""], [120514, 1, ""], [120515, 1, ""], [120516, 1, ""], [120517, 1, ""], [120518, 1, ""], [120519, 1, ""], [120520, 1, ""], [120521, 1, ""], [120522, 1, ""], [120523, 1, ""], [120524, 1, ""], [120525, 1, ""], [120526, 1, ""], [120527, 1, ""], [120528, 1, ""], [120529, 1, ""], [120530, 1, ""], [[120531, 120532], 1, ""], [120533, 1, ""], [120534, 1, ""], [120535, 1, ""], [120536, 1, ""], [120537, 1, ""], [120538, 1, ""], [120539, 1, ""], [120540, 1, ""], [120541, 1, ""], [120542, 1, ""], [120543, 1, ""], [120544, 1, ""], [120545, 1, ""], [120546, 1, ""], [120547, 1, ""], [120548, 1, ""], [120549, 1, ""], [120550, 1, ""], [120551, 1, ""], [120552, 1, ""], [120553, 1, ""], [120554, 1, ""], [120555, 1, ""], [120556, 1, ""], [120557, 1, ""], [120558, 1, ""], [120559, 1, ""], [120560, 1, ""], [120561, 1, ""], [120562, 1, ""], [120563, 1, ""], [120564, 1, ""], [120565, 1, ""], [120566, 1, ""], [120567, 1, ""], [120568, 1, ""], [120569, 1, ""], [120570, 1, ""], [120571, 1, ""], [120572, 1, ""], [120573, 1, ""], [120574, 1, ""], [120575, 1, ""], [120576, 1, ""], [120577, 1, ""], [120578, 1, ""], [120579, 1, ""], [120580, 1, ""], [120581, 1, ""], [120582, 1, ""], [120583, 1, ""], [120584, 1, ""], [120585, 1, ""], [120586, 1, ""], [120587, 1, ""], [120588, 1, ""], [[120589, 120590], 1, ""], [120591, 1, ""], [120592, 1, ""], [120593, 1, ""], [120594, 1, ""], [120595, 1, ""], [120596, 1, ""], [120597, 1, ""], [120598, 1, ""], [120599, 1, ""], [120600, 1, ""], [120601, 1, ""], [120602, 1, ""], [120603, 1, ""], [120604, 1, ""], [120605, 1, ""], [120606, 1, ""], [120607, 1, ""], [120608, 1, ""], [120609, 1, ""], [120610, 1, ""], [120611, 1, ""], [120612, 1, ""], [120613, 1, ""], [120614, 1, ""], [120615, 1, ""], [120616, 1, ""], [120617, 1, ""], [120618, 1, ""], [120619, 1, ""], [120620, 1, ""], [120621, 1, ""], [120622, 1, ""], [120623, 1, ""], [120624, 1, ""], [120625, 1, ""], [120626, 1, ""], [120627, 1, ""], [120628, 1, ""], [120629, 1, ""], [120630, 1, ""], [120631, 1, ""], [120632, 1, ""], [120633, 1, ""], [120634, 1, ""], [120635, 1, ""], [120636, 1, ""], [120637, 1, ""], [120638, 1, ""], [120639, 1, ""], [120640, 1, ""], [120641, 1, ""], [120642, 1, ""], [120643, 1, ""], [120644, 1, ""], [120645, 1, ""], [120646, 1, ""], [[120647, 120648], 1, ""], [120649, 1, ""], [120650, 1, ""], [120651, 1, ""], [120652, 1, ""], [120653, 1, ""], [120654, 1, ""], [120655, 1, ""], [120656, 1, ""], [120657, 1, ""], [120658, 1, ""], [120659, 1, ""], [120660, 1, ""], [120661, 1, ""], [120662, 1, ""], [120663, 1, ""], [120664, 1, ""], [120665, 1, ""], [120666, 1, ""], [120667, 1, ""], [120668, 1, ""], [120669, 1, ""], [120670, 1, ""], [120671, 1, ""], [120672, 1, ""], [120673, 1, ""], [120674, 1, ""], [120675, 1, ""], [120676, 1, ""], [120677, 1, ""], [120678, 1, ""], [120679, 1, ""], [120680, 1, ""], [120681, 1, ""], [120682, 1, ""], [120683, 1, ""], [120684, 1, ""], [120685, 1, ""], [120686, 1, ""], [120687, 1, ""], [120688, 1, ""], [120689, 1, ""], [120690, 1, ""], [120691, 1, ""], [120692, 1, ""], [120693, 1, ""], [120694, 1, ""], [120695, 1, ""], [120696, 1, ""], [120697, 1, ""], [120698, 1, ""], [120699, 1, ""], [120700, 1, ""], [120701, 1, ""], [120702, 1, ""], [120703, 1, ""], [120704, 1, ""], [[120705, 120706], 1, ""], [120707, 1, ""], [120708, 1, ""], [120709, 1, ""], [120710, 1, ""], [120711, 1, ""], [120712, 1, ""], [120713, 1, ""], [120714, 1, ""], [120715, 1, ""], [120716, 1, ""], [120717, 1, ""], [120718, 1, ""], [120719, 1, ""], [120720, 1, ""], [120721, 1, ""], [120722, 1, ""], [120723, 1, ""], [120724, 1, ""], [120725, 1, ""], [120726, 1, ""], [120727, 1, ""], [120728, 1, ""], [120729, 1, ""], [120730, 1, ""], [120731, 1, ""], [120732, 1, ""], [120733, 1, ""], [120734, 1, ""], [120735, 1, ""], [120736, 1, ""], [120737, 1, ""], [120738, 1, ""], [120739, 1, ""], [120740, 1, ""], [120741, 1, ""], [120742, 1, ""], [120743, 1, ""], [120744, 1, ""], [120745, 1, ""], [120746, 1, ""], [120747, 1, ""], [120748, 1, ""], [120749, 1, ""], [120750, 1, ""], [120751, 1, ""], [120752, 1, ""], [120753, 1, ""], [120754, 1, ""], [120755, 1, ""], [120756, 1, ""], [120757, 1, ""], [120758, 1, ""], [120759, 1, ""], [120760, 1, ""], [120761, 1, ""], [120762, 1, ""], [[120763, 120764], 1, ""], [120765, 1, ""], [120766, 1, ""], [120767, 1, ""], [120768, 1, ""], [120769, 1, ""], [120770, 1, ""], [120771, 1, ""], [120772, 1, ""], [120773, 1, ""], [120774, 1, ""], [120775, 1, ""], [120776, 1, ""], [120777, 1, ""], [[120778, 120779], 1, ""], [[120780, 120781], 3], [120782, 1, "0"], [120783, 1, "1"], [120784, 1, "2"], [120785, 1, "3"], [120786, 1, "4"], [120787, 1, "5"], [120788, 1, "6"], [120789, 1, "7"], [120790, 1, "8"], [120791, 1, "9"], [120792, 1, "0"], [120793, 1, "1"], [120794, 1, "2"], [120795, 1, "3"], [120796, 1, "4"], [120797, 1, "5"], [120798, 1, "6"], [120799, 1, "7"], [120800, 1, "8"], [120801, 1, "9"], [120802, 1, "0"], [120803, 1, "1"], [120804, 1, "2"], [120805, 1, "3"], [120806, 1, "4"], [120807, 1, "5"], [120808, 1, "6"], [120809, 1, "7"], [120810, 1, "8"], [120811, 1, "9"], [120812, 1, "0"], [120813, 1, "1"], [120814, 1, "2"], [120815, 1, "3"], [120816, 1, "4"], [120817, 1, "5"], [120818, 1, "6"], [120819, 1, "7"], [120820, 1, "8"], [120821, 1, "9"], [120822, 1, "0"], [120823, 1, "1"], [120824, 1, "2"], [120825, 1, "3"], [120826, 1, "4"], [120827, 1, "5"], [120828, 1, "6"], [120829, 1, "7"], [120830, 1, "8"], [120831, 1, "9"], [[120832, 121343], 2], [[121344, 121398], 2], [[121399, 121402], 2], [[121403, 121452], 2], [[121453, 121460], 2], [121461, 2], [[121462, 121475], 2], [121476, 2], [[121477, 121483], 2], [[121484, 121498], 3], [[121499, 121503], 2], [121504, 3], [[121505, 121519], 2], [[121520, 122623], 3], [[122624, 122654], 2], [[122655, 122660], 3], [[122661, 122666], 2], [[122667, 122879], 3], [[122880, 122886], 2], [122887, 3], [[122888, 122904], 2], [[122905, 122906], 3], [[122907, 122913], 2], [122914, 3], [[122915, 122916], 2], [122917, 3], [[122918, 122922], 2], [[122923, 122927], 3], [122928, 1, ""], [122929, 1, ""], [122930, 1, ""], [122931, 1, ""], [122932, 1, ""], [122933, 1, ""], [122934, 1, ""], [122935, 1, ""], [122936, 1, ""], [122937, 1, ""], [122938, 1, ""], [122939, 1, ""], [122940, 1, ""], [122941, 1, ""], [122942, 1, ""], [122943, 1, ""], [122944, 1, ""], [122945, 1, ""], [122946, 1, ""], [122947, 1, ""], [122948, 1, ""], [122949, 1, ""], [122950, 1, ""], [122951, 1, ""], [122952, 1, ""], [122953, 1, ""], [122954, 1, ""], [122955, 1, ""], [122956, 1, ""], [122957, 1, ""], [122958, 1, ""], [122959, 1, ""], [122960, 1, ""], [122961, 1, ""], [122962, 1, ""], [122963, 1, ""], [122964, 1, ""], [122965, 1, ""], [122966, 1, ""], [122967, 1, ""], [122968, 1, ""], [122969, 1, ""], [122970, 1, ""], [122971, 1, ""], [122972, 1, ""], [122973, 1, ""], [122974, 1, ""], [122975, 1, ""], [122976, 1, ""], [122977, 1, ""], [122978, 1, ""], [122979, 1, ""], [122980, 1, ""], [122981, 1, ""], [122982, 1, ""], [122983, 1, ""], [122984, 1, ""], [122985, 1, ""], [122986, 1, ""], [122987, 1, ""], [122988, 1, ""], [122989, 1, ""], [[122990, 123022], 3], [123023, 2], [[123024, 123135], 3], [[123136, 123180], 2], [[123181, 123183], 3], [[123184, 123197], 2], [[123198, 123199], 3], [[123200, 123209], 2], [[123210, 123213], 3], [123214, 2], [123215, 2], [[123216, 123535], 3], [[123536, 123566], 2], [[123567, 123583], 3], [[123584, 123641], 2], [[123642, 123646], 3], [123647, 2], [[123648, 124111], 3], [[124112, 124153], 2], [[124154, 124895], 3], [[124896, 124902], 2], [124903, 3], [[124904, 124907], 2], [124908, 3], [[124909, 124910], 2], [124911, 3], [[124912, 124926], 2], [124927, 3], [[124928, 125124], 2], [[125125, 125126], 3], [[125127, 125135], 2], [[125136, 125142], 2], [[125143, 125183], 3], [125184, 1, ""], [125185, 1, ""], [125186, 1, ""], [125187, 1, ""], [125188, 1, ""], [125189, 1, ""], [125190, 1, ""], [125191, 1, ""], [125192, 1, ""], [125193, 1, ""], [125194, 1, ""], [125195, 1, ""], [125196, 1, ""], [125197, 1, ""], [125198, 1, ""], [125199, 1, ""], [125200, 1, ""], [125201, 1, ""], [125202, 1, ""], [125203, 1, ""], [125204, 1, ""], [125205, 1, ""], [125206, 1, ""], [125207, 1, ""], [125208, 1, ""], [125209, 1, ""], [125210, 1, ""], [125211, 1, ""], [125212, 1, ""], [125213, 1, ""], [125214, 1, ""], [125215, 1, ""], [125216, 1, ""], [125217, 1, ""], [[125218, 125258], 2], [125259, 2], [[125260, 125263], 3], [[125264, 125273], 2], [[125274, 125277], 3], [[125278, 125279], 2], [[125280, 126064], 3], [[126065, 126132], 2], [[126133, 126208], 3], [[126209, 126269], 2], [[126270, 126463], 3], [126464, 1, ""], [126465, 1, ""], [126466, 1, ""], [126467, 1, ""], [126468, 3], [126469, 1, ""], [126470, 1, ""], [126471, 1, ""], [126472, 1, ""], [126473, 1, ""], [126474, 1, ""], [126475, 1, ""], [126476, 1, ""], [126477, 1, ""], [126478, 1, ""], [126479, 1, ""], [126480, 1, ""], [126481, 1, ""], [126482, 1, ""], [126483, 1, ""], [126484, 1, ""], [126485, 1, ""], [126486, 1, ""], [126487, 1, ""], [126488, 1, ""], [126489, 1, ""], [126490, 1, ""], [126491, 1, ""], [126492, 1, ""], [126493, 1, ""], [126494, 1, ""], [126495, 1, ""], [126496, 3], [126497, 1, ""], [126498, 1, ""], [126499, 3], [126500, 1, ""], [[126501, 126502], 3], [126503, 1, ""], [126504, 3], [126505, 1, ""], [126506, 1, ""], [126507, 1, ""], [126508, 1, ""], [126509, 1, ""], [126510, 1, ""], [126511, 1, ""], [126512, 1, ""], [126513, 1, ""], [126514, 1, ""], [126515, 3], [126516, 1, ""], [126517, 1, ""], [126518, 1, ""], [126519, 1, ""], [126520, 3], [126521, 1, ""], [126522, 3], [126523, 1, ""], [[126524, 126529], 3], [126530, 1, ""], [[126531, 126534], 3], [126535, 1, ""], [126536, 3], [126537, 1, ""], [126538, 3], [126539, 1, ""], [126540, 3], [126541, 1, ""], [126542, 1, ""], [126543, 1, ""], [126544, 3], [126545, 1, ""], [126546, 1, ""], [126547, 3], [126548, 1, ""], [[126549, 126550], 3], [126551, 1, ""], [126552, 3], [126553, 1, ""], [126554, 3], [126555, 1, ""], [126556, 3], [126557, 1, ""], [126558, 3], [126559, 1, ""], [126560, 3], [126561, 1, ""], [126562, 1, ""], [126563, 3], [126564, 1, ""], [[126565, 126566], 3], [126567, 1, ""], [126568, 1, ""], [126569, 1, ""], [126570, 1, ""], [126571, 3], [126572, 1, ""], [126573, 1, ""], [126574, 1, ""], [126575, 1, ""], [126576, 1, ""], [126577, 1, ""], [126578, 1, ""], [126579, 3], [126580, 1, ""], [126581, 1, ""], [126582, 1, ""], [126583, 1, ""], [126584, 3], [126585, 1, ""], [126586, 1, ""], [126587, 1, ""], [126588, 1, ""], [126589, 3], [126590, 1, ""], [126591, 3], [126592, 1, ""], [126593, 1, ""], [126594, 1, ""], [126595, 1, ""], [126596, 1, ""], [126597, 1, ""], [126598, 1, ""], [126599, 1, ""], [126600, 1, ""], [126601, 1, ""], [126602, 3], [126603, 1, ""], [126604, 1, ""], [126605, 1, ""], [126606, 1, ""], [126607, 1, ""], [126608, 1, ""], [126609, 1, ""], [126610, 1, ""], [126611, 1, ""], [126612, 1, ""], [126613, 1, ""], [126614, 1, ""], [126615, 1, ""], [126616, 1, ""], [126617, 1, ""], [126618, 1, ""], [126619, 1, ""], [[126620, 126624], 3], [126625, 1, ""], [126626, 1, ""], [126627, 1, ""], [126628, 3], [126629, 1, ""], [126630, 1, ""], [126631, 1, ""], [126632, 1, ""], [126633, 1, ""], [126634, 3], [126635, 1, ""], [126636, 1, ""], [126637, 1, ""], [126638, 1, ""], [126639, 1, ""], [126640, 1, ""], [126641, 1, ""], [126642, 1, ""], [126643, 1, ""], [126644, 1, ""], [126645, 1, ""], [126646, 1, ""], [126647, 1, ""], [126648, 1, ""], [126649, 1, ""], [126650, 1, ""], [126651, 1, ""], [[126652, 126703], 3], [[126704, 126705], 2], [[126706, 126975], 3], [[126976, 127019], 2], [[127020, 127023], 3], [[127024, 127123], 2], [[127124, 127135], 3], [[127136, 127150], 2], [[127151, 127152], 3], [[127153, 127166], 2], [127167, 2], [127168, 3], [[127169, 127183], 2], [127184, 3], [[127185, 127199], 2], [[127200, 127221], 2], [[127222, 127231], 3], [127232, 3], [127233, 5, "0,"], [127234, 5, "1,"], [127235, 5, "2,"], [127236, 5, "3,"], [127237, 5, "4,"], [127238, 5, "5,"], [127239, 5, "6,"], [127240, 5, "7,"], [127241, 5, "8,"], [127242, 5, "9,"], [[127243, 127244], 2], [[127245, 127247], 2], [127248, 5, "(a)"], [127249, 5, "(b)"], [127250, 5, "(c)"], [127251, 5, "(d)"], [127252, 5, "(e)"], [127253, 5, "(f)"], [127254, 5, "(g)"], [127255, 5, "(h)"], [127256, 5, "(i)"], [127257, 5, "(j)"], [127258, 5, "(k)"], [127259, 5, "(l)"], [127260, 5, "(m)"], [127261, 5, "(n)"], [127262, 5, "(o)"], [127263, 5, "(p)"], [127264, 5, "(q)"], [127265, 5, "(r)"], [127266, 5, "(s)"], [127267, 5, "(t)"], [127268, 5, "(u)"], [127269, 5, "(v)"], [127270, 5, "(w)"], [127271, 5, "(x)"], [127272, 5, "(y)"], [127273, 5, "(z)"], [127274, 1, "s"], [127275, 1, "c"], [127276, 1, "r"], [127277, 1, "cd"], [127278, 1, "wz"], [127279, 2], [127280, 1, "a"], [127281, 1, "b"], [127282, 1, "c"], [127283, 1, "d"], [127284, 1, "e"], [127285, 1, "f"], [127286, 1, "g"], [127287, 1, "h"], [127288, 1, "i"], [127289, 1, "j"], [127290, 1, "k"], [127291, 1, "l"], [127292, 1, "m"], [127293, 1, "n"], [127294, 1, "o"], [127295, 1, "p"], [127296, 1, "q"], [127297, 1, "r"], [127298, 1, "s"], [127299, 1, "t"], [127300, 1, "u"], [127301, 1, "v"], [127302, 1, "w"], [127303, 1, "x"], [127304, 1, "y"], [127305, 1, "z"], [127306, 1, "hv"], [127307, 1, "mv"], [127308, 1, "sd"], [127309, 1, "ss"], [127310, 1, "ppv"], [127311, 1, "wc"], [[127312, 127318], 2], [127319, 2], [[127320, 127326], 2], [127327, 2], [[127328, 127337], 2], [127338, 1, "mc"], [127339, 1, "md"], [127340, 1, "mr"], [[127341, 127343], 2], [[127344, 127352], 2], [127353, 2], [127354, 2], [[127355, 127356], 2], [[127357, 127358], 2], [127359, 2], [[127360, 127369], 2], [[127370, 127373], 2], [[127374, 127375], 2], [127376, 1, "dj"], [[127377, 127386], 2], [[127387, 127404], 2], [127405, 2], [[127406, 127461], 3], [[127462, 127487], 2], [127488, 1, ""], [127489, 1, ""], [127490, 1, ""], [[127491, 127503], 3], [127504, 1, ""], [127505, 1, ""], [127506, 1, ""], [127507, 1, ""], [127508, 1, ""], [127509, 1, ""], [127510, 1, ""], [127511, 1, ""], [127512, 1, ""], [127513, 1, ""], [127514, 1, ""], [127515, 1, ""], [127516, 1, ""], [127517, 1, ""], [127518, 1, ""], [127519, 1, ""], [127520, 1, ""], [127521, 1, ""], [127522, 1, ""], [127523, 1, ""], [127524, 1, ""], [127525, 1, ""], [127526, 1, ""], [127527, 1, ""], [127528, 1, ""], [127529, 1, ""], [127530, 1, ""], [127531, 1, ""], [127532, 1, ""], [127533, 1, ""], [127534, 1, ""], [127535, 1, ""], [127536, 1, ""], [127537, 1, ""], [127538, 1, ""], [127539, 1, ""], [127540, 1, ""], [127541, 1, ""], [127542, 1, ""], [127543, 1, ""], [127544, 1, ""], [127545, 1, ""], [127546, 1, ""], [127547, 1, ""], [[127548, 127551], 3], [127552, 1, ""], [127553, 1, ""], [127554, 1, ""], [127555, 1, ""], [127556, 1, ""], [127557, 1, ""], [127558, 1, ""], [127559, 1, ""], [127560, 1, ""], [[127561, 127567], 3], [127568, 1, ""], [127569, 1, ""], [[127570, 127583], 3], [[127584, 127589], 2], [[127590, 127743], 3], [[127744, 127776], 2], [[127777, 127788], 2], [[127789, 127791], 2], [[127792, 127797], 2], [127798, 2], [[127799, 127868], 2], [127869, 2], [[127870, 127871], 2], [[127872, 127891], 2], [[127892, 127903], 2], [[127904, 127940], 2], [127941, 2], [[127942, 127946], 2], [[127947, 127950], 2], [[127951, 127955], 2], [[127956, 127967], 2], [[127968, 127984], 2], [[127985, 127991], 2], [[127992, 127999], 2], [[128000, 128062], 2], [128063, 2], [128064, 2], [128065, 2], [[128066, 128247], 2], [128248, 2], [[128249, 128252], 2], [[128253, 128254], 2], [128255, 2], [[128256, 128317], 2], [[128318, 128319], 2], [[128320, 128323], 2], [[128324, 128330], 2], [[128331, 128335], 2], [[128336, 128359], 2], [[128360, 128377], 2], [128378, 2], [[128379, 128419], 2], [128420, 2], [[128421, 128506], 2], [[128507, 128511], 2], [128512, 2], [[128513, 128528], 2], [128529, 2], [[128530, 128532], 2], [128533, 2], [128534, 2], [128535, 2], [128536, 2], [128537, 2], [128538, 2], [128539, 2], [[128540, 128542], 2], [128543, 2], [[128544, 128549], 2], [[128550, 128551], 2], [[128552, 128555], 2], [128556, 2], [128557, 2], [[128558, 128559], 2], [[128560, 128563], 2], [128564, 2], [[128565, 128576], 2], [[128577, 128578], 2], [[128579, 128580], 2], [[128581, 128591], 2], [[128592, 128639], 2], [[128640, 128709], 2], [[128710, 128719], 2], [128720, 2], [[128721, 128722], 2], [[128723, 128724], 2], [128725, 2], [[128726, 128727], 2], [[128728, 128731], 3], [128732, 2], [[128733, 128735], 2], [[128736, 128748], 2], [[128749, 128751], 3], [[128752, 128755], 2], [[128756, 128758], 2], [[128759, 128760], 2], [128761, 2], [128762, 2], [[128763, 128764], 2], [[128765, 128767], 3], [[128768, 128883], 2], [[128884, 128886], 2], [[128887, 128890], 3], [[128891, 128895], 2], [[128896, 128980], 2], [[128981, 128984], 2], [128985, 2], [[128986, 128991], 3], [[128992, 129003], 2], [[129004, 129007], 3], [129008, 2], [[129009, 129023], 3], [[129024, 129035], 2], [[129036, 129039], 3], [[129040, 129095], 2], [[129096, 129103], 3], [[129104, 129113], 2], [[129114, 129119], 3], [[129120, 129159], 2], [[129160, 129167], 3], [[129168, 129197], 2], [[129198, 129199], 3], [[129200, 129201], 2], [[129202, 129279], 3], [[129280, 129291], 2], [129292, 2], [[129293, 129295], 2], [[129296, 129304], 2], [[129305, 129310], 2], [129311, 2], [[129312, 129319], 2], [[129320, 129327], 2], [129328, 2], [[129329, 129330], 2], [[129331, 129342], 2], [129343, 2], [[129344, 129355], 2], [129356, 2], [[129357, 129359], 2], [[129360, 129374], 2], [[129375, 129387], 2], [[129388, 129392], 2], [129393, 2], [129394, 2], [[129395, 129398], 2], [[129399, 129400], 2], [129401, 2], [129402, 2], [129403, 2], [[129404, 129407], 2], [[129408, 129412], 2], [[129413, 129425], 2], [[129426, 129431], 2], [[129432, 129442], 2], [[129443, 129444], 2], [[129445, 129450], 2], [[129451, 129453], 2], [[129454, 129455], 2], [[129456, 129465], 2], [[129466, 129471], 2], [129472, 2], [[129473, 129474], 2], [[129475, 129482], 2], [129483, 2], [129484, 2], [[129485, 129487], 2], [[129488, 129510], 2], [[129511, 129535], 2], [[129536, 129619], 2], [[129620, 129631], 3], [[129632, 129645], 2], [[129646, 129647], 3], [[129648, 129651], 2], [129652, 2], [[129653, 129655], 2], [[129656, 129658], 2], [[129659, 129660], 2], [[129661, 129663], 3], [[129664, 129666], 2], [[129667, 129670], 2], [[129671, 129672], 2], [[129673, 129679], 3], [[129680, 129685], 2], [[129686, 129704], 2], [[129705, 129708], 2], [[129709, 129711], 2], [[129712, 129718], 2], [[129719, 129722], 2], [[129723, 129725], 2], [129726, 3], [129727, 2], [[129728, 129730], 2], [[129731, 129733], 2], [[129734, 129741], 3], [[129742, 129743], 2], [[129744, 129750], 2], [[129751, 129753], 2], [[129754, 129755], 2], [[129756, 129759], 3], [[129760, 129767], 2], [129768, 2], [[129769, 129775], 3], [[129776, 129782], 2], [[129783, 129784], 2], [[129785, 129791], 3], [[129792, 129938], 2], [129939, 3], [[129940, 129994], 2], [[129995, 130031], 3], [130032, 1, "0"], [130033, 1, "1"], [130034, 1, "2"], [130035, 1, "3"], [130036, 1, "4"], [130037, 1, "5"], [130038, 1, "6"], [130039, 1, "7"], [130040, 1, "8"], [130041, 1, "9"], [[130042, 131069], 3], [[131070, 131071], 3], [[131072, 173782], 2], [[173783, 173789], 2], [[173790, 173791], 2], [[173792, 173823], 3], [[173824, 177972], 2], [[177973, 177976], 2], [177977, 2], [[177978, 177983], 3], [[177984, 178205], 2], [[178206, 178207], 3], [[178208, 183969], 2], [[183970, 183983], 3], [[183984, 191456], 2], [[191457, 191471], 3], [[191472, 192093], 2], [[192094, 194559], 3], [194560, 1, ""], [194561, 1, ""], [194562, 1, ""], [194563, 1, ""], [194564, 1, ""], [194565, 1, ""], [194566, 1, ""], [194567, 1, ""], [194568, 1, ""], [194569, 1, ""], [194570, 1, ""], [194571, 1, ""], [194572, 1, ""], [194573, 1, ""], [194574, 1, ""], [194575, 1, ""], [194576, 1, ""], [194577, 1, ""], [194578, 1, ""], [194579, 1, ""], [194580, 1, ""], [194581, 1, ""], [194582, 1, ""], [194583, 1, ""], [194584, 1, ""], [194585, 1, ""], [194586, 1, ""], [194587, 1, ""], [194588, 1, ""], [194589, 1, ""], [194590, 1, ""], [194591, 1, ""], [194592, 1, ""], [194593, 1, ""], [194594, 1, ""], [194595, 1, ""], [194596, 1, ""], [194597, 1, ""], [194598, 1, ""], [194599, 1, ""], [194600, 1, ""], [194601, 1, ""], [194602, 1, ""], [194603, 1, ""], [194604, 1, ""], [194605, 1, ""], [194606, 1, ""], [194607, 1, ""], [194608, 1, ""], [[194609, 194611], 1, ""], [194612, 1, ""], [194613, 1, ""], [194614, 1, ""], [194615, 1, ""], [194616, 1, ""], [194617, 1, ""], [194618, 1, ""], [194619, 1, ""], [194620, 1, ""], [194621, 1, ""], [194622, 1, ""], [194623, 1, ""], [194624, 1, ""], [194625, 1, ""], [194626, 1, ""], [194627, 1, ""], [194628, 1, ""], [[194629, 194630], 1, ""], [194631, 1, ""], [194632, 1, ""], [194633, 1, ""], [194634, 1, ""], [194635, 1, ""], [194636, 1, ""], [194637, 1, ""], [194638, 1, ""], [194639, 1, ""], [194640, 1, ""], [194641, 1, ""], [194642, 1, ""], [194643, 1, ""], [194644, 1, ""], [194645, 1, ""], [194646, 1, ""], [194647, 1, ""], [194648, 1, ""], [194649, 1, ""], [194650, 1, ""], [194651, 1, ""], [194652, 1, ""], [194653, 1, ""], [194654, 1, ""], [194655, 1, ""], [194656, 1, ""], [194657, 1, ""], [194658, 1, ""], [194659, 1, ""], [194660, 1, ""], [194661, 1, ""], [194662, 1, ""], [194663, 1, ""], [194664, 3], [194665, 1, ""], [[194666, 194667], 1, ""], [194668, 1, ""], [194669, 1, ""], [194670, 1, ""], [194671, 1, ""], [194672, 1, ""], [194673, 1, ""], [194674, 1, ""], [194675, 1, ""], [194676, 3], [194677, 1, ""], [194678, 1, ""], [194679, 1, ""], [194680, 1, ""], [194681, 1, ""], [194682, 1, ""], [194683, 1, ""], [194684, 1, ""], [194685, 1, ""], [194686, 1, ""], [194687, 1, ""], [194688, 1, ""], [194689, 1, ""], [194690, 1, ""], [194691, 1, ""], [194692, 1, ""], [194693, 1, ""], [194694, 1, ""], [194695, 1, ""], [194696, 1, ""], [194697, 1, ""], [194698, 1, ""], [194699, 1, ""], [194700, 1, ""], [194701, 1, ""], [194702, 1, ""], [194703, 1, ""], [194704, 1, ""], [[194705, 194706], 1, ""], [194707, 1, ""], [[194708, 194709], 1, ""], [194710, 1, ""], [194711, 1, ""], [194712, 1, ""], [194713, 1, ""], [194714, 1, ""], [194715, 1, ""], [194716, 1, ""], [194717, 1, ""], [194718, 1, ""], [194719, 1, ""], [194720, 1, ""], [194721, 1, ""], [194722, 1, ""], [194723, 1, ""], [194724, 1, ""], [194725, 1, ""], [194726, 1, ""], [194727, 1, ""], [194728, 1, ""], [194729, 1, ""], [194730, 1, ""], [194731, 1, ""], [194732, 1, ""], [194733, 1, ""], [194734, 1, ""], [194735, 1, ""], [194736, 1, ""], [194737, 1, ""], [194738, 1, ""], [194739, 1, ""], [194740, 1, ""], [194741, 1, ""], [194742, 1, ""], [194743, 1, ""], [194744, 1, ""], [194745, 1, ""], [194746, 1, ""], [194747, 1, ""], [194748, 1, ""], [194749, 1, ""], [194750, 1, ""], [194751, 1, ""], [194752, 1, ""], [194753, 1, ""], [194754, 1, ""], [194755, 1, ""], [194756, 1, ""], [194757, 1, ""], [194758, 1, ""], [194759, 1, ""], [194760, 1, ""], [194761, 1, ""], [194762, 1, ""], [194763, 1, ""], [194764, 1, ""], [194765, 1, ""], [194766, 1, ""], [194767, 1, ""], [194768, 1, ""], [194769, 1, ""], [194770, 1, ""], [194771, 1, ""], [194772, 1, ""], [194773, 1, ""], [194774, 1, ""], [194775, 1, ""], [194776, 1, ""], [194777, 1, ""], [194778, 1, ""], [194779, 1, ""], [194780, 1, ""], [194781, 1, ""], [194782, 1, ""], [194783, 1, ""], [194784, 1, ""], [194785, 1, ""], [194786, 1, ""], [194787, 1, ""], [194788, 1, ""], [194789, 1, ""], [194790, 1, ""], [194791, 1, ""], [194792, 1, ""], [194793, 1, ""], [194794, 1, ""], [194795, 1, ""], [194796, 1, ""], [194797, 1, ""], [194798, 1, ""], [194799, 1, ""], [194800, 1, ""], [194801, 1, ""], [194802, 1, ""], [194803, 1, ""], [194804, 1, ""], [194805, 1, ""], [194806, 1, ""], [194807, 1, ""], [194808, 1, ""], [194809, 1, ""], [194810, 1, ""], [194811, 1, ""], [194812, 1, ""], [194813, 1, ""], [194814, 1, ""], [194815, 1, ""], [194816, 1, ""], [194817, 1, ""], [194818, 1, ""], [194819, 1, ""], [194820, 1, ""], [194821, 1, ""], [194822, 1, ""], [194823, 1, ""], [194824, 1, ""], [194825, 1, ""], [194826, 1, ""], [194827, 1, ""], [194828, 1, ""], [194829, 1, ""], [194830, 1, ""], [194831, 1, ""], [194832, 1, ""], [194833, 1, ""], [194834, 1, ""], [194835, 1, ""], [194836, 1, ""], [194837, 1, ""], [194838, 1, ""], [194839, 1, ""], [194840, 1, ""], [194841, 1, ""], [194842, 1, ""], [194843, 1, ""], [194844, 1, ""], [194845, 1, ""], [194846, 1, ""], [194847, 3], [194848, 1, ""], [194849, 1, ""], [194850, 1, ""], [194851, 1, ""], [194852, 1, ""], [194853, 1, ""], [194854, 1, ""], [194855, 1, ""], [194856, 1, ""], [194857, 1, ""], [194858, 1, ""], [194859, 1, ""], [[194860, 194861], 1, ""], [194862, 1, ""], [194863, 1, ""], [194864, 1, ""], [194865, 1, ""], [194866, 1, ""], [194867, 1, ""], [194868, 1, ""], [194869, 1, ""], [194870, 1, ""], [194871, 1, ""], [194872, 1, ""], [194873, 1, ""], [194874, 1, ""], [194875, 1, ""], [194876, 1, ""], [194877, 1, ""], [194878, 1, ""], [194879, 1, ""], [194880, 1, ""], [194881, 1, ""], [194882, 1, ""], [194883, 1, ""], [194884, 1, ""], [194885, 1, ""], [[194886, 194887], 1, ""], [194888, 1, ""], [194889, 1, ""], [194890, 1, ""], [194891, 1, ""], [194892, 1, ""], [194893, 1, ""], [194894, 1, ""], [194895, 1, ""], [194896, 1, ""], [194897, 1, ""], [194898, 1, ""], [194899, 1, ""], [194900, 1, ""], [194901, 1, ""], [194902, 1, ""], [194903, 1, ""], [194904, 1, ""], [194905, 1, ""], [194906, 1, ""], [194907, 1, ""], [194908, 1, ""], [[194909, 194910], 1, ""], [194911, 3], [194912, 1, ""], [194913, 1, ""], [194914, 1, ""], [194915, 1, ""], [194916, 1, ""], [194917, 1, ""], [194918, 1, ""], [194919, 1, ""], [194920, 1, ""], [194921, 1, ""], [194922, 1, ""], [194923, 1, ""], [194924, 1, ""], [194925, 1, ""], [194926, 1, ""], [194927, 1, ""], [194928, 1, ""], [194929, 1, ""], [194930, 1, ""], [194931, 1, ""], [194932, 1, ""], [194933, 1, ""], [194934, 1, ""], [194935, 1, ""], [194936, 1, ""], [194937, 1, ""], [194938, 1, ""], [194939, 1, ""], [194940, 1, ""], [194941, 1, ""], [194942, 1, ""], [194943, 1, ""], [194944, 1, ""], [194945, 1, ""], [194946, 1, ""], [194947, 1, ""], [194948, 1, ""], [194949, 1, ""], [194950, 1, ""], [194951, 1, ""], [194952, 1, ""], [194953, 1, ""], [194954, 1, ""], [194955, 1, ""], [194956, 1, ""], [194957, 1, ""], [194958, 1, ""], [194959, 1, ""], [194960, 1, ""], [194961, 1, ""], [194962, 1, ""], [194963, 1, ""], [194964, 1, ""], [194965, 1, ""], [194966, 1, ""], [194967, 1, ""], [194968, 1, ""], [194969, 1, ""], [194970, 1, ""], [194971, 1, ""], [194972, 1, ""], [194973, 1, ""], [194974, 1, ""], [194975, 1, ""], [194976, 1, ""], [194977, 1, ""], [194978, 1, ""], [194979, 1, ""], [194980, 1, ""], [194981, 1, ""], [194982, 1, ""], [194983, 1, ""], [194984, 1, ""], [194985, 1, ""], [194986, 1, ""], [194987, 1, ""], [194988, 1, ""], [194989, 1, ""], [194990, 1, ""], [194991, 1, ""], [194992, 1, ""], [194993, 1, ""], [194994, 1, ""], [194995, 1, ""], [194996, 1, ""], [194997, 1, ""], [194998, 1, ""], [194999, 1, ""], [195000, 1, ""], [195001, 1, ""], [195002, 1, ""], [195003, 1, ""], [195004, 1, ""], [195005, 1, ""], [195006, 1, ""], [195007, 3], [195008, 1, ""], [195009, 1, ""], [195010, 1, ""], [195011, 1, ""], [195012, 1, ""], [195013, 1, ""], [195014, 1, ""], [195015, 1, ""], [195016, 1, ""], [195017, 1, ""], [195018, 1, ""], [195019, 1, ""], [195020, 1, ""], [195021, 1, ""], [195022, 1, ""], [195023, 1, ""], [195024, 1, ""], [195025, 1, ""], [195026, 1, ""], [195027, 1, ""], [195028, 1, ""], [195029, 1, ""], [195030, 1, ""], [195031, 1, ""], [195032, 1, ""], [195033, 1, ""], [195034, 1, ""], [195035, 1, ""], [195036, 1, ""], [195037, 1, ""], [195038, 1, ""], [195039, 1, ""], [195040, 1, ""], [195041, 1, ""], [195042, 1, ""], [195043, 1, ""], [195044, 1, ""], [195045, 1, ""], [195046, 1, ""], [195047, 1, ""], [195048, 1, ""], [195049, 1, ""], [195050, 1, ""], [195051, 1, ""], [195052, 1, ""], [195053, 1, ""], [195054, 1, ""], [195055, 1, ""], [195056, 1, ""], [195057, 1, ""], [195058, 1, ""], [195059, 1, ""], [195060, 1, ""], [195061, 1, ""], [195062, 1, ""], [195063, 1, ""], [195064, 1, ""], [195065, 1, ""], [195066, 1, ""], [195067, 1, ""], [195068, 1, ""], [195069, 1, ""], [[195070, 195071], 1, ""], [195072, 1, ""], [195073, 1, ""], [195074, 1, ""], [195075, 1, ""], [195076, 1, ""], [195077, 1, ""], [195078, 1, ""], [195079, 1, ""], [195080, 1, ""], [195081, 1, ""], [195082, 1, ""], [195083, 1, ""], [195084, 1, ""], [195085, 1, ""], [195086, 1, ""], [195087, 1, ""], [195088, 1, ""], [195089, 1, ""], [195090, 1, ""], [195091, 1, ""], [195092, 1, ""], [195093, 1, ""], [195094, 1, ""], [195095, 1, ""], [195096, 1, ""], [195097, 1, ""], [195098, 1, ""], [195099, 1, ""], [195100, 1, ""], [195101, 1, ""], [[195102, 196605], 3], [[196606, 196607], 3], [[196608, 201546], 2], [[201547, 201551], 3], [[201552, 205743], 2], [[205744, 262141], 3], [[262142, 262143], 3], [[262144, 327677], 3], [[327678, 327679], 3], [[327680, 393213], 3], [[393214, 393215], 3], [[393216, 458749], 3], [[458750, 458751], 3], [[458752, 524285], 3], [[524286, 524287], 3], [[524288, 589821], 3], [[589822, 589823], 3], [[589824, 655357], 3], [[655358, 655359], 3], [[655360, 720893], 3], [[720894, 720895], 3], [[720896, 786429], 3], [[786430, 786431], 3], [[786432, 851965], 3], [[851966, 851967], 3], [[851968, 917501], 3], [[917502, 917503], 3], [917504, 3], [917505, 3], [[917506, 917535], 3], [[917536, 917631], 3], [[917632, 917759], 3], [[917760, 917999], 7], [[918000, 983037], 3], [[983038, 983039], 3], [[983040, 1048573], 3], [[1048574, 1048575], 3], [[1048576, 1114109], 3], [[1114110, 1114111], 3]];
});

// node_modules/tr46/lib/statusMapping.js
var require_statusMapping = __commonJS((exports, module) => {
  exports.STATUS_MAPPING = {
    mapped: 1,
    valid: 2,
    disallowed: 3,
    disallowed_STD3_valid: 4,
    disallowed_STD3_mapped: 5,
    deviation: 6,
    ignored: 7
  };
});

// node_modules/tr46/index.js
var require_tr46 = __commonJS((exports, module) => {
  function containsNonASCII(str) {
    return /[^\x00-\x7F]/u.test(str);
  }
  function findStatus(val, { useSTD3ASCIIRules }) {
    let start = 0;
    let end = mappingTable.length - 1;
    while (start <= end) {
      const mid = Math.floor((start + end) / 2);
      const target = mappingTable[mid];
      const min = Array.isArray(target[0]) ? target[0][0] : target[0];
      const max = Array.isArray(target[0]) ? target[0][1] : target[0];
      if (min <= val && max >= val) {
        if (useSTD3ASCIIRules && (target[1] === STATUS_MAPPING.disallowed_STD3_valid || target[1] === STATUS_MAPPING.disallowed_STD3_mapped)) {
          return [STATUS_MAPPING.disallowed, ...target.slice(2)];
        } else if (target[1] === STATUS_MAPPING.disallowed_STD3_valid) {
          return [STATUS_MAPPING.valid, ...target.slice(2)];
        } else if (target[1] === STATUS_MAPPING.disallowed_STD3_mapped) {
          return [STATUS_MAPPING.mapped, ...target.slice(2)];
        }
        return target.slice(1);
      } else if (min > val) {
        end = mid - 1;
      } else {
        start = mid + 1;
      }
    }
    return null;
  }
  function mapChars(domainName, { useSTD3ASCIIRules, transitionalProcessing }) {
    let processed = "";
    for (const ch of domainName) {
      const [status, mapping] = findStatus(ch.codePointAt(0), { useSTD3ASCIIRules });
      switch (status) {
        case STATUS_MAPPING.disallowed:
          processed += ch;
          break;
        case STATUS_MAPPING.ignored:
          break;
        case STATUS_MAPPING.mapped:
          if (transitionalProcessing && ch === "\u1E9E") {
            processed += "ss";
          } else {
            processed += mapping;
          }
          break;
        case STATUS_MAPPING.deviation:
          if (transitionalProcessing) {
            processed += mapping;
          } else {
            processed += ch;
          }
          break;
        case STATUS_MAPPING.valid:
          processed += ch;
          break;
      }
    }
    return processed;
  }
  function validateLabel(label, {
    checkHyphens,
    checkBidi,
    checkJoiners,
    transitionalProcessing,
    useSTD3ASCIIRules,
    isBidi
  }) {
    if (label.length === 0) {
      return true;
    }
    if (label.normalize("NFC") !== label) {
      return false;
    }
    const codePoints = Array.from(label);
    if (checkHyphens) {
      if (codePoints[2] === "-" && codePoints[3] === "-" || (label.startsWith("-") || label.endsWith("-"))) {
        return false;
      }
    }
    if (label.includes(".")) {
      return false;
    }
    if (regexes.combiningMarks.test(codePoints[0])) {
      return false;
    }
    for (const ch of codePoints) {
      const [status] = findStatus(ch.codePointAt(0), { useSTD3ASCIIRules });
      if (transitionalProcessing) {
        if (status !== STATUS_MAPPING.valid) {
          return false;
        }
      } else if (status !== STATUS_MAPPING.valid && status !== STATUS_MAPPING.deviation) {
        return false;
      }
    }
    if (checkJoiners) {
      let last = 0;
      for (const [i, ch] of codePoints.entries()) {
        if (ch === "\u200C" || ch === "\u200D") {
          if (i > 0) {
            if (regexes.combiningClassVirama.test(codePoints[i - 1])) {
              continue;
            }
            if (ch === "\u200C") {
              const next = codePoints.indexOf("\u200C", i + 1);
              const test = next < 0 ? codePoints.slice(last) : codePoints.slice(last, next);
              if (regexes.validZWNJ.test(test.join(""))) {
                last = i + 1;
                continue;
              }
            }
          }
          return false;
        }
      }
    }
    if (checkBidi && isBidi) {
      let rtl;
      if (regexes.bidiS1LTR.test(codePoints[0])) {
        rtl = false;
      } else if (regexes.bidiS1RTL.test(codePoints[0])) {
        rtl = true;
      } else {
        return false;
      }
      if (rtl) {
        if (!regexes.bidiS2.test(label) || !regexes.bidiS3.test(label) || regexes.bidiS4EN.test(label) && regexes.bidiS4AN.test(label)) {
          return false;
        }
      } else if (!regexes.bidiS5.test(label) || !regexes.bidiS6.test(label)) {
        return false;
      }
    }
    return true;
  }
  function isBidiDomain(labels) {
    const domain = labels.map((label) => {
      if (label.startsWith("xn--")) {
        try {
          return punycode.decode(label.substring(4));
        } catch (err) {
          return "";
        }
      }
      return label;
    }).join(".");
    return regexes.bidiDomain.test(domain);
  }
  function processing(domainName, options) {
    let string = mapChars(domainName, options);
    string = string.normalize("NFC");
    const labels = string.split(".");
    const isBidi = isBidiDomain(labels);
    let error = false;
    for (const [i, origLabel] of labels.entries()) {
      let label = origLabel;
      let transitionalProcessingForThisLabel = options.transitionalProcessing;
      if (label.startsWith("xn--")) {
        if (containsNonASCII(label)) {
          error = true;
          continue;
        }
        try {
          label = punycode.decode(label.substring(4));
        } catch {
          if (!options.ignoreInvalidPunycode) {
            error = true;
            continue;
          }
        }
        labels[i] = label;
        transitionalProcessingForThisLabel = false;
      }
      if (error) {
        continue;
      }
      const validation = validateLabel(label, {
        ...options,
        transitionalProcessing: transitionalProcessingForThisLabel,
        isBidi
      });
      if (!validation) {
        error = true;
      }
    }
    return {
      string: labels.join("."),
      error
    };
  }
  function toASCII(domainName, {
    checkHyphens = false,
    checkBidi = false,
    checkJoiners = false,
    useSTD3ASCIIRules = false,
    verifyDNSLength = false,
    transitionalProcessing = false,
    ignoreInvalidPunycode = false
  } = {}) {
    const result = processing(domainName, {
      checkHyphens,
      checkBidi,
      checkJoiners,
      useSTD3ASCIIRules,
      transitionalProcessing,
      ignoreInvalidPunycode
    });
    let labels = result.string.split(".");
    labels = labels.map((l) => {
      if (containsNonASCII(l)) {
        try {
          return `xn--${punycode.encode(l)}`;
        } catch (e) {
          result.error = true;
        }
      }
      return l;
    });
    if (verifyDNSLength) {
      const total = labels.join(".").length;
      if (total > 253 || total === 0) {
        result.error = true;
      }
      for (let i = 0;i < labels.length; ++i) {
        if (labels[i].length > 63 || labels[i].length === 0) {
          result.error = true;
          break;
        }
      }
    }
    if (result.error) {
      return null;
    }
    return labels.join(".");
  }
  function toUnicode(domainName, {
    checkHyphens = false,
    checkBidi = false,
    checkJoiners = false,
    useSTD3ASCIIRules = false,
    transitionalProcessing = false,
    ignoreInvalidPunycode = false
  } = {}) {
    const result = processing(domainName, {
      checkHyphens,
      checkBidi,
      checkJoiners,
      useSTD3ASCIIRules,
      transitionalProcessing,
      ignoreInvalidPunycode
    });
    return {
      domain: result.string,
      error: result.error
    };
  }
  var punycode = require_punycode();
  var regexes = require_regexes();
  var mappingTable = require_mappingTable();
  var { STATUS_MAPPING } = require_statusMapping();
  module.exports = {
    toASCII,
    toUnicode
  };
});

// node_modules/whatwg-url/lib/infra.js
var require_infra = __commonJS((exports, module) => {
  function isASCIIDigit(c) {
    return c >= 48 && c <= 57;
  }
  function isASCIIAlpha(c) {
    return c >= 65 && c <= 90 || c >= 97 && c <= 122;
  }
  function isASCIIAlphanumeric(c) {
    return isASCIIAlpha(c) || isASCIIDigit(c);
  }
  function isASCIIHex(c) {
    return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
  }
  module.exports = {
    isASCIIDigit,
    isASCIIAlpha,
    isASCIIAlphanumeric,
    isASCIIHex
  };
});

// node_modules/whatwg-url/lib/encoding.js
var require_encoding = __commonJS((exports, module) => {
  function utf8Encode(string) {
    return utf8Encoder.encode(string);
  }
  function utf8DecodeWithoutBOM(bytes) {
    return utf8Decoder.decode(bytes);
  }
  var utf8Encoder = new TextEncoder;
  var utf8Decoder = new TextDecoder("utf-8", { ignoreBOM: true });
  module.exports = {
    utf8Encode,
    utf8DecodeWithoutBOM
  };
});

// node_modules/whatwg-url/lib/percent-encoding.js
var require_percent_encoding = __commonJS((exports, module) => {
  function p(char) {
    return char.codePointAt(0);
  }
  function percentEncode(c) {
    let hex = c.toString(16).toUpperCase();
    if (hex.length === 1) {
      hex = `0${hex}`;
    }
    return `%${hex}`;
  }
  function percentDecodeBytes(input) {
    const output = new Uint8Array(input.byteLength);
    let outputIndex = 0;
    for (let i = 0;i < input.byteLength; ++i) {
      const byte = input[i];
      if (byte !== 37) {
        output[outputIndex++] = byte;
      } else if (byte === 37 && (!isASCIIHex(input[i + 1]) || !isASCIIHex(input[i + 2]))) {
        output[outputIndex++] = byte;
      } else {
        const bytePoint = parseInt(String.fromCodePoint(input[i + 1], input[i + 2]), 16);
        output[outputIndex++] = bytePoint;
        i += 2;
      }
    }
    return output.slice(0, outputIndex);
  }
  function percentDecodeString(input) {
    const bytes = utf8Encode(input);
    return percentDecodeBytes(bytes);
  }
  function isC0ControlPercentEncode(c) {
    return c <= 31 || c > 126;
  }
  function isFragmentPercentEncode(c) {
    return isC0ControlPercentEncode(c) || extraFragmentPercentEncodeSet.has(c);
  }
  function isQueryPercentEncode(c) {
    return isC0ControlPercentEncode(c) || extraQueryPercentEncodeSet.has(c);
  }
  function isSpecialQueryPercentEncode(c) {
    return isQueryPercentEncode(c) || c === p("'");
  }
  function isPathPercentEncode(c) {
    return isQueryPercentEncode(c) || extraPathPercentEncodeSet.has(c);
  }
  function isUserinfoPercentEncode(c) {
    return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
  }
  function isComponentPercentEncode(c) {
    return isUserinfoPercentEncode(c) || extraComponentPercentEncodeSet.has(c);
  }
  function isURLEncodedPercentEncode(c) {
    return isComponentPercentEncode(c) || extraURLEncodedPercentEncodeSet.has(c);
  }
  function utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate) {
    const bytes = utf8Encode(codePoint);
    let output = "";
    for (const byte of bytes) {
      if (!percentEncodePredicate(byte)) {
        output += String.fromCharCode(byte);
      } else {
        output += percentEncode(byte);
      }
    }
    return output;
  }
  function utf8PercentEncodeCodePoint(codePoint, percentEncodePredicate) {
    return utf8PercentEncodeCodePointInternal(String.fromCodePoint(codePoint), percentEncodePredicate);
  }
  function utf8PercentEncodeString(input, percentEncodePredicate, spaceAsPlus = false) {
    let output = "";
    for (const codePoint of input) {
      if (spaceAsPlus && codePoint === " ") {
        output += "+";
      } else {
        output += utf8PercentEncodeCodePointInternal(codePoint, percentEncodePredicate);
      }
    }
    return output;
  }
  var { isASCIIHex } = require_infra();
  var { utf8Encode } = require_encoding();
  var extraFragmentPercentEncodeSet = new Set([p(" "), p("\""), p("<"), p(">"), p("`")]);
  var extraQueryPercentEncodeSet = new Set([p(" "), p("\""), p("#"), p("<"), p(">")]);
  var extraPathPercentEncodeSet = new Set([p("?"), p("`"), p("{"), p("}")]);
  var extraUserinfoPercentEncodeSet = new Set([p("/"), p(":"), p(";"), p("="), p("@"), p("["), p("\\"), p("]"), p("^"), p("|")]);
  var extraComponentPercentEncodeSet = new Set([p("$"), p("%"), p("&"), p("+"), p(",")]);
  var extraURLEncodedPercentEncodeSet = new Set([p("!"), p("'"), p("("), p(")"), p("~")]);
  module.exports = {
    isC0ControlPercentEncode,
    isFragmentPercentEncode,
    isQueryPercentEncode,
    isSpecialQueryPercentEncode,
    isPathPercentEncode,
    isUserinfoPercentEncode,
    isURLEncodedPercentEncode,
    percentDecodeString,
    percentDecodeBytes,
    utf8PercentEncodeString,
    utf8PercentEncodeCodePoint
  };
});

// node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS((exports, module) => {
  function p(char) {
    return char.codePointAt(0);
  }
  function countSymbols(str) {
    return [...str].length;
  }
  function at(input, idx) {
    const c = input[idx];
    return isNaN(c) ? undefined : String.fromCodePoint(c);
  }
  function isSingleDot(buffer) {
    return buffer === "." || buffer.toLowerCase() === "%2e";
  }
  function isDoubleDot(buffer) {
    buffer = buffer.toLowerCase();
    return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
  }
  function isWindowsDriveLetterCodePoints(cp1, cp2) {
    return infra.isASCIIAlpha(cp1) && (cp2 === p(":") || cp2 === p("|"));
  }
  function isWindowsDriveLetterString(string) {
    return string.length === 2 && infra.isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
  }
  function isNormalizedWindowsDriveLetterString(string) {
    return string.length === 2 && infra.isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
  }
  function containsForbiddenHostCodePoint(string) {
    return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|<|>|\?|@|\[|\\|\]|\^|\|/u) !== -1;
  }
  function containsForbiddenDomainCodePoint(string) {
    return containsForbiddenHostCodePoint(string) || string.search(/[\u0000-\u001F]|%|\u007F/u) !== -1;
  }
  function isSpecialScheme(scheme) {
    return specialSchemes[scheme] !== undefined;
  }
  function isSpecial(url) {
    return isSpecialScheme(url.scheme);
  }
  function isNotSpecial(url) {
    return !isSpecialScheme(url.scheme);
  }
  function defaultPort(scheme) {
    return specialSchemes[scheme];
  }
  function parseIPv4Number(input) {
    if (input === "") {
      return failure;
    }
    let R = 10;
    if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
      input = input.substring(2);
      R = 16;
    } else if (input.length >= 2 && input.charAt(0) === "0") {
      input = input.substring(1);
      R = 8;
    }
    if (input === "") {
      return 0;
    }
    let regex = /[^0-7]/u;
    if (R === 10) {
      regex = /[^0-9]/u;
    }
    if (R === 16) {
      regex = /[^0-9A-Fa-f]/u;
    }
    if (regex.test(input)) {
      return failure;
    }
    return parseInt(input, R);
  }
  function parseIPv4(input) {
    const parts = input.split(".");
    if (parts[parts.length - 1] === "") {
      if (parts.length > 1) {
        parts.pop();
      }
    }
    if (parts.length > 4) {
      return failure;
    }
    const numbers = [];
    for (const part of parts) {
      const n = parseIPv4Number(part);
      if (n === failure) {
        return failure;
      }
      numbers.push(n);
    }
    for (let i = 0;i < numbers.length - 1; ++i) {
      if (numbers[i] > 255) {
        return failure;
      }
    }
    if (numbers[numbers.length - 1] >= 256 ** (5 - numbers.length)) {
      return failure;
    }
    let ipv4 = numbers.pop();
    let counter = 0;
    for (const n of numbers) {
      ipv4 += n * 256 ** (3 - counter);
      ++counter;
    }
    return ipv4;
  }
  function serializeIPv4(address) {
    let output = "";
    let n = address;
    for (let i = 1;i <= 4; ++i) {
      output = String(n % 256) + output;
      if (i !== 4) {
        output = `.${output}`;
      }
      n = Math.floor(n / 256);
    }
    return output;
  }
  function parseIPv6(input) {
    const address = [0, 0, 0, 0, 0, 0, 0, 0];
    let pieceIndex = 0;
    let compress2 = null;
    let pointer = 0;
    input = Array.from(input, (c) => c.codePointAt(0));
    if (input[pointer] === p(":")) {
      if (input[pointer + 1] !== p(":")) {
        return failure;
      }
      pointer += 2;
      ++pieceIndex;
      compress2 = pieceIndex;
    }
    while (pointer < input.length) {
      if (pieceIndex === 8) {
        return failure;
      }
      if (input[pointer] === p(":")) {
        if (compress2 !== null) {
          return failure;
        }
        ++pointer;
        ++pieceIndex;
        compress2 = pieceIndex;
        continue;
      }
      let value = 0;
      let length = 0;
      while (length < 4 && infra.isASCIIHex(input[pointer])) {
        value = value * 16 + parseInt(at(input, pointer), 16);
        ++pointer;
        ++length;
      }
      if (input[pointer] === p(".")) {
        if (length === 0) {
          return failure;
        }
        pointer -= length;
        if (pieceIndex > 6) {
          return failure;
        }
        let numbersSeen = 0;
        while (input[pointer] !== undefined) {
          let ipv4Piece = null;
          if (numbersSeen > 0) {
            if (input[pointer] === p(".") && numbersSeen < 4) {
              ++pointer;
            } else {
              return failure;
            }
          }
          if (!infra.isASCIIDigit(input[pointer])) {
            return failure;
          }
          while (infra.isASCIIDigit(input[pointer])) {
            const number = parseInt(at(input, pointer));
            if (ipv4Piece === null) {
              ipv4Piece = number;
            } else if (ipv4Piece === 0) {
              return failure;
            } else {
              ipv4Piece = ipv4Piece * 10 + number;
            }
            if (ipv4Piece > 255) {
              return failure;
            }
            ++pointer;
          }
          address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
          ++numbersSeen;
          if (numbersSeen === 2 || numbersSeen === 4) {
            ++pieceIndex;
          }
        }
        if (numbersSeen !== 4) {
          return failure;
        }
        break;
      } else if (input[pointer] === p(":")) {
        ++pointer;
        if (input[pointer] === undefined) {
          return failure;
        }
      } else if (input[pointer] !== undefined) {
        return failure;
      }
      address[pieceIndex] = value;
      ++pieceIndex;
    }
    if (compress2 !== null) {
      let swaps = pieceIndex - compress2;
      pieceIndex = 7;
      while (pieceIndex !== 0 && swaps > 0) {
        const temp = address[compress2 + swaps - 1];
        address[compress2 + swaps - 1] = address[pieceIndex];
        address[pieceIndex] = temp;
        --pieceIndex;
        --swaps;
      }
    } else if (compress2 === null && pieceIndex !== 8) {
      return failure;
    }
    return address;
  }
  function serializeIPv6(address) {
    let output = "";
    const compress2 = findTheIPv6AddressCompressedPieceIndex(address);
    let ignore0 = false;
    for (let pieceIndex = 0;pieceIndex <= 7; ++pieceIndex) {
      if (ignore0 && address[pieceIndex] === 0) {
        continue;
      } else if (ignore0) {
        ignore0 = false;
      }
      if (compress2 === pieceIndex) {
        const separator = pieceIndex === 0 ? "::" : ":";
        output += separator;
        ignore0 = true;
        continue;
      }
      output += address[pieceIndex].toString(16);
      if (pieceIndex !== 7) {
        output += ":";
      }
    }
    return output;
  }
  function parseHost(input, isOpaque = false) {
    if (input[0] === "[") {
      if (input[input.length - 1] !== "]") {
        return failure;
      }
      return parseIPv6(input.substring(1, input.length - 1));
    }
    if (isOpaque) {
      return parseOpaqueHost(input);
    }
    const domain = utf8DecodeWithoutBOM(percentDecodeString(input));
    const asciiDomain = domainToASCII(domain);
    if (asciiDomain === failure) {
      return failure;
    }
    if (containsForbiddenDomainCodePoint(asciiDomain)) {
      return failure;
    }
    if (endsInANumber(asciiDomain)) {
      return parseIPv4(asciiDomain);
    }
    return asciiDomain;
  }
  function endsInANumber(input) {
    const parts = input.split(".");
    if (parts[parts.length - 1] === "") {
      if (parts.length === 1) {
        return false;
      }
      parts.pop();
    }
    const last = parts[parts.length - 1];
    if (parseIPv4Number(last) !== failure) {
      return true;
    }
    if (/^[0-9]+$/u.test(last)) {
      return true;
    }
    return false;
  }
  function parseOpaqueHost(input) {
    if (containsForbiddenHostCodePoint(input)) {
      return failure;
    }
    return utf8PercentEncodeString(input, isC0ControlPercentEncode);
  }
  function findTheIPv6AddressCompressedPieceIndex(address) {
    let longestIndex = null;
    let longestSize = 1;
    let foundIndex = null;
    let foundSize = 0;
    for (let pieceIndex = 0;pieceIndex < address.length; ++pieceIndex) {
      if (address[pieceIndex] !== 0) {
        if (foundSize > longestSize) {
          longestIndex = foundIndex;
          longestSize = foundSize;
        }
        foundIndex = null;
        foundSize = 0;
      } else {
        if (foundIndex === null) {
          foundIndex = pieceIndex;
        }
        ++foundSize;
      }
    }
    if (foundSize > longestSize) {
      return foundIndex;
    }
    return longestIndex;
  }
  function serializeHost(host) {
    if (typeof host === "number") {
      return serializeIPv4(host);
    }
    if (host instanceof Array) {
      return `[${serializeIPv6(host)}]`;
    }
    return host;
  }
  function domainToASCII(domain, beStrict = false) {
    const result = tr46.toASCII(domain, {
      checkBidi: true,
      checkHyphens: false,
      checkJoiners: true,
      useSTD3ASCIIRules: beStrict,
      verifyDNSLength: beStrict
    });
    if (result === null || result === "") {
      return failure;
    }
    return result;
  }
  function trimControlChars(string) {
    let start = 0;
    let end = string.length;
    for (;start < end; ++start) {
      if (string.charCodeAt(start) > 32) {
        break;
      }
    }
    for (;end > start; --end) {
      if (string.charCodeAt(end - 1) > 32) {
        break;
      }
    }
    return string.substring(start, end);
  }
  function trimTabAndNewline(url) {
    return url.replace(/\u0009|\u000A|\u000D/ug, "");
  }
  function shortenPath(url) {
    const { path } = url;
    if (path.length === 0) {
      return;
    }
    if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
      return;
    }
    path.pop();
  }
  function includesCredentials(url) {
    return url.username !== "" || url.password !== "";
  }
  function cannotHaveAUsernamePasswordPort(url) {
    return url.host === null || url.host === "" || url.scheme === "file";
  }
  function hasAnOpaquePath(url) {
    return typeof url.path === "string";
  }
  function isNormalizedWindowsDriveLetter(string) {
    return /^[A-Za-z]:$/u.test(string);
  }
  function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
    this.pointer = 0;
    this.input = input;
    this.base = base || null;
    this.encodingOverride = encodingOverride || "utf-8";
    this.stateOverride = stateOverride;
    this.url = url;
    this.failure = false;
    this.parseError = false;
    if (!this.url) {
      this.url = {
        scheme: "",
        username: "",
        password: "",
        host: null,
        port: null,
        path: [],
        query: null,
        fragment: null
      };
      const res2 = trimControlChars(this.input);
      if (res2 !== this.input) {
        this.parseError = true;
      }
      this.input = res2;
    }
    const res = trimTabAndNewline(this.input);
    if (res !== this.input) {
      this.parseError = true;
    }
    this.input = res;
    this.state = stateOverride || "scheme start";
    this.buffer = "";
    this.atFlag = false;
    this.arrFlag = false;
    this.passwordTokenSeenFlag = false;
    this.input = Array.from(this.input, (c) => c.codePointAt(0));
    for (;this.pointer <= this.input.length; ++this.pointer) {
      const c = this.input[this.pointer];
      const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);
      const ret = this[`parse ${this.state}`](c, cStr);
      if (!ret) {
        break;
      } else if (ret === failure) {
        this.failure = true;
        break;
      }
    }
  }
  function startsWithWindowsDriveLetter(input, pointer) {
    const length = input.length - pointer;
    return length >= 2 && isWindowsDriveLetterCodePoints(input[pointer], input[pointer + 1]) && (length === 2 || fileOtherwiseCodePoints.has(input[pointer + 2]));
  }
  function serializeURL(url, excludeFragment) {
    let output = `${url.scheme}:`;
    if (url.host !== null) {
      output += "//";
      if (url.username !== "" || url.password !== "") {
        output += url.username;
        if (url.password !== "") {
          output += `:${url.password}`;
        }
        output += "@";
      }
      output += serializeHost(url.host);
      if (url.port !== null) {
        output += `:${url.port}`;
      }
    }
    if (url.host === null && !hasAnOpaquePath(url) && url.path.length > 1 && url.path[0] === "") {
      output += "/.";
    }
    output += serializePath(url);
    if (url.query !== null) {
      output += `?${url.query}`;
    }
    if (!excludeFragment && url.fragment !== null) {
      output += `#${url.fragment}`;
    }
    return output;
  }
  function serializeOrigin(tuple) {
    let result = `${tuple.scheme}://`;
    result += serializeHost(tuple.host);
    if (tuple.port !== null) {
      result += `:${tuple.port}`;
    }
    return result;
  }
  function serializePath(url) {
    if (hasAnOpaquePath(url)) {
      return url.path;
    }
    let output = "";
    for (const segment of url.path) {
      output += `/${segment}`;
    }
    return output;
  }
  var tr46 = require_tr46();
  var infra = require_infra();
  var { utf8DecodeWithoutBOM } = require_encoding();
  var {
    percentDecodeString,
    utf8PercentEncodeCodePoint,
    utf8PercentEncodeString,
    isC0ControlPercentEncode,
    isFragmentPercentEncode,
    isQueryPercentEncode,
    isSpecialQueryPercentEncode,
    isPathPercentEncode,
    isUserinfoPercentEncode
  } = require_percent_encoding();
  var specialSchemes = {
    ftp: 21,
    file: null,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var failure = Symbol("failure");
  URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
    if (infra.isASCIIAlpha(c)) {
      this.buffer += cStr.toLowerCase();
      this.state = "scheme";
    } else if (!this.stateOverride) {
      this.state = "no scheme";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
    if (infra.isASCIIAlphanumeric(c) || c === p("+") || c === p("-") || c === p(".")) {
      this.buffer += cStr.toLowerCase();
    } else if (c === p(":")) {
      if (this.stateOverride) {
        if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
          return false;
        }
        if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
          return false;
        }
        if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
          return false;
        }
        if (this.url.scheme === "file" && this.url.host === "") {
          return false;
        }
      }
      this.url.scheme = this.buffer;
      if (this.stateOverride) {
        if (this.url.port === defaultPort(this.url.scheme)) {
          this.url.port = null;
        }
        return false;
      }
      this.buffer = "";
      if (this.url.scheme === "file") {
        if (this.input[this.pointer + 1] !== p("/") || this.input[this.pointer + 2] !== p("/")) {
          this.parseError = true;
        }
        this.state = "file";
      } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
        this.state = "special relative or authority";
      } else if (isSpecial(this.url)) {
        this.state = "special authority slashes";
      } else if (this.input[this.pointer + 1] === p("/")) {
        this.state = "path or authority";
        ++this.pointer;
      } else {
        this.url.path = "";
        this.state = "opaque path";
      }
    } else if (!this.stateOverride) {
      this.buffer = "";
      this.state = "no scheme";
      this.pointer = -1;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
    if (this.base === null || hasAnOpaquePath(this.base) && c !== p("#")) {
      return failure;
    } else if (hasAnOpaquePath(this.base) && c === p("#")) {
      this.url.scheme = this.base.scheme;
      this.url.path = this.base.path;
      this.url.query = this.base.query;
      this.url.fragment = "";
      this.state = "fragment";
    } else if (this.base.scheme === "file") {
      this.state = "file";
      --this.pointer;
    } else {
      this.state = "relative";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
    if (c === p("/") && this.input[this.pointer + 1] === p("/")) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "relative";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
    if (c === p("/")) {
      this.state = "authority";
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
    this.url.scheme = this.base.scheme;
    if (c === p("/")) {
      this.state = "relative slash";
    } else if (isSpecial(this.url) && c === p("\\")) {
      this.parseError = true;
      this.state = "relative slash";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      if (c === p("?")) {
        this.url.query = "";
        this.state = "query";
      } else if (c === p("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (!isNaN(c)) {
        this.url.query = null;
        this.url.path.pop();
        this.state = "path";
        --this.pointer;
      }
    }
    return true;
  };
  URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
    if (isSpecial(this.url) && (c === p("/") || c === p("\\"))) {
      if (c === p("\\")) {
        this.parseError = true;
      }
      this.state = "special authority ignore slashes";
    } else if (c === p("/")) {
      this.state = "authority";
    } else {
      this.url.username = this.base.username;
      this.url.password = this.base.password;
      this.url.host = this.base.host;
      this.url.port = this.base.port;
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
    if (c === p("/") && this.input[this.pointer + 1] === p("/")) {
      this.state = "special authority ignore slashes";
      ++this.pointer;
    } else {
      this.parseError = true;
      this.state = "special authority ignore slashes";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
    if (c !== p("/") && c !== p("\\")) {
      this.state = "authority";
      --this.pointer;
    } else {
      this.parseError = true;
    }
    return true;
  };
  URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
    if (c === p("@")) {
      this.parseError = true;
      if (this.atFlag) {
        this.buffer = `%40${this.buffer}`;
      }
      this.atFlag = true;
      const len = countSymbols(this.buffer);
      for (let pointer = 0;pointer < len; ++pointer) {
        const codePoint = this.buffer.codePointAt(pointer);
        if (codePoint === p(":") && !this.passwordTokenSeenFlag) {
          this.passwordTokenSeenFlag = true;
          continue;
        }
        const encodedCodePoints = utf8PercentEncodeCodePoint(codePoint, isUserinfoPercentEncode);
        if (this.passwordTokenSeenFlag) {
          this.url.password += encodedCodePoints;
        } else {
          this.url.username += encodedCodePoints;
        }
      }
      this.buffer = "";
    } else if (isNaN(c) || c === p("/") || c === p("?") || c === p("#") || isSpecial(this.url) && c === p("\\")) {
      if (this.atFlag && this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      this.pointer -= countSymbols(this.buffer) + 1;
      this.buffer = "";
      this.state = "host";
    } else {
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
    if (this.stateOverride && this.url.scheme === "file") {
      --this.pointer;
      this.state = "file host";
    } else if (c === p(":") && !this.arrFlag) {
      if (this.buffer === "") {
        this.parseError = true;
        return failure;
      }
      if (this.stateOverride === "hostname") {
        return false;
      }
      const host = parseHost(this.buffer, isNotSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      this.url.host = host;
      this.buffer = "";
      this.state = "port";
    } else if (isNaN(c) || c === p("/") || c === p("?") || c === p("#") || isSpecial(this.url) && c === p("\\")) {
      --this.pointer;
      if (isSpecial(this.url) && this.buffer === "") {
        this.parseError = true;
        return failure;
      } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
        this.parseError = true;
        return false;
      }
      const host = parseHost(this.buffer, isNotSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      this.url.host = host;
      this.buffer = "";
      this.state = "path start";
      if (this.stateOverride) {
        return false;
      }
    } else {
      if (c === p("[")) {
        this.arrFlag = true;
      } else if (c === p("]")) {
        this.arrFlag = false;
      }
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
    if (infra.isASCIIDigit(c)) {
      this.buffer += cStr;
    } else if (isNaN(c) || c === p("/") || c === p("?") || c === p("#") || isSpecial(this.url) && c === p("\\") || this.stateOverride) {
      if (this.buffer !== "") {
        const port = parseInt(this.buffer);
        if (port > 2 ** 16 - 1) {
          this.parseError = true;
          return failure;
        }
        this.url.port = port === defaultPort(this.url.scheme) ? null : port;
        this.buffer = "";
      }
      if (this.stateOverride) {
        return false;
      }
      this.state = "path start";
      --this.pointer;
    } else {
      this.parseError = true;
      return failure;
    }
    return true;
  };
  var fileOtherwiseCodePoints = new Set([p("/"), p("\\"), p("?"), p("#")]);
  URLStateMachine.prototype["parse file"] = function parseFile(c) {
    this.url.scheme = "file";
    this.url.host = "";
    if (c === p("/") || c === p("\\")) {
      if (c === p("\\")) {
        this.parseError = true;
      }
      this.state = "file slash";
    } else if (this.base !== null && this.base.scheme === "file") {
      this.url.host = this.base.host;
      this.url.path = this.base.path.slice();
      this.url.query = this.base.query;
      if (c === p("?")) {
        this.url.query = "";
        this.state = "query";
      } else if (c === p("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (!isNaN(c)) {
        this.url.query = null;
        if (!startsWithWindowsDriveLetter(this.input, this.pointer)) {
          shortenPath(this.url);
        } else {
          this.parseError = true;
          this.url.path = [];
        }
        this.state = "path";
        --this.pointer;
      }
    } else {
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
    if (c === p("/") || c === p("\\")) {
      if (c === p("\\")) {
        this.parseError = true;
      }
      this.state = "file host";
    } else {
      if (this.base !== null && this.base.scheme === "file") {
        if (!startsWithWindowsDriveLetter(this.input, this.pointer) && isNormalizedWindowsDriveLetterString(this.base.path[0])) {
          this.url.path.push(this.base.path[0]);
        }
        this.url.host = this.base.host;
      }
      this.state = "path";
      --this.pointer;
    }
    return true;
  };
  URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
    if (isNaN(c) || c === p("/") || c === p("\\") || c === p("?") || c === p("#")) {
      --this.pointer;
      if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
        this.parseError = true;
        this.state = "path";
      } else if (this.buffer === "") {
        this.url.host = "";
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
      } else {
        let host = parseHost(this.buffer, isNotSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        if (host === "localhost") {
          host = "";
        }
        this.url.host = host;
        if (this.stateOverride) {
          return false;
        }
        this.buffer = "";
        this.state = "path start";
      }
    } else {
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
    if (isSpecial(this.url)) {
      if (c === p("\\")) {
        this.parseError = true;
      }
      this.state = "path";
      if (c !== p("/") && c !== p("\\")) {
        --this.pointer;
      }
    } else if (!this.stateOverride && c === p("?")) {
      this.url.query = "";
      this.state = "query";
    } else if (!this.stateOverride && c === p("#")) {
      this.url.fragment = "";
      this.state = "fragment";
    } else if (c !== undefined) {
      this.state = "path";
      if (c !== p("/")) {
        --this.pointer;
      }
    } else if (this.stateOverride && this.url.host === null) {
      this.url.path.push("");
    }
    return true;
  };
  URLStateMachine.prototype["parse path"] = function parsePath(c) {
    if (isNaN(c) || c === p("/") || isSpecial(this.url) && c === p("\\") || !this.stateOverride && (c === p("?") || c === p("#"))) {
      if (isSpecial(this.url) && c === p("\\")) {
        this.parseError = true;
      }
      if (isDoubleDot(this.buffer)) {
        shortenPath(this.url);
        if (c !== p("/") && !(isSpecial(this.url) && c === p("\\"))) {
          this.url.path.push("");
        }
      } else if (isSingleDot(this.buffer) && c !== p("/") && !(isSpecial(this.url) && c === p("\\"))) {
        this.url.path.push("");
      } else if (!isSingleDot(this.buffer)) {
        if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
          this.buffer = `${this.buffer[0]}:`;
        }
        this.url.path.push(this.buffer);
      }
      this.buffer = "";
      if (c === p("?")) {
        this.url.query = "";
        this.state = "query";
      }
      if (c === p("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else {
      if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += utf8PercentEncodeCodePoint(c, isPathPercentEncode);
    }
    return true;
  };
  URLStateMachine.prototype["parse opaque path"] = function parseOpaquePath(c) {
    if (c === p("?")) {
      this.url.query = "";
      this.state = "query";
    } else if (c === p("#")) {
      this.url.fragment = "";
      this.state = "fragment";
    } else {
      if (!isNaN(c) && c !== p("%")) {
        this.parseError = true;
      }
      if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      if (!isNaN(c)) {
        this.url.path += utf8PercentEncodeCodePoint(c, isC0ControlPercentEncode);
      }
    }
    return true;
  };
  URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
    if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
      this.encodingOverride = "utf-8";
    }
    if (!this.stateOverride && c === p("#") || isNaN(c)) {
      const queryPercentEncodePredicate = isSpecial(this.url) ? isSpecialQueryPercentEncode : isQueryPercentEncode;
      this.url.query += utf8PercentEncodeString(this.buffer, queryPercentEncodePredicate);
      this.buffer = "";
      if (c === p("#")) {
        this.url.fragment = "";
        this.state = "fragment";
      }
    } else if (!isNaN(c)) {
      if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.buffer += cStr;
    }
    return true;
  };
  URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
    if (!isNaN(c)) {
      if (c === p("%") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
        this.parseError = true;
      }
      this.url.fragment += utf8PercentEncodeCodePoint(c, isFragmentPercentEncode);
    }
    return true;
  };
  exports.serializeURL = serializeURL;
  exports.serializePath = serializePath;
  exports.serializeURLOrigin = function(url) {
    switch (url.scheme) {
      case "blob": {
        const pathURL = exports.parseURL(serializePath(url));
        if (pathURL === null) {
          return "null";
        }
        if (pathURL.scheme !== "http" && pathURL.scheme !== "https") {
          return "null";
        }
        return exports.serializeURLOrigin(pathURL);
      }
      case "ftp":
      case "http":
      case "https":
      case "ws":
      case "wss":
        return serializeOrigin({
          scheme: url.scheme,
          host: url.host,
          port: url.port
        });
      case "file":
        return "null";
      default:
        return "null";
    }
  };
  exports.basicURLParse = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
    if (usm.failure) {
      return null;
    }
    return usm.url;
  };
  exports.setTheUsername = function(url, username) {
    url.username = utf8PercentEncodeString(username, isUserinfoPercentEncode);
  };
  exports.setThePassword = function(url, password) {
    url.password = utf8PercentEncodeString(password, isUserinfoPercentEncode);
  };
  exports.serializeHost = serializeHost;
  exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
  exports.hasAnOpaquePath = hasAnOpaquePath;
  exports.serializeInteger = function(integer) {
    return String(integer);
  };
  exports.parseURL = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    return exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
  };
});

// node_modules/whatwg-url/lib/urlencoded.js
var require_urlencoded = __commonJS((exports, module) => {
  function p(char) {
    return char.codePointAt(0);
  }
  function parseUrlencoded(input) {
    const sequences = strictlySplitByteSequence(input, p("&"));
    const output = [];
    for (const bytes of sequences) {
      if (bytes.length === 0) {
        continue;
      }
      let name, value;
      const indexOfEqual = bytes.indexOf(p("="));
      if (indexOfEqual >= 0) {
        name = bytes.slice(0, indexOfEqual);
        value = bytes.slice(indexOfEqual + 1);
      } else {
        name = bytes;
        value = new Uint8Array(0);
      }
      name = replaceByteInByteSequence(name, 43, 32);
      value = replaceByteInByteSequence(value, 43, 32);
      const nameString = utf8DecodeWithoutBOM(percentDecodeBytes(name));
      const valueString = utf8DecodeWithoutBOM(percentDecodeBytes(value));
      output.push([nameString, valueString]);
    }
    return output;
  }
  function parseUrlencodedString(input) {
    return parseUrlencoded(utf8Encode(input));
  }
  function serializeUrlencoded(tuples, encodingOverride = undefined) {
    let encoding = "utf-8";
    if (encodingOverride !== undefined) {
      encoding = encodingOverride;
    }
    let output = "";
    for (const [i, tuple] of tuples.entries()) {
      const name = utf8PercentEncodeString(tuple[0], isURLEncodedPercentEncode, true);
      let value = tuple[1];
      if (tuple.length > 2 && tuple[2] !== undefined) {
        if (tuple[2] === "hidden" && name === "_charset_") {
          value = encoding;
        } else if (tuple[2] === "file") {
          value = value.name;
        }
      }
      value = utf8PercentEncodeString(value, isURLEncodedPercentEncode, true);
      if (i !== 0) {
        output += "&";
      }
      output += `${name}=${value}`;
    }
    return output;
  }
  function strictlySplitByteSequence(buf, cp) {
    const list = [];
    let last = 0;
    let i = buf.indexOf(cp);
    while (i >= 0) {
      list.push(buf.slice(last, i));
      last = i + 1;
      i = buf.indexOf(cp, last);
    }
    if (last !== buf.length) {
      list.push(buf.slice(last));
    }
    return list;
  }
  function replaceByteInByteSequence(buf, from, to) {
    let i = buf.indexOf(from);
    while (i >= 0) {
      buf[i] = to;
      i = buf.indexOf(from, i + 1);
    }
    return buf;
  }
  var { utf8Encode, utf8DecodeWithoutBOM } = require_encoding();
  var { percentDecodeBytes, utf8PercentEncodeString, isURLEncodedPercentEncode } = require_percent_encoding();
  module.exports = {
    parseUrlencodedString,
    serializeUrlencoded
  };
});

// node_modules/whatwg-url/lib/Function.js
var require_Function = __commonJS((exports) => {
  var conversions = require_lib();
  var utils = require_utils3();
  exports.convert = (globalObject, value, { context = "The provided value" } = {}) => {
    if (typeof value !== "function") {
      throw new globalObject.TypeError(context + " is not a function");
    }
    function invokeTheCallbackFunction(...args) {
      const thisArg = utils.tryWrapperForImpl(this);
      let callResult;
      for (let i = 0;i < args.length; i++) {
        args[i] = utils.tryWrapperForImpl(args[i]);
      }
      callResult = Reflect.apply(value, thisArg, args);
      callResult = conversions["any"](callResult, { context, globals: globalObject });
      return callResult;
    }
    invokeTheCallbackFunction.construct = (...args) => {
      for (let i = 0;i < args.length; i++) {
        args[i] = utils.tryWrapperForImpl(args[i]);
      }
      let callResult = Reflect.construct(value, args);
      callResult = conversions["any"](callResult, { context, globals: globalObject });
      return callResult;
    };
    invokeTheCallbackFunction[utils.wrapperSymbol] = value;
    invokeTheCallbackFunction.objectReference = value;
    return invokeTheCallbackFunction;
  };
});

// node_modules/whatwg-url/lib/URLSearchParams-impl.js
var require_URLSearchParams_impl = __commonJS((exports) => {
  var urlencoded = require_urlencoded();
  exports.implementation = class URLSearchParamsImpl {
    constructor(globalObject, constructorArgs, { doNotStripQMark = false }) {
      let init = constructorArgs[0];
      this._list = [];
      this._url = null;
      if (!doNotStripQMark && typeof init === "string" && init[0] === "?") {
        init = init.slice(1);
      }
      if (Array.isArray(init)) {
        for (const pair of init) {
          if (pair.length !== 2) {
            throw new TypeError("Failed to construct 'URLSearchParams': parameter 1 sequence's element does not " + "contain exactly two elements.");
          }
          this._list.push([pair[0], pair[1]]);
        }
      } else if (typeof init === "object" && Object.getPrototypeOf(init) === null) {
        for (const name of Object.keys(init)) {
          const value = init[name];
          this._list.push([name, value]);
        }
      } else {
        this._list = urlencoded.parseUrlencodedString(init);
      }
    }
    _updateSteps() {
      if (this._url !== null) {
        let serializedQuery = urlencoded.serializeUrlencoded(this._list);
        if (serializedQuery === "") {
          serializedQuery = null;
        }
        this._url._url.query = serializedQuery;
        if (serializedQuery === null) {
          this._url._potentiallyStripTrailingSpacesFromAnOpaquePath();
        }
      }
    }
    get size() {
      return this._list.length;
    }
    append(name, value) {
      this._list.push([name, value]);
      this._updateSteps();
    }
    delete(name, value) {
      let i = 0;
      while (i < this._list.length) {
        if (this._list[i][0] === name && (value === undefined || this._list[i][1] === value)) {
          this._list.splice(i, 1);
        } else {
          i++;
        }
      }
      this._updateSteps();
    }
    get(name) {
      for (const tuple of this._list) {
        if (tuple[0] === name) {
          return tuple[1];
        }
      }
      return null;
    }
    getAll(name) {
      const output = [];
      for (const tuple of this._list) {
        if (tuple[0] === name) {
          output.push(tuple[1]);
        }
      }
      return output;
    }
    has(name, value) {
      for (const tuple of this._list) {
        if (tuple[0] === name && (value === undefined || tuple[1] === value)) {
          return true;
        }
      }
      return false;
    }
    set(name, value) {
      let found = false;
      let i = 0;
      while (i < this._list.length) {
        if (this._list[i][0] === name) {
          if (found) {
            this._list.splice(i, 1);
          } else {
            found = true;
            this._list[i][1] = value;
            i++;
          }
        } else {
          i++;
        }
      }
      if (!found) {
        this._list.push([name, value]);
      }
      this._updateSteps();
    }
    sort() {
      this._list.sort((a, b) => {
        if (a[0] < b[0]) {
          return -1;
        }
        if (a[0] > b[0]) {
          return 1;
        }
        return 0;
      });
      this._updateSteps();
    }
    [Symbol.iterator]() {
      return this._list[Symbol.iterator]();
    }
    toString() {
      return urlencoded.serializeUrlencoded(this._list);
    }
  };
});

// node_modules/whatwg-url/lib/URLSearchParams.js
var require_URLSearchParams = __commonJS((exports) => {
  function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
      proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
      proto = globalObject[ctorRegistrySymbol]["URLSearchParams"].prototype;
    }
    return Object.create(proto);
  }
  var conversions = require_lib();
  var utils = require_utils3();
  var Function2 = require_Function();
  var newObjectInRealm = utils.newObjectInRealm;
  var implSymbol = utils.implSymbol;
  var ctorRegistrySymbol = utils.ctorRegistrySymbol;
  var interfaceName = "URLSearchParams";
  exports.is = (value) => {
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
  };
  exports.isImpl = (value) => {
    return utils.isObject(value) && value instanceof Impl.implementation;
  };
  exports.convert = (globalObject, value, { context = "The provided value" } = {}) => {
    if (exports.is(value)) {
      return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'URLSearchParams'.`);
  };
  exports.createDefaultIterator = (globalObject, target, kind) => {
    const ctorRegistry = globalObject[ctorRegistrySymbol];
    const iteratorPrototype = ctorRegistry["URLSearchParams Iterator"];
    const iterator = Object.create(iteratorPrototype);
    Object.defineProperty(iterator, utils.iterInternalSymbol, {
      value: { target, kind, index: 0 },
      configurable: true
    });
    return iterator;
  };
  exports.create = (globalObject, constructorArgs, privateData) => {
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
  };
  exports.createImpl = (globalObject, constructorArgs, privateData) => {
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
  };
  exports._internalSetup = (wrapper, globalObject) => {
  };
  exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
      value: new Impl.implementation(globalObject, constructorArgs, privateData),
      configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
      Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
  };
  exports.new = (globalObject, newTarget) => {
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
      value: Object.create(Impl.implementation.prototype),
      configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
      Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
  };
  var exposed = new Set(["Window", "Worker"]);
  exports.install = (globalObject, globalNames) => {
    if (!globalNames.some((globalName) => exposed.has(globalName))) {
      return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);

    class URLSearchParams {
      constructor() {
        const args = [];
        {
          let curArg = arguments[0];
          if (curArg !== undefined) {
            if (utils.isObject(curArg)) {
              if (curArg[Symbol.iterator] !== undefined) {
                if (!utils.isObject(curArg)) {
                  throw new globalObject.TypeError("Failed to construct 'URLSearchParams': parameter 1" + " sequence" + " is not an iterable object.");
                } else {
                  const V = [];
                  const tmp = curArg;
                  for (let nextItem of tmp) {
                    if (!utils.isObject(nextItem)) {
                      throw new globalObject.TypeError("Failed to construct 'URLSearchParams': parameter 1" + " sequence" + "'s element" + " is not an iterable object.");
                    } else {
                      const V2 = [];
                      const tmp2 = nextItem;
                      for (let nextItem2 of tmp2) {
                        nextItem2 = conversions["USVString"](nextItem2, {
                          context: "Failed to construct 'URLSearchParams': parameter 1" + " sequence" + "'s element" + "'s element",
                          globals: globalObject
                        });
                        V2.push(nextItem2);
                      }
                      nextItem = V2;
                    }
                    V.push(nextItem);
                  }
                  curArg = V;
                }
              } else {
                if (!utils.isObject(curArg)) {
                  throw new globalObject.TypeError("Failed to construct 'URLSearchParams': parameter 1" + " record" + " is not an object.");
                } else {
                  const result = Object.create(null);
                  for (const key of Reflect.ownKeys(curArg)) {
                    const desc = Object.getOwnPropertyDescriptor(curArg, key);
                    if (desc && desc.enumerable) {
                      let typedKey = key;
                      typedKey = conversions["USVString"](typedKey, {
                        context: "Failed to construct 'URLSearchParams': parameter 1" + " record" + "'s key",
                        globals: globalObject
                      });
                      let typedValue = curArg[key];
                      typedValue = conversions["USVString"](typedValue, {
                        context: "Failed to construct 'URLSearchParams': parameter 1" + " record" + "'s value",
                        globals: globalObject
                      });
                      result[typedKey] = typedValue;
                    }
                  }
                  curArg = result;
                }
              }
            } else {
              curArg = conversions["USVString"](curArg, {
                context: "Failed to construct 'URLSearchParams': parameter 1",
                globals: globalObject
              });
            }
          } else {
            curArg = "";
          }
          args.push(curArg);
        }
        return exports.setup(Object.create(new.target.prototype), globalObject, args);
      }
      append(name, value) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'append' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 2) {
          throw new globalObject.TypeError(`Failed to execute 'append' on 'URLSearchParams': 2 arguments required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'append' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'append' on 'URLSearchParams': parameter 2",
            globals: globalObject
          });
          args.push(curArg);
        }
        return utils.tryWrapperForImpl(esValue[implSymbol].append(...args));
      }
      delete(name) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'delete' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 1) {
          throw new globalObject.TypeError(`Failed to execute 'delete' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'delete' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          if (curArg !== undefined) {
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'delete' on 'URLSearchParams': parameter 2",
              globals: globalObject
            });
          }
          args.push(curArg);
        }
        return utils.tryWrapperForImpl(esValue[implSymbol].delete(...args));
      }
      get(name) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 1) {
          throw new globalObject.TypeError(`Failed to execute 'get' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'get' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        return esValue[implSymbol].get(...args);
      }
      getAll(name) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'getAll' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 1) {
          throw new globalObject.TypeError(`Failed to execute 'getAll' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'getAll' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        return utils.tryWrapperForImpl(esValue[implSymbol].getAll(...args));
      }
      has(name) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'has' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 1) {
          throw new globalObject.TypeError(`Failed to execute 'has' on 'URLSearchParams': 1 argument required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'has' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          if (curArg !== undefined) {
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'has' on 'URLSearchParams': parameter 2",
              globals: globalObject
            });
          }
          args.push(curArg);
        }
        return esValue[implSymbol].has(...args);
      }
      set(name, value) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 2) {
          throw new globalObject.TypeError(`Failed to execute 'set' on 'URLSearchParams': 2 arguments required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'set' on 'URLSearchParams': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'set' on 'URLSearchParams': parameter 2",
            globals: globalObject
          });
          args.push(curArg);
        }
        return utils.tryWrapperForImpl(esValue[implSymbol].set(...args));
      }
      sort() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'sort' called on an object that is not a valid instance of URLSearchParams.");
        }
        return utils.tryWrapperForImpl(esValue[implSymbol].sort());
      }
      toString() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'toString' called on an object that is not a valid instance of URLSearchParams.");
        }
        return esValue[implSymbol].toString();
      }
      keys() {
        if (!exports.is(this)) {
          throw new globalObject.TypeError("'keys' called on an object that is not a valid instance of URLSearchParams.");
        }
        return exports.createDefaultIterator(globalObject, this, "key");
      }
      values() {
        if (!exports.is(this)) {
          throw new globalObject.TypeError("'values' called on an object that is not a valid instance of URLSearchParams.");
        }
        return exports.createDefaultIterator(globalObject, this, "value");
      }
      entries() {
        if (!exports.is(this)) {
          throw new globalObject.TypeError("'entries' called on an object that is not a valid instance of URLSearchParams.");
        }
        return exports.createDefaultIterator(globalObject, this, "key+value");
      }
      forEach(callback) {
        if (!exports.is(this)) {
          throw new globalObject.TypeError("'forEach' called on an object that is not a valid instance of URLSearchParams.");
        }
        if (arguments.length < 1) {
          throw new globalObject.TypeError("Failed to execute 'forEach' on 'iterable': 1 argument required, but only 0 present.");
        }
        callback = Function2.convert(globalObject, callback, {
          context: "Failed to execute 'forEach' on 'iterable': The callback provided as parameter 1"
        });
        const thisArg = arguments[1];
        let pairs = Array.from(this[implSymbol]);
        let i = 0;
        while (i < pairs.length) {
          const [key, value] = pairs[i].map(utils.tryWrapperForImpl);
          callback.call(thisArg, value, key, this);
          pairs = Array.from(this[implSymbol]);
          i++;
        }
      }
      get size() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get size' called on an object that is not a valid instance of URLSearchParams.");
        }
        return esValue[implSymbol]["size"];
      }
    }
    Object.defineProperties(URLSearchParams.prototype, {
      append: { enumerable: true },
      delete: { enumerable: true },
      get: { enumerable: true },
      getAll: { enumerable: true },
      has: { enumerable: true },
      set: { enumerable: true },
      sort: { enumerable: true },
      toString: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true },
      forEach: { enumerable: true },
      size: { enumerable: true },
      [Symbol.toStringTag]: { value: "URLSearchParams", configurable: true },
      [Symbol.iterator]: { value: URLSearchParams.prototype.entries, configurable: true, writable: true }
    });
    ctorRegistry[interfaceName] = URLSearchParams;
    ctorRegistry["URLSearchParams Iterator"] = Object.create(ctorRegistry["%IteratorPrototype%"], {
      [Symbol.toStringTag]: {
        configurable: true,
        value: "URLSearchParams Iterator"
      }
    });
    utils.define(ctorRegistry["URLSearchParams Iterator"], {
      next() {
        const internal = this && this[utils.iterInternalSymbol];
        if (!internal) {
          throw new globalObject.TypeError("next() called on a value that is not a URLSearchParams iterator object");
        }
        const { target, kind, index } = internal;
        const values = Array.from(target[implSymbol]);
        const len = values.length;
        if (index >= len) {
          return newObjectInRealm(globalObject, { value: undefined, done: true });
        }
        const pair = values[index];
        internal.index = index + 1;
        return newObjectInRealm(globalObject, utils.iteratorResult(pair.map(utils.tryWrapperForImpl), kind));
      }
    });
    Object.defineProperty(globalObject, interfaceName, {
      configurable: true,
      writable: true,
      value: URLSearchParams
    });
  };
  var Impl = require_URLSearchParams_impl();
});

// node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS((exports) => {
  var usm = require_url_state_machine();
  var urlencoded = require_urlencoded();
  var URLSearchParams = require_URLSearchParams();
  exports.implementation = class URLImpl {
    constructor(globalObject, [url, base]) {
      let parsedBase = null;
      if (base !== undefined) {
        parsedBase = usm.basicURLParse(base);
        if (parsedBase === null) {
          throw new TypeError(`Invalid base URL: ${base}`);
        }
      }
      const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
      if (parsedURL === null) {
        throw new TypeError(`Invalid URL: ${url}`);
      }
      const query = parsedURL.query !== null ? parsedURL.query : "";
      this._url = parsedURL;
      this._query = URLSearchParams.createImpl(globalObject, [query], { doNotStripQMark: true });
      this._query._url = this;
    }
    static parse(globalObject, input, base) {
      try {
        return new URLImpl(globalObject, [input, base]);
      } catch {
        return null;
      }
    }
    static canParse(url, base) {
      let parsedBase = null;
      if (base !== undefined) {
        parsedBase = usm.basicURLParse(base);
        if (parsedBase === null) {
          return false;
        }
      }
      const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
      if (parsedURL === null) {
        return false;
      }
      return true;
    }
    get href() {
      return usm.serializeURL(this._url);
    }
    set href(v) {
      const parsedURL = usm.basicURLParse(v);
      if (parsedURL === null) {
        throw new TypeError(`Invalid URL: ${v}`);
      }
      this._url = parsedURL;
      this._query._list.splice(0);
      const { query } = parsedURL;
      if (query !== null) {
        this._query._list = urlencoded.parseUrlencodedString(query);
      }
    }
    get origin() {
      return usm.serializeURLOrigin(this._url);
    }
    get protocol() {
      return `${this._url.scheme}:`;
    }
    set protocol(v) {
      usm.basicURLParse(`${v}:`, { url: this._url, stateOverride: "scheme start" });
    }
    get username() {
      return this._url.username;
    }
    set username(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      usm.setTheUsername(this._url, v);
    }
    get password() {
      return this._url.password;
    }
    set password(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      usm.setThePassword(this._url, v);
    }
    get host() {
      const url = this._url;
      if (url.host === null) {
        return "";
      }
      if (url.port === null) {
        return usm.serializeHost(url.host);
      }
      return `${usm.serializeHost(url.host)}:${usm.serializeInteger(url.port)}`;
    }
    set host(v) {
      if (usm.hasAnOpaquePath(this._url)) {
        return;
      }
      usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
    }
    get hostname() {
      if (this._url.host === null) {
        return "";
      }
      return usm.serializeHost(this._url.host);
    }
    set hostname(v) {
      if (usm.hasAnOpaquePath(this._url)) {
        return;
      }
      usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
    }
    get port() {
      if (this._url.port === null) {
        return "";
      }
      return usm.serializeInteger(this._url.port);
    }
    set port(v) {
      if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
        return;
      }
      if (v === "") {
        this._url.port = null;
      } else {
        usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
      }
    }
    get pathname() {
      return usm.serializePath(this._url);
    }
    set pathname(v) {
      if (usm.hasAnOpaquePath(this._url)) {
        return;
      }
      this._url.path = [];
      usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
    }
    get search() {
      if (this._url.query === null || this._url.query === "") {
        return "";
      }
      return `?${this._url.query}`;
    }
    set search(v) {
      const url = this._url;
      if (v === "") {
        url.query = null;
        this._query._list = [];
        this._potentiallyStripTrailingSpacesFromAnOpaquePath();
        return;
      }
      const input = v[0] === "?" ? v.substring(1) : v;
      url.query = "";
      usm.basicURLParse(input, { url, stateOverride: "query" });
      this._query._list = urlencoded.parseUrlencodedString(input);
    }
    get searchParams() {
      return this._query;
    }
    get hash() {
      if (this._url.fragment === null || this._url.fragment === "") {
        return "";
      }
      return `#${this._url.fragment}`;
    }
    set hash(v) {
      if (v === "") {
        this._url.fragment = null;
        this._potentiallyStripTrailingSpacesFromAnOpaquePath();
        return;
      }
      const input = v[0] === "#" ? v.substring(1) : v;
      this._url.fragment = "";
      usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
    }
    toJSON() {
      return this.href;
    }
    _potentiallyStripTrailingSpacesFromAnOpaquePath() {
      if (!usm.hasAnOpaquePath(this._url)) {
        return;
      }
      if (this._url.fragment !== null) {
        return;
      }
      if (this._url.query !== null) {
        return;
      }
      this._url.path = this._url.path.replace(/\u0020+$/u, "");
    }
  };
});

// node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS((exports) => {
  function makeWrapper(globalObject, newTarget) {
    let proto;
    if (newTarget !== undefined) {
      proto = newTarget.prototype;
    }
    if (!utils.isObject(proto)) {
      proto = globalObject[ctorRegistrySymbol]["URL"].prototype;
    }
    return Object.create(proto);
  }
  var conversions = require_lib();
  var utils = require_utils3();
  var implSymbol = utils.implSymbol;
  var ctorRegistrySymbol = utils.ctorRegistrySymbol;
  var interfaceName = "URL";
  exports.is = (value) => {
    return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;
  };
  exports.isImpl = (value) => {
    return utils.isObject(value) && value instanceof Impl.implementation;
  };
  exports.convert = (globalObject, value, { context = "The provided value" } = {}) => {
    if (exports.is(value)) {
      return utils.implForWrapper(value);
    }
    throw new globalObject.TypeError(`${context} is not of type 'URL'.`);
  };
  exports.create = (globalObject, constructorArgs, privateData) => {
    const wrapper = makeWrapper(globalObject);
    return exports.setup(wrapper, globalObject, constructorArgs, privateData);
  };
  exports.createImpl = (globalObject, constructorArgs, privateData) => {
    const wrapper = exports.create(globalObject, constructorArgs, privateData);
    return utils.implForWrapper(wrapper);
  };
  exports._internalSetup = (wrapper, globalObject) => {
  };
  exports.setup = (wrapper, globalObject, constructorArgs = [], privateData = {}) => {
    privateData.wrapper = wrapper;
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
      value: new Impl.implementation(globalObject, constructorArgs, privateData),
      configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
      Impl.init(wrapper[implSymbol]);
    }
    return wrapper;
  };
  exports.new = (globalObject, newTarget) => {
    const wrapper = makeWrapper(globalObject, newTarget);
    exports._internalSetup(wrapper, globalObject);
    Object.defineProperty(wrapper, implSymbol, {
      value: Object.create(Impl.implementation.prototype),
      configurable: true
    });
    wrapper[implSymbol][utils.wrapperSymbol] = wrapper;
    if (Impl.init) {
      Impl.init(wrapper[implSymbol]);
    }
    return wrapper[implSymbol];
  };
  var exposed = new Set(["Window", "Worker"]);
  exports.install = (globalObject, globalNames) => {
    if (!globalNames.some((globalName) => exposed.has(globalName))) {
      return;
    }
    const ctorRegistry = utils.initCtorRegistry(globalObject);

    class URL2 {
      constructor(url) {
        if (arguments.length < 1) {
          throw new globalObject.TypeError(`Failed to construct 'URL': 1 argument required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to construct 'URL': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          if (curArg !== undefined) {
            curArg = conversions["USVString"](curArg, {
              context: "Failed to construct 'URL': parameter 2",
              globals: globalObject
            });
          }
          args.push(curArg);
        }
        return exports.setup(Object.create(new.target.prototype), globalObject, args);
      }
      toJSON() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'toJSON' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol].toJSON();
      }
      get href() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get href' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["href"];
      }
      set href(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set href' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'href' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["href"] = V;
      }
      toString() {
        const esValue = this;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'toString' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["href"];
      }
      get origin() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get origin' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["origin"];
      }
      get protocol() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get protocol' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["protocol"];
      }
      set protocol(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set protocol' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'protocol' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["protocol"] = V;
      }
      get username() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get username' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["username"];
      }
      set username(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set username' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'username' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["username"] = V;
      }
      get password() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get password' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["password"];
      }
      set password(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set password' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'password' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["password"] = V;
      }
      get host() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get host' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["host"];
      }
      set host(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set host' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'host' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["host"] = V;
      }
      get hostname() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get hostname' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["hostname"];
      }
      set hostname(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set hostname' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'hostname' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["hostname"] = V;
      }
      get port() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get port' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["port"];
      }
      set port(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set port' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'port' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["port"] = V;
      }
      get pathname() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get pathname' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["pathname"];
      }
      set pathname(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set pathname' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'pathname' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["pathname"] = V;
      }
      get search() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get search' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["search"];
      }
      set search(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set search' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'search' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["search"] = V;
      }
      get searchParams() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get searchParams' called on an object that is not a valid instance of URL.");
        }
        return utils.getSameObject(this, "searchParams", () => {
          return utils.tryWrapperForImpl(esValue[implSymbol]["searchParams"]);
        });
      }
      get hash() {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'get hash' called on an object that is not a valid instance of URL.");
        }
        return esValue[implSymbol]["hash"];
      }
      set hash(V) {
        const esValue = this !== null && this !== undefined ? this : globalObject;
        if (!exports.is(esValue)) {
          throw new globalObject.TypeError("'set hash' called on an object that is not a valid instance of URL.");
        }
        V = conversions["USVString"](V, {
          context: "Failed to set the 'hash' property on 'URL': The provided value",
          globals: globalObject
        });
        esValue[implSymbol]["hash"] = V;
      }
      static parse(url) {
        if (arguments.length < 1) {
          throw new globalObject.TypeError(`Failed to execute 'parse' on 'URL': 1 argument required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'parse' on 'URL': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          if (curArg !== undefined) {
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'parse' on 'URL': parameter 2",
              globals: globalObject
            });
          }
          args.push(curArg);
        }
        return utils.tryWrapperForImpl(Impl.implementation.parse(globalObject, ...args));
      }
      static canParse(url) {
        if (arguments.length < 1) {
          throw new globalObject.TypeError(`Failed to execute 'canParse' on 'URL': 1 argument required, but only ${arguments.length} present.`);
        }
        const args = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'canParse' on 'URL': parameter 1",
            globals: globalObject
          });
          args.push(curArg);
        }
        {
          let curArg = arguments[1];
          if (curArg !== undefined) {
            curArg = conversions["USVString"](curArg, {
              context: "Failed to execute 'canParse' on 'URL': parameter 2",
              globals: globalObject
            });
          }
          args.push(curArg);
        }
        return Impl.implementation.canParse(...args);
      }
    }
    Object.defineProperties(URL2.prototype, {
      toJSON: { enumerable: true },
      href: { enumerable: true },
      toString: { enumerable: true },
      origin: { enumerable: true },
      protocol: { enumerable: true },
      username: { enumerable: true },
      password: { enumerable: true },
      host: { enumerable: true },
      hostname: { enumerable: true },
      port: { enumerable: true },
      pathname: { enumerable: true },
      search: { enumerable: true },
      searchParams: { enumerable: true },
      hash: { enumerable: true },
      [Symbol.toStringTag]: { value: "URL", configurable: true }
    });
    Object.defineProperties(URL2, { parse: { enumerable: true }, canParse: { enumerable: true } });
    ctorRegistry[interfaceName] = URL2;
    Object.defineProperty(globalObject, interfaceName, {
      configurable: true,
      writable: true,
      value: URL2
    });
    if (globalNames.includes("Window")) {
      Object.defineProperty(globalObject, "webkitURL", {
        configurable: true,
        writable: true,
        value: URL2
      });
    }
  };
  var Impl = require_URL_impl();
});

// node_modules/whatwg-url/webidl2js-wrapper.js
var require_webidl2js_wrapper = __commonJS((exports) => {
  var URL2 = require_URL();
  var URLSearchParams = require_URLSearchParams();
  exports.URL = URL2;
  exports.URLSearchParams = URLSearchParams;
});

// node_modules/whatwg-url/index.js
var require_whatwg_url = __commonJS((exports) => {
  var { URL: URL2, URLSearchParams } = require_webidl2js_wrapper();
  var urlStateMachine = require_url_state_machine();
  var percentEncoding = require_percent_encoding();
  var sharedGlobalObject = { Array, Object, Promise, String, TypeError };
  URL2.install(sharedGlobalObject, ["Window"]);
  URLSearchParams.install(sharedGlobalObject, ["Window"]);
  exports.URL = sharedGlobalObject.URL;
  exports.URLSearchParams = sharedGlobalObject.URLSearchParams;
  exports.parseURL = urlStateMachine.parseURL;
  exports.basicURLParse = urlStateMachine.basicURLParse;
  exports.serializeURL = urlStateMachine.serializeURL;
  exports.serializePath = urlStateMachine.serializePath;
  exports.serializeHost = urlStateMachine.serializeHost;
  exports.serializeInteger = urlStateMachine.serializeInteger;
  exports.serializeURLOrigin = urlStateMachine.serializeURLOrigin;
  exports.setTheUsername = urlStateMachine.setTheUsername;
  exports.setThePassword = urlStateMachine.setThePassword;
  exports.cannotHaveAUsernamePasswordPort = urlStateMachine.cannotHaveAUsernamePasswordPort;
  exports.hasAnOpaquePath = urlStateMachine.hasAnOpaquePath;
  exports.percentDecodeString = percentEncoding.percentDecodeString;
  exports.percentDecodeBytes = percentEncoding.percentDecodeBytes;
});

// node_modules/mongodb-connection-string-url/lib/redact.js
var require_redact = __commonJS((exports) => {
  function redactValidConnectionString(inputUrl, options) {
    var _a, _b;
    const url = inputUrl.clone();
    const replacementString = (_a = options === null || options === undefined ? undefined : options.replacementString) !== null && _a !== undefined ? _a : "_credentials_";
    const redactUsernames = (_b = options === null || options === undefined ? undefined : options.redactUsernames) !== null && _b !== undefined ? _b : true;
    if ((url.username || url.password) && redactUsernames) {
      url.username = replacementString;
      url.password = "";
    } else if (url.password) {
      url.password = replacementString;
    }
    if (url.searchParams.has("authMechanismProperties")) {
      const props = new index_1.CommaAndColonSeparatedRecord(url.searchParams.get("authMechanismProperties"));
      if (props.get("AWS_SESSION_TOKEN")) {
        props.set("AWS_SESSION_TOKEN", replacementString);
        url.searchParams.set("authMechanismProperties", props.toString());
      }
    }
    if (url.searchParams.has("tlsCertificateKeyFilePassword")) {
      url.searchParams.set("tlsCertificateKeyFilePassword", replacementString);
    }
    if (url.searchParams.has("proxyUsername") && redactUsernames) {
      url.searchParams.set("proxyUsername", replacementString);
    }
    if (url.searchParams.has("proxyPassword")) {
      url.searchParams.set("proxyPassword", replacementString);
    }
    return url;
  }
  function redactConnectionString(uri, options) {
    var _a, _b;
    const replacementString = (_a = options === null || options === undefined ? undefined : options.replacementString) !== null && _a !== undefined ? _a : "<credentials>";
    const redactUsernames = (_b = options === null || options === undefined ? undefined : options.redactUsernames) !== null && _b !== undefined ? _b : true;
    let parsed;
    try {
      parsed = new index_1.default(uri);
    } catch (_c) {
    }
    if (parsed) {
      options = { ...options, replacementString: "___credentials___" };
      return parsed.redact(options).toString().replace(/___credentials___/g, replacementString);
    }
    const R = replacementString;
    const replacements = [
      (uri2) => uri2.replace(redactUsernames ? /(\/\/)(.*)(@)/g : /(\/\/[^@]*:)(.*)(@)/g, `\$1${R}\$3`),
      (uri2) => uri2.replace(/(AWS_SESSION_TOKEN(:|%3A))([^,&]+)/gi, `\$1${R}`),
      (uri2) => uri2.replace(/(tlsCertificateKeyFilePassword=)([^&]+)/gi, `\$1${R}`),
      (uri2) => redactUsernames ? uri2.replace(/(proxyUsername=)([^&]+)/gi, `\$1${R}`) : uri2,
      (uri2) => uri2.replace(/(proxyPassword=)([^&]+)/gi, `\$1${R}`)
    ];
    for (const replacer of replacements) {
      uri = replacer(uri);
    }
    return uri;
  }
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.redactConnectionString = exports.redactValidConnectionString = undefined;
  var index_1 = __importStar(require_lib2());
  exports.redactValidConnectionString = redactValidConnectionString;
  exports.redactConnectionString = redactConnectionString;
});

// node_modules/mongodb-connection-string-url/lib/index.js
var require_lib2 = __commonJS((exports) => {
  function connectionStringHasValidScheme(connectionString) {
    return connectionString.startsWith("mongodb://") || connectionString.startsWith("mongodb+srv://");
  }
  function caseInsenstiveURLSearchParams(Ctor) {
    return class CaseInsenstiveURLSearchParams extends Ctor {
      append(name, value) {
        return super.append(this._normalizeKey(name), value);
      }
      delete(name) {
        return super.delete(this._normalizeKey(name));
      }
      get(name) {
        return super.get(this._normalizeKey(name));
      }
      getAll(name) {
        return super.getAll(this._normalizeKey(name));
      }
      has(name) {
        return super.has(this._normalizeKey(name));
      }
      set(name, value) {
        return super.set(this._normalizeKey(name), value);
      }
      keys() {
        return super.keys();
      }
      values() {
        return super.values();
      }
      entries() {
        return super.entries();
      }
      [Symbol.iterator]() {
        return super[Symbol.iterator]();
      }
      _normalizeKey(name) {
        return CaseInsensitiveMap.prototype._normalizeKey.call(this, name);
      }
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CommaAndColonSeparatedRecord = exports.ConnectionString = exports.redactConnectionString = undefined;
  var whatwg_url_1 = require_whatwg_url();
  var redact_1 = require_redact();
  Object.defineProperty(exports, "redactConnectionString", { enumerable: true, get: function() {
    return redact_1.redactConnectionString;
  } });
  var DUMMY_HOSTNAME = "__this_is_a_placeholder__";
  var HOSTS_REGEX = /^(?<protocol>[^/]+):\/\/(?:(?<username>[^:@]*)(?::(?<password>[^@]*))?@)?(?<hosts>(?!:)[^/?@]*)(?<rest>.*)/;

  class CaseInsensitiveMap extends Map {
    delete(name) {
      return super.delete(this._normalizeKey(name));
    }
    get(name) {
      return super.get(this._normalizeKey(name));
    }
    has(name) {
      return super.has(this._normalizeKey(name));
    }
    set(name, value) {
      return super.set(this._normalizeKey(name), value);
    }
    _normalizeKey(name) {
      name = `${name}`;
      for (const key of this.keys()) {
        if (key.toLowerCase() === name.toLowerCase()) {
          name = key;
          break;
        }
      }
      return name;
    }
  }

  class URLWithoutHost extends whatwg_url_1.URL {
  }

  class MongoParseError extends Error {
    get name() {
      return "MongoParseError";
    }
  }

  class ConnectionString extends URLWithoutHost {
    constructor(uri, options = {}) {
      var _a;
      const { looseValidation } = options;
      if (!looseValidation && !connectionStringHasValidScheme(uri)) {
        throw new MongoParseError('Invalid scheme, expected connection string to start with "mongodb://" or "mongodb+srv://"');
      }
      const match = uri.match(HOSTS_REGEX);
      if (!match) {
        throw new MongoParseError(`Invalid connection string "${uri}"`);
      }
      const { protocol, username, password, hosts, rest } = (_a = match.groups) !== null && _a !== undefined ? _a : {};
      if (!looseValidation) {
        if (!protocol || !hosts) {
          throw new MongoParseError(`Protocol and host list are required in "${uri}"`);
        }
        try {
          decodeURIComponent(username !== null && username !== undefined ? username : "");
          decodeURIComponent(password !== null && password !== undefined ? password : "");
        } catch (err) {
          throw new MongoParseError(err.message);
        }
        const illegalCharacters = /[:/?#[\]@]/gi;
        if (username === null || username === undefined ? undefined : username.match(illegalCharacters)) {
          throw new MongoParseError(`Username contains unescaped characters ${username}`);
        }
        if (!username || !password) {
          const uriWithoutProtocol = uri.replace(`${protocol}://`, "");
          if (uriWithoutProtocol.startsWith("@") || uriWithoutProtocol.startsWith(":")) {
            throw new MongoParseError("URI contained empty userinfo section");
          }
        }
        if (password === null || password === undefined ? undefined : password.match(illegalCharacters)) {
          throw new MongoParseError("Password contains unescaped characters");
        }
      }
      let authString = "";
      if (typeof username === "string")
        authString += username;
      if (typeof password === "string")
        authString += `:${password}`;
      if (authString)
        authString += "@";
      try {
        super(`${protocol.toLowerCase()}://${authString}${DUMMY_HOSTNAME}${rest}`);
      } catch (err) {
        if (looseValidation) {
          new ConnectionString(uri, {
            ...options,
            looseValidation: false
          });
        }
        if (typeof err.message === "string") {
          err.message = err.message.replace(DUMMY_HOSTNAME, hosts);
        }
        throw err;
      }
      this._hosts = hosts.split(",");
      if (!looseValidation) {
        if (this.isSRV && this.hosts.length !== 1) {
          throw new MongoParseError("mongodb+srv URI cannot have multiple service names");
        }
        if (this.isSRV && this.hosts.some((host) => host.includes(":"))) {
          throw new MongoParseError("mongodb+srv URI cannot have port number");
        }
      }
      if (!this.pathname) {
        this.pathname = "/";
      }
      Object.setPrototypeOf(this.searchParams, caseInsenstiveURLSearchParams(this.searchParams.constructor).prototype);
    }
    get host() {
      return DUMMY_HOSTNAME;
    }
    set host(_ignored) {
      throw new Error("No single host for connection string");
    }
    get hostname() {
      return DUMMY_HOSTNAME;
    }
    set hostname(_ignored) {
      throw new Error("No single host for connection string");
    }
    get port() {
      return "";
    }
    set port(_ignored) {
      throw new Error("No single host for connection string");
    }
    get href() {
      return this.toString();
    }
    set href(_ignored) {
      throw new Error("Cannot set href for connection strings");
    }
    get isSRV() {
      return this.protocol.includes("srv");
    }
    get hosts() {
      return this._hosts;
    }
    set hosts(list) {
      this._hosts = list;
    }
    toString() {
      return super.toString().replace(DUMMY_HOSTNAME, this.hosts.join(","));
    }
    clone() {
      return new ConnectionString(this.toString(), {
        looseValidation: true
      });
    }
    redact(options) {
      return (0, redact_1.redactValidConnectionString)(this, options);
    }
    typedSearchParams() {
      const sametype = false;
      return this.searchParams;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      const { href, origin, protocol, username, password, hosts, pathname, search, searchParams, hash } = this;
      return { href, origin, protocol, username, password, hosts, pathname, search, searchParams, hash };
    }
  }
  exports.ConnectionString = ConnectionString;

  class CommaAndColonSeparatedRecord extends CaseInsensitiveMap {
    constructor(from) {
      super();
      for (const entry of (from !== null && from !== undefined ? from : "").split(",")) {
        if (!entry)
          continue;
        const colonIndex = entry.indexOf(":");
        if (colonIndex === -1) {
          this.set(entry, "");
        } else {
          this.set(entry.slice(0, colonIndex), entry.slice(colonIndex + 1));
        }
      }
    }
    toString() {
      return [...this].map((entry) => entry.join(":")).join(",");
    }
  }
  exports.CommaAndColonSeparatedRecord = CommaAndColonSeparatedRecord;
  exports.default = ConnectionString;
});

// node_modules/mongodb/package.json
var require_package2 = __commonJS((exports, module) => {
  module.exports = {
    name: "mongodb",
    version: "6.13.0",
    description: "The official MongoDB driver for Node.js",
    main: "lib/index.js",
    files: [
      "lib",
      "src",
      "etc/prepare.js",
      "mongodb.d.ts",
      "tsconfig.json"
    ],
    types: "mongodb.d.ts",
    repository: {
      type: "git",
      url: "git@github.com:mongodb/node-mongodb-native.git"
    },
    keywords: [
      "mongodb",
      "driver",
      "official"
    ],
    author: {
      name: "The MongoDB NodeJS Team",
      email: "dbx-node@mongodb.com"
    },
    dependencies: {
      "@mongodb-js/saslprep": "^1.1.9",
      bson: "^6.10.1",
      "mongodb-connection-string-url": "^3.0.0"
    },
    peerDependencies: {
      "@aws-sdk/credential-providers": "^3.188.0",
      "@mongodb-js/zstd": "^1.1.0 || ^2.0.0",
      "gcp-metadata": "^5.2.0",
      kerberos: "^2.0.1",
      "mongodb-client-encryption": ">=6.0.0 <7",
      snappy: "^7.2.2",
      socks: "^2.7.1"
    },
    peerDependenciesMeta: {
      "@aws-sdk/credential-providers": {
        optional: true
      },
      "@mongodb-js/zstd": {
        optional: true
      },
      kerberos: {
        optional: true
      },
      snappy: {
        optional: true
      },
      "mongodb-client-encryption": {
        optional: true
      },
      "gcp-metadata": {
        optional: true
      },
      socks: {
        optional: true
      }
    },
    devDependencies: {
      "@aws-sdk/credential-providers": "^3.686.0",
      "@iarna/toml": "^2.2.5",
      "@istanbuljs/nyc-config-typescript": "^1.0.2",
      "@microsoft/api-extractor": "^7.47.11",
      "@microsoft/tsdoc-config": "^0.17.0",
      "@mongodb-js/zstd": "^2.0.0",
      "@types/chai": "^4.3.17",
      "@types/chai-subset": "^1.3.5",
      "@types/express": "^4.17.21",
      "@types/kerberos": "^1.1.5",
      "@types/mocha": "^10.0.9",
      "@types/node": "^22.9.0",
      "@types/saslprep": "^1.0.3",
      "@types/semver": "^7.5.8",
      "@types/sinon": "^17.0.3",
      "@types/sinon-chai": "^3.2.12",
      "@types/whatwg-url": "^11.0.5",
      "@typescript-eslint/eslint-plugin": "8.4.0",
      "@typescript-eslint/parser": "8.4.0",
      chai: "^4.4.1",
      "chai-subset": "^1.6.0",
      chalk: "^4.1.2",
      eslint: "9.9.0",
      "eslint-config-prettier": "^9.1.0",
      "eslint-plugin-mocha": "^10.4.1",
      "eslint-plugin-prettier": "^5.2.1",
      "eslint-plugin-simple-import-sort": "^12.1.1",
      "eslint-plugin-tsdoc": "^0.3.0",
      "eslint-plugin-unused-imports": "^4.1.4",
      express: "^4.21.1",
      "gcp-metadata": "^5.3.0",
      "js-yaml": "^4.1.0",
      mocha: "^10.8.2",
      "mocha-sinon": "^2.1.2",
      "mongodb-client-encryption": "^6.1.0",
      "mongodb-legacy": "^6.1.3",
      nyc: "^15.1.0",
      prettier: "^3.3.3",
      semver: "^7.6.3",
      sinon: "^18.0.0",
      "sinon-chai": "^3.7.0",
      snappy: "^7.2.2",
      socks: "^2.8.1",
      "source-map-support": "^0.5.21",
      "ts-node": "^10.9.2",
      tsd: "^0.31.2",
      typescript: "5.5",
      "typescript-cached-transpile": "^0.0.6",
      "v8-heapsnapshot": "^1.3.1",
      yargs: "^17.7.2"
    },
    license: "Apache-2.0",
    engines: {
      node: ">=16.20.1"
    },
    bugs: {
      url: "https://jira.mongodb.org/projects/NODE/issues/"
    },
    homepage: "https://github.com/mongodb/node-mongodb-native",
    scripts: {
      "build:evergreen": "node .evergreen/generate_evergreen_tasks.js",
      "build:ts": "node ./node_modules/typescript/bin/tsc",
      "build:dts": "npm run build:ts && api-extractor run && node etc/clean_definition_files.cjs && ESLINT_USE_FLAT_CONFIG=false eslint --no-ignore --fix mongodb.d.ts lib/beta.d.ts",
      "build:docs": "./etc/docs/build.ts",
      "build:typedoc": "typedoc",
      "build:nightly": "node ./.github/scripts/nightly.mjs",
      "check:bench": "node test/benchmarks/driverBench",
      "check:coverage": "nyc npm run test:all",
      "check:integration-coverage": "nyc npm run check:test",
      "check:lambda": "mocha --config test/mocha_lambda.json test/integration/node-specific/examples/handler.test.js",
      "check:lambda:aws": "mocha --config test/mocha_lambda.json test/integration/node-specific/examples/aws_handler.test.js",
      "check:lint": "npm run build:dts && npm run check:dts && npm run check:eslint && npm run check:tsd",
      "check:eslint": "npm run build:dts && ESLINT_USE_FLAT_CONFIG=false eslint -v && ESLINT_USE_FLAT_CONFIG=false eslint --max-warnings=0 --ext '.js,.ts' src test",
      "check:tsd": "tsd --version && tsd",
      "check:dependencies": "mocha test/action/dependency.test.ts",
      "check:dts": "node ./node_modules/typescript/bin/tsc --noEmit mongodb.d.ts && tsd",
      "check:search-indexes": "nyc mocha --config test/mocha_mongodb.json test/manual/search-index-management.prose.test.ts",
      "check:test": "mocha --config test/mocha_mongodb.json test/integration",
      "check:unit": "mocha test/unit",
      "check:ts": "node ./node_modules/typescript/bin/tsc -v && node ./node_modules/typescript/bin/tsc --noEmit",
      "check:atlas": "mocha --config test/manual/mocharc.json test/manual/atlas_connectivity.test.ts",
      "check:resource-management": "mocha --config test/manual/mocharc.json test/manual/resource_management.test.ts",
      "check:drivers-atlas-testing": "mocha --config test/mocha_mongodb.json test/atlas/drivers_atlas_testing.test.ts",
      "check:adl": "mocha --config test/mocha_mongodb.json test/manual/atlas-data-lake-testing",
      "check:aws": "nyc mocha --config test/mocha_mongodb.json test/integration/auth/mongodb_aws.test.ts",
      "check:oidc-auth": "mocha --config test/mocha_mongodb.json test/integration/auth/auth.spec.test.ts",
      "check:oidc-test": "mocha --config test/mocha_mongodb.json test/integration/auth/mongodb_oidc.prose.test.ts",
      "check:oidc-azure": "mocha --config test/mocha_mongodb.json test/integration/auth/mongodb_oidc_azure.prose.05.test.ts",
      "check:oidc-gcp": "mocha --config test/mocha_mongodb.json test/integration/auth/mongodb_oidc_gcp.prose.06.test.ts",
      "check:oidc-k8s": "mocha --config test/mocha_mongodb.json test/integration/auth/mongodb_oidc_k8s.prose.07.test.ts",
      "check:ocsp": "mocha --config test/manual/mocharc.json test/manual/ocsp_support.test.js",
      "check:kerberos": "nyc mocha --config test/manual/mocharc.json test/manual/kerberos.test.ts",
      "check:tls": "mocha --config test/manual/mocharc.json test/manual/tls_support.test.ts",
      "check:ldap": "nyc mocha --config test/manual/mocharc.json test/manual/ldap.test.js",
      "check:socks5": "mocha --config test/manual/mocharc.json test/manual/socks5.test.ts",
      "check:csfle": "mocha --config test/mocha_mongodb.json test/integration/client-side-encryption",
      "check:snappy": "mocha test/unit/assorted/snappy.test.js",
      "check:x509": "mocha test/manual/x509_auth.test.ts",
      "fix:eslint": "npm run check:eslint -- --fix",
      prepare: "node etc/prepare.js",
      "preview:docs": "ts-node etc/docs/preview.ts",
      test: "npm run check:lint && npm run test:all",
      "test:all": "npm run check:unit && npm run check:test",
      "update:docs": "npm run build:docs -- --yes"
    },
    tsd: {
      directory: "test/types",
      compilerOptions: {
        strict: true,
        target: "esnext",
        module: "commonjs",
        moduleResolution: "node"
      }
    }
  };
});

// node_modules/mongodb/lib/cmap/handshake/client_metadata.js
var require_client_metadata = __commonJS((exports) => {
  function makeClientMetadata(options) {
    const metadataDocument = new LimitedSizeDocument(512);
    const { appName = "" } = options;
    if (appName.length > 0) {
      const name2 = Buffer.byteLength(appName, "utf8") <= 128 ? options.appName : Buffer.from(appName, "utf8").subarray(0, 128).toString("utf8");
      metadataDocument.ifItFitsItSits("application", { name: name2 });
    }
    const { name = "", version = "", platform = "" } = options.driverInfo;
    const driverInfo = {
      name: name.length > 0 ? `nodejs|${name}` : "nodejs",
      version: version.length > 0 ? `${NODE_DRIVER_VERSION}|${version}` : NODE_DRIVER_VERSION
    };
    if (!metadataDocument.ifItFitsItSits("driver", driverInfo)) {
      throw new error_1.MongoInvalidArgumentError("Unable to include driverInfo name and version, metadata cannot exceed 512 bytes");
    }
    let runtimeInfo = getRuntimeInfo();
    if (platform.length > 0) {
      runtimeInfo = `${runtimeInfo}|${platform}`;
    }
    if (!metadataDocument.ifItFitsItSits("platform", runtimeInfo)) {
      throw new error_1.MongoInvalidArgumentError("Unable to include driverInfo platform, metadata cannot exceed 512 bytes");
    }
    const osInfo = new Map().set("name", process2.platform).set("architecture", process2.arch).set("version", os.release()).set("type", os.type());
    if (!metadataDocument.ifItFitsItSits("os", osInfo)) {
      for (const key of osInfo.keys()) {
        osInfo.delete(key);
        if (osInfo.size === 0)
          break;
        if (metadataDocument.ifItFitsItSits("os", osInfo))
          break;
      }
    }
    const faasEnv = getFAASEnv();
    if (faasEnv != null) {
      if (!metadataDocument.ifItFitsItSits("env", faasEnv)) {
        for (const key of faasEnv.keys()) {
          faasEnv.delete(key);
          if (faasEnv.size === 0)
            break;
          if (metadataDocument.ifItFitsItSits("env", faasEnv))
            break;
        }
      }
    }
    return metadataDocument.toObject();
  }
  async function getContainerMetadata() {
    const containerMetadata = {};
    dockerPromise ??= (0, utils_1.fileIsAccessible)("/.dockerenv");
    const isDocker = await dockerPromise;
    const { KUBERNETES_SERVICE_HOST = "" } = process2.env;
    const isKubernetes = KUBERNETES_SERVICE_HOST.length > 0 ? true : false;
    if (isDocker)
      containerMetadata.runtime = "docker";
    if (isKubernetes)
      containerMetadata.orchestrator = "kubernetes";
    return containerMetadata;
  }
  async function addContainerMetadata(originalMetadata) {
    const containerMetadata = await getContainerMetadata();
    if (Object.keys(containerMetadata).length === 0)
      return originalMetadata;
    const extendedMetadata = new LimitedSizeDocument(512);
    const extendedEnvMetadata = { ...originalMetadata?.env, container: containerMetadata };
    for (const [key, val] of Object.entries(originalMetadata)) {
      if (key !== "env") {
        extendedMetadata.ifItFitsItSits(key, val);
      } else {
        if (!extendedMetadata.ifItFitsItSits("env", extendedEnvMetadata)) {
          extendedMetadata.ifItFitsItSits("env", val);
        }
      }
    }
    if (!("env" in originalMetadata)) {
      extendedMetadata.ifItFitsItSits("env", extendedEnvMetadata);
    }
    return extendedMetadata.toObject();
  }
  function getFAASEnv() {
    const { AWS_EXECUTION_ENV = "", AWS_LAMBDA_RUNTIME_API = "", FUNCTIONS_WORKER_RUNTIME = "", K_SERVICE = "", FUNCTION_NAME = "", VERCEL = "", AWS_LAMBDA_FUNCTION_MEMORY_SIZE = "", AWS_REGION = "", FUNCTION_MEMORY_MB = "", FUNCTION_REGION = "", FUNCTION_TIMEOUT_SEC = "", VERCEL_REGION = "" } = process2.env;
    const isAWSFaaS = AWS_EXECUTION_ENV.startsWith("AWS_Lambda_") || AWS_LAMBDA_RUNTIME_API.length > 0;
    const isAzureFaaS = FUNCTIONS_WORKER_RUNTIME.length > 0;
    const isGCPFaaS = K_SERVICE.length > 0 || FUNCTION_NAME.length > 0;
    const isVercelFaaS = VERCEL.length > 0;
    const faasEnv = new Map;
    if (isVercelFaaS && !(isAzureFaaS || isGCPFaaS)) {
      if (VERCEL_REGION.length > 0) {
        faasEnv.set("region", VERCEL_REGION);
      }
      faasEnv.set("name", "vercel");
      return faasEnv;
    }
    if (isAWSFaaS && !(isAzureFaaS || isGCPFaaS || isVercelFaaS)) {
      if (AWS_REGION.length > 0) {
        faasEnv.set("region", AWS_REGION);
      }
      if (AWS_LAMBDA_FUNCTION_MEMORY_SIZE.length > 0 && Number.isInteger(+AWS_LAMBDA_FUNCTION_MEMORY_SIZE)) {
        faasEnv.set("memory_mb", new bson_1.Int32(AWS_LAMBDA_FUNCTION_MEMORY_SIZE));
      }
      faasEnv.set("name", "aws.lambda");
      return faasEnv;
    }
    if (isAzureFaaS && !(isGCPFaaS || isAWSFaaS || isVercelFaaS)) {
      faasEnv.set("name", "azure.func");
      return faasEnv;
    }
    if (isGCPFaaS && !(isAzureFaaS || isAWSFaaS || isVercelFaaS)) {
      if (FUNCTION_REGION.length > 0) {
        faasEnv.set("region", FUNCTION_REGION);
      }
      if (FUNCTION_MEMORY_MB.length > 0 && Number.isInteger(+FUNCTION_MEMORY_MB)) {
        faasEnv.set("memory_mb", new bson_1.Int32(FUNCTION_MEMORY_MB));
      }
      if (FUNCTION_TIMEOUT_SEC.length > 0 && Number.isInteger(+FUNCTION_TIMEOUT_SEC)) {
        faasEnv.set("timeout_sec", new bson_1.Int32(FUNCTION_TIMEOUT_SEC));
      }
      faasEnv.set("name", "gcp.func");
      return faasEnv;
    }
    return null;
  }
  function getRuntimeInfo() {
    if ("Deno" in globalThis) {
      const version = typeof Deno?.version?.deno === "string" ? Deno?.version?.deno : "0.0.0-unknown";
      return `Deno v${version}, ${os.endianness()}`;
    }
    if ("Bun" in globalThis) {
      const version = typeof Bun?.version === "string" ? Bun?.version : "0.0.0-unknown";
      return `Bun v${version}, ${os.endianness()}`;
    }
    return `Node.js ${process2.version}, ${os.endianness()}`;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LimitedSizeDocument = undefined;
  exports.makeClientMetadata = makeClientMetadata;
  exports.addContainerMetadata = addContainerMetadata;
  exports.getFAASEnv = getFAASEnv;
  var os = import.meta.require("os");
  var process2 = import.meta.require("process");
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var utils_1 = require_utils2();
  var NODE_DRIVER_VERSION = require_package2().version;

  class LimitedSizeDocument {
    constructor(maxSize) {
      this.maxSize = maxSize;
      this.document = new Map;
      this.documentSize = 5;
    }
    ifItFitsItSits(key, value) {
      const newElementSize = bson_1.BSON.serialize(new Map().set(key, value)).byteLength - 5;
      if (newElementSize + this.documentSize > this.maxSize) {
        return false;
      }
      this.documentSize += newElementSize;
      this.document.set(key, value);
      return true;
    }
    toObject() {
      return bson_1.BSON.deserialize(bson_1.BSON.serialize(this.document), {
        promoteLongs: false,
        promoteBuffers: false,
        promoteValues: false,
        useBigInt64: false
      });
    }
  }
  exports.LimitedSizeDocument = LimitedSizeDocument;
  var dockerPromise;
});

// node_modules/mongodb/lib/cmap/commands.js
var require_commands = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OpCompressedRequest = exports.OpMsgResponse = exports.OpMsgRequest = exports.DocumentSequence = exports.OpReply = exports.OpQueryRequest = undefined;
  var BSON = require_bson2();
  var error_1 = require_error();
  var compression_1 = require_compression();
  var constants_1 = require_constants();
  var _requestId = 0;
  var OPTS_TAILABLE_CURSOR = 2;
  var OPTS_SECONDARY = 4;
  var OPTS_OPLOG_REPLAY = 8;
  var OPTS_NO_CURSOR_TIMEOUT = 16;
  var OPTS_AWAIT_DATA = 32;
  var OPTS_EXHAUST = 64;
  var OPTS_PARTIAL = 128;
  var CURSOR_NOT_FOUND = 1;
  var QUERY_FAILURE = 2;
  var SHARD_CONFIG_STALE = 4;
  var AWAIT_CAPABLE = 8;
  var encodeUTF8Into = BSON.BSON.onDemand.ByteUtils.encodeUTF8Into;

  class OpQueryRequest {
    constructor(databaseName, query, options) {
      this.databaseName = databaseName;
      this.query = query;
      this.moreToCome = false;
      const ns = `${databaseName}.\$cmd`;
      if (typeof databaseName !== "string") {
        throw new error_1.MongoRuntimeError("Database name must be a string for a query");
      }
      if (query == null)
        throw new error_1.MongoRuntimeError("A query document must be specified for query");
      if (ns.indexOf("\0") !== -1) {
        throw new error_1.MongoRuntimeError("Namespace cannot contain a null character");
      }
      this.ns = ns;
      this.numberToSkip = options.numberToSkip || 0;
      this.numberToReturn = options.numberToReturn || 0;
      this.returnFieldSelector = options.returnFieldSelector || undefined;
      this.requestId = options.requestId ?? OpQueryRequest.getRequestId();
      this.pre32Limit = options.pre32Limit;
      this.serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      this.ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : false;
      this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
      this.checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
      this.batchSize = this.numberToReturn;
      this.tailable = false;
      this.secondaryOk = typeof options.secondaryOk === "boolean" ? options.secondaryOk : false;
      this.oplogReplay = false;
      this.noCursorTimeout = false;
      this.awaitData = false;
      this.exhaust = false;
      this.partial = false;
    }
    incRequestId() {
      this.requestId = _requestId++;
    }
    nextRequestId() {
      return _requestId + 1;
    }
    static getRequestId() {
      return ++_requestId;
    }
    toBin() {
      const buffers = [];
      let projection = null;
      let flags = 0;
      if (this.tailable) {
        flags |= OPTS_TAILABLE_CURSOR;
      }
      if (this.secondaryOk) {
        flags |= OPTS_SECONDARY;
      }
      if (this.oplogReplay) {
        flags |= OPTS_OPLOG_REPLAY;
      }
      if (this.noCursorTimeout) {
        flags |= OPTS_NO_CURSOR_TIMEOUT;
      }
      if (this.awaitData) {
        flags |= OPTS_AWAIT_DATA;
      }
      if (this.exhaust) {
        flags |= OPTS_EXHAUST;
      }
      if (this.partial) {
        flags |= OPTS_PARTIAL;
      }
      if (this.batchSize !== this.numberToReturn)
        this.numberToReturn = this.batchSize;
      const header = Buffer.alloc(4 * 4 + 4 + Buffer.byteLength(this.ns) + 1 + 4 + 4);
      buffers.push(header);
      const query = BSON.serialize(this.query, {
        checkKeys: this.checkKeys,
        serializeFunctions: this.serializeFunctions,
        ignoreUndefined: this.ignoreUndefined
      });
      buffers.push(query);
      if (this.returnFieldSelector && Object.keys(this.returnFieldSelector).length > 0) {
        projection = BSON.serialize(this.returnFieldSelector, {
          checkKeys: this.checkKeys,
          serializeFunctions: this.serializeFunctions,
          ignoreUndefined: this.ignoreUndefined
        });
        buffers.push(projection);
      }
      const totalLength = header.length + query.length + (projection ? projection.length : 0);
      let index = 4;
      header[3] = totalLength >> 24 & 255;
      header[2] = totalLength >> 16 & 255;
      header[1] = totalLength >> 8 & 255;
      header[0] = totalLength & 255;
      header[index + 3] = this.requestId >> 24 & 255;
      header[index + 2] = this.requestId >> 16 & 255;
      header[index + 1] = this.requestId >> 8 & 255;
      header[index] = this.requestId & 255;
      index = index + 4;
      header[index + 3] = 0 >> 24 & 255;
      header[index + 2] = 0 >> 16 & 255;
      header[index + 1] = 0 >> 8 & 255;
      header[index] = 0 & 255;
      index = index + 4;
      header[index + 3] = constants_1.OP_QUERY >> 24 & 255;
      header[index + 2] = constants_1.OP_QUERY >> 16 & 255;
      header[index + 1] = constants_1.OP_QUERY >> 8 & 255;
      header[index] = constants_1.OP_QUERY & 255;
      index = index + 4;
      header[index + 3] = flags >> 24 & 255;
      header[index + 2] = flags >> 16 & 255;
      header[index + 1] = flags >> 8 & 255;
      header[index] = flags & 255;
      index = index + 4;
      index = index + header.write(this.ns, index, "utf8") + 1;
      header[index - 1] = 0;
      header[index + 3] = this.numberToSkip >> 24 & 255;
      header[index + 2] = this.numberToSkip >> 16 & 255;
      header[index + 1] = this.numberToSkip >> 8 & 255;
      header[index] = this.numberToSkip & 255;
      index = index + 4;
      header[index + 3] = this.numberToReturn >> 24 & 255;
      header[index + 2] = this.numberToReturn >> 16 & 255;
      header[index + 1] = this.numberToReturn >> 8 & 255;
      header[index] = this.numberToReturn & 255;
      index = index + 4;
      return buffers;
    }
  }
  exports.OpQueryRequest = OpQueryRequest;

  class OpReply {
    constructor(message, msgHeader, msgBody, opts) {
      this.index = 0;
      this.sections = [];
      this.moreToCome = false;
      this.parsed = false;
      this.raw = message;
      this.data = msgBody;
      this.opts = opts ?? {
        useBigInt64: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: false,
        bsonRegExp: false
      };
      this.length = msgHeader.length;
      this.requestId = msgHeader.requestId;
      this.responseTo = msgHeader.responseTo;
      this.opCode = msgHeader.opCode;
      this.fromCompressed = msgHeader.fromCompressed;
      this.useBigInt64 = typeof this.opts.useBigInt64 === "boolean" ? this.opts.useBigInt64 : false;
      this.promoteLongs = typeof this.opts.promoteLongs === "boolean" ? this.opts.promoteLongs : true;
      this.promoteValues = typeof this.opts.promoteValues === "boolean" ? this.opts.promoteValues : true;
      this.promoteBuffers = typeof this.opts.promoteBuffers === "boolean" ? this.opts.promoteBuffers : false;
      this.bsonRegExp = typeof this.opts.bsonRegExp === "boolean" ? this.opts.bsonRegExp : false;
    }
    isParsed() {
      return this.parsed;
    }
    parse() {
      if (this.parsed)
        return this.sections[0];
      this.index = 20;
      this.responseFlags = this.data.readInt32LE(0);
      this.cursorId = new BSON.Long(this.data.readInt32LE(4), this.data.readInt32LE(8));
      this.startingFrom = this.data.readInt32LE(12);
      this.numberReturned = this.data.readInt32LE(16);
      if (this.numberReturned < 0 || this.numberReturned > 2 ** 32 - 1) {
        throw new RangeError(`OP_REPLY numberReturned is an invalid array length ${this.numberReturned}`);
      }
      this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) !== 0;
      this.queryFailure = (this.responseFlags & QUERY_FAILURE) !== 0;
      this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) !== 0;
      this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) !== 0;
      for (let i = 0;i < this.numberReturned; i++) {
        const bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24;
        const section = this.data.subarray(this.index, this.index + bsonSize);
        this.sections.push(section);
        this.index = this.index + bsonSize;
      }
      this.parsed = true;
      return this.sections[0];
    }
  }
  exports.OpReply = OpReply;
  var OPTS_CHECKSUM_PRESENT = 1;
  var OPTS_MORE_TO_COME = 2;
  var OPTS_EXHAUST_ALLOWED = 1 << 16;

  class DocumentSequence {
    constructor(field, documents) {
      this.field = field;
      this.documents = [];
      this.chunks = [];
      this.serializedDocumentsLength = 0;
      const buffer = Buffer.allocUnsafe(1 + 4 + this.field.length + 1);
      buffer[0] = 1;
      encodeUTF8Into(buffer, `${this.field}\0`, 5);
      this.chunks.push(buffer);
      this.header = buffer;
      if (documents) {
        for (const doc of documents) {
          this.push(doc, BSON.serialize(doc));
        }
      }
    }
    push(document2, buffer) {
      this.serializedDocumentsLength += buffer.length;
      this.documents.push(document2);
      this.chunks.push(buffer);
      this.header?.writeInt32LE(4 + this.field.length + 1 + this.serializedDocumentsLength, 1);
      return this.serializedDocumentsLength + this.header.length;
    }
    toBin() {
      return Buffer.concat(this.chunks);
    }
  }
  exports.DocumentSequence = DocumentSequence;

  class OpMsgRequest {
    constructor(databaseName, command, options) {
      this.databaseName = databaseName;
      this.command = command;
      this.options = options;
      if (command == null)
        throw new error_1.MongoInvalidArgumentError("Query document must be specified for query");
      this.command.$db = databaseName;
      this.options = options ?? {};
      this.requestId = options.requestId ? options.requestId : OpMsgRequest.getRequestId();
      this.serializeFunctions = typeof options.serializeFunctions === "boolean" ? options.serializeFunctions : false;
      this.ignoreUndefined = typeof options.ignoreUndefined === "boolean" ? options.ignoreUndefined : false;
      this.checkKeys = typeof options.checkKeys === "boolean" ? options.checkKeys : false;
      this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;
      this.checksumPresent = false;
      this.moreToCome = options.moreToCome ?? command.writeConcern?.w === 0;
      this.exhaustAllowed = typeof options.exhaustAllowed === "boolean" ? options.exhaustAllowed : false;
    }
    toBin() {
      const buffers = [];
      let flags = 0;
      if (this.checksumPresent) {
        flags |= OPTS_CHECKSUM_PRESENT;
      }
      if (this.moreToCome) {
        flags |= OPTS_MORE_TO_COME;
      }
      if (this.exhaustAllowed) {
        flags |= OPTS_EXHAUST_ALLOWED;
      }
      const header = Buffer.alloc(4 * 4 + 4);
      buffers.push(header);
      let totalLength = header.length;
      const command = this.command;
      totalLength += this.makeSections(buffers, command);
      header.writeInt32LE(totalLength, 0);
      header.writeInt32LE(this.requestId, 4);
      header.writeInt32LE(0, 8);
      header.writeInt32LE(constants_1.OP_MSG, 12);
      header.writeUInt32LE(flags, 16);
      return buffers;
    }
    makeSections(buffers, document2) {
      const sequencesBuffer = this.extractDocumentSequences(document2);
      const payloadTypeBuffer = Buffer.allocUnsafe(1);
      payloadTypeBuffer[0] = 0;
      const documentBuffer = this.serializeBson(document2);
      buffers.push(payloadTypeBuffer);
      buffers.push(documentBuffer);
      buffers.push(sequencesBuffer);
      return payloadTypeBuffer.length + documentBuffer.length + sequencesBuffer.length;
    }
    extractDocumentSequences(document2) {
      const chunks = [];
      for (const [key, value] of Object.entries(document2)) {
        if (value instanceof DocumentSequence) {
          chunks.push(value.toBin());
          delete document2[key];
        }
      }
      if (chunks.length > 0) {
        return Buffer.concat(chunks);
      }
      return Buffer.alloc(0);
    }
    serializeBson(document2) {
      return BSON.serialize(document2, {
        checkKeys: this.checkKeys,
        serializeFunctions: this.serializeFunctions,
        ignoreUndefined: this.ignoreUndefined
      });
    }
    static getRequestId() {
      _requestId = _requestId + 1 & 2147483647;
      return _requestId;
    }
  }
  exports.OpMsgRequest = OpMsgRequest;

  class OpMsgResponse {
    constructor(message, msgHeader, msgBody, opts) {
      this.index = 0;
      this.sections = [];
      this.parsed = false;
      this.raw = message;
      this.data = msgBody;
      this.opts = opts ?? {
        useBigInt64: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: false,
        bsonRegExp: false
      };
      this.length = msgHeader.length;
      this.requestId = msgHeader.requestId;
      this.responseTo = msgHeader.responseTo;
      this.opCode = msgHeader.opCode;
      this.fromCompressed = msgHeader.fromCompressed;
      this.responseFlags = msgBody.readInt32LE(0);
      this.checksumPresent = (this.responseFlags & OPTS_CHECKSUM_PRESENT) !== 0;
      this.moreToCome = (this.responseFlags & OPTS_MORE_TO_COME) !== 0;
      this.exhaustAllowed = (this.responseFlags & OPTS_EXHAUST_ALLOWED) !== 0;
      this.useBigInt64 = typeof this.opts.useBigInt64 === "boolean" ? this.opts.useBigInt64 : false;
      this.promoteLongs = typeof this.opts.promoteLongs === "boolean" ? this.opts.promoteLongs : true;
      this.promoteValues = typeof this.opts.promoteValues === "boolean" ? this.opts.promoteValues : true;
      this.promoteBuffers = typeof this.opts.promoteBuffers === "boolean" ? this.opts.promoteBuffers : false;
      this.bsonRegExp = typeof this.opts.bsonRegExp === "boolean" ? this.opts.bsonRegExp : false;
    }
    isParsed() {
      return this.parsed;
    }
    parse() {
      if (this.parsed)
        return this.sections[0];
      this.index = 4;
      while (this.index < this.data.length) {
        const payloadType = this.data.readUInt8(this.index++);
        if (payloadType === 0) {
          const bsonSize = this.data.readUInt32LE(this.index);
          const bin = this.data.subarray(this.index, this.index + bsonSize);
          this.sections.push(bin);
          this.index += bsonSize;
        } else if (payloadType === 1) {
          throw new error_1.MongoRuntimeError("OP_MSG Payload Type 1 detected unsupported protocol");
        }
      }
      this.parsed = true;
      return this.sections[0];
    }
  }
  exports.OpMsgResponse = OpMsgResponse;
  var MESSAGE_HEADER_SIZE = 16;
  var COMPRESSION_DETAILS_SIZE = 9;

  class OpCompressedRequest {
    constructor(command, options) {
      this.command = command;
      this.options = options;
    }
    static canCompress(command) {
      const commandDoc = command instanceof OpMsgRequest ? command.command : command.query;
      const commandName = Object.keys(commandDoc)[0];
      return !compression_1.uncompressibleCommands.has(commandName);
    }
    async toBin() {
      const concatenatedOriginalCommandBuffer = Buffer.concat(this.command.toBin());
      const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);
      const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);
      const compressedMessage = await (0, compression_1.compress)(this.options, messageToBeCompressed);
      const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);
      msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0);
      msgHeader.writeInt32LE(this.command.requestId, 4);
      msgHeader.writeInt32LE(0, 8);
      msgHeader.writeInt32LE(constants_1.OP_COMPRESSED, 12);
      const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);
      compressionDetails.writeInt32LE(originalCommandOpCode, 0);
      compressionDetails.writeInt32LE(messageToBeCompressed.length, 4);
      compressionDetails.writeUInt8(compression_1.Compressor[this.options.agreedCompressor], 8);
      return [msgHeader, compressionDetails, compressedMessage];
    }
  }
  exports.OpCompressedRequest = OpCompressedRequest;
});

// node_modules/mongodb/lib/cmap/wire_protocol/compression.js
var require_compression = __commonJS((exports) => {
  function loadSnappy() {
    if (Snappy == null) {
      const snappyImport = (0, deps_1.getSnappy)();
      if ("kModuleError" in snappyImport) {
        throw snappyImport.kModuleError;
      }
      Snappy = snappyImport;
    }
    return Snappy;
  }
  async function compress2(options, dataToBeCompressed) {
    const zlibOptions = {};
    switch (options.agreedCompressor) {
      case "snappy": {
        Snappy ??= loadSnappy();
        return await Snappy.compress(dataToBeCompressed);
      }
      case "zstd": {
        loadZstd();
        if ("kModuleError" in zstd) {
          throw zstd["kModuleError"];
        }
        return await zstd.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL);
      }
      case "zlib": {
        if (options.zlibCompressionLevel) {
          zlibOptions.level = options.zlibCompressionLevel;
        }
        return await zlibDeflate(dataToBeCompressed, zlibOptions);
      }
      default: {
        throw new error_1.MongoInvalidArgumentError(`Unknown compressor ${options.agreedCompressor} failed to compress`);
      }
    }
  }
  async function decompress(compressorID, compressedData) {
    if (compressorID !== exports.Compressor.snappy && compressorID !== exports.Compressor.zstd && compressorID !== exports.Compressor.zlib && compressorID !== exports.Compressor.none) {
      throw new error_1.MongoDecompressionError(`Server sent message compressed using an unsupported compressor. (Received compressor ID ${compressorID})`);
    }
    switch (compressorID) {
      case exports.Compressor.snappy: {
        Snappy ??= loadSnappy();
        return await Snappy.uncompress(compressedData, { asBuffer: true });
      }
      case exports.Compressor.zstd: {
        loadZstd();
        if ("kModuleError" in zstd) {
          throw zstd["kModuleError"];
        }
        return await zstd.decompress(compressedData);
      }
      case exports.Compressor.zlib: {
        return await zlibInflate(compressedData);
      }
      default: {
        return compressedData;
      }
    }
  }
  function loadZstd() {
    if (!zstd) {
      zstd = (0, deps_1.getZstdLibrary)();
    }
  }
  async function compressCommand(command, description) {
    const finalCommand = description.agreedCompressor === "none" || !commands_1.OpCompressedRequest.canCompress(command) ? command : new commands_1.OpCompressedRequest(command, {
      agreedCompressor: description.agreedCompressor ?? "none",
      zlibCompressionLevel: description.zlibCompressionLevel ?? 0
    });
    const data = await finalCommand.toBin();
    return Buffer.concat(data);
  }
  async function decompressResponse(message) {
    const messageHeader = {
      length: message.readInt32LE(0),
      requestId: message.readInt32LE(4),
      responseTo: message.readInt32LE(8),
      opCode: message.readInt32LE(12)
    };
    if (messageHeader.opCode !== constants_2.OP_COMPRESSED) {
      const ResponseType2 = messageHeader.opCode === constants_2.OP_MSG ? commands_1.OpMsgResponse : commands_1.OpReply;
      const messageBody2 = message.subarray(MESSAGE_HEADER_SIZE);
      return new ResponseType2(message, messageHeader, messageBody2);
    }
    const header = {
      ...messageHeader,
      fromCompressed: true,
      opCode: message.readInt32LE(MESSAGE_HEADER_SIZE),
      length: message.readInt32LE(MESSAGE_HEADER_SIZE + 4)
    };
    const compressorID = message[MESSAGE_HEADER_SIZE + 8];
    const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);
    const ResponseType = header.opCode === constants_2.OP_MSG ? commands_1.OpMsgResponse : commands_1.OpReply;
    const messageBody = await decompress(compressorID, compressedBuffer);
    if (messageBody.length !== header.length) {
      throw new error_1.MongoDecompressionError("Message body and message header must be the same length");
    }
    return new ResponseType(message, header, messageBody);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uncompressibleCommands = exports.Compressor = undefined;
  exports.compress = compress2;
  exports.decompress = decompress;
  exports.compressCommand = compressCommand;
  exports.decompressResponse = decompressResponse;
  var util_1 = import.meta.require("util");
  var zlib = import.meta.require("zlib");
  var constants_1 = require_constants2();
  var deps_1 = require_deps();
  var error_1 = require_error();
  var commands_1 = require_commands();
  var constants_2 = require_constants();
  exports.Compressor = Object.freeze({
    none: 0,
    snappy: 1,
    zlib: 2,
    zstd: 3
  });
  exports.uncompressibleCommands = new Set([
    constants_1.LEGACY_HELLO_COMMAND,
    "saslStart",
    "saslContinue",
    "getnonce",
    "authenticate",
    "createUser",
    "updateUser",
    "copydbSaslStart",
    "copydbgetnonce",
    "copydb"
  ]);
  var ZSTD_COMPRESSION_LEVEL = 3;
  var zlibInflate = (0, util_1.promisify)(zlib.inflate.bind(zlib));
  var zlibDeflate = (0, util_1.promisify)(zlib.deflate.bind(zlib));
  var zstd;
  var Snappy = null;
  var MESSAGE_HEADER_SIZE = 16;
});

// node_modules/mongodb/lib/client-side-encryption/crypto_callbacks.js
var require_crypto_callbacks = __commonJS((exports) => {
  function makeAES256Hook(method, mode) {
    return function(key, iv, input, output) {
      let result;
      try {
        const cipher = crypto3[method](mode, key, iv);
        cipher.setAutoPadding(false);
        result = cipher.update(input);
        const final = cipher.final();
        if (final.length > 0) {
          result = Buffer.concat([result, final]);
        }
      } catch (e) {
        return e;
      }
      result.copy(output);
      return result.length;
    };
  }
  function randomHook(buffer, count) {
    try {
      crypto3.randomFillSync(buffer, 0, count);
    } catch (e) {
      return e;
    }
    return count;
  }
  function sha256Hook(input, output) {
    let result;
    try {
      result = crypto3.createHash("sha256").update(input).digest();
    } catch (e) {
      return e;
    }
    result.copy(output);
    return result.length;
  }
  function makeHmacHook(algorithm) {
    return (key, input, output) => {
      let result;
      try {
        result = crypto3.createHmac(algorithm, key).update(input).digest();
      } catch (e) {
        return e;
      }
      result.copy(output);
      return result.length;
    };
  }
  function signRsaSha256Hook(key, input, output) {
    let result;
    try {
      const signer = crypto3.createSign("sha256WithRSAEncryption");
      const privateKey = Buffer.from(`-----BEGIN PRIVATE KEY-----\n${key.toString("base64")}\n-----END PRIVATE KEY-----\n`);
      result = signer.update(input).end().sign(privateKey);
    } catch (e) {
      return e;
    }
    result.copy(output);
    return result.length;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hmacSha256Hook = exports.hmacSha512Hook = exports.aes256CtrDecryptHook = exports.aes256CtrEncryptHook = exports.aes256CbcDecryptHook = exports.aes256CbcEncryptHook = undefined;
  exports.makeAES256Hook = makeAES256Hook;
  exports.randomHook = randomHook;
  exports.sha256Hook = sha256Hook;
  exports.makeHmacHook = makeHmacHook;
  exports.signRsaSha256Hook = signRsaSha256Hook;
  var crypto3 = import.meta.require("crypto");
  exports.aes256CbcEncryptHook = makeAES256Hook("createCipheriv", "aes-256-cbc");
  exports.aes256CbcDecryptHook = makeAES256Hook("createDecipheriv", "aes-256-cbc");
  exports.aes256CtrEncryptHook = makeAES256Hook("createCipheriv", "aes-256-ctr");
  exports.aes256CtrDecryptHook = makeAES256Hook("createDecipheriv", "aes-256-ctr");
  exports.hmacSha512Hook = makeHmacHook("sha512");
  exports.hmacSha256Hook = makeHmacHook("sha256");
});

// node_modules/mongodb/lib/client-side-encryption/errors.js
var require_errors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoCryptKMSRequestNetworkTimeoutError = exports.MongoCryptAzureKMSRequestError = exports.MongoCryptCreateEncryptedCollectionError = exports.MongoCryptCreateDataKeyError = exports.MongoCryptInvalidArgumentError = exports.MongoCryptError = undefined;
  var error_1 = require_error();

  class MongoCryptError extends error_1.MongoError {
    constructor(message, options = {}) {
      super(message, options);
    }
    get name() {
      return "MongoCryptError";
    }
  }
  exports.MongoCryptError = MongoCryptError;

  class MongoCryptInvalidArgumentError extends MongoCryptError {
    constructor(message) {
      super(message);
    }
    get name() {
      return "MongoCryptInvalidArgumentError";
    }
  }
  exports.MongoCryptInvalidArgumentError = MongoCryptInvalidArgumentError;

  class MongoCryptCreateDataKeyError extends MongoCryptError {
    constructor(encryptedFields, { cause }) {
      super(`Unable to complete creating data keys: ${cause.message}`, { cause });
      this.encryptedFields = encryptedFields;
    }
    get name() {
      return "MongoCryptCreateDataKeyError";
    }
  }
  exports.MongoCryptCreateDataKeyError = MongoCryptCreateDataKeyError;

  class MongoCryptCreateEncryptedCollectionError extends MongoCryptError {
    constructor(encryptedFields, { cause }) {
      super(`Unable to create collection: ${cause.message}`, { cause });
      this.encryptedFields = encryptedFields;
    }
    get name() {
      return "MongoCryptCreateEncryptedCollectionError";
    }
  }
  exports.MongoCryptCreateEncryptedCollectionError = MongoCryptCreateEncryptedCollectionError;

  class MongoCryptAzureKMSRequestError extends MongoCryptError {
    constructor(message, body) {
      super(message);
      this.body = body;
    }
    get name() {
      return "MongoCryptAzureKMSRequestError";
    }
  }
  exports.MongoCryptAzureKMSRequestError = MongoCryptAzureKMSRequestError;

  class MongoCryptKMSRequestNetworkTimeoutError extends MongoCryptError {
    get name() {
      return "MongoCryptKMSRequestNetworkTimeoutError";
    }
  }
  exports.MongoCryptKMSRequestNetworkTimeoutError = MongoCryptKMSRequestNetworkTimeoutError;
});

// node_modules/mongodb/lib/cmap/auth/aws_temporary_credentials.js
var require_aws_temporary_credentials = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LegacyAWSTemporaryCredentialProvider = exports.AWSSDKCredentialProvider = exports.AWSTemporaryCredentialProvider = undefined;
  var deps_1 = require_deps();
  var error_1 = require_error();
  var utils_1 = require_utils2();
  var AWS_RELATIVE_URI = "http://169.254.170.2";
  var AWS_EC2_URI = "http://169.254.169.254";
  var AWS_EC2_PATH = "/latest/meta-data/iam/security-credentials";

  class AWSTemporaryCredentialProvider {
    static get awsSDK() {
      AWSTemporaryCredentialProvider._awsSDK ??= (0, deps_1.getAwsCredentialProvider)();
      return AWSTemporaryCredentialProvider._awsSDK;
    }
    static get isAWSSDKInstalled() {
      return !("kModuleError" in AWSTemporaryCredentialProvider.awsSDK);
    }
  }
  exports.AWSTemporaryCredentialProvider = AWSTemporaryCredentialProvider;

  class AWSSDKCredentialProvider extends AWSTemporaryCredentialProvider {
    get provider() {
      if ("kModuleError" in AWSTemporaryCredentialProvider.awsSDK) {
        throw AWSTemporaryCredentialProvider.awsSDK.kModuleError;
      }
      if (this._provider) {
        return this._provider;
      }
      let { AWS_STS_REGIONAL_ENDPOINTS = "", AWS_REGION = "" } = process.env;
      AWS_STS_REGIONAL_ENDPOINTS = AWS_STS_REGIONAL_ENDPOINTS.toLowerCase();
      AWS_REGION = AWS_REGION.toLowerCase();
      const awsRegionSettingsExist = AWS_REGION.length !== 0 && AWS_STS_REGIONAL_ENDPOINTS.length !== 0;
      const LEGACY_REGIONS = new Set([
        "ap-northeast-1",
        "ap-south-1",
        "ap-southeast-1",
        "ap-southeast-2",
        "aws-global",
        "ca-central-1",
        "eu-central-1",
        "eu-north-1",
        "eu-west-1",
        "eu-west-2",
        "eu-west-3",
        "sa-east-1",
        "us-east-1",
        "us-east-2",
        "us-west-1",
        "us-west-2"
      ]);
      const useRegionalSts = AWS_STS_REGIONAL_ENDPOINTS === "regional" || AWS_STS_REGIONAL_ENDPOINTS === "legacy" && !LEGACY_REGIONS.has(AWS_REGION);
      this._provider = awsRegionSettingsExist && useRegionalSts ? AWSTemporaryCredentialProvider.awsSDK.fromNodeProviderChain({
        clientConfig: { region: AWS_REGION }
      }) : AWSTemporaryCredentialProvider.awsSDK.fromNodeProviderChain();
      return this._provider;
    }
    async getCredentials() {
      try {
        const creds = await this.provider();
        return {
          AccessKeyId: creds.accessKeyId,
          SecretAccessKey: creds.secretAccessKey,
          Token: creds.sessionToken,
          Expiration: creds.expiration
        };
      } catch (error) {
        throw new error_1.MongoAWSError(error.message, { cause: error });
      }
    }
  }
  exports.AWSSDKCredentialProvider = AWSSDKCredentialProvider;

  class LegacyAWSTemporaryCredentialProvider extends AWSTemporaryCredentialProvider {
    async getCredentials() {
      if (process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {
        return await (0, utils_1.request)(`${AWS_RELATIVE_URI}${process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}`);
      }
      const token = await (0, utils_1.request)(`${AWS_EC2_URI}/latest/api/token`, {
        method: "PUT",
        json: false,
        headers: { "X-aws-ec2-metadata-token-ttl-seconds": 30 }
      });
      const roleName = await (0, utils_1.request)(`${AWS_EC2_URI}/${AWS_EC2_PATH}`, {
        json: false,
        headers: { "X-aws-ec2-metadata-token": token }
      });
      const creds = await (0, utils_1.request)(`${AWS_EC2_URI}/${AWS_EC2_PATH}/${roleName}`, {
        headers: { "X-aws-ec2-metadata-token": token }
      });
      return creds;
    }
  }
  exports.LegacyAWSTemporaryCredentialProvider = LegacyAWSTemporaryCredentialProvider;
});

// node_modules/mongodb/lib/client-side-encryption/providers/aws.js
var require_aws = __commonJS((exports) => {
  async function loadAWSCredentials(kmsProviders) {
    const credentialProvider = new aws_temporary_credentials_1.AWSSDKCredentialProvider;
    const { SecretAccessKey = "", AccessKeyId = "", Token } = await credentialProvider.getCredentials();
    const aws = {
      secretAccessKey: SecretAccessKey,
      accessKeyId: AccessKeyId
    };
    Token != null && (aws.sessionToken = Token);
    return { ...kmsProviders, aws };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.loadAWSCredentials = loadAWSCredentials;
  var aws_temporary_credentials_1 = require_aws_temporary_credentials();
});

// node_modules/mongodb/lib/client-side-encryption/providers/azure.js
var require_azure = __commonJS((exports) => {
  async function parseResponse(response) {
    const { status, body: rawBody } = response;
    const body = (() => {
      try {
        return JSON.parse(rawBody);
      } catch {
        throw new errors_1.MongoCryptAzureKMSRequestError("Malformed JSON body in GET request.");
      }
    })();
    if (status !== 200) {
      throw new errors_1.MongoCryptAzureKMSRequestError("Unable to complete request.", body);
    }
    if (!body.access_token) {
      throw new errors_1.MongoCryptAzureKMSRequestError("Malformed response body - missing field `access_token`.");
    }
    if (!body.expires_in) {
      throw new errors_1.MongoCryptAzureKMSRequestError("Malformed response body - missing field `expires_in`.");
    }
    const expiresInMS = Number(body.expires_in) * 1000;
    if (Number.isNaN(expiresInMS)) {
      throw new errors_1.MongoCryptAzureKMSRequestError("Malformed response body - unable to parse int from `expires_in` field.");
    }
    return {
      accessToken: body.access_token,
      expiresOnTimestamp: Date.now() + expiresInMS
    };
  }
  function addAzureParams(url, resource, username) {
    url.searchParams.append("api-version", "2018-02-01");
    url.searchParams.append("resource", resource);
    if (username) {
      url.searchParams.append("client_id", username);
    }
    return url;
  }
  function prepareRequest(options) {
    const url = new URL(options.url?.toString() ?? exports.AZURE_BASE_URL);
    addAzureParams(url, "https://vault.azure.net");
    const headers = { ...options.headers, "Content-Type": "application/json", Metadata: true };
    return { headers, url };
  }
  async function fetchAzureKMSToken(options = {}) {
    const { headers, url } = prepareRequest(options);
    try {
      const response = await (0, utils_1.get)(url, { headers });
      return await parseResponse(response);
    } catch (error) {
      if (error instanceof error_1.MongoNetworkTimeoutError) {
        throw new errors_1.MongoCryptAzureKMSRequestError(`[Azure KMS] ${error.message}`);
      }
      throw error;
    }
  }
  async function loadAzureCredentials(kmsProviders) {
    const azure = await exports.tokenCache.getToken();
    return { ...kmsProviders, azure };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tokenCache = exports.AzureCredentialCache = exports.AZURE_BASE_URL = undefined;
  exports.addAzureParams = addAzureParams;
  exports.prepareRequest = prepareRequest;
  exports.fetchAzureKMSToken = fetchAzureKMSToken;
  exports.loadAzureCredentials = loadAzureCredentials;
  var error_1 = require_error();
  var utils_1 = require_utils2();
  var errors_1 = require_errors();
  var MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS = 6000;
  exports.AZURE_BASE_URL = "http://169.254.169.254/metadata/identity/oauth2/token?";

  class AzureCredentialCache {
    constructor() {
      this.cachedToken = null;
    }
    async getToken() {
      if (this.cachedToken == null || this.needsRefresh(this.cachedToken)) {
        this.cachedToken = await this._getToken();
      }
      return { accessToken: this.cachedToken.accessToken };
    }
    needsRefresh(token) {
      const timeUntilExpirationMS = token.expiresOnTimestamp - Date.now();
      return timeUntilExpirationMS <= MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS;
    }
    resetCache() {
      this.cachedToken = null;
    }
    _getToken() {
      return fetchAzureKMSToken();
    }
  }
  exports.AzureCredentialCache = AzureCredentialCache;
  exports.tokenCache = new AzureCredentialCache;
});

// node_modules/mongodb/lib/client-side-encryption/providers/gcp.js
var require_gcp = __commonJS((exports) => {
  async function loadGCPCredentials(kmsProviders) {
    const gcpMetadata = (0, deps_1.getGcpMetadata)();
    if ("kModuleError" in gcpMetadata) {
      return kmsProviders;
    }
    const { access_token: accessToken } = await gcpMetadata.instance({
      property: "service-accounts/default/token"
    });
    return { ...kmsProviders, gcp: { accessToken } };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.loadGCPCredentials = loadGCPCredentials;
  var deps_1 = require_deps();
});

// node_modules/mongodb/lib/client-side-encryption/providers/index.js
var require_providers2 = __commonJS((exports) => {
  function isEmptyCredentials(providerName, kmsProviders) {
    const provider = kmsProviders[providerName];
    if (provider == null) {
      return false;
    }
    return typeof provider === "object" && Object.keys(provider).length === 0;
  }
  async function refreshKMSCredentials(kmsProviders) {
    let finalKMSProviders = kmsProviders;
    if (isEmptyCredentials("aws", kmsProviders)) {
      finalKMSProviders = await (0, aws_1.loadAWSCredentials)(finalKMSProviders);
    }
    if (isEmptyCredentials("gcp", kmsProviders)) {
      finalKMSProviders = await (0, gcp_1.loadGCPCredentials)(finalKMSProviders);
    }
    if (isEmptyCredentials("azure", kmsProviders)) {
      finalKMSProviders = await (0, azure_1.loadAzureCredentials)(finalKMSProviders);
    }
    return finalKMSProviders;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isEmptyCredentials = isEmptyCredentials;
  exports.refreshKMSCredentials = refreshKMSCredentials;
  var aws_1 = require_aws();
  var azure_1 = require_azure();
  var gcp_1 = require_gcp();
});

// node_modules/mongodb/lib/client-side-encryption/state_machine.js
var require_state_machine = __commonJS((exports) => {
  function loadSocks() {
    if (socks == null) {
      const socksImport = (0, deps_1.getSocks)();
      if ("kModuleError" in socksImport) {
        throw socksImport.kModuleError;
      }
      socks = socksImport;
    }
    return socks;
  }
  function debug(msg) {
    if (process.env.MONGODB_CRYPT_DEBUG) {
      console.error(msg);
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StateMachine = undefined;
  var fs = import.meta.require("fs/promises");
  var net = import.meta.require("net");
  var tls = import.meta.require("tls");
  var bson_1 = require_bson2();
  var abstract_cursor_1 = require_abstract_cursor();
  var deps_1 = require_deps();
  var error_1 = require_error();
  var timeout_1 = require_timeout();
  var utils_1 = require_utils2();
  var client_encryption_1 = require_client_encryption();
  var errors_1 = require_errors();
  var socks = null;
  var MONGOCRYPT_CTX_ERROR = 0;
  var MONGOCRYPT_CTX_NEED_MONGO_COLLINFO = 1;
  var MONGOCRYPT_CTX_NEED_MONGO_MARKINGS = 2;
  var MONGOCRYPT_CTX_NEED_MONGO_KEYS = 3;
  var MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS = 7;
  var MONGOCRYPT_CTX_NEED_KMS = 4;
  var MONGOCRYPT_CTX_READY = 5;
  var MONGOCRYPT_CTX_DONE = 6;
  var HTTPS_PORT = 443;
  var stateToString = new Map([
    [MONGOCRYPT_CTX_ERROR, "MONGOCRYPT_CTX_ERROR"],
    [MONGOCRYPT_CTX_NEED_MONGO_COLLINFO, "MONGOCRYPT_CTX_NEED_MONGO_COLLINFO"],
    [MONGOCRYPT_CTX_NEED_MONGO_MARKINGS, "MONGOCRYPT_CTX_NEED_MONGO_MARKINGS"],
    [MONGOCRYPT_CTX_NEED_MONGO_KEYS, "MONGOCRYPT_CTX_NEED_MONGO_KEYS"],
    [MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS, "MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS"],
    [MONGOCRYPT_CTX_NEED_KMS, "MONGOCRYPT_CTX_NEED_KMS"],
    [MONGOCRYPT_CTX_READY, "MONGOCRYPT_CTX_READY"],
    [MONGOCRYPT_CTX_DONE, "MONGOCRYPT_CTX_DONE"]
  ]);
  var INSECURE_TLS_OPTIONS = [
    "tlsInsecure",
    "tlsAllowInvalidCertificates",
    "tlsAllowInvalidHostnames",
    "tlsDisableOCSPEndpointCheck",
    "tlsDisableCertificateRevocationCheck"
  ];
  var EMPTY_V;

  class StateMachine {
    constructor(options, bsonOptions = (0, bson_1.pluckBSONSerializeOptions)(options)) {
      this.options = options;
      this.bsonOptions = bsonOptions;
    }
    async execute(executor, context, options) {
      const keyVaultNamespace = executor._keyVaultNamespace;
      const keyVaultClient = executor._keyVaultClient;
      const metaDataClient = executor._metaDataClient;
      const mongocryptdClient = executor._mongocryptdClient;
      const mongocryptdManager = executor._mongocryptdManager;
      let result = null;
      while (context.state !== MONGOCRYPT_CTX_DONE && context.state !== MONGOCRYPT_CTX_ERROR) {
        options.signal?.throwIfAborted();
        debug(`[context#${context.id}] ${stateToString.get(context.state) || context.state}`);
        switch (context.state) {
          case MONGOCRYPT_CTX_NEED_MONGO_COLLINFO: {
            const filter = (0, bson_1.deserialize)(context.nextMongoOperation());
            if (!metaDataClient) {
              throw new errors_1.MongoCryptError("unreachable state machine state: entered MONGOCRYPT_CTX_NEED_MONGO_COLLINFO but metadata client is undefined");
            }
            const collInfo = await this.fetchCollectionInfo(metaDataClient, context.ns, filter, options);
            if (collInfo) {
              context.addMongoOperationResponse(collInfo);
            }
            context.finishMongoOperation();
            break;
          }
          case MONGOCRYPT_CTX_NEED_MONGO_MARKINGS: {
            const command = context.nextMongoOperation();
            if (!mongocryptdClient) {
              throw new errors_1.MongoCryptError("unreachable state machine state: entered MONGOCRYPT_CTX_NEED_MONGO_MARKINGS but mongocryptdClient is undefined");
            }
            const markedCommand = mongocryptdManager ? await mongocryptdManager.withRespawn(this.markCommand.bind(this, mongocryptdClient, context.ns, command, options)) : await this.markCommand(mongocryptdClient, context.ns, command, options);
            context.addMongoOperationResponse(markedCommand);
            context.finishMongoOperation();
            break;
          }
          case MONGOCRYPT_CTX_NEED_MONGO_KEYS: {
            const filter = context.nextMongoOperation();
            const keys = await this.fetchKeys(keyVaultClient, keyVaultNamespace, filter, options);
            if (keys.length === 0) {
              result = EMPTY_V ??= (0, bson_1.serialize)({ v: [] });
            }
            for await (const key of keys) {
              context.addMongoOperationResponse((0, bson_1.serialize)(key));
            }
            context.finishMongoOperation();
            break;
          }
          case MONGOCRYPT_CTX_NEED_KMS_CREDENTIALS: {
            const kmsProviders = await executor.askForKMSCredentials();
            context.provideKMSProviders((0, bson_1.serialize)(kmsProviders));
            break;
          }
          case MONGOCRYPT_CTX_NEED_KMS: {
            await Promise.all(this.requests(context, options));
            context.finishKMSRequests();
            break;
          }
          case MONGOCRYPT_CTX_READY: {
            const finalizedContext = context.finalize();
            if (context.state === MONGOCRYPT_CTX_ERROR) {
              const message = context.status.message || "Finalization error";
              throw new errors_1.MongoCryptError(message);
            }
            result = finalizedContext;
            break;
          }
          default:
            throw new errors_1.MongoCryptError(`Unknown state: ${context.state}`);
        }
      }
      if (context.state === MONGOCRYPT_CTX_ERROR || result == null) {
        const message = context.status.message;
        if (!message) {
          debug(`unidentifiable error in MongoCrypt - received an error status from \`libmongocrypt\` but received no error message.`);
        }
        throw new errors_1.MongoCryptError(message ?? "unidentifiable error in MongoCrypt - received an error status from `libmongocrypt` but received no error message.");
      }
      return result;
    }
    async kmsRequest(request, options) {
      const parsedUrl = request.endpoint.split(":");
      const port = parsedUrl[1] != null ? Number.parseInt(parsedUrl[1], 10) : HTTPS_PORT;
      const socketOptions = {
        host: parsedUrl[0],
        servername: parsedUrl[0],
        port,
        ...(0, client_encryption_1.autoSelectSocketOptions)(this.options.socketOptions || {})
      };
      const message = request.message;
      const buffer = new utils_1.BufferPool;
      const netSocket = new net.Socket;
      let socket;
      function destroySockets() {
        for (const sock of [socket, netSocket]) {
          if (sock) {
            sock.removeAllListeners();
            sock.destroy();
          }
        }
      }
      function onerror(cause) {
        return new errors_1.MongoCryptError("KMS request failed", { cause });
      }
      function onclose() {
        return new errors_1.MongoCryptError("KMS request closed");
      }
      const tlsOptions = this.options.tlsOptions;
      if (tlsOptions) {
        const kmsProvider = request.kmsProvider;
        const providerTlsOptions = tlsOptions[kmsProvider];
        if (providerTlsOptions) {
          const error = this.validateTlsOptions(kmsProvider, providerTlsOptions);
          if (error) {
            throw error;
          }
          try {
            await this.setTlsOptions(providerTlsOptions, socketOptions);
          } catch (err) {
            throw onerror(err);
          }
        }
      }
      const { promise: willConnect, reject: rejectOnNetSocketError, resolve: resolveOnNetSocketConnect } = (0, utils_1.promiseWithResolvers)();
      netSocket.once("error", (err) => rejectOnNetSocketError(onerror(err))).once("close", () => rejectOnNetSocketError(onclose())).once("connect", () => resolveOnNetSocketConnect());
      let abortListener;
      try {
        if (this.options.proxyOptions && this.options.proxyOptions.proxyHost) {
          const netSocketOptions = {
            ...socketOptions,
            host: this.options.proxyOptions.proxyHost,
            port: this.options.proxyOptions.proxyPort || 1080
          };
          netSocket.connect(netSocketOptions);
          await willConnect;
          try {
            socks ??= loadSocks();
            socketOptions.socket = (await socks.SocksClient.createConnection({
              existing_socket: netSocket,
              command: "connect",
              destination: { host: socketOptions.host, port: socketOptions.port },
              proxy: {
                host: "iLoveJavaScript",
                port: 0,
                type: 5,
                userId: this.options.proxyOptions.proxyUsername,
                password: this.options.proxyOptions.proxyPassword
              }
            })).socket;
          } catch (err) {
            throw onerror(err);
          }
        }
        socket = tls.connect(socketOptions, () => {
          socket.write(message);
        });
        const { promise: willResolveKmsRequest, reject: rejectOnTlsSocketError, resolve } = (0, utils_1.promiseWithResolvers)();
        abortListener = (0, utils_1.addAbortListener)(options?.signal, function() {
          destroySockets();
          rejectOnTlsSocketError(this.reason);
        });
        socket.once("error", (err) => rejectOnTlsSocketError(onerror(err))).once("close", () => rejectOnTlsSocketError(onclose())).on("data", (data) => {
          buffer.append(data);
          while (request.bytesNeeded > 0 && buffer.length) {
            const bytesNeeded = Math.min(request.bytesNeeded, buffer.length);
            request.addResponse(buffer.read(bytesNeeded));
          }
          if (request.bytesNeeded <= 0) {
            resolve();
          }
        });
        await (options?.timeoutContext?.csotEnabled() ? Promise.all([
          willResolveKmsRequest,
          timeout_1.Timeout.expires(options.timeoutContext?.remainingTimeMS)
        ]) : willResolveKmsRequest);
      } catch (error) {
        if (error instanceof timeout_1.TimeoutError)
          throw new error_1.MongoOperationTimeoutError("KMS request timed out");
        throw error;
      } finally {
        destroySockets();
        abortListener?.[utils_1.kDispose]();
      }
    }
    *requests(context, options) {
      for (let request = context.nextKMSRequest();request != null; request = context.nextKMSRequest()) {
        yield this.kmsRequest(request, options);
      }
    }
    validateTlsOptions(kmsProvider, tlsOptions) {
      const tlsOptionNames = Object.keys(tlsOptions);
      for (const option of INSECURE_TLS_OPTIONS) {
        if (tlsOptionNames.includes(option)) {
          return new errors_1.MongoCryptError(`Insecure TLS options prohibited for ${kmsProvider}: ${option}`);
        }
      }
    }
    async setTlsOptions(tlsOptions, options) {
      if (tlsOptions.tlsCertificateKeyFile) {
        const cert = await fs.readFile(tlsOptions.tlsCertificateKeyFile);
        options.cert = options.key = cert;
      }
      if (tlsOptions.tlsCAFile) {
        options.ca = await fs.readFile(tlsOptions.tlsCAFile);
      }
      if (tlsOptions.tlsCertificateKeyFilePassword) {
        options.passphrase = tlsOptions.tlsCertificateKeyFilePassword;
      }
    }
    async fetchCollectionInfo(client, ns, filter, options) {
      const { db } = utils_1.MongoDBCollectionNamespace.fromString(ns);
      const cursor = client.db(db).listCollections(filter, {
        promoteLongs: false,
        promoteValues: false,
        timeoutContext: options?.timeoutContext && new abstract_cursor_1.CursorTimeoutContext(options?.timeoutContext, Symbol()),
        signal: options?.signal
      });
      const collections = await cursor.toArray();
      const info = collections.length > 0 ? (0, bson_1.serialize)(collections[0]) : null;
      return info;
    }
    async markCommand(client, ns, command, options) {
      const { db } = utils_1.MongoDBCollectionNamespace.fromString(ns);
      const bsonOptions = { promoteLongs: false, promoteValues: false };
      const rawCommand = (0, bson_1.deserialize)(command, bsonOptions);
      const commandOptions = {
        timeoutMS: undefined,
        signal: undefined
      };
      if (options?.timeoutContext?.csotEnabled()) {
        commandOptions.timeoutMS = options.timeoutContext.remainingTimeMS;
      }
      if (options?.signal) {
        commandOptions.signal = options.signal;
      }
      const response = await client.db(db).command(rawCommand, {
        ...bsonOptions,
        ...commandOptions
      });
      return (0, bson_1.serialize)(response, this.bsonOptions);
    }
    fetchKeys(client, keyVaultNamespace, filter, options) {
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(keyVaultNamespace);
      const commandOptions = {
        timeoutContext: undefined,
        signal: undefined
      };
      if (options?.timeoutContext != null) {
        commandOptions.timeoutContext = new abstract_cursor_1.CursorTimeoutContext(options.timeoutContext, Symbol());
      }
      if (options?.signal != null) {
        commandOptions.signal = options.signal;
      }
      return client.db(dbName).collection(collectionName, { readConcern: { level: "majority" } }).find((0, bson_1.deserialize)(filter), commandOptions).toArray();
    }
  }
  exports.StateMachine = StateMachine;
});

// node_modules/mongodb/lib/client-side-encryption/client_encryption.js
var require_client_encryption = __commonJS((exports) => {
  function autoSelectSocketOptions(baseOptions) {
    const options = { autoSelectFamily: true };
    if ("autoSelectFamily" in baseOptions) {
      options.autoSelectFamily = baseOptions.autoSelectFamily;
    }
    if ("autoSelectFamilyAttemptTimeout" in baseOptions) {
      options.autoSelectFamilyAttemptTimeout = baseOptions.autoSelectFamilyAttemptTimeout;
    }
    return options;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ClientEncryption = undefined;
  exports.autoSelectSocketOptions = autoSelectSocketOptions;
  var bson_1 = require_bson2();
  var deps_1 = require_deps();
  var timeout_1 = require_timeout();
  var utils_1 = require_utils2();
  var cryptoCallbacks = require_crypto_callbacks();
  var errors_1 = require_errors();
  var index_1 = require_providers2();
  var state_machine_1 = require_state_machine();

  class ClientEncryption {
    static getMongoCrypt() {
      const encryption = (0, deps_1.getMongoDBClientEncryption)();
      if ("kModuleError" in encryption) {
        throw encryption.kModuleError;
      }
      return encryption.MongoCrypt;
    }
    constructor(client, options) {
      this._client = client;
      this._proxyOptions = options.proxyOptions ?? {};
      this._tlsOptions = options.tlsOptions ?? {};
      this._kmsProviders = options.kmsProviders || {};
      const { timeoutMS } = (0, utils_1.resolveTimeoutOptions)(client, options);
      this._timeoutMS = timeoutMS;
      if (options.keyVaultNamespace == null) {
        throw new errors_1.MongoCryptInvalidArgumentError("Missing required option `keyVaultNamespace`");
      }
      const mongoCryptOptions = {
        ...options,
        cryptoCallbacks,
        kmsProviders: !Buffer.isBuffer(this._kmsProviders) ? (0, bson_1.serialize)(this._kmsProviders) : this._kmsProviders
      };
      this._keyVaultNamespace = options.keyVaultNamespace;
      this._keyVaultClient = options.keyVaultClient || client;
      const MongoCrypt = ClientEncryption.getMongoCrypt();
      this._mongoCrypt = new MongoCrypt(mongoCryptOptions);
    }
    async createDataKey(provider, options = {}) {
      if (options.keyAltNames && !Array.isArray(options.keyAltNames)) {
        throw new errors_1.MongoCryptInvalidArgumentError(`Option "keyAltNames" must be an array of strings, but was of type ${typeof options.keyAltNames}.`);
      }
      let keyAltNames = undefined;
      if (options.keyAltNames && options.keyAltNames.length > 0) {
        keyAltNames = options.keyAltNames.map((keyAltName, i) => {
          if (typeof keyAltName !== "string") {
            throw new errors_1.MongoCryptInvalidArgumentError(`Option "keyAltNames" must be an array of strings, but item at index ${i} was of type ${typeof keyAltName}`);
          }
          return (0, bson_1.serialize)({ keyAltName });
        });
      }
      let keyMaterial = undefined;
      if (options.keyMaterial) {
        keyMaterial = (0, bson_1.serialize)({ keyMaterial: options.keyMaterial });
      }
      const dataKeyBson = (0, bson_1.serialize)({
        provider,
        ...options.masterKey
      });
      const context = this._mongoCrypt.makeDataKeyContext(dataKeyBson, {
        keyAltNames,
        keyMaterial
      });
      const stateMachine = new state_machine_1.StateMachine({
        proxyOptions: this._proxyOptions,
        tlsOptions: this._tlsOptions,
        socketOptions: autoSelectSocketOptions(this._client.s.options)
      });
      const timeoutContext = options?.timeoutContext ?? timeout_1.TimeoutContext.create((0, utils_1.resolveTimeoutOptions)(this._client, { timeoutMS: this._timeoutMS }));
      const dataKey = (0, bson_1.deserialize)(await stateMachine.execute(this, context, { timeoutContext }));
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
      const { insertedId } = await this._keyVaultClient.db(dbName).collection(collectionName).insertOne(dataKey, {
        writeConcern: { w: "majority" },
        timeoutMS: timeoutContext?.csotEnabled() ? timeoutContext?.getRemainingTimeMSOrThrow() : undefined
      });
      return insertedId;
    }
    async rewrapManyDataKey(filter, options) {
      let keyEncryptionKeyBson = undefined;
      if (options) {
        const keyEncryptionKey = Object.assign({ provider: options.provider }, options.masterKey);
        keyEncryptionKeyBson = (0, bson_1.serialize)(keyEncryptionKey);
      }
      const filterBson = (0, bson_1.serialize)(filter);
      const context = this._mongoCrypt.makeRewrapManyDataKeyContext(filterBson, keyEncryptionKeyBson);
      const stateMachine = new state_machine_1.StateMachine({
        proxyOptions: this._proxyOptions,
        tlsOptions: this._tlsOptions,
        socketOptions: autoSelectSocketOptions(this._client.s.options)
      });
      const timeoutContext = timeout_1.TimeoutContext.create((0, utils_1.resolveTimeoutOptions)(this._client, { timeoutMS: this._timeoutMS }));
      const { v: dataKeys } = (0, bson_1.deserialize)(await stateMachine.execute(this, context, { timeoutContext }));
      if (dataKeys.length === 0) {
        return {};
      }
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
      const replacements = dataKeys.map((key) => ({
        updateOne: {
          filter: { _id: key._id },
          update: {
            $set: {
              masterKey: key.masterKey,
              keyMaterial: key.keyMaterial
            },
            $currentDate: {
              updateDate: true
            }
          }
        }
      }));
      const result = await this._keyVaultClient.db(dbName).collection(collectionName).bulkWrite(replacements, {
        writeConcern: { w: "majority" },
        timeoutMS: timeoutContext.csotEnabled() ? timeoutContext?.remainingTimeMS : undefined
      });
      return { bulkWriteResult: result };
    }
    async deleteKey(_id) {
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
      return await this._keyVaultClient.db(dbName).collection(collectionName).deleteOne({ _id }, { writeConcern: { w: "majority" }, timeoutMS: this._timeoutMS });
    }
    getKeys() {
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
      return this._keyVaultClient.db(dbName).collection(collectionName).find({}, { readConcern: { level: "majority" }, timeoutMS: this._timeoutMS });
    }
    async getKey(_id) {
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
      return await this._keyVaultClient.db(dbName).collection(collectionName).findOne({ _id }, { readConcern: { level: "majority" }, timeoutMS: this._timeoutMS });
    }
    async getKeyByAltName(keyAltName) {
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
      return await this._keyVaultClient.db(dbName).collection(collectionName).findOne({ keyAltNames: keyAltName }, { readConcern: { level: "majority" }, timeoutMS: this._timeoutMS });
    }
    async addKeyAltName(_id, keyAltName) {
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
      const value = await this._keyVaultClient.db(dbName).collection(collectionName).findOneAndUpdate({ _id }, { $addToSet: { keyAltNames: keyAltName } }, { writeConcern: { w: "majority" }, returnDocument: "before", timeoutMS: this._timeoutMS });
      return value;
    }
    async removeKeyAltName(_id, keyAltName) {
      const { db: dbName, collection: collectionName } = utils_1.MongoDBCollectionNamespace.fromString(this._keyVaultNamespace);
      const pipeline = [
        {
          $set: {
            keyAltNames: {
              $cond: [
                {
                  $eq: ["$keyAltNames", [keyAltName]]
                },
                "$$REMOVE",
                {
                  $filter: {
                    input: "$keyAltNames",
                    cond: {
                      $ne: ["$$this", keyAltName]
                    }
                  }
                }
              ]
            }
          }
        }
      ];
      const value = await this._keyVaultClient.db(dbName).collection(collectionName).findOneAndUpdate({ _id }, pipeline, {
        writeConcern: { w: "majority" },
        returnDocument: "before",
        timeoutMS: this._timeoutMS
      });
      return value;
    }
    async createEncryptedCollection(db, name, options) {
      const { provider, masterKey, createCollectionOptions: { encryptedFields: { ...encryptedFields }, ...createCollectionOptions } } = options;
      const timeoutContext = this._timeoutMS != null ? timeout_1.TimeoutContext.create((0, utils_1.resolveTimeoutOptions)(this._client, { timeoutMS: this._timeoutMS })) : undefined;
      if (Array.isArray(encryptedFields.fields)) {
        const createDataKeyPromises = encryptedFields.fields.map(async (field) => field == null || typeof field !== "object" || field.keyId != null ? field : {
          ...field,
          keyId: await this.createDataKey(provider, {
            masterKey,
            timeoutContext: timeoutContext?.csotEnabled() ? timeoutContext?.clone() : undefined
          })
        });
        const createDataKeyResolutions = await Promise.allSettled(createDataKeyPromises);
        encryptedFields.fields = createDataKeyResolutions.map((resolution, index) => resolution.status === "fulfilled" ? resolution.value : encryptedFields.fields[index]);
        const rejection = createDataKeyResolutions.find((result) => result.status === "rejected");
        if (rejection != null) {
          throw new errors_1.MongoCryptCreateDataKeyError(encryptedFields, { cause: rejection.reason });
        }
      }
      try {
        const collection = await db.createCollection(name, {
          ...createCollectionOptions,
          encryptedFields,
          timeoutMS: timeoutContext?.csotEnabled() ? timeoutContext?.getRemainingTimeMSOrThrow() : undefined
        });
        return { collection, encryptedFields };
      } catch (cause) {
        throw new errors_1.MongoCryptCreateEncryptedCollectionError(encryptedFields, { cause });
      }
    }
    async encrypt(value, options) {
      return await this._encrypt(value, false, options);
    }
    async encryptExpression(expression, options) {
      return await this._encrypt(expression, true, options);
    }
    async decrypt(value) {
      const valueBuffer = (0, bson_1.serialize)({ v: value });
      const context = this._mongoCrypt.makeExplicitDecryptionContext(valueBuffer);
      const stateMachine = new state_machine_1.StateMachine({
        proxyOptions: this._proxyOptions,
        tlsOptions: this._tlsOptions,
        socketOptions: autoSelectSocketOptions(this._client.s.options)
      });
      const timeoutContext = this._timeoutMS != null ? timeout_1.TimeoutContext.create((0, utils_1.resolveTimeoutOptions)(this._client, { timeoutMS: this._timeoutMS })) : undefined;
      const { v } = (0, bson_1.deserialize)(await stateMachine.execute(this, context, { timeoutContext }));
      return v;
    }
    async askForKMSCredentials() {
      return await (0, index_1.refreshKMSCredentials)(this._kmsProviders);
    }
    static get libmongocryptVersion() {
      return ClientEncryption.getMongoCrypt().libmongocryptVersion;
    }
    async _encrypt(value, expressionMode, options) {
      const { algorithm, keyId, keyAltName, contentionFactor, queryType, rangeOptions } = options;
      const contextOptions = {
        expressionMode,
        algorithm
      };
      if (keyId) {
        contextOptions.keyId = keyId.buffer;
      }
      if (keyAltName) {
        if (keyId) {
          throw new errors_1.MongoCryptInvalidArgumentError(`"options" cannot contain both "keyId" and "keyAltName"`);
        }
        if (typeof keyAltName !== "string") {
          throw new errors_1.MongoCryptInvalidArgumentError(`"options.keyAltName" must be of type string, but was of type ${typeof keyAltName}`);
        }
        contextOptions.keyAltName = (0, bson_1.serialize)({ keyAltName });
      }
      if (typeof contentionFactor === "number" || typeof contentionFactor === "bigint") {
        contextOptions.contentionFactor = contentionFactor;
      }
      if (typeof queryType === "string") {
        contextOptions.queryType = queryType;
      }
      if (typeof rangeOptions === "object") {
        contextOptions.rangeOptions = (0, bson_1.serialize)(rangeOptions);
      }
      const valueBuffer = (0, bson_1.serialize)({ v: value });
      const stateMachine = new state_machine_1.StateMachine({
        proxyOptions: this._proxyOptions,
        tlsOptions: this._tlsOptions,
        socketOptions: autoSelectSocketOptions(this._client.s.options)
      });
      const context = this._mongoCrypt.makeExplicitEncryptionContext(valueBuffer, contextOptions);
      const timeoutContext = this._timeoutMS != null ? timeout_1.TimeoutContext.create((0, utils_1.resolveTimeoutOptions)(this._client, { timeoutMS: this._timeoutMS })) : undefined;
      const { v } = (0, bson_1.deserialize)(await stateMachine.execute(this, context, { timeoutContext }));
      return v;
    }
  }
  exports.ClientEncryption = ClientEncryption;
});

// node_modules/mongodb/lib/client-side-encryption/mongocryptd_manager.js
var require_mongocryptd_manager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongocryptdManager = undefined;
  var error_1 = require_error();

  class MongocryptdManager {
    constructor(extraOptions = {}) {
      this.spawnPath = "";
      this.spawnArgs = [];
      this.uri = typeof extraOptions.mongocryptdURI === "string" && extraOptions.mongocryptdURI.length > 0 ? extraOptions.mongocryptdURI : MongocryptdManager.DEFAULT_MONGOCRYPTD_URI;
      this.bypassSpawn = !!extraOptions.mongocryptdBypassSpawn;
      if (Object.hasOwn(extraOptions, "mongocryptdSpawnPath") && extraOptions.mongocryptdSpawnPath) {
        this.spawnPath = extraOptions.mongocryptdSpawnPath;
      }
      if (Object.hasOwn(extraOptions, "mongocryptdSpawnArgs") && Array.isArray(extraOptions.mongocryptdSpawnArgs)) {
        this.spawnArgs = this.spawnArgs.concat(extraOptions.mongocryptdSpawnArgs);
      }
      if (this.spawnArgs.filter((arg) => typeof arg === "string").every((arg) => arg.indexOf("--idleShutdownTimeoutSecs") < 0)) {
        this.spawnArgs.push("--idleShutdownTimeoutSecs", "60");
      }
    }
    async spawn() {
      const cmdName = this.spawnPath || "mongocryptd";
      const { spawn } = import.meta.require("child_process");
      this._child = spawn(cmdName, this.spawnArgs, {
        stdio: "ignore",
        detached: true
      });
      this._child.on("error", () => {
      });
      this._child.unref();
    }
    async withRespawn(fn) {
      try {
        const result2 = await fn();
        return result2;
      } catch (err) {
        const shouldSpawn = err instanceof error_1.MongoNetworkTimeoutError && !this.bypassSpawn;
        if (!shouldSpawn) {
          throw err;
        }
      }
      await this.spawn();
      const result = await fn();
      return result;
    }
  }
  exports.MongocryptdManager = MongocryptdManager;
  MongocryptdManager.DEFAULT_MONGOCRYPTD_URI = "mongodb://localhost:27020";
});

// node_modules/mongodb/lib/client-side-encryption/auto_encrypter.js
var require_auto_encrypter = __commonJS((exports) => {
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AutoEncrypter = exports.AutoEncryptionLoggerLevel = undefined;
  var net = import.meta.require("net");
  var bson_1 = require_bson2();
  var constants_1 = require_constants2();
  var deps_1 = require_deps();
  var error_1 = require_error();
  var mongo_client_1 = require_mongo_client();
  var utils_1 = require_utils2();
  var client_encryption_1 = require_client_encryption();
  var cryptoCallbacks = require_crypto_callbacks();
  var errors_1 = require_errors();
  var mongocryptd_manager_1 = require_mongocryptd_manager();
  var providers_1 = require_providers2();
  var state_machine_1 = require_state_machine();
  exports.AutoEncryptionLoggerLevel = Object.freeze({
    FatalError: 0,
    Error: 1,
    Warning: 2,
    Info: 3,
    Trace: 4
  });

  class AutoEncrypter {
    static getMongoCrypt() {
      const encryption = (0, deps_1.getMongoDBClientEncryption)();
      if ("kModuleError" in encryption) {
        throw encryption.kModuleError;
      }
      return encryption.MongoCrypt;
    }
    constructor(client, options) {
      this[_a] = false;
      this._client = client;
      this._bypassEncryption = options.bypassAutoEncryption === true;
      this._keyVaultNamespace = options.keyVaultNamespace || "admin.datakeys";
      this._keyVaultClient = options.keyVaultClient || client;
      this._metaDataClient = options.metadataClient || client;
      this._proxyOptions = options.proxyOptions || {};
      this._tlsOptions = options.tlsOptions || {};
      this._kmsProviders = options.kmsProviders || {};
      const mongoCryptOptions = {
        cryptoCallbacks
      };
      if (options.schemaMap) {
        mongoCryptOptions.schemaMap = Buffer.isBuffer(options.schemaMap) ? options.schemaMap : (0, bson_1.serialize)(options.schemaMap);
      }
      if (options.encryptedFieldsMap) {
        mongoCryptOptions.encryptedFieldsMap = Buffer.isBuffer(options.encryptedFieldsMap) ? options.encryptedFieldsMap : (0, bson_1.serialize)(options.encryptedFieldsMap);
      }
      mongoCryptOptions.kmsProviders = !Buffer.isBuffer(this._kmsProviders) ? (0, bson_1.serialize)(this._kmsProviders) : this._kmsProviders;
      if (options.options?.logger) {
        mongoCryptOptions.logger = options.options.logger;
      }
      if (options.extraOptions && options.extraOptions.cryptSharedLibPath) {
        mongoCryptOptions.cryptSharedLibPath = options.extraOptions.cryptSharedLibPath;
      }
      if (options.bypassQueryAnalysis) {
        mongoCryptOptions.bypassQueryAnalysis = options.bypassQueryAnalysis;
      }
      this._bypassMongocryptdAndCryptShared = this._bypassEncryption || !!options.bypassQueryAnalysis;
      if (options.extraOptions && options.extraOptions.cryptSharedLibSearchPaths) {
        mongoCryptOptions.cryptSharedLibSearchPaths = options.extraOptions.cryptSharedLibSearchPaths;
      } else if (!this._bypassMongocryptdAndCryptShared) {
        mongoCryptOptions.cryptSharedLibSearchPaths = ["$SYSTEM"];
      }
      const MongoCrypt = AutoEncrypter.getMongoCrypt();
      this._mongocrypt = new MongoCrypt(mongoCryptOptions);
      this._contextCounter = 0;
      if (options.extraOptions && options.extraOptions.cryptSharedLibRequired && !this.cryptSharedLibVersionInfo) {
        throw new errors_1.MongoCryptInvalidArgumentError("`cryptSharedLibRequired` set but no crypt_shared library loaded");
      }
      if (!this._bypassMongocryptdAndCryptShared && !this.cryptSharedLibVersionInfo) {
        this._mongocryptdManager = new mongocryptd_manager_1.MongocryptdManager(options.extraOptions);
        const clientOptions = {
          serverSelectionTimeoutMS: 1e4
        };
        if ((options.extraOptions == null || typeof options.extraOptions.mongocryptdURI !== "string") && !net.getDefaultAutoSelectFamily) {
          clientOptions.family = 4;
        }
        if (net.getDefaultAutoSelectFamily) {
          Object.assign(clientOptions, (0, client_encryption_1.autoSelectSocketOptions)(this._client.s?.options ?? {}));
        }
        this._mongocryptdClient = new mongo_client_1.MongoClient(this._mongocryptdManager.uri, clientOptions);
      }
    }
    async init() {
      if (this._bypassMongocryptdAndCryptShared || this.cryptSharedLibVersionInfo) {
        return;
      }
      if (!this._mongocryptdManager) {
        throw new error_1.MongoRuntimeError("Reached impossible state: mongocryptdManager is undefined when neither bypassSpawn nor the shared lib are specified.");
      }
      if (!this._mongocryptdClient) {
        throw new error_1.MongoRuntimeError("Reached impossible state: mongocryptdClient is undefined when neither bypassSpawn nor the shared lib are specified.");
      }
      if (!this._mongocryptdManager.bypassSpawn) {
        await this._mongocryptdManager.spawn();
      }
      try {
        const client = await this._mongocryptdClient.connect();
        return client;
      } catch (error) {
        const { message } = error;
        if (message && (message.match(/timed out after/) || message.match(/ENOTFOUND/))) {
          throw new error_1.MongoRuntimeError("Unable to connect to `mongocryptd`, please make sure it is running or in your PATH for auto-spawn", { cause: error });
        }
        throw error;
      }
    }
    async teardown(force) {
      await this._mongocryptdClient?.close(force);
    }
    async encrypt(ns, cmd, options = {}) {
      options.signal?.throwIfAborted();
      if (this._bypassEncryption) {
        return cmd;
      }
      const commandBuffer = Buffer.isBuffer(cmd) ? cmd : (0, bson_1.serialize)(cmd, options);
      const context = this._mongocrypt.makeEncryptionContext(utils_1.MongoDBCollectionNamespace.fromString(ns).db, commandBuffer);
      context.id = this._contextCounter++;
      context.ns = ns;
      context.document = cmd;
      const stateMachine = new state_machine_1.StateMachine({
        promoteValues: false,
        promoteLongs: false,
        proxyOptions: this._proxyOptions,
        tlsOptions: this._tlsOptions,
        socketOptions: (0, client_encryption_1.autoSelectSocketOptions)(this._client.s.options)
      });
      return (0, bson_1.deserialize)(await stateMachine.execute(this, context, options), {
        promoteValues: false,
        promoteLongs: false
      });
    }
    async decrypt(response, options = {}) {
      options.signal?.throwIfAborted();
      const context = this._mongocrypt.makeDecryptionContext(response);
      context.id = this._contextCounter++;
      const stateMachine = new state_machine_1.StateMachine({
        ...options,
        proxyOptions: this._proxyOptions,
        tlsOptions: this._tlsOptions,
        socketOptions: (0, client_encryption_1.autoSelectSocketOptions)(this._client.s.options)
      });
      return await stateMachine.execute(this, context, options);
    }
    async askForKMSCredentials() {
      return await (0, providers_1.refreshKMSCredentials)(this._kmsProviders);
    }
    get cryptSharedLibVersionInfo() {
      return this._mongocrypt.cryptSharedLibVersionInfo;
    }
    static get libmongocryptVersion() {
      return AutoEncrypter.getMongoCrypt().libmongocryptVersion;
    }
  }
  exports.AutoEncrypter = AutoEncrypter;
  _a = constants_1.kDecorateResult;
});

// node_modules/mongodb/lib/encrypter.js
var require_encrypter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Encrypter = undefined;
  var util_1 = import.meta.require("util");
  var auto_encrypter_1 = require_auto_encrypter();
  var constants_1 = require_constants2();
  var deps_1 = require_deps();
  var error_1 = require_error();
  var mongo_client_1 = require_mongo_client();

  class Encrypter {
    constructor(client, uri, options) {
      if (typeof options.autoEncryption !== "object") {
        throw new error_1.MongoInvalidArgumentError('Option "autoEncryption" must be specified');
      }
      this.internalClient = null;
      this.bypassAutoEncryption = !!options.autoEncryption.bypassAutoEncryption;
      this.needsConnecting = false;
      if (options.maxPoolSize === 0 && options.autoEncryption.keyVaultClient == null) {
        options.autoEncryption.keyVaultClient = client;
      } else if (options.autoEncryption.keyVaultClient == null) {
        options.autoEncryption.keyVaultClient = this.getInternalClient(client, uri, options);
      }
      if (this.bypassAutoEncryption) {
        options.autoEncryption.metadataClient = undefined;
      } else if (options.maxPoolSize === 0) {
        options.autoEncryption.metadataClient = client;
      } else {
        options.autoEncryption.metadataClient = this.getInternalClient(client, uri, options);
      }
      if (options.proxyHost) {
        options.autoEncryption.proxyOptions = {
          proxyHost: options.proxyHost,
          proxyPort: options.proxyPort,
          proxyUsername: options.proxyUsername,
          proxyPassword: options.proxyPassword
        };
      }
      this.autoEncrypter = new auto_encrypter_1.AutoEncrypter(client, options.autoEncryption);
    }
    getInternalClient(client, uri, options) {
      let internalClient = this.internalClient;
      if (internalClient == null) {
        const clonedOptions = {};
        for (const key of [
          ...Object.getOwnPropertyNames(options),
          ...Object.getOwnPropertySymbols(options)
        ]) {
          if (["autoEncryption", "minPoolSize", "servers", "caseTranslate", "dbName"].includes(key))
            continue;
          Reflect.set(clonedOptions, key, Reflect.get(options, key));
        }
        clonedOptions.minPoolSize = 0;
        internalClient = new mongo_client_1.MongoClient(uri, clonedOptions);
        this.internalClient = internalClient;
        for (const eventName of constants_1.MONGO_CLIENT_EVENTS) {
          for (const listener of client.listeners(eventName)) {
            internalClient.on(eventName, listener);
          }
        }
        client.on("newListener", (eventName, listener) => {
          internalClient?.on(eventName, listener);
        });
        this.needsConnecting = true;
      }
      return internalClient;
    }
    async connectInternalClient() {
      const internalClient = this.internalClient;
      if (this.needsConnecting && internalClient != null) {
        this.needsConnecting = false;
        await internalClient.connect();
      }
    }
    closeCallback(client, force, callback) {
      (0, util_1.callbackify)(this.close.bind(this))(client, force, callback);
    }
    async close(client, force) {
      let error;
      try {
        await this.autoEncrypter.teardown(force);
      } catch (autoEncrypterError) {
        error = autoEncrypterError;
      }
      const internalClient = this.internalClient;
      if (internalClient != null && client !== internalClient) {
        return await internalClient.close(force);
      }
      if (error != null) {
        throw error;
      }
    }
    static checkForMongoCrypt() {
      const mongodbClientEncryption = (0, deps_1.getMongoDBClientEncryption)();
      if ("kModuleError" in mongodbClientEncryption) {
        throw new error_1.MongoMissingDependencyError("Auto-encryption requested, but the module is not installed. " + "Please add `mongodb-client-encryption` as a dependency of your project", {
          cause: mongodbClientEncryption["kModuleError"],
          dependencyName: "mongodb-client-encryption"
        });
      }
    }
  }
  exports.Encrypter = Encrypter;
});

// node_modules/mongodb/lib/cmap/metrics.js
var require_metrics = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectionPoolMetrics = undefined;

  class ConnectionPoolMetrics {
    constructor() {
      this.txnConnections = 0;
      this.cursorConnections = 0;
      this.otherConnections = 0;
    }
    markPinned(pinType) {
      if (pinType === ConnectionPoolMetrics.TXN) {
        this.txnConnections += 1;
      } else if (pinType === ConnectionPoolMetrics.CURSOR) {
        this.cursorConnections += 1;
      } else {
        this.otherConnections += 1;
      }
    }
    markUnpinned(pinType) {
      if (pinType === ConnectionPoolMetrics.TXN) {
        this.txnConnections -= 1;
      } else if (pinType === ConnectionPoolMetrics.CURSOR) {
        this.cursorConnections -= 1;
      } else {
        this.otherConnections -= 1;
      }
    }
    info(maxPoolSize) {
      return "Timed out while checking out a connection from connection pool: " + `maxPoolSize: ${maxPoolSize}, ` + `connections in use by cursors: ${this.cursorConnections}, ` + `connections in use by transactions: ${this.txnConnections}, ` + `connections in use by other operations: ${this.otherConnections}`;
    }
    reset() {
      this.txnConnections = 0;
      this.cursorConnections = 0;
      this.otherConnections = 0;
    }
  }
  exports.ConnectionPoolMetrics = ConnectionPoolMetrics;
  ConnectionPoolMetrics.TXN = "txn";
  ConnectionPoolMetrics.CURSOR = "cursor";
  ConnectionPoolMetrics.OTHER = "other";
});

// node_modules/mongodb/lib/sdam/server_description.js
var require_server_description = __commonJS((exports) => {
  function parseServerType(hello, options) {
    if (options?.loadBalanced) {
      return common_1.ServerType.LoadBalancer;
    }
    if (!hello || !hello.ok) {
      return common_1.ServerType.Unknown;
    }
    if (hello.isreplicaset) {
      return common_1.ServerType.RSGhost;
    }
    if (hello.msg && hello.msg === "isdbgrid") {
      return common_1.ServerType.Mongos;
    }
    if (hello.setName) {
      if (hello.hidden) {
        return common_1.ServerType.RSOther;
      } else if (hello.isWritablePrimary) {
        return common_1.ServerType.RSPrimary;
      } else if (hello.secondary) {
        return common_1.ServerType.RSSecondary;
      } else if (hello.arbiterOnly) {
        return common_1.ServerType.RSArbiter;
      } else {
        return common_1.ServerType.RSOther;
      }
    }
    return common_1.ServerType.Standalone;
  }
  function tagsStrictEqual(tags, tags2) {
    const tagsKeys = Object.keys(tags);
    const tags2Keys = Object.keys(tags2);
    return tagsKeys.length === tags2Keys.length && tagsKeys.every((key) => tags2[key] === tags[key]);
  }
  function compareTopologyVersion(currentTv, newTv) {
    if (currentTv == null || newTv == null) {
      return -1;
    }
    if (!currentTv.processId.equals(newTv.processId)) {
      return -1;
    }
    const currentCounter = typeof currentTv.counter === "bigint" ? bson_1.Long.fromBigInt(currentTv.counter) : bson_1.Long.isLong(currentTv.counter) ? currentTv.counter : bson_1.Long.fromNumber(currentTv.counter);
    const newCounter = typeof newTv.counter === "bigint" ? bson_1.Long.fromBigInt(newTv.counter) : bson_1.Long.isLong(newTv.counter) ? newTv.counter : bson_1.Long.fromNumber(newTv.counter);
    return currentCounter.compare(newCounter);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServerDescription = undefined;
  exports.parseServerType = parseServerType;
  exports.compareTopologyVersion = compareTopologyVersion;
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var utils_1 = require_utils2();
  var common_1 = require_common();
  var WRITABLE_SERVER_TYPES = new Set([
    common_1.ServerType.RSPrimary,
    common_1.ServerType.Standalone,
    common_1.ServerType.Mongos,
    common_1.ServerType.LoadBalancer
  ]);
  var DATA_BEARING_SERVER_TYPES = new Set([
    common_1.ServerType.RSPrimary,
    common_1.ServerType.RSSecondary,
    common_1.ServerType.Mongos,
    common_1.ServerType.Standalone,
    common_1.ServerType.LoadBalancer
  ]);

  class ServerDescription {
    constructor(address, hello, options = {}) {
      if (address == null || address === "") {
        throw new error_1.MongoRuntimeError("ServerDescription must be provided with a non-empty address");
      }
      this.address = typeof address === "string" ? utils_1.HostAddress.fromString(address).toString() : address.toString();
      this.type = parseServerType(hello, options);
      this.hosts = hello?.hosts?.map((host) => host.toLowerCase()) ?? [];
      this.passives = hello?.passives?.map((host) => host.toLowerCase()) ?? [];
      this.arbiters = hello?.arbiters?.map((host) => host.toLowerCase()) ?? [];
      this.tags = hello?.tags ?? {};
      this.minWireVersion = hello?.minWireVersion ?? 0;
      this.maxWireVersion = hello?.maxWireVersion ?? 0;
      this.roundTripTime = options?.roundTripTime ?? -1;
      this.minRoundTripTime = options?.minRoundTripTime ?? 0;
      this.lastUpdateTime = (0, utils_1.now)();
      this.lastWriteDate = hello?.lastWrite?.lastWriteDate ?? 0;
      this.error = options.error ?? null;
      this.error?.stack;
      this.topologyVersion = this.error?.topologyVersion ?? hello?.topologyVersion ?? null;
      this.setName = hello?.setName ?? null;
      this.setVersion = hello?.setVersion ?? null;
      this.electionId = hello?.electionId ?? null;
      this.logicalSessionTimeoutMinutes = hello?.logicalSessionTimeoutMinutes ?? null;
      this.maxMessageSizeBytes = hello?.maxMessageSizeBytes ?? null;
      this.maxWriteBatchSize = hello?.maxWriteBatchSize ?? null;
      this.maxBsonObjectSize = hello?.maxBsonObjectSize ?? null;
      this.primary = hello?.primary ?? null;
      this.me = hello?.me?.toLowerCase() ?? null;
      this.$clusterTime = hello?.$clusterTime ?? null;
      this.iscryptd = Boolean(hello?.iscryptd);
    }
    get hostAddress() {
      return utils_1.HostAddress.fromString(this.address);
    }
    get allHosts() {
      return this.hosts.concat(this.arbiters).concat(this.passives);
    }
    get isReadable() {
      return this.type === common_1.ServerType.RSSecondary || this.isWritable;
    }
    get isDataBearing() {
      return DATA_BEARING_SERVER_TYPES.has(this.type);
    }
    get isWritable() {
      return WRITABLE_SERVER_TYPES.has(this.type);
    }
    get host() {
      const chopLength = `:${this.port}`.length;
      return this.address.slice(0, -chopLength);
    }
    get port() {
      const port = this.address.split(":").pop();
      return port ? Number.parseInt(port, 10) : 27017;
    }
    equals(other) {
      const topologyVersionsEqual = this.topologyVersion === other?.topologyVersion || compareTopologyVersion(this.topologyVersion, other?.topologyVersion) === 0;
      const electionIdsEqual = this.electionId != null && other?.electionId != null ? (0, utils_1.compareObjectId)(this.electionId, other.electionId) === 0 : this.electionId === other?.electionId;
      return other != null && other.iscryptd === this.iscryptd && (0, utils_1.errorStrictEqual)(this.error, other.error) && this.type === other.type && this.minWireVersion === other.minWireVersion && (0, utils_1.arrayStrictEqual)(this.hosts, other.hosts) && tagsStrictEqual(this.tags, other.tags) && this.setName === other.setName && this.setVersion === other.setVersion && electionIdsEqual && this.primary === other.primary && this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes && topologyVersionsEqual;
    }
  }
  exports.ServerDescription = ServerDescription;
});

// node_modules/mongodb/lib/sdam/topology_description.js
var require_topology_description = __commonJS((exports) => {
  function topologyTypeForServerType(serverType) {
    switch (serverType) {
      case common_1.ServerType.Standalone:
        return common_1.TopologyType.Single;
      case common_1.ServerType.Mongos:
        return common_1.TopologyType.Sharded;
      case common_1.ServerType.RSPrimary:
        return common_1.TopologyType.ReplicaSetWithPrimary;
      case common_1.ServerType.RSOther:
      case common_1.ServerType.RSSecondary:
        return common_1.TopologyType.ReplicaSetNoPrimary;
      default:
        return common_1.TopologyType.Unknown;
    }
  }
  function updateRsFromPrimary(serverDescriptions, serverDescription, setName = null, maxSetVersion = null, maxElectionId = null) {
    setName = setName || serverDescription.setName;
    if (setName !== serverDescription.setName) {
      serverDescriptions.delete(serverDescription.address);
      return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
    }
    if (serverDescription.maxWireVersion >= 17) {
      const electionIdComparison = (0, utils_1.compareObjectId)(maxElectionId, serverDescription.electionId);
      const maxElectionIdIsEqual = electionIdComparison === 0;
      const maxElectionIdIsLess = electionIdComparison === -1;
      const maxSetVersionIsLessOrEqual = (maxSetVersion ?? -1) <= (serverDescription.setVersion ?? -1);
      if (maxElectionIdIsLess || maxElectionIdIsEqual && maxSetVersionIsLessOrEqual) {
        maxElectionId = serverDescription.electionId;
        maxSetVersion = serverDescription.setVersion;
      } else {
        serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address, undefined, {
          error: new error_1.MongoStalePrimaryError(serverDescription, maxSetVersion, maxElectionId)
        }));
        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
      }
    } else {
      const electionId = serverDescription.electionId ? serverDescription.electionId : null;
      if (serverDescription.setVersion && electionId) {
        if (maxSetVersion && maxElectionId) {
          if (maxSetVersion > serverDescription.setVersion || (0, utils_1.compareObjectId)(maxElectionId, electionId) > 0) {
            serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address, undefined, {
              error: new error_1.MongoStalePrimaryError(serverDescription, maxSetVersion, maxElectionId)
            }));
            return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
          }
        }
        maxElectionId = serverDescription.electionId;
      }
      if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {
        maxSetVersion = serverDescription.setVersion;
      }
    }
    for (const [address, server] of serverDescriptions) {
      if (server.type === common_1.ServerType.RSPrimary && server.address !== serverDescription.address) {
        serverDescriptions.set(address, new server_description_1.ServerDescription(server.address, undefined, {
          error: new error_1.MongoStalePrimaryError(serverDescription, maxSetVersion, maxElectionId)
        }));
        break;
      }
    }
    serverDescription.allHosts.forEach((address) => {
      if (!serverDescriptions.has(address)) {
        serverDescriptions.set(address, new server_description_1.ServerDescription(address));
      }
    });
    const currentAddresses = Array.from(serverDescriptions.keys());
    const responseAddresses = serverDescription.allHosts;
    currentAddresses.filter((addr) => responseAddresses.indexOf(addr) === -1).forEach((address) => {
      serverDescriptions.delete(address);
    });
    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];
  }
  function updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName = null) {
    if (setName == null) {
      throw new error_1.MongoRuntimeError('Argument "setName" is required if connected to a replica set');
    }
    if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {
      serverDescriptions.delete(serverDescription.address);
    }
    return checkHasPrimary(serverDescriptions);
  }
  function updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName = null) {
    const topologyType = common_1.TopologyType.ReplicaSetNoPrimary;
    setName = setName ?? serverDescription.setName;
    if (setName !== serverDescription.setName) {
      serverDescriptions.delete(serverDescription.address);
      return [topologyType, setName];
    }
    serverDescription.allHosts.forEach((address) => {
      if (!serverDescriptions.has(address)) {
        serverDescriptions.set(address, new server_description_1.ServerDescription(address));
      }
    });
    if (serverDescription.me && serverDescription.address !== serverDescription.me) {
      serverDescriptions.delete(serverDescription.address);
    }
    return [topologyType, setName];
  }
  function checkHasPrimary(serverDescriptions) {
    for (const serverDescription of serverDescriptions.values()) {
      if (serverDescription.type === common_1.ServerType.RSPrimary) {
        return common_1.TopologyType.ReplicaSetWithPrimary;
      }
    }
    return common_1.TopologyType.ReplicaSetNoPrimary;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TopologyDescription = undefined;
  var bson_1 = require_bson2();
  var WIRE_CONSTANTS = require_constants();
  var error_1 = require_error();
  var utils_1 = require_utils2();
  var common_1 = require_common();
  var server_description_1 = require_server_description();
  var MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;
  var MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;
  var MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;
  var MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;
  var MONGOS_OR_UNKNOWN = new Set([common_1.ServerType.Mongos, common_1.ServerType.Unknown]);
  var MONGOS_OR_STANDALONE = new Set([common_1.ServerType.Mongos, common_1.ServerType.Standalone]);
  var NON_PRIMARY_RS_MEMBERS = new Set([
    common_1.ServerType.RSSecondary,
    common_1.ServerType.RSArbiter,
    common_1.ServerType.RSOther
  ]);

  class TopologyDescription {
    constructor(topologyType, serverDescriptions = null, setName = null, maxSetVersion = null, maxElectionId = null, commonWireVersion = null, options = null) {
      options = options ?? {};
      this.type = topologyType ?? common_1.TopologyType.Unknown;
      this.servers = serverDescriptions ?? new Map;
      this.stale = false;
      this.compatible = true;
      this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 0;
      this.localThresholdMS = options.localThresholdMS ?? 15;
      this.setName = setName ?? null;
      this.maxElectionId = maxElectionId ?? null;
      this.maxSetVersion = maxSetVersion ?? null;
      this.commonWireVersion = commonWireVersion ?? 0;
      for (const serverDescription of this.servers.values()) {
        if (serverDescription.type === common_1.ServerType.Unknown || serverDescription.type === common_1.ServerType.LoadBalancer) {
          continue;
        }
        if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {
          this.compatible = false;
          this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;
        }
        if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {
          this.compatible = false;
          this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;
          break;
        }
      }
      this.logicalSessionTimeoutMinutes = null;
      for (const [, server] of this.servers) {
        if (server.isReadable) {
          if (server.logicalSessionTimeoutMinutes == null) {
            this.logicalSessionTimeoutMinutes = null;
            break;
          }
          if (this.logicalSessionTimeoutMinutes == null) {
            this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;
            continue;
          }
          this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);
        }
      }
    }
    updateFromSrvPollingEvent(ev, srvMaxHosts = 0) {
      const incomingHostnames = ev.hostnames();
      const currentHostnames = new Set(this.servers.keys());
      const hostnamesToAdd = new Set(incomingHostnames);
      const hostnamesToRemove = new Set;
      for (const hostname of currentHostnames) {
        hostnamesToAdd.delete(hostname);
        if (!incomingHostnames.has(hostname)) {
          hostnamesToRemove.add(hostname);
        }
      }
      if (hostnamesToAdd.size === 0 && hostnamesToRemove.size === 0) {
        return this;
      }
      const serverDescriptions = new Map(this.servers);
      for (const removedHost of hostnamesToRemove) {
        serverDescriptions.delete(removedHost);
      }
      if (hostnamesToAdd.size > 0) {
        if (srvMaxHosts === 0) {
          for (const hostToAdd of hostnamesToAdd) {
            serverDescriptions.set(hostToAdd, new server_description_1.ServerDescription(hostToAdd));
          }
        } else if (serverDescriptions.size < srvMaxHosts) {
          const selectedHosts = (0, utils_1.shuffle)(hostnamesToAdd, srvMaxHosts - serverDescriptions.size);
          for (const selectedHostToAdd of selectedHosts) {
            serverDescriptions.set(selectedHostToAdd, new server_description_1.ServerDescription(selectedHostToAdd));
          }
        }
      }
      return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
    }
    update(serverDescription) {
      const address = serverDescription.address;
      let { type: topologyType, setName, maxSetVersion, maxElectionId, commonWireVersion } = this;
      const serverType = serverDescription.type;
      const serverDescriptions = new Map(this.servers);
      if (serverDescription.maxWireVersion !== 0) {
        if (commonWireVersion == null) {
          commonWireVersion = serverDescription.maxWireVersion;
        } else {
          commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);
        }
      }
      if (typeof serverDescription.setName === "string" && typeof setName === "string" && serverDescription.setName !== setName) {
        if (topologyType === common_1.TopologyType.Single) {
          serverDescription = new server_description_1.ServerDescription(address);
        } else {
          serverDescriptions.delete(address);
        }
      }
      serverDescriptions.set(address, serverDescription);
      if (topologyType === common_1.TopologyType.Single) {
        return new TopologyDescription(common_1.TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
      }
      if (topologyType === common_1.TopologyType.Unknown) {
        if (serverType === common_1.ServerType.Standalone && this.servers.size !== 1) {
          serverDescriptions.delete(address);
        } else {
          topologyType = topologyTypeForServerType(serverType);
        }
      }
      if (topologyType === common_1.TopologyType.Sharded) {
        if (!MONGOS_OR_UNKNOWN.has(serverType)) {
          serverDescriptions.delete(address);
        }
      }
      if (topologyType === common_1.TopologyType.ReplicaSetNoPrimary) {
        if (MONGOS_OR_STANDALONE.has(serverType)) {
          serverDescriptions.delete(address);
        }
        if (serverType === common_1.ServerType.RSPrimary) {
          const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);
          topologyType = result[0];
          setName = result[1];
          maxSetVersion = result[2];
          maxElectionId = result[3];
        } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {
          const result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);
          topologyType = result[0];
          setName = result[1];
        }
      }
      if (topologyType === common_1.TopologyType.ReplicaSetWithPrimary) {
        if (MONGOS_OR_STANDALONE.has(serverType)) {
          serverDescriptions.delete(address);
          topologyType = checkHasPrimary(serverDescriptions);
        } else if (serverType === common_1.ServerType.RSPrimary) {
          const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);
          topologyType = result[0];
          setName = result[1];
          maxSetVersion = result[2];
          maxElectionId = result[3];
        } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {
          topologyType = updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName);
        } else {
          topologyType = checkHasPrimary(serverDescriptions);
        }
      }
      return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });
    }
    get error() {
      const descriptionsWithError = Array.from(this.servers.values()).filter((sd) => sd.error);
      if (descriptionsWithError.length > 0) {
        return descriptionsWithError[0].error;
      }
      return null;
    }
    get hasKnownServers() {
      return Array.from(this.servers.values()).some((sd) => sd.type !== common_1.ServerType.Unknown);
    }
    get hasDataBearingServers() {
      return Array.from(this.servers.values()).some((sd) => sd.isDataBearing);
    }
    hasServer(address) {
      return this.servers.has(address);
    }
    toJSON() {
      return bson_1.EJSON.serialize(this);
    }
  }
  exports.TopologyDescription = TopologyDescription;
});

// node_modules/mongodb/lib/cmap/wire_protocol/shared.js
var require_shared = __commonJS((exports) => {
  function getReadPreference(options) {
    let readPreference = options?.readPreference ?? read_preference_1.ReadPreference.primary;
    if (typeof readPreference === "string") {
      readPreference = read_preference_1.ReadPreference.fromString(readPreference);
    }
    if (!(readPreference instanceof read_preference_1.ReadPreference)) {
      throw new error_1.MongoInvalidArgumentError('Option "readPreference" must be a ReadPreference instance');
    }
    return readPreference;
  }
  function isSharded(topologyOrServer) {
    if (topologyOrServer == null) {
      return false;
    }
    if (topologyOrServer.description && topologyOrServer.description.type === common_1.ServerType.Mongos) {
      return true;
    }
    if (topologyOrServer.description && topologyOrServer.description instanceof topology_description_1.TopologyDescription) {
      const servers = Array.from(topologyOrServer.description.servers.values());
      return servers.some((server) => server.type === common_1.ServerType.Mongos);
    }
    return false;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getReadPreference = getReadPreference;
  exports.isSharded = isSharded;
  var error_1 = require_error();
  var read_preference_1 = require_read_preference();
  var common_1 = require_common();
  var topology_description_1 = require_topology_description();
});

// node_modules/mongodb/lib/transactions.js
var require_transactions = __commonJS((exports) => {
  function isTransactionCommand(command) {
    return !!(command.commitTransaction || command.abortTransaction);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Transaction = exports.TxnState = undefined;
  exports.isTransactionCommand = isTransactionCommand;
  var error_1 = require_error();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var write_concern_1 = require_write_concern();
  exports.TxnState = Object.freeze({
    NO_TRANSACTION: "NO_TRANSACTION",
    STARTING_TRANSACTION: "STARTING_TRANSACTION",
    TRANSACTION_IN_PROGRESS: "TRANSACTION_IN_PROGRESS",
    TRANSACTION_COMMITTED: "TRANSACTION_COMMITTED",
    TRANSACTION_COMMITTED_EMPTY: "TRANSACTION_COMMITTED_EMPTY",
    TRANSACTION_ABORTED: "TRANSACTION_ABORTED"
  });
  var stateMachine = {
    [exports.TxnState.NO_TRANSACTION]: [exports.TxnState.NO_TRANSACTION, exports.TxnState.STARTING_TRANSACTION],
    [exports.TxnState.STARTING_TRANSACTION]: [
      exports.TxnState.TRANSACTION_IN_PROGRESS,
      exports.TxnState.TRANSACTION_COMMITTED,
      exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
      exports.TxnState.TRANSACTION_ABORTED
    ],
    [exports.TxnState.TRANSACTION_IN_PROGRESS]: [
      exports.TxnState.TRANSACTION_IN_PROGRESS,
      exports.TxnState.TRANSACTION_COMMITTED,
      exports.TxnState.TRANSACTION_ABORTED
    ],
    [exports.TxnState.TRANSACTION_COMMITTED]: [
      exports.TxnState.TRANSACTION_COMMITTED,
      exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
      exports.TxnState.STARTING_TRANSACTION,
      exports.TxnState.NO_TRANSACTION
    ],
    [exports.TxnState.TRANSACTION_ABORTED]: [exports.TxnState.STARTING_TRANSACTION, exports.TxnState.NO_TRANSACTION],
    [exports.TxnState.TRANSACTION_COMMITTED_EMPTY]: [
      exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
      exports.TxnState.NO_TRANSACTION
    ]
  };
  var ACTIVE_STATES = new Set([
    exports.TxnState.STARTING_TRANSACTION,
    exports.TxnState.TRANSACTION_IN_PROGRESS
  ]);
  var COMMITTED_STATES = new Set([
    exports.TxnState.TRANSACTION_COMMITTED,
    exports.TxnState.TRANSACTION_COMMITTED_EMPTY,
    exports.TxnState.TRANSACTION_ABORTED
  ]);

  class Transaction {
    constructor(options) {
      options = options ?? {};
      this.state = exports.TxnState.NO_TRANSACTION;
      this.options = {};
      const writeConcern = write_concern_1.WriteConcern.fromOptions(options);
      if (writeConcern) {
        if (writeConcern.w === 0) {
          throw new error_1.MongoTransactionError("Transactions do not support unacknowledged write concern");
        }
        this.options.writeConcern = writeConcern;
      }
      if (options.readConcern) {
        this.options.readConcern = read_concern_1.ReadConcern.fromOptions(options);
      }
      if (options.readPreference) {
        this.options.readPreference = read_preference_1.ReadPreference.fromOptions(options);
      }
      if (options.maxCommitTimeMS) {
        this.options.maxTimeMS = options.maxCommitTimeMS;
      }
      this._pinnedServer = undefined;
      this._recoveryToken = undefined;
    }
    get server() {
      return this._pinnedServer;
    }
    get recoveryToken() {
      return this._recoveryToken;
    }
    get isPinned() {
      return !!this.server;
    }
    get isStarting() {
      return this.state === exports.TxnState.STARTING_TRANSACTION;
    }
    get isActive() {
      return ACTIVE_STATES.has(this.state);
    }
    get isCommitted() {
      return COMMITTED_STATES.has(this.state);
    }
    transition(nextState) {
      const nextStates = stateMachine[this.state];
      if (nextStates && nextStates.includes(nextState)) {
        this.state = nextState;
        if (this.state === exports.TxnState.NO_TRANSACTION || this.state === exports.TxnState.STARTING_TRANSACTION || this.state === exports.TxnState.TRANSACTION_ABORTED) {
          this.unpinServer();
        }
        return;
      }
      throw new error_1.MongoRuntimeError(`Attempted illegal state transition from [${this.state}] to [${nextState}]`);
    }
    pinServer(server) {
      if (this.isActive) {
        this._pinnedServer = server;
      }
    }
    unpinServer() {
      this._pinnedServer = undefined;
    }
  }
  exports.Transaction = Transaction;
});

// node_modules/mongodb/lib/sessions.js
var require_sessions = __commonJS((exports) => {
  function shouldUnpinAfterCommitError(commitError) {
    if (commitError instanceof error_1.MongoError) {
      if ((0, error_1.isRetryableWriteError)(commitError) || commitError instanceof error_1.MongoWriteConcernError || isMaxTimeMSExpiredError(commitError)) {
        if (isUnknownTransactionCommitResult(commitError)) {
          return true;
        }
      } else if (commitError.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
        return true;
      }
    }
    return false;
  }
  function shouldAddUnknownTransactionCommitResultLabel(commitError) {
    let ok = (0, error_1.isRetryableWriteError)(commitError);
    ok ||= commitError instanceof error_1.MongoWriteConcernError;
    ok ||= isMaxTimeMSExpiredError(commitError);
    ok &&= isUnknownTransactionCommitResult(commitError);
    return ok;
  }
  function isUnknownTransactionCommitResult(err) {
    const isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError && err.codeName && NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);
    return isMaxTimeMSExpiredError(err) || !isNonDeterministicWriteConcernError && err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern && err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern;
  }
  function maybeClearPinnedConnection(session, options) {
    const conn = session.pinnedConnection;
    const error = options?.error;
    if (session.inTransaction() && error && error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
      return;
    }
    const topology = session.client.topology;
    if (conn && topology != null) {
      const servers = Array.from(topology.s.servers.values());
      const loadBalancer = servers[0];
      if (options?.error == null || options?.force) {
        loadBalancer.pool.checkIn(conn);
        session.pinnedConnection = undefined;
        conn.emit(constants_1.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);
        if (options?.forceClear) {
          loadBalancer.pool.clear({ serviceId: conn.serviceId });
        }
      }
    }
  }
  function isMaxTimeMSExpiredError(err) {
    if (err == null || !(err instanceof error_1.MongoServerError)) {
      return false;
    }
    return err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired || err.writeConcernError?.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;
  }
  function applySession(session, command, options) {
    if (session.hasEnded) {
      return new error_1.MongoExpiredSessionError;
    }
    const serverSession = session.serverSession;
    if (serverSession == null) {
      return new error_1.MongoRuntimeError("Unable to acquire server session");
    }
    if (options.writeConcern?.w === 0) {
      if (session && session.explicit) {
        return new error_1.MongoAPIError("Cannot have explicit session with unacknowledged writes");
      }
      return;
    }
    serverSession.lastUse = (0, utils_1.now)();
    command.lsid = serverSession.id;
    const inTxnOrTxnCommand = session.inTransaction() || (0, transactions_1.isTransactionCommand)(command);
    const isRetryableWrite = !!options.willRetryWrite;
    if (isRetryableWrite || inTxnOrTxnCommand) {
      serverSession.txnNumber += session.txnNumberIncrement;
      session.txnNumberIncrement = 0;
      command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);
    }
    if (!inTxnOrTxnCommand) {
      if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {
        session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);
      }
      if (session.supports.causalConsistency && session.operationTime && (0, utils_1.commandSupportsReadConcern)(command)) {
        command.readConcern = command.readConcern || {};
        Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
      } else if (session.snapshotEnabled) {
        command.readConcern = command.readConcern || { level: read_concern_1.ReadConcernLevel.snapshot };
        if (session.snapshotTime != null) {
          Object.assign(command.readConcern, { atClusterTime: session.snapshotTime });
        }
      }
      return;
    }
    command.autocommit = false;
    if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {
      session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);
      command.startTransaction = true;
      const readConcern = session.transaction.options.readConcern || session?.clientOptions?.readConcern;
      if (readConcern) {
        command.readConcern = readConcern;
      }
      if (session.supports.causalConsistency && session.operationTime) {
        command.readConcern = command.readConcern || {};
        Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
      }
    }
    return;
  }
  function updateSessionFromResponse(session, document2) {
    if (document2.$clusterTime) {
      (0, common_1._advanceClusterTime)(session, document2.$clusterTime);
    }
    if (document2.operationTime && session && session.supports.causalConsistency) {
      session.advanceOperationTime(document2.operationTime);
    }
    if (document2.recoveryToken && session && session.inTransaction()) {
      session.transaction._recoveryToken = document2.recoveryToken;
    }
    if (session?.snapshotEnabled && session.snapshotTime == null) {
      const atClusterTime = document2.atClusterTime;
      if (atClusterTime) {
        session.snapshotTime = atClusterTime;
      }
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServerSessionPool = exports.ServerSession = exports.ClientSession = undefined;
  exports.maybeClearPinnedConnection = maybeClearPinnedConnection;
  exports.applySession = applySession;
  exports.updateSessionFromResponse = updateSessionFromResponse;
  var bson_1 = require_bson2();
  var metrics_1 = require_metrics();
  var shared_1 = require_shared();
  var constants_1 = require_constants2();
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var execute_operation_1 = require_execute_operation();
  var run_command_1 = require_run_command();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var resource_management_1 = require_resource_management();
  var common_1 = require_common();
  var timeout_1 = require_timeout();
  var transactions_1 = require_transactions();
  var utils_1 = require_utils2();
  var write_concern_1 = require_write_concern();
  var minWireVersionForShardedTransactions = 8;

  class ClientSession extends mongo_types_1.TypedEventEmitter {
    constructor(client, sessionPool, options, clientOptions) {
      super();
      this.timeoutContext = null;
      if (client == null) {
        throw new error_1.MongoRuntimeError("ClientSession requires a MongoClient");
      }
      if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {
        throw new error_1.MongoRuntimeError("ClientSession requires a ServerSessionPool");
      }
      options = options ?? {};
      this.snapshotEnabled = options.snapshot === true;
      if (options.causalConsistency === true && this.snapshotEnabled) {
        throw new error_1.MongoInvalidArgumentError('Properties "causalConsistency" and "snapshot" are mutually exclusive');
      }
      this.client = client;
      this.sessionPool = sessionPool;
      this.hasEnded = false;
      this.clientOptions = clientOptions;
      this.timeoutMS = options.defaultTimeoutMS ?? client.s.options?.timeoutMS;
      this.explicit = !!options.explicit;
      this._serverSession = this.explicit ? this.sessionPool.acquire() : null;
      this.txnNumberIncrement = 0;
      const defaultCausalConsistencyValue = this.explicit && options.snapshot !== true;
      this.supports = {
        causalConsistency: options.causalConsistency ?? defaultCausalConsistencyValue
      };
      this.clusterTime = options.initialClusterTime;
      this.operationTime = undefined;
      this.owner = options.owner;
      this.defaultTransactionOptions = { ...options.defaultTransactionOptions };
      this.transaction = new transactions_1.Transaction;
    }
    get id() {
      return this.serverSession?.id;
    }
    get serverSession() {
      let serverSession = this._serverSession;
      if (serverSession == null) {
        if (this.explicit) {
          throw new error_1.MongoRuntimeError("Unexpected null serverSession for an explicit session");
        }
        if (this.hasEnded) {
          throw new error_1.MongoRuntimeError("Unexpected null serverSession for an ended implicit session");
        }
        serverSession = this.sessionPool.acquire();
        this._serverSession = serverSession;
      }
      return serverSession;
    }
    get loadBalanced() {
      return this.client.topology?.description.type === common_1.TopologyType.LoadBalanced;
    }
    pin(conn) {
      if (this.pinnedConnection) {
        throw TypeError("Cannot pin multiple connections to the same session");
      }
      this.pinnedConnection = conn;
      conn.emit(constants_1.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);
    }
    unpin(options) {
      if (this.loadBalanced) {
        return maybeClearPinnedConnection(this, options);
      }
      this.transaction.unpinServer();
    }
    get isPinned() {
      return this.loadBalanced ? !!this.pinnedConnection : this.transaction.isPinned;
    }
    async endSession(options) {
      try {
        if (this.inTransaction()) {
          await this.abortTransaction({ ...options, throwTimeout: true });
        }
      } catch (error) {
        if (error.name === "MongoOperationTimeoutError")
          throw error;
        (0, utils_1.squashError)(error);
      } finally {
        if (!this.hasEnded) {
          const serverSession = this.serverSession;
          if (serverSession != null) {
            this.sessionPool.release(serverSession);
            this._serverSession = new ServerSession(serverSession);
          }
          this.hasEnded = true;
          this.emit("ended", this);
        }
        maybeClearPinnedConnection(this, { force: true, ...options });
      }
    }
    async asyncDispose() {
      await this.endSession({ force: true });
    }
    advanceOperationTime(operationTime) {
      if (this.operationTime == null) {
        this.operationTime = operationTime;
        return;
      }
      if (operationTime.greaterThan(this.operationTime)) {
        this.operationTime = operationTime;
      }
    }
    advanceClusterTime(clusterTime) {
      if (!clusterTime || typeof clusterTime !== "object") {
        throw new error_1.MongoInvalidArgumentError("input cluster time must be an object");
      }
      if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== "Timestamp") {
        throw new error_1.MongoInvalidArgumentError('input cluster time "clusterTime" property must be a valid BSON Timestamp');
      }
      if (!clusterTime.signature || clusterTime.signature.hash?._bsontype !== "Binary" || typeof clusterTime.signature.keyId !== "bigint" && typeof clusterTime.signature.keyId !== "number" && clusterTime.signature.keyId?._bsontype !== "Long") {
        throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid "signature" property with BSON Binary hash and BSON Long keyId');
      }
      (0, common_1._advanceClusterTime)(this, clusterTime);
    }
    equals(session) {
      if (!(session instanceof ClientSession)) {
        return false;
      }
      if (this.id == null || session.id == null) {
        return false;
      }
      return utils_1.ByteUtils.equals(this.id.id.buffer, session.id.id.buffer);
    }
    incrementTransactionNumber() {
      this.txnNumberIncrement += 1;
    }
    inTransaction() {
      return this.transaction.isActive;
    }
    startTransaction(options) {
      if (this.snapshotEnabled) {
        throw new error_1.MongoCompatibilityError("Transactions are not supported in snapshot sessions");
      }
      if (this.inTransaction()) {
        throw new error_1.MongoTransactionError("Transaction already in progress");
      }
      if (this.isPinned && this.transaction.isCommitted) {
        this.unpin();
      }
      const topologyMaxWireVersion = (0, utils_1.maxWireVersion)(this.client.topology);
      if ((0, shared_1.isSharded)(this.client.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {
        throw new error_1.MongoCompatibilityError("Transactions are not supported on sharded clusters in MongoDB < 4.2.");
      }
      this.commitAttempted = false;
      this.incrementTransactionNumber();
      this.transaction = new transactions_1.Transaction({
        readConcern: options?.readConcern ?? this.defaultTransactionOptions.readConcern ?? this.clientOptions?.readConcern,
        writeConcern: options?.writeConcern ?? this.defaultTransactionOptions.writeConcern ?? this.clientOptions?.writeConcern,
        readPreference: options?.readPreference ?? this.defaultTransactionOptions.readPreference ?? this.clientOptions?.readPreference,
        maxCommitTimeMS: options?.maxCommitTimeMS ?? this.defaultTransactionOptions.maxCommitTimeMS
      });
      this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);
    }
    async commitTransaction(options) {
      if (this.transaction.state === transactions_1.TxnState.NO_TRANSACTION) {
        throw new error_1.MongoTransactionError("No transaction started");
      }
      if (this.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION || this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {
        this.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);
        return;
      }
      if (this.transaction.state === transactions_1.TxnState.TRANSACTION_ABORTED) {
        throw new error_1.MongoTransactionError("Cannot call commitTransaction after calling abortTransaction");
      }
      const command = { commitTransaction: 1 };
      const timeoutMS = typeof options?.timeoutMS === "number" ? options.timeoutMS : typeof this.timeoutMS === "number" ? this.timeoutMS : null;
      const wc = this.transaction.options.writeConcern ?? this.clientOptions?.writeConcern;
      if (wc != null) {
        if (timeoutMS == null && this.timeoutContext == null) {
          write_concern_1.WriteConcern.apply(command, { wtimeoutMS: 1e4, w: "majority", ...wc });
        } else {
          const wcKeys = Object.keys(wc);
          if (wcKeys.length > 2 || !wcKeys.includes("wtimeoutMS") && !wcKeys.includes("wTimeoutMS"))
            write_concern_1.WriteConcern.apply(command, { ...wc, wtimeoutMS: undefined });
        }
      }
      if (this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED || this.commitAttempted) {
        if (timeoutMS == null && this.timeoutContext == null) {
          write_concern_1.WriteConcern.apply(command, { wtimeoutMS: 1e4, ...wc, w: "majority" });
        } else {
          write_concern_1.WriteConcern.apply(command, { w: "majority", ...wc, wtimeoutMS: undefined });
        }
      }
      if (typeof this.transaction.options.maxTimeMS === "number") {
        command.maxTimeMS = this.transaction.options.maxTimeMS;
      }
      if (this.transaction.recoveryToken) {
        command.recoveryToken = this.transaction.recoveryToken;
      }
      const operation = new run_command_1.RunAdminCommandOperation(command, {
        session: this,
        readPreference: read_preference_1.ReadPreference.primary,
        bypassPinningCheck: true
      });
      const timeoutContext = this.timeoutContext ?? (typeof timeoutMS === "number" ? timeout_1.TimeoutContext.create({
        serverSelectionTimeoutMS: this.clientOptions.serverSelectionTimeoutMS,
        socketTimeoutMS: this.clientOptions.socketTimeoutMS,
        timeoutMS
      }) : null);
      try {
        await (0, execute_operation_1.executeOperation)(this.client, operation, timeoutContext);
        this.commitAttempted = undefined;
        return;
      } catch (firstCommitError) {
        this.commitAttempted = true;
        if (firstCommitError instanceof error_1.MongoError && (0, error_1.isRetryableWriteError)(firstCommitError)) {
          write_concern_1.WriteConcern.apply(command, { wtimeoutMS: 1e4, ...wc, w: "majority" });
          this.unpin({ force: true });
          try {
            await (0, execute_operation_1.executeOperation)(this.client, new run_command_1.RunAdminCommandOperation(command, {
              session: this,
              readPreference: read_preference_1.ReadPreference.primary,
              bypassPinningCheck: true
            }), timeoutContext);
            return;
          } catch (retryCommitError) {
            if (shouldAddUnknownTransactionCommitResultLabel(retryCommitError)) {
              retryCommitError.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);
            }
            if (shouldUnpinAfterCommitError(retryCommitError)) {
              this.unpin({ error: retryCommitError });
            }
            throw retryCommitError;
          }
        }
        if (shouldAddUnknownTransactionCommitResultLabel(firstCommitError)) {
          firstCommitError.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);
        }
        if (shouldUnpinAfterCommitError(firstCommitError)) {
          this.unpin({ error: firstCommitError });
        }
        throw firstCommitError;
      } finally {
        this.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);
      }
    }
    async abortTransaction(options) {
      if (this.transaction.state === transactions_1.TxnState.NO_TRANSACTION) {
        throw new error_1.MongoTransactionError("No transaction started");
      }
      if (this.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {
        this.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);
        return;
      }
      if (this.transaction.state === transactions_1.TxnState.TRANSACTION_ABORTED) {
        throw new error_1.MongoTransactionError("Cannot call abortTransaction twice");
      }
      if (this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED || this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {
        throw new error_1.MongoTransactionError("Cannot call abortTransaction after calling commitTransaction");
      }
      const command = { abortTransaction: 1 };
      const timeoutMS = typeof options?.timeoutMS === "number" ? options.timeoutMS : this.timeoutContext?.csotEnabled() ? this.timeoutContext.timeoutMS : typeof this.timeoutMS === "number" ? this.timeoutMS : null;
      const timeoutContext = timeoutMS != null ? timeout_1.TimeoutContext.create({
        timeoutMS,
        serverSelectionTimeoutMS: this.clientOptions.serverSelectionTimeoutMS,
        socketTimeoutMS: this.clientOptions.socketTimeoutMS
      }) : null;
      const wc = this.transaction.options.writeConcern ?? this.clientOptions?.writeConcern;
      if (wc != null && timeoutMS == null) {
        write_concern_1.WriteConcern.apply(command, { wtimeoutMS: 1e4, w: "majority", ...wc });
      }
      if (this.transaction.recoveryToken) {
        command.recoveryToken = this.transaction.recoveryToken;
      }
      const operation = new run_command_1.RunAdminCommandOperation(command, {
        session: this,
        readPreference: read_preference_1.ReadPreference.primary,
        bypassPinningCheck: true
      });
      try {
        await (0, execute_operation_1.executeOperation)(this.client, operation, timeoutContext);
        this.unpin();
        return;
      } catch (firstAbortError) {
        this.unpin();
        if (firstAbortError.name === "MongoRuntimeError")
          throw firstAbortError;
        if (options?.throwTimeout && firstAbortError.name === "MongoOperationTimeoutError") {
          throw firstAbortError;
        }
        if (firstAbortError instanceof error_1.MongoError && (0, error_1.isRetryableWriteError)(firstAbortError)) {
          try {
            await (0, execute_operation_1.executeOperation)(this.client, operation, timeoutContext);
            return;
          } catch (secondAbortError) {
            if (secondAbortError.name === "MongoRuntimeError")
              throw secondAbortError;
            if (options?.throwTimeout && secondAbortError.name === "MongoOperationTimeoutError") {
              throw secondAbortError;
            }
          }
        }
      } finally {
        this.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);
        if (this.loadBalanced) {
          maybeClearPinnedConnection(this, { force: false });
        }
      }
    }
    toBSON() {
      throw new error_1.MongoRuntimeError("ClientSession cannot be serialized to BSON.");
    }
    async withTransaction(fn, options) {
      const MAX_TIMEOUT = 120000;
      const timeoutMS = options?.timeoutMS ?? this.timeoutMS ?? null;
      this.timeoutContext = timeoutMS != null ? timeout_1.TimeoutContext.create({
        timeoutMS,
        serverSelectionTimeoutMS: this.clientOptions.serverSelectionTimeoutMS,
        socketTimeoutMS: this.clientOptions.socketTimeoutMS
      }) : null;
      const startTime = this.timeoutContext?.csotEnabled() ? this.timeoutContext.start : (0, utils_1.now)();
      let committed = false;
      let result;
      try {
        while (!committed) {
          this.startTransaction(options);
          try {
            const promise = fn(this);
            if (!(0, utils_1.isPromiseLike)(promise)) {
              throw new error_1.MongoInvalidArgumentError("Function provided to `withTransaction` must return a Promise");
            }
            result = await promise;
            if (this.transaction.state === transactions_1.TxnState.NO_TRANSACTION || this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED || this.transaction.state === transactions_1.TxnState.TRANSACTION_ABORTED) {
              return result;
            }
          } catch (fnError) {
            if (!(fnError instanceof error_1.MongoError) || fnError instanceof error_1.MongoInvalidArgumentError) {
              await this.abortTransaction();
              throw fnError;
            }
            if (this.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION || this.transaction.state === transactions_1.TxnState.TRANSACTION_IN_PROGRESS) {
              await this.abortTransaction();
            }
            if (fnError.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) && (this.timeoutContext != null || (0, utils_1.now)() - startTime < MAX_TIMEOUT)) {
              continue;
            }
            throw fnError;
          }
          while (!committed) {
            try {
              await this.commitTransaction();
              committed = true;
            } catch (commitError) {
              if (!isMaxTimeMSExpiredError(commitError) && commitError.hasErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult) && (this.timeoutContext != null || (0, utils_1.now)() - startTime < MAX_TIMEOUT)) {
                continue;
              }
              if (commitError.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) && (this.timeoutContext != null || (0, utils_1.now)() - startTime < MAX_TIMEOUT)) {
                break;
              }
              throw commitError;
            }
          }
        }
        return result;
      } finally {
        this.timeoutContext = null;
      }
    }
  }
  exports.ClientSession = ClientSession;
  (0, resource_management_1.configureResourceManagement)(ClientSession.prototype);
  var NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([
    "CannotSatisfyWriteConcern",
    "UnknownReplWriteConcern",
    "UnsatisfiableWriteConcern"
  ]);

  class ServerSession {
    constructor(cloned) {
      if (cloned != null) {
        const idBytes = Buffer.allocUnsafe(16);
        idBytes.set(cloned.id.id.buffer);
        this.id = { id: new bson_1.Binary(idBytes, cloned.id.id.sub_type) };
        this.lastUse = cloned.lastUse;
        this.txnNumber = cloned.txnNumber;
        this.isDirty = cloned.isDirty;
        return;
      }
      this.id = { id: new bson_1.Binary((0, utils_1.uuidV4)(), bson_1.Binary.SUBTYPE_UUID) };
      this.lastUse = (0, utils_1.now)();
      this.txnNumber = 0;
      this.isDirty = false;
    }
    hasTimedOut(sessionTimeoutMinutes) {
      const idleTimeMinutes = Math.round((0, utils_1.calculateDurationInMs)(this.lastUse) % 86400000 % 3600000 / 60000);
      return idleTimeMinutes > sessionTimeoutMinutes - 1;
    }
  }
  exports.ServerSession = ServerSession;

  class ServerSessionPool {
    constructor(client) {
      if (client == null) {
        throw new error_1.MongoRuntimeError("ServerSessionPool requires a MongoClient");
      }
      this.client = client;
      this.sessions = new utils_1.List;
    }
    acquire() {
      const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;
      let session = null;
      while (this.sessions.length > 0) {
        const potentialSession = this.sessions.shift();
        if (potentialSession != null && (!!this.client.topology?.loadBalanced || !potentialSession.hasTimedOut(sessionTimeoutMinutes))) {
          session = potentialSession;
          break;
        }
      }
      if (session == null) {
        session = new ServerSession;
      }
      return session;
    }
    release(session) {
      const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;
      if (this.client.topology?.loadBalanced && !sessionTimeoutMinutes) {
        this.sessions.unshift(session);
      }
      if (!sessionTimeoutMinutes) {
        return;
      }
      this.sessions.prune((session2) => session2.hasTimedOut(sessionTimeoutMinutes));
      if (!session.hasTimedOut(sessionTimeoutMinutes)) {
        if (session.isDirty) {
          return;
        }
        this.sessions.unshift(session);
      }
    }
  }
  exports.ServerSessionPool = ServerSessionPool;
});

// node_modules/mongodb/lib/cmap/command_monitoring_events.js
var require_command_monitoring_events = __commonJS((exports) => {
  function extractCommand(command) {
    if (command instanceof commands_1.OpMsgRequest) {
      const cmd = { ...command.command };
      if (cmd.ops instanceof commands_1.DocumentSequence) {
        cmd.ops = cmd.ops.documents;
      }
      if (cmd.nsInfo instanceof commands_1.DocumentSequence) {
        cmd.nsInfo = cmd.nsInfo.documents;
      }
      return cmd;
    }
    if (command.query?.$query) {
      let result;
      if (command.ns === "admin.$cmd") {
        result = Object.assign({}, command.query.$query);
      } else {
        result = { find: collectionName(command) };
        Object.keys(LEGACY_FIND_QUERY_MAP).forEach((key) => {
          if (command.query[key] != null) {
            result[LEGACY_FIND_QUERY_MAP[key]] = { ...command.query[key] };
          }
        });
      }
      Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach((key) => {
        const legacyKey = key;
        if (command[legacyKey] != null) {
          result[LEGACY_FIND_OPTIONS_MAP[legacyKey]] = command[legacyKey];
        }
      });
      return result;
    }
    let clonedQuery = {};
    const clonedCommand = { ...command };
    if (command.query) {
      clonedQuery = { ...command.query };
      clonedCommand.query = clonedQuery;
    }
    return command.query ? clonedQuery : clonedCommand;
  }
  function extractReply(reply) {
    if (!reply) {
      return reply;
    }
    return reply.result ? reply.result : reply;
  }
  function extractConnectionDetails(connection) {
    let connectionId;
    if ("id" in connection) {
      connectionId = connection.id;
    }
    return {
      address: connection.address,
      serviceId: connection.serviceId,
      connectionId
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SENSITIVE_COMMANDS = exports.CommandFailedEvent = exports.CommandSucceededEvent = exports.CommandStartedEvent = undefined;
  var constants_1 = require_constants2();
  var utils_1 = require_utils2();
  var commands_1 = require_commands();

  class CommandStartedEvent {
    constructor(connection, command, serverConnectionId) {
      this.name = constants_1.COMMAND_STARTED;
      const cmd = extractCommand(command);
      const commandName = extractCommandName(cmd);
      const { address, connectionId, serviceId } = extractConnectionDetails(connection);
      if (exports.SENSITIVE_COMMANDS.has(commandName)) {
        this.commandObj = {};
        this.commandObj[commandName] = true;
      }
      this.address = address;
      this.connectionId = connectionId;
      this.serviceId = serviceId;
      this.requestId = command.requestId;
      this.databaseName = command.databaseName;
      this.commandName = commandName;
      this.command = maybeRedact(commandName, cmd, cmd);
      this.serverConnectionId = serverConnectionId;
    }
    get hasServiceId() {
      return !!this.serviceId;
    }
  }
  exports.CommandStartedEvent = CommandStartedEvent;

  class CommandSucceededEvent {
    constructor(connection, command, reply, started, serverConnectionId) {
      this.name = constants_1.COMMAND_SUCCEEDED;
      const cmd = extractCommand(command);
      const commandName = extractCommandName(cmd);
      const { address, connectionId, serviceId } = extractConnectionDetails(connection);
      this.address = address;
      this.connectionId = connectionId;
      this.serviceId = serviceId;
      this.requestId = command.requestId;
      this.commandName = commandName;
      this.duration = (0, utils_1.calculateDurationInMs)(started);
      this.reply = maybeRedact(commandName, cmd, extractReply(reply));
      this.serverConnectionId = serverConnectionId;
    }
    get hasServiceId() {
      return !!this.serviceId;
    }
  }
  exports.CommandSucceededEvent = CommandSucceededEvent;

  class CommandFailedEvent {
    constructor(connection, command, error, started, serverConnectionId) {
      this.name = constants_1.COMMAND_FAILED;
      const cmd = extractCommand(command);
      const commandName = extractCommandName(cmd);
      const { address, connectionId, serviceId } = extractConnectionDetails(connection);
      this.address = address;
      this.connectionId = connectionId;
      this.serviceId = serviceId;
      this.requestId = command.requestId;
      this.commandName = commandName;
      this.duration = (0, utils_1.calculateDurationInMs)(started);
      this.failure = maybeRedact(commandName, cmd, error);
      this.serverConnectionId = serverConnectionId;
    }
    get hasServiceId() {
      return !!this.serviceId;
    }
  }
  exports.CommandFailedEvent = CommandFailedEvent;
  exports.SENSITIVE_COMMANDS = new Set([
    "authenticate",
    "saslStart",
    "saslContinue",
    "getnonce",
    "createUser",
    "updateUser",
    "copydbgetnonce",
    "copydbsaslstart",
    "copydb"
  ]);
  var HELLO_COMMANDS = new Set(["hello", constants_1.LEGACY_HELLO_COMMAND, constants_1.LEGACY_HELLO_COMMAND_CAMEL_CASE]);
  var extractCommandName = (commandDoc) => Object.keys(commandDoc)[0];
  var collectionName = (command) => command.ns.split(".")[1];
  var maybeRedact = (commandName, commandDoc, result) => exports.SENSITIVE_COMMANDS.has(commandName) || HELLO_COMMANDS.has(commandName) && commandDoc.speculativeAuthenticate ? {} : result;
  var LEGACY_FIND_QUERY_MAP = {
    $query: "filter",
    $orderby: "sort",
    $hint: "hint",
    $comment: "comment",
    $maxScan: "maxScan",
    $max: "max",
    $min: "min",
    $returnKey: "returnKey",
    $showDiskLoc: "showRecordId",
    $maxTimeMS: "maxTimeMS",
    $snapshot: "snapshot"
  };
  var LEGACY_FIND_OPTIONS_MAP = {
    numberToSkip: "skip",
    numberToReturn: "batchSize",
    returnFieldSelector: "projection"
  };
});

// node_modules/mongodb/lib/cmap/stream_description.js
var require_stream_description = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamDescription = undefined;
  var bson_1 = require_bson2();
  var common_1 = require_common();
  var server_description_1 = require_server_description();
  var RESPONSE_FIELDS = [
    "minWireVersion",
    "maxWireVersion",
    "maxBsonObjectSize",
    "maxMessageSizeBytes",
    "maxWriteBatchSize",
    "logicalSessionTimeoutMinutes"
  ];

  class StreamDescription {
    constructor(address, options) {
      this.hello = null;
      this.address = address;
      this.type = common_1.ServerType.Unknown;
      this.minWireVersion = undefined;
      this.maxWireVersion = undefined;
      this.maxBsonObjectSize = 16777216;
      this.maxMessageSizeBytes = 48000000;
      this.maxWriteBatchSize = 1e5;
      this.logicalSessionTimeoutMinutes = options?.logicalSessionTimeoutMinutes;
      this.loadBalanced = !!options?.loadBalanced;
      this.compressors = options && options.compressors && Array.isArray(options.compressors) ? options.compressors : [];
      this.serverConnectionId = null;
    }
    receiveResponse(response) {
      if (response == null) {
        return;
      }
      this.hello = response;
      this.type = (0, server_description_1.parseServerType)(response);
      if ("connectionId" in response) {
        this.serverConnectionId = this.parseServerConnectionID(response.connectionId);
      } else {
        this.serverConnectionId = null;
      }
      for (const field of RESPONSE_FIELDS) {
        if (response[field] != null) {
          this[field] = response[field];
        }
        if ("__nodejs_mock_server__" in response) {
          this.__nodejs_mock_server__ = response["__nodejs_mock_server__"];
        }
      }
      if (response.compression) {
        this.compressor = this.compressors.filter((c) => response.compression?.includes(c))[0];
      }
    }
    parseServerConnectionID(serverConnectionId) {
      return bson_1.Long.isLong(serverConnectionId) ? serverConnectionId.toBigInt() : BigInt(serverConnectionId);
    }
  }
  exports.StreamDescription = StreamDescription;
});

// node_modules/mongodb/lib/cmap/wire_protocol/on_data.js
var require_on_data = __commonJS((exports) => {
  function onData(emitter, { timeoutContext, signal }) {
    signal?.throwIfAborted();
    const unconsumedEvents = new utils_1.List;
    const unconsumedPromises = new utils_1.List;
    let error = null;
    let finished = false;
    const iterator = {
      next() {
        const value = unconsumedEvents.shift();
        if (value != null) {
          return Promise.resolve({ value, done: false });
        }
        if (error != null) {
          const p = Promise.reject(error);
          error = null;
          return p;
        }
        if (finished)
          return closeHandler();
        const { promise, resolve, reject } = (0, utils_1.promiseWithResolvers)();
        unconsumedPromises.push({ resolve, reject });
        return promise;
      },
      return() {
        return closeHandler();
      },
      throw(err) {
        errorHandler2(err);
        return Promise.resolve({ value: undefined, done: true });
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
    emitter.on("data", eventHandler);
    emitter.on("error", errorHandler2);
    const abortListener = (0, utils_1.addAbortListener)(signal, function() {
      errorHandler2(this.reason);
    });
    const timeoutForSocketRead = timeoutContext?.timeoutForSocketRead;
    timeoutForSocketRead?.throwIfExpired();
    timeoutForSocketRead?.then(undefined, errorHandler2);
    return iterator;
    function eventHandler(value) {
      const promise = unconsumedPromises.shift();
      if (promise != null)
        promise.resolve({ value, done: false });
      else
        unconsumedEvents.push(value);
    }
    function errorHandler2(err) {
      const promise = unconsumedPromises.shift();
      if (promise != null)
        promise.reject(err);
      else
        error = err;
      closeHandler();
    }
    function closeHandler() {
      emitter.off("data", eventHandler);
      emitter.off("error", errorHandler2);
      abortListener?.[utils_1.kDispose]();
      finished = true;
      timeoutForSocketRead?.clear();
      const doneResult = { value: undefined, done: finished };
      for (const promise of unconsumedPromises) {
        promise.resolve(doneResult);
      }
      return Promise.resolve(doneResult);
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.onData = onData;
  var utils_1 = require_utils2();
});

// node_modules/mongodb/lib/cmap/connection.js
var require_connection = __commonJS((exports) => {
  function hasSessionSupport(conn) {
    const description = conn.description;
    return description.logicalSessionTimeoutMinutes != null;
  }
  function streamIdentifier(stream, options) {
    if (options.proxyHost) {
      return options.hostAddress.toString();
    }
    const { remoteAddress, remotePort } = stream;
    if (typeof remoteAddress === "string" && typeof remotePort === "number") {
      return utils_1.HostAddress.fromHostPort(remoteAddress, remotePort).toString();
    }
    return (0, utils_1.uuidV4)().toString("hex");
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CryptoConnection = exports.SizedMessageTransform = exports.Connection = undefined;
  exports.hasSessionSupport = hasSessionSupport;
  var stream_1 = import.meta.require("stream");
  var timers_1 = import.meta.require("timers");
  var bson_1 = require_bson2();
  var constants_1 = require_constants2();
  var error_1 = require_error();
  var mongo_logger_1 = require_mongo_logger();
  var mongo_types_1 = require_mongo_types();
  var read_preference_1 = require_read_preference();
  var common_1 = require_common();
  var sessions_1 = require_sessions();
  var timeout_1 = require_timeout();
  var utils_1 = require_utils2();
  var command_monitoring_events_1 = require_command_monitoring_events();
  var commands_1 = require_commands();
  var stream_description_1 = require_stream_description();
  var compression_1 = require_compression();
  var on_data_1 = require_on_data();
  var responses_1 = require_responses();
  var shared_1 = require_shared();

  class Connection extends mongo_types_1.TypedEventEmitter {
    constructor(stream, options) {
      super();
      this.lastHelloMS = -1;
      this.helloOk = false;
      this.delayedTimeoutId = null;
      this.closed = false;
      this.clusterTime = null;
      this.error = null;
      this.dataEvents = null;
      this.socket = stream;
      this.id = options.id;
      this.address = streamIdentifier(stream, options);
      this.socketTimeoutMS = options.socketTimeoutMS ?? 0;
      this.monitorCommands = options.monitorCommands;
      this.serverApi = options.serverApi;
      this.mongoLogger = options.mongoLogger;
      this.established = false;
      this.description = new stream_description_1.StreamDescription(this.address, options);
      this.generation = options.generation;
      this.lastUseTime = (0, utils_1.now)();
      this.messageStream = this.socket.on("error", this.onError.bind(this)).pipe(new SizedMessageTransform({ connection: this })).on("error", this.onError.bind(this));
      this.socket.on("close", this.onClose.bind(this));
      this.socket.on("timeout", this.onTimeout.bind(this));
      this.messageStream.pause();
    }
    get hello() {
      return this.description.hello;
    }
    set hello(response) {
      this.description.receiveResponse(response);
      Object.freeze(this.description);
    }
    get serviceId() {
      return this.hello?.serviceId;
    }
    get loadBalanced() {
      return this.description.loadBalanced;
    }
    get idleTime() {
      return (0, utils_1.calculateDurationInMs)(this.lastUseTime);
    }
    get hasSessionSupport() {
      return this.description.logicalSessionTimeoutMinutes != null;
    }
    get supportsOpMsg() {
      return this.description != null && (0, utils_1.maxWireVersion)(this) >= 6 && !this.description.__nodejs_mock_server__;
    }
    get shouldEmitAndLogCommand() {
      return (this.monitorCommands || this.established && !this.authContext?.reauthenticating && this.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.COMMAND, mongo_logger_1.SeverityLevel.DEBUG)) ?? false;
    }
    markAvailable() {
      this.lastUseTime = (0, utils_1.now)();
    }
    onError(error) {
      this.cleanup(error);
    }
    onClose() {
      const message = `connection ${this.id} to ${this.address} closed`;
      this.cleanup(new error_1.MongoNetworkError(message));
    }
    onTimeout() {
      this.delayedTimeoutId = (0, timers_1.setTimeout)(() => {
        const message = `connection ${this.id} to ${this.address} timed out`;
        const beforeHandshake = this.hello == null;
        this.cleanup(new error_1.MongoNetworkTimeoutError(message, { beforeHandshake }));
      }, 1).unref();
    }
    destroy() {
      if (this.closed) {
        return;
      }
      this.removeAllListeners(Connection.PINNED);
      this.removeAllListeners(Connection.UNPINNED);
      const message = `connection ${this.id} to ${this.address} closed`;
      this.cleanup(new error_1.MongoNetworkError(message));
    }
    cleanup(error) {
      if (this.closed) {
        return;
      }
      this.socket.destroy();
      this.error = error;
      this.dataEvents?.throw(error).then(undefined, utils_1.squashError);
      this.closed = true;
      this.emit(Connection.CLOSE);
    }
    prepareCommand(db, command, options) {
      let cmd = { ...command };
      const readPreference = (0, shared_1.getReadPreference)(options);
      const session = options?.session;
      let clusterTime = this.clusterTime;
      if (this.serverApi) {
        const { version, strict, deprecationErrors } = this.serverApi;
        cmd.apiVersion = version;
        if (strict != null)
          cmd.apiStrict = strict;
        if (deprecationErrors != null)
          cmd.apiDeprecationErrors = deprecationErrors;
      }
      if (this.hasSessionSupport && session) {
        if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {
          clusterTime = session.clusterTime;
        }
        const sessionError = (0, sessions_1.applySession)(session, cmd, options);
        if (sessionError)
          throw sessionError;
      } else if (session?.explicit) {
        throw new error_1.MongoCompatibilityError("Current topology does not support sessions");
      }
      if (clusterTime) {
        cmd.$clusterTime = clusterTime;
      }
      if (this.description.type !== common_1.ServerType.Standalone) {
        if (!(0, shared_1.isSharded)(this) && !this.description.loadBalanced && this.supportsOpMsg && options.directConnection === true && readPreference?.mode === "primary") {
          cmd.$readPreference = read_preference_1.ReadPreference.primaryPreferred.toJSON();
        } else if ((0, shared_1.isSharded)(this) && !this.supportsOpMsg && readPreference?.mode !== "primary") {
          cmd = {
            $query: cmd,
            $readPreference: readPreference.toJSON()
          };
        } else if (readPreference?.mode !== "primary") {
          cmd.$readPreference = readPreference.toJSON();
        }
      }
      const commandOptions = {
        numberToSkip: 0,
        numberToReturn: -1,
        checkKeys: false,
        secondaryOk: readPreference.secondaryOk(),
        ...options
      };
      options.timeoutContext?.addMaxTimeMSToCommand(cmd, options);
      const message = this.supportsOpMsg ? new commands_1.OpMsgRequest(db, cmd, commandOptions) : new commands_1.OpQueryRequest(db, cmd, commandOptions);
      return message;
    }
    async* sendWire(message, options, responseType) {
      this.throwIfAborted();
      const timeout = options.socketTimeoutMS ?? options?.timeoutContext?.getSocketTimeoutMS() ?? this.socketTimeoutMS;
      this.socket.setTimeout(timeout);
      try {
        await this.writeCommand(message, {
          agreedCompressor: this.description.compressor ?? "none",
          zlibCompressionLevel: this.description.zlibCompressionLevel,
          timeoutContext: options.timeoutContext,
          signal: options.signal
        });
        if (options.noResponse || message.moreToCome) {
          yield responses_1.MongoDBResponse.empty;
          return;
        }
        this.throwIfAborted();
        if (options.timeoutContext?.csotEnabled() && options.timeoutContext.minRoundTripTime != null && options.timeoutContext.remainingTimeMS < options.timeoutContext.minRoundTripTime) {
          throw new error_1.MongoOperationTimeoutError("Server roundtrip time is greater than the time remaining");
        }
        for await (const response of this.readMany(options)) {
          this.socket.setTimeout(0);
          const bson = response.parse();
          const document2 = (responseType ?? responses_1.MongoDBResponse).make(bson);
          yield document2;
          this.throwIfAborted();
          this.socket.setTimeout(timeout);
        }
      } finally {
        this.socket.setTimeout(0);
      }
    }
    async* sendCommand(ns, command, options, responseType) {
      options?.signal?.throwIfAborted();
      const message = this.prepareCommand(ns.db, command, options);
      let started = 0;
      if (this.shouldEmitAndLogCommand) {
        started = (0, utils_1.now)();
        this.emitAndLogCommand(this.monitorCommands, Connection.COMMAND_STARTED, message.databaseName, this.established, new command_monitoring_events_1.CommandStartedEvent(this, message, this.description.serverConnectionId));
      }
      const bsonOptions = options.documentsReturnedIn == null || !options.raw ? options : {
        ...options,
        raw: false,
        fieldsAsRaw: { [options.documentsReturnedIn]: true }
      };
      let document2 = undefined;
      let object = undefined;
      try {
        this.throwIfAborted();
        for await (document2 of this.sendWire(message, options, responseType)) {
          object = undefined;
          if (options.session != null) {
            (0, sessions_1.updateSessionFromResponse)(options.session, document2);
          }
          if (document2.$clusterTime) {
            this.clusterTime = document2.$clusterTime;
            this.emit(Connection.CLUSTER_TIME_RECEIVED, document2.$clusterTime);
          }
          if (document2.ok === 0) {
            if (options.timeoutContext?.csotEnabled() && document2.isMaxTimeExpiredError) {
              throw new error_1.MongoOperationTimeoutError("Server reported a timeout error", {
                cause: new error_1.MongoServerError(object ??= document2.toObject(bsonOptions))
              });
            }
            throw new error_1.MongoServerError(object ??= document2.toObject(bsonOptions));
          }
          if (this.shouldEmitAndLogCommand) {
            this.emitAndLogCommand(this.monitorCommands, Connection.COMMAND_SUCCEEDED, message.databaseName, this.established, new command_monitoring_events_1.CommandSucceededEvent(this, message, options.noResponse ? undefined : message.moreToCome ? { ok: 1 } : object ??= document2.toObject(bsonOptions), started, this.description.serverConnectionId));
          }
          if (responseType == null) {
            yield object ??= document2.toObject(bsonOptions);
          } else {
            yield document2;
          }
          this.throwIfAborted();
        }
      } catch (error) {
        if (this.shouldEmitAndLogCommand) {
          this.emitAndLogCommand(this.monitorCommands, Connection.COMMAND_FAILED, message.databaseName, this.established, new command_monitoring_events_1.CommandFailedEvent(this, message, error, started, this.description.serverConnectionId));
        }
        throw error;
      }
    }
    async command(ns, command, options = {}, responseType) {
      this.throwIfAborted();
      options.signal?.throwIfAborted();
      for await (const document2 of this.sendCommand(ns, command, options, responseType)) {
        if (options.timeoutContext?.csotEnabled()) {
          if (responses_1.MongoDBResponse.is(document2)) {
            if (document2.isMaxTimeExpiredError) {
              throw new error_1.MongoOperationTimeoutError("Server reported a timeout error", {
                cause: new error_1.MongoServerError(document2.toObject())
              });
            }
          } else {
            if (Array.isArray(document2?.writeErrors) && document2.writeErrors.some((error) => error?.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired) || document2?.writeConcernError?.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired) {
              throw new error_1.MongoOperationTimeoutError("Server reported a timeout error", {
                cause: new error_1.MongoServerError(document2)
              });
            }
          }
        }
        return document2;
      }
      throw new error_1.MongoUnexpectedServerResponseError("Unable to get response from server");
    }
    exhaustCommand(ns, command, options, replyListener) {
      const exhaustLoop = async () => {
        this.throwIfAborted();
        for await (const reply of this.sendCommand(ns, command, options)) {
          replyListener(undefined, reply);
          this.throwIfAborted();
        }
        throw new error_1.MongoUnexpectedServerResponseError("Server ended moreToCome unexpectedly");
      };
      exhaustLoop().then(undefined, replyListener);
    }
    throwIfAborted() {
      if (this.error)
        throw this.error;
    }
    async writeCommand(command, options) {
      const finalCommand = options.agreedCompressor === "none" || !commands_1.OpCompressedRequest.canCompress(command) ? command : new commands_1.OpCompressedRequest(command, {
        agreedCompressor: options.agreedCompressor ?? "none",
        zlibCompressionLevel: options.zlibCompressionLevel ?? 0
      });
      const buffer = Buffer.concat(await finalCommand.toBin());
      if (options.timeoutContext?.csotEnabled()) {
        if (options.timeoutContext.minRoundTripTime != null && options.timeoutContext.remainingTimeMS < options.timeoutContext.minRoundTripTime) {
          throw new error_1.MongoOperationTimeoutError("Server roundtrip time is greater than the time remaining");
        }
      }
      if (this.socket.write(buffer))
        return;
      const drainEvent = (0, utils_1.once)(this.socket, "drain", options);
      const timeout = options?.timeoutContext?.timeoutForSocketWrite;
      const drained = timeout ? Promise.race([drainEvent, timeout]) : drainEvent;
      try {
        return await drained;
      } catch (writeError) {
        if (timeout_1.TimeoutError.is(writeError)) {
          const timeoutError = new error_1.MongoOperationTimeoutError("Timed out at socket write");
          this.onError(timeoutError);
          throw timeoutError;
        } else if (writeError === options.signal?.reason) {
          this.onError(writeError);
        }
        throw writeError;
      } finally {
        timeout?.clear();
      }
    }
    async* readMany(options) {
      try {
        this.dataEvents = (0, on_data_1.onData)(this.messageStream, options);
        this.messageStream.resume();
        for await (const message of this.dataEvents) {
          const response = await (0, compression_1.decompressResponse)(message);
          yield response;
          if (!response.moreToCome) {
            return;
          }
        }
      } catch (readError) {
        if (timeout_1.TimeoutError.is(readError)) {
          const timeoutError = new error_1.MongoOperationTimeoutError(`Timed out during socket read (${readError.duration}ms)`);
          this.dataEvents = null;
          this.onError(timeoutError);
          throw timeoutError;
        } else if (readError === options.signal?.reason) {
          this.onError(readError);
        }
        throw readError;
      } finally {
        this.dataEvents = null;
        this.messageStream.pause();
        this.throwIfAborted();
      }
    }
  }
  exports.Connection = Connection;
  Connection.COMMAND_STARTED = constants_1.COMMAND_STARTED;
  Connection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;
  Connection.COMMAND_FAILED = constants_1.COMMAND_FAILED;
  Connection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;
  Connection.CLOSE = constants_1.CLOSE;
  Connection.PINNED = constants_1.PINNED;
  Connection.UNPINNED = constants_1.UNPINNED;

  class SizedMessageTransform extends stream_1.Transform {
    constructor({ connection }) {
      super({ writableObjectMode: false, readableObjectMode: true });
      this.bufferPool = new utils_1.BufferPool;
      this.connection = connection;
    }
    _transform(chunk, encoding, callback) {
      if (this.connection.delayedTimeoutId != null) {
        (0, timers_1.clearTimeout)(this.connection.delayedTimeoutId);
        this.connection.delayedTimeoutId = null;
      }
      this.bufferPool.append(chunk);
      const sizeOfMessage = this.bufferPool.getInt32();
      if (sizeOfMessage == null) {
        return callback();
      }
      if (sizeOfMessage < 0) {
        return callback(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}, too small`));
      }
      if (sizeOfMessage > this.bufferPool.length) {
        return callback();
      }
      const message = this.bufferPool.read(sizeOfMessage);
      return callback(null, message);
    }
  }
  exports.SizedMessageTransform = SizedMessageTransform;

  class CryptoConnection extends Connection {
    constructor(stream, options) {
      super(stream, options);
      this.autoEncrypter = options.autoEncrypter;
    }
    async command(ns, cmd, options, responseType) {
      const { autoEncrypter } = this;
      if (!autoEncrypter) {
        throw new error_1.MongoMissingDependencyError("No AutoEncrypter available for encryption", {
          dependencyName: "n/a"
        });
      }
      const serverWireVersion = (0, utils_1.maxWireVersion)(this);
      if (serverWireVersion === 0) {
        return await super.command(ns, cmd, options, responseType);
      }
      if (serverWireVersion < 8) {
        throw new error_1.MongoCompatibilityError("Auto-encryption requires a minimum MongoDB version of 4.2");
      }
      const sort = cmd.find || cmd.findAndModify ? cmd.sort : null;
      const indexKeys = cmd.createIndexes ? cmd.indexes.map((index) => index.key) : null;
      const encrypted = await autoEncrypter.encrypt(ns.toString(), cmd, options);
      if (sort != null && (cmd.find || cmd.findAndModify)) {
        encrypted.sort = sort;
      }
      if (indexKeys != null && cmd.createIndexes) {
        for (const [offset, index] of indexKeys.entries()) {
          encrypted.indexes[offset].key = index;
        }
      }
      const encryptedResponse = await super.command(ns, encrypted, options, responseType ?? responses_1.MongoDBResponse);
      const result = await autoEncrypter.decrypt(encryptedResponse.toBytes(), options);
      const decryptedResponse = responseType?.make(result) ?? (0, bson_1.deserialize)(result, options);
      if (autoEncrypter[constants_1.kDecorateResult]) {
        if (responseType == null) {
          (0, utils_1.decorateDecryptionResult)(decryptedResponse, encryptedResponse.toObject(), true);
        } else if (decryptedResponse instanceof responses_1.CursorResponse) {
          decryptedResponse.encryptedResponse = encryptedResponse;
        }
      }
      return decryptedResponse;
    }
  }
  exports.CryptoConnection = CryptoConnection;
});

// node_modules/mongodb/lib/cmap/connect.js
var require_connect = __commonJS((exports) => {
  async function connect(options) {
    let connection = null;
    try {
      const socket = await makeSocket(options);
      connection = makeConnection(options, socket);
      await performInitialHandshake(connection, options);
      return connection;
    } catch (error) {
      connection?.destroy();
      throw error;
    }
  }
  function makeConnection(options, socket) {
    let ConnectionType = options.connectionType ?? connection_1.Connection;
    if (options.autoEncrypter) {
      ConnectionType = connection_1.CryptoConnection;
    }
    return new ConnectionType(socket, options);
  }
  function checkSupportedServer(hello, options) {
    const maxWireVersion = Number(hello.maxWireVersion);
    const minWireVersion = Number(hello.minWireVersion);
    const serverVersionHighEnough = !Number.isNaN(maxWireVersion) && maxWireVersion >= constants_2.MIN_SUPPORTED_WIRE_VERSION;
    const serverVersionLowEnough = !Number.isNaN(minWireVersion) && minWireVersion <= constants_2.MAX_SUPPORTED_WIRE_VERSION;
    if (serverVersionHighEnough) {
      if (serverVersionLowEnough) {
        return null;
      }
      const message2 = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(hello.minWireVersion)}, but this version of the Node.js Driver requires at most ${constants_2.MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MAX_SUPPORTED_SERVER_VERSION})`;
      return new error_1.MongoCompatibilityError(message2);
    }
    const message = `Server at ${options.hostAddress} reports maximum wire version ${JSON.stringify(hello.maxWireVersion) ?? 0}, but this version of the Node.js Driver requires at least ${constants_2.MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MIN_SUPPORTED_SERVER_VERSION})`;
    return new error_1.MongoCompatibilityError(message);
  }
  async function performInitialHandshake(conn, options) {
    const credentials = options.credentials;
    if (credentials) {
      if (!(credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT) && !options.authProviders.getOrCreateProvider(credentials.mechanism, credentials.mechanismProperties)) {
        throw new error_1.MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`);
      }
    }
    const authContext = new auth_provider_1.AuthContext(conn, credentials, options);
    conn.authContext = authContext;
    const handshakeDoc = await prepareHandshakeDocument(authContext);
    const handshakeOptions = { ...options, raw: false };
    if (typeof options.connectTimeoutMS === "number") {
      handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;
    }
    const start = new Date().getTime();
    const response = await executeHandshake(handshakeDoc, handshakeOptions);
    if (!("isWritablePrimary" in response)) {
      response.isWritablePrimary = response[constants_1.LEGACY_HELLO_COMMAND];
    }
    if (response.helloOk) {
      conn.helloOk = true;
    }
    const supportedServerErr = checkSupportedServer(response, options);
    if (supportedServerErr) {
      throw supportedServerErr;
    }
    if (options.loadBalanced) {
      if (!response.serviceId) {
        throw new error_1.MongoCompatibilityError("Driver attempted to initialize in load balancing mode, " + "but the server does not support this mode.");
      }
    }
    conn.hello = response;
    conn.lastHelloMS = new Date().getTime() - start;
    if (!response.arbiterOnly && credentials) {
      authContext.response = response;
      const resolvedCredentials = credentials.resolveAuthMechanism(response);
      const provider = options.authProviders.getOrCreateProvider(resolvedCredentials.mechanism, resolvedCredentials.mechanismProperties);
      if (!provider) {
        throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${resolvedCredentials.mechanism} defined.`);
      }
      try {
        await provider.auth(authContext);
      } catch (error) {
        if (error instanceof error_1.MongoError) {
          error.addErrorLabel(error_1.MongoErrorLabel.HandshakeError);
          if ((0, error_1.needsRetryableWriteLabel)(error, response.maxWireVersion, conn.description.type)) {
            error.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
          }
        }
        throw error;
      }
    }
    conn.established = true;
    async function executeHandshake(handshakeDoc2, handshakeOptions2) {
      try {
        const handshakeResponse = await conn.command((0, utils_1.ns)("admin.$cmd"), handshakeDoc2, handshakeOptions2);
        return handshakeResponse;
      } catch (error) {
        if (error instanceof error_1.MongoError) {
          error.addErrorLabel(error_1.MongoErrorLabel.HandshakeError);
        }
        throw error;
      }
    }
  }
  async function prepareHandshakeDocument(authContext) {
    const options = authContext.options;
    const compressors = options.compressors ? options.compressors : [];
    const { serverApi } = authContext.connection;
    const clientMetadata = await options.extendedMetadata;
    const handshakeDoc = {
      [serverApi?.version || options.loadBalanced === true ? "hello" : constants_1.LEGACY_HELLO_COMMAND]: 1,
      helloOk: true,
      client: clientMetadata,
      compression: compressors
    };
    if (options.loadBalanced === true) {
      handshakeDoc.loadBalanced = true;
    }
    const credentials = authContext.credentials;
    if (credentials) {
      if (credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && credentials.username) {
        handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;
        const provider2 = authContext.options.authProviders.getOrCreateProvider(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, credentials.mechanismProperties);
        if (!provider2) {
          throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${providers_1.AuthMechanism.MONGODB_SCRAM_SHA256} defined.`);
        }
        return await provider2.prepare(handshakeDoc, authContext);
      }
      const provider = authContext.options.authProviders.getOrCreateProvider(credentials.mechanism, credentials.mechanismProperties);
      if (!provider) {
        throw new error_1.MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`);
      }
      return await provider.prepare(handshakeDoc, authContext);
    }
    return handshakeDoc;
  }
  function parseConnectOptions(options) {
    const hostAddress = options.hostAddress;
    if (!hostAddress)
      throw new error_1.MongoInvalidArgumentError('Option "hostAddress" is required');
    const result = {};
    for (const name of exports.LEGAL_TCP_SOCKET_OPTIONS) {
      if (options[name] != null) {
        result[name] = options[name];
      }
    }
    if (typeof hostAddress.socketPath === "string") {
      result.path = hostAddress.socketPath;
      return result;
    } else if (typeof hostAddress.host === "string") {
      result.host = hostAddress.host;
      result.port = hostAddress.port;
      return result;
    } else {
      throw new error_1.MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);
    }
  }
  function parseSslOptions(options) {
    const result = parseConnectOptions(options);
    for (const name of exports.LEGAL_TLS_SOCKET_OPTIONS) {
      if (options[name] != null) {
        result[name] = options[name];
      }
    }
    if (options.existingSocket) {
      result.socket = options.existingSocket;
    }
    if (result.servername == null && result.host && !net.isIP(result.host)) {
      result.servername = result.host;
    }
    return result;
  }
  async function makeSocket(options) {
    const useTLS = options.tls ?? false;
    const noDelay = options.noDelay ?? true;
    const connectTimeoutMS = options.connectTimeoutMS ?? 30000;
    const existingSocket = options.existingSocket;
    let socket;
    if (options.proxyHost != null) {
      return await makeSocks5Connection({
        ...options,
        connectTimeoutMS
      });
    }
    if (useTLS) {
      const tlsSocket = tls.connect(parseSslOptions(options));
      if (typeof tlsSocket.disableRenegotiation === "function") {
        tlsSocket.disableRenegotiation();
      }
      socket = tlsSocket;
    } else if (existingSocket) {
      socket = existingSocket;
    } else {
      socket = net.createConnection(parseConnectOptions(options));
    }
    socket.setKeepAlive(true, 300000);
    socket.setTimeout(connectTimeoutMS);
    socket.setNoDelay(noDelay);
    let cancellationHandler = null;
    const { promise: connectedSocket, resolve, reject } = (0, utils_1.promiseWithResolvers)();
    if (existingSocket) {
      resolve(socket);
    } else {
      const start = performance.now();
      const connectEvent = useTLS ? "secureConnect" : "connect";
      socket.once(connectEvent, () => resolve(socket)).once("error", (cause) => reject(new error_1.MongoNetworkError(error_1.MongoError.buildErrorMessage(cause), { cause }))).once("timeout", () => {
        reject(new error_1.MongoNetworkTimeoutError(`Socket '${connectEvent}' timed out after ${performance.now() - start | 0}ms (connectTimeoutMS: ${connectTimeoutMS})`));
      }).once("close", () => reject(new error_1.MongoNetworkError(`Socket closed after ${performance.now() - start | 0} during connection establishment`)));
      if (options.cancellationToken != null) {
        cancellationHandler = () => reject(new error_1.MongoNetworkError(`Socket connection establishment was cancelled after ${performance.now() - start | 0}`));
        options.cancellationToken.once("cancel", cancellationHandler);
      }
    }
    try {
      socket = await connectedSocket;
      return socket;
    } catch (error) {
      socket.destroy();
      throw error;
    } finally {
      socket.setTimeout(0);
      socket.removeAllListeners();
      if (cancellationHandler != null) {
        options.cancellationToken?.removeListener("cancel", cancellationHandler);
      }
    }
  }
  function loadSocks() {
    if (socks == null) {
      const socksImport = (0, deps_1.getSocks)();
      if ("kModuleError" in socksImport) {
        throw socksImport.kModuleError;
      }
      socks = socksImport;
    }
    return socks;
  }
  async function makeSocks5Connection(options) {
    const hostAddress = utils_1.HostAddress.fromHostPort(options.proxyHost ?? "", options.proxyPort ?? 1080);
    const rawSocket = await makeSocket({
      ...options,
      hostAddress,
      tls: false,
      proxyHost: undefined
    });
    const destination = parseConnectOptions(options);
    if (typeof destination.host !== "string" || typeof destination.port !== "number") {
      throw new error_1.MongoInvalidArgumentError("Can only make Socks5 connections to TCP hosts");
    }
    socks ??= loadSocks();
    let existingSocket;
    try {
      const connection = await socks.SocksClient.createConnection({
        existing_socket: rawSocket,
        timeout: options.connectTimeoutMS,
        command: "connect",
        destination: {
          host: destination.host,
          port: destination.port
        },
        proxy: {
          host: "iLoveJavaScript",
          port: 0,
          type: 5,
          userId: options.proxyUsername || undefined,
          password: options.proxyPassword || undefined
        }
      });
      existingSocket = connection.socket;
    } catch (cause) {
      throw new error_1.MongoNetworkError(error_1.MongoError.buildErrorMessage(cause), { cause });
    }
    return await makeSocket({ ...options, existingSocket, proxyHost: undefined });
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LEGAL_TCP_SOCKET_OPTIONS = exports.LEGAL_TLS_SOCKET_OPTIONS = undefined;
  exports.connect = connect;
  exports.makeConnection = makeConnection;
  exports.performInitialHandshake = performInitialHandshake;
  exports.prepareHandshakeDocument = prepareHandshakeDocument;
  exports.makeSocket = makeSocket;
  var net = import.meta.require("net");
  var tls = import.meta.require("tls");
  var constants_1 = require_constants2();
  var deps_1 = require_deps();
  var error_1 = require_error();
  var utils_1 = require_utils2();
  var auth_provider_1 = require_auth_provider();
  var providers_1 = require_providers();
  var connection_1 = require_connection();
  var constants_2 = require_constants();
  exports.LEGAL_TLS_SOCKET_OPTIONS = [
    "allowPartialTrustChain",
    "ALPNProtocols",
    "ca",
    "cert",
    "checkServerIdentity",
    "ciphers",
    "crl",
    "ecdhCurve",
    "key",
    "minDHSize",
    "passphrase",
    "pfx",
    "rejectUnauthorized",
    "secureContext",
    "secureProtocol",
    "servername",
    "session"
  ];
  exports.LEGAL_TCP_SOCKET_OPTIONS = [
    "autoSelectFamily",
    "autoSelectFamilyAttemptTimeout",
    "family",
    "hints",
    "localAddress",
    "localPort",
    "lookup"
  ];
  var socks = null;
});

// node_modules/mongodb/lib/sdam/events.js
var require_events = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServerHeartbeatFailedEvent = exports.ServerHeartbeatSucceededEvent = exports.ServerHeartbeatStartedEvent = exports.TopologyClosedEvent = exports.TopologyOpeningEvent = exports.TopologyDescriptionChangedEvent = exports.ServerClosedEvent = exports.ServerOpeningEvent = exports.ServerDescriptionChangedEvent = undefined;
  var constants_1 = require_constants2();

  class ServerDescriptionChangedEvent {
    constructor(topologyId, address, previousDescription, newDescription) {
      this.name = constants_1.SERVER_DESCRIPTION_CHANGED;
      this.topologyId = topologyId;
      this.address = address;
      this.previousDescription = previousDescription;
      this.newDescription = newDescription;
    }
  }
  exports.ServerDescriptionChangedEvent = ServerDescriptionChangedEvent;

  class ServerOpeningEvent {
    constructor(topologyId, address) {
      this.name = constants_1.SERVER_OPENING;
      this.topologyId = topologyId;
      this.address = address;
    }
  }
  exports.ServerOpeningEvent = ServerOpeningEvent;

  class ServerClosedEvent {
    constructor(topologyId, address) {
      this.name = constants_1.SERVER_CLOSED;
      this.topologyId = topologyId;
      this.address = address;
    }
  }
  exports.ServerClosedEvent = ServerClosedEvent;

  class TopologyDescriptionChangedEvent {
    constructor(topologyId, previousDescription, newDescription) {
      this.name = constants_1.TOPOLOGY_DESCRIPTION_CHANGED;
      this.topologyId = topologyId;
      this.previousDescription = previousDescription;
      this.newDescription = newDescription;
    }
  }
  exports.TopologyDescriptionChangedEvent = TopologyDescriptionChangedEvent;

  class TopologyOpeningEvent {
    constructor(topologyId) {
      this.name = constants_1.TOPOLOGY_OPENING;
      this.topologyId = topologyId;
    }
  }
  exports.TopologyOpeningEvent = TopologyOpeningEvent;

  class TopologyClosedEvent {
    constructor(topologyId) {
      this.name = constants_1.TOPOLOGY_CLOSED;
      this.topologyId = topologyId;
    }
  }
  exports.TopologyClosedEvent = TopologyClosedEvent;

  class ServerHeartbeatStartedEvent {
    constructor(connectionId, awaited) {
      this.name = constants_1.SERVER_HEARTBEAT_STARTED;
      this.connectionId = connectionId;
      this.awaited = awaited;
    }
  }
  exports.ServerHeartbeatStartedEvent = ServerHeartbeatStartedEvent;

  class ServerHeartbeatSucceededEvent {
    constructor(connectionId, duration, reply, awaited) {
      this.name = constants_1.SERVER_HEARTBEAT_SUCCEEDED;
      this.connectionId = connectionId;
      this.duration = duration;
      this.reply = reply ?? {};
      this.awaited = awaited;
    }
  }
  exports.ServerHeartbeatSucceededEvent = ServerHeartbeatSucceededEvent;

  class ServerHeartbeatFailedEvent {
    constructor(connectionId, duration, failure, awaited) {
      this.name = constants_1.SERVER_HEARTBEAT_FAILED;
      this.connectionId = connectionId;
      this.duration = duration;
      this.failure = failure;
      this.awaited = awaited;
    }
  }
  exports.ServerHeartbeatFailedEvent = ServerHeartbeatFailedEvent;
});

// node_modules/mongodb/lib/cmap/connection_pool_events.js
var require_connection_pool_events = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectionPoolClearedEvent = exports.ConnectionCheckedInEvent = exports.ConnectionCheckedOutEvent = exports.ConnectionCheckOutFailedEvent = exports.ConnectionCheckOutStartedEvent = exports.ConnectionClosedEvent = exports.ConnectionReadyEvent = exports.ConnectionCreatedEvent = exports.ConnectionPoolClosedEvent = exports.ConnectionPoolReadyEvent = exports.ConnectionPoolCreatedEvent = exports.ConnectionPoolMonitoringEvent = undefined;
  var constants_1 = require_constants2();
  var utils_1 = require_utils2();

  class ConnectionPoolMonitoringEvent {
    constructor(pool) {
      this.time = new Date;
      this.address = pool.address;
    }
  }
  exports.ConnectionPoolMonitoringEvent = ConnectionPoolMonitoringEvent;

  class ConnectionPoolCreatedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool) {
      super(pool);
      this.name = constants_1.CONNECTION_POOL_CREATED;
      const { maxConnecting, maxPoolSize, minPoolSize, maxIdleTimeMS, waitQueueTimeoutMS } = pool.options;
      this.options = { maxConnecting, maxPoolSize, minPoolSize, maxIdleTimeMS, waitQueueTimeoutMS };
    }
  }
  exports.ConnectionPoolCreatedEvent = ConnectionPoolCreatedEvent;

  class ConnectionPoolReadyEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool) {
      super(pool);
      this.name = constants_1.CONNECTION_POOL_READY;
    }
  }
  exports.ConnectionPoolReadyEvent = ConnectionPoolReadyEvent;

  class ConnectionPoolClosedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool) {
      super(pool);
      this.name = constants_1.CONNECTION_POOL_CLOSED;
    }
  }
  exports.ConnectionPoolClosedEvent = ConnectionPoolClosedEvent;

  class ConnectionCreatedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection) {
      super(pool);
      this.name = constants_1.CONNECTION_CREATED;
      this.connectionId = connection.id;
    }
  }
  exports.ConnectionCreatedEvent = ConnectionCreatedEvent;

  class ConnectionReadyEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection, connectionCreatedEventTime) {
      super(pool);
      this.name = constants_1.CONNECTION_READY;
      this.durationMS = (0, utils_1.now)() - connectionCreatedEventTime;
      this.connectionId = connection.id;
    }
  }
  exports.ConnectionReadyEvent = ConnectionReadyEvent;

  class ConnectionClosedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection, reason, error) {
      super(pool);
      this.name = constants_1.CONNECTION_CLOSED;
      this.connectionId = connection.id;
      this.reason = reason;
      this.serviceId = connection.serviceId;
      this.error = error ?? null;
    }
  }
  exports.ConnectionClosedEvent = ConnectionClosedEvent;

  class ConnectionCheckOutStartedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool) {
      super(pool);
      this.name = constants_1.CONNECTION_CHECK_OUT_STARTED;
    }
  }
  exports.ConnectionCheckOutStartedEvent = ConnectionCheckOutStartedEvent;

  class ConnectionCheckOutFailedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, reason, checkoutTime, error) {
      super(pool);
      this.name = constants_1.CONNECTION_CHECK_OUT_FAILED;
      this.durationMS = (0, utils_1.now)() - checkoutTime;
      this.reason = reason;
      this.error = error;
    }
  }
  exports.ConnectionCheckOutFailedEvent = ConnectionCheckOutFailedEvent;

  class ConnectionCheckedOutEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection, checkoutTime) {
      super(pool);
      this.name = constants_1.CONNECTION_CHECKED_OUT;
      this.durationMS = (0, utils_1.now)() - checkoutTime;
      this.connectionId = connection.id;
    }
  }
  exports.ConnectionCheckedOutEvent = ConnectionCheckedOutEvent;

  class ConnectionCheckedInEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, connection) {
      super(pool);
      this.name = constants_1.CONNECTION_CHECKED_IN;
      this.connectionId = connection.id;
    }
  }
  exports.ConnectionCheckedInEvent = ConnectionCheckedInEvent;

  class ConnectionPoolClearedEvent extends ConnectionPoolMonitoringEvent {
    constructor(pool, options = {}) {
      super(pool);
      this.name = constants_1.CONNECTION_POOL_CLEARED;
      this.serviceId = options.serviceId;
      this.interruptInUseConnections = options.interruptInUseConnections;
    }
  }
  exports.ConnectionPoolClearedEvent = ConnectionPoolClearedEvent;
});

// node_modules/mongodb/lib/cmap/errors.js
var require_errors2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WaitQueueTimeoutError = exports.PoolClearedOnNetworkError = exports.PoolClearedError = exports.PoolClosedError = undefined;
  var error_1 = require_error();

  class PoolClosedError extends error_1.MongoDriverError {
    constructor(pool) {
      super("Attempted to check out a connection from closed connection pool");
      this.address = pool.address;
    }
    get name() {
      return "MongoPoolClosedError";
    }
  }
  exports.PoolClosedError = PoolClosedError;

  class PoolClearedError extends error_1.MongoNetworkError {
    constructor(pool, message) {
      const errorMessage = message ? message : `Connection pool for ${pool.address} was cleared because another operation failed with: "${pool.serverError?.message}"`;
      super(errorMessage, pool.serverError ? { cause: pool.serverError } : undefined);
      this.address = pool.address;
      this.addErrorLabel(error_1.MongoErrorLabel.PoolRequstedRetry);
    }
    get name() {
      return "MongoPoolClearedError";
    }
  }
  exports.PoolClearedError = PoolClearedError;

  class PoolClearedOnNetworkError extends PoolClearedError {
    constructor(pool) {
      super(pool, `Connection to ${pool.address} interrupted due to server monitor timeout`);
    }
    get name() {
      return "PoolClearedOnNetworkError";
    }
  }
  exports.PoolClearedOnNetworkError = PoolClearedOnNetworkError;

  class WaitQueueTimeoutError extends error_1.MongoDriverError {
    constructor(message, address) {
      super(message);
      this.address = address;
    }
    get name() {
      return "MongoWaitQueueTimeoutError";
    }
  }
  exports.WaitQueueTimeoutError = WaitQueueTimeoutError;
});

// node_modules/mongodb/lib/cmap/connection_pool.js
var require_connection_pool = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectionPool = exports.PoolState = undefined;
  var timers_1 = import.meta.require("timers");
  var constants_1 = require_constants2();
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var timeout_1 = require_timeout();
  var utils_1 = require_utils2();
  var connect_1 = require_connect();
  var connection_1 = require_connection();
  var connection_pool_events_1 = require_connection_pool_events();
  var errors_1 = require_errors2();
  var metrics_1 = require_metrics();
  exports.PoolState = Object.freeze({
    paused: "paused",
    ready: "ready",
    closed: "closed"
  });

  class ConnectionPool extends mongo_types_1.TypedEventEmitter {
    constructor(server, options) {
      super();
      this.options = Object.freeze({
        connectionType: connection_1.Connection,
        ...options,
        maxPoolSize: options.maxPoolSize ?? 100,
        minPoolSize: options.minPoolSize ?? 0,
        maxConnecting: options.maxConnecting ?? 2,
        maxIdleTimeMS: options.maxIdleTimeMS ?? 0,
        waitQueueTimeoutMS: options.waitQueueTimeoutMS ?? 0,
        minPoolSizeCheckFrequencyMS: options.minPoolSizeCheckFrequencyMS ?? 100,
        autoEncrypter: options.autoEncrypter
      });
      if (this.options.minPoolSize > this.options.maxPoolSize) {
        throw new error_1.MongoInvalidArgumentError("Connection pool minimum size must not be greater than maximum pool size");
      }
      this.poolState = exports.PoolState.paused;
      this.server = server;
      this.connections = new utils_1.List;
      this.pending = 0;
      this.checkedOut = new Set;
      this.minPoolSizeTimer = undefined;
      this.generation = 0;
      this.serviceGenerations = new Map;
      this.connectionCounter = (0, utils_1.makeCounter)(1);
      this.cancellationToken = new mongo_types_1.CancellationToken;
      this.cancellationToken.setMaxListeners(Infinity);
      this.waitQueue = new utils_1.List;
      this.metrics = new metrics_1.ConnectionPoolMetrics;
      this.processingWaitQueue = false;
      this.mongoLogger = this.server.topology.client?.mongoLogger;
      this.component = "connection";
      process.nextTick(() => {
        this.emitAndLog(ConnectionPool.CONNECTION_POOL_CREATED, new connection_pool_events_1.ConnectionPoolCreatedEvent(this));
      });
    }
    get address() {
      return this.options.hostAddress.toString();
    }
    get closed() {
      return this.poolState === exports.PoolState.closed;
    }
    get totalConnectionCount() {
      return this.availableConnectionCount + this.pendingConnectionCount + this.currentCheckedOutCount;
    }
    get availableConnectionCount() {
      return this.connections.length;
    }
    get pendingConnectionCount() {
      return this.pending;
    }
    get currentCheckedOutCount() {
      return this.checkedOut.size;
    }
    get waitQueueSize() {
      return this.waitQueue.length;
    }
    get loadBalanced() {
      return this.options.loadBalanced;
    }
    get serverError() {
      return this.server.description.error;
    }
    get checkedOutConnections() {
      return this.checkedOut;
    }
    waitQueueErrorMetrics() {
      return this.metrics.info(this.options.maxPoolSize);
    }
    ready() {
      if (this.poolState !== exports.PoolState.paused) {
        return;
      }
      this.poolState = exports.PoolState.ready;
      this.emitAndLog(ConnectionPool.CONNECTION_POOL_READY, new connection_pool_events_1.ConnectionPoolReadyEvent(this));
      (0, timers_1.clearTimeout)(this.minPoolSizeTimer);
      this.ensureMinPoolSize();
    }
    async checkOut(options) {
      const checkoutTime = (0, utils_1.now)();
      this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_STARTED, new connection_pool_events_1.ConnectionCheckOutStartedEvent(this));
      const { promise, resolve, reject } = (0, utils_1.promiseWithResolvers)();
      const timeout = options.timeoutContext.connectionCheckoutTimeout;
      const waitQueueMember = {
        resolve,
        reject,
        cancelled: false,
        checkoutTime
      };
      const abortListener = (0, utils_1.addAbortListener)(options.signal, function() {
        waitQueueMember.cancelled = true;
        reject(this.reason);
      });
      this.waitQueue.push(waitQueueMember);
      process.nextTick(() => this.processWaitQueue());
      try {
        timeout?.throwIfExpired();
        return await (timeout ? Promise.race([promise, timeout]) : promise);
      } catch (error) {
        if (timeout_1.TimeoutError.is(error)) {
          timeout?.clear();
          waitQueueMember.cancelled = true;
          this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, "timeout", waitQueueMember.checkoutTime));
          const timeoutError = new errors_1.WaitQueueTimeoutError(this.loadBalanced ? this.waitQueueErrorMetrics() : "Timed out while checking out a connection from connection pool", this.address);
          if (options.timeoutContext.csotEnabled()) {
            throw new error_1.MongoOperationTimeoutError("Timed out during connection checkout", {
              cause: timeoutError
            });
          }
          throw timeoutError;
        }
        throw error;
      } finally {
        abortListener?.[utils_1.kDispose]();
        timeout?.clear();
      }
    }
    checkIn(connection) {
      if (!this.checkedOut.has(connection)) {
        return;
      }
      const poolClosed = this.closed;
      const stale = this.connectionIsStale(connection);
      const willDestroy = !!(poolClosed || stale || connection.closed);
      if (!willDestroy) {
        connection.markAvailable();
        this.connections.unshift(connection);
      }
      this.checkedOut.delete(connection);
      this.emitAndLog(ConnectionPool.CONNECTION_CHECKED_IN, new connection_pool_events_1.ConnectionCheckedInEvent(this, connection));
      if (willDestroy) {
        const reason = connection.closed ? "error" : poolClosed ? "poolClosed" : "stale";
        this.destroyConnection(connection, reason);
      }
      process.nextTick(() => this.processWaitQueue());
    }
    clear(options = {}) {
      if (this.closed) {
        return;
      }
      if (this.loadBalanced) {
        const { serviceId } = options;
        if (!serviceId) {
          throw new error_1.MongoRuntimeError("ConnectionPool.clear() called in load balanced mode with no serviceId.");
        }
        const sid = serviceId.toHexString();
        const generation = this.serviceGenerations.get(sid);
        if (generation == null) {
          throw new error_1.MongoRuntimeError("Service generations are required in load balancer mode.");
        } else {
          this.serviceGenerations.set(sid, generation + 1);
        }
        this.emitAndLog(ConnectionPool.CONNECTION_POOL_CLEARED, new connection_pool_events_1.ConnectionPoolClearedEvent(this, { serviceId }));
        return;
      }
      const interruptInUseConnections = options.interruptInUseConnections ?? false;
      const oldGeneration = this.generation;
      this.generation += 1;
      const alreadyPaused = this.poolState === exports.PoolState.paused;
      this.poolState = exports.PoolState.paused;
      this.clearMinPoolSizeTimer();
      if (!alreadyPaused) {
        this.emitAndLog(ConnectionPool.CONNECTION_POOL_CLEARED, new connection_pool_events_1.ConnectionPoolClearedEvent(this, {
          interruptInUseConnections
        }));
      }
      if (interruptInUseConnections) {
        process.nextTick(() => this.interruptInUseConnections(oldGeneration));
      }
      this.processWaitQueue();
    }
    interruptInUseConnections(minGeneration) {
      for (const connection of this.checkedOut) {
        if (connection.generation <= minGeneration) {
          connection.onError(new errors_1.PoolClearedOnNetworkError(this));
          this.checkIn(connection);
        }
      }
    }
    close() {
      if (this.closed) {
        return;
      }
      this.cancellationToken.emit("cancel");
      if (typeof this.connectionCounter.return === "function") {
        this.connectionCounter.return(undefined);
      }
      this.poolState = exports.PoolState.closed;
      this.clearMinPoolSizeTimer();
      this.processWaitQueue();
      for (const conn of this.connections) {
        this.emitAndLog(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, conn, "poolClosed"));
        conn.destroy();
      }
      this.connections.clear();
      this.emitAndLog(ConnectionPool.CONNECTION_POOL_CLOSED, new connection_pool_events_1.ConnectionPoolClosedEvent(this));
    }
    async reauthenticate(connection) {
      const authContext = connection.authContext;
      if (!authContext) {
        throw new error_1.MongoRuntimeError("No auth context found on connection.");
      }
      const credentials = authContext.credentials;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError("Connection is missing credentials when asked to reauthenticate");
      }
      const resolvedCredentials = credentials.resolveAuthMechanism(connection.hello);
      const provider = this.server.topology.client.s.authProviders.getOrCreateProvider(resolvedCredentials.mechanism, resolvedCredentials.mechanismProperties);
      if (!provider) {
        throw new error_1.MongoMissingCredentialsError(`Reauthenticate failed due to no auth provider for ${credentials.mechanism}`);
      }
      await provider.reauth(authContext);
      return;
    }
    clearMinPoolSizeTimer() {
      const minPoolSizeTimer = this.minPoolSizeTimer;
      if (minPoolSizeTimer) {
        (0, timers_1.clearTimeout)(minPoolSizeTimer);
      }
    }
    destroyConnection(connection, reason) {
      this.emitAndLog(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, connection, reason));
      connection.destroy();
    }
    connectionIsStale(connection) {
      const serviceId = connection.serviceId;
      if (this.loadBalanced && serviceId) {
        const sid = serviceId.toHexString();
        const generation = this.serviceGenerations.get(sid);
        return connection.generation !== generation;
      }
      return connection.generation !== this.generation;
    }
    connectionIsIdle(connection) {
      return !!(this.options.maxIdleTimeMS && connection.idleTime > this.options.maxIdleTimeMS);
    }
    destroyConnectionIfPerished(connection) {
      const isStale = this.connectionIsStale(connection);
      const isIdle = this.connectionIsIdle(connection);
      if (!isStale && !isIdle && !connection.closed) {
        return false;
      }
      const reason = connection.closed ? "error" : isStale ? "stale" : "idle";
      this.destroyConnection(connection, reason);
      return true;
    }
    createConnection(callback) {
      const connectOptions = {
        ...this.options,
        id: this.connectionCounter.next().value,
        generation: this.generation,
        cancellationToken: this.cancellationToken,
        mongoLogger: this.mongoLogger,
        authProviders: this.server.topology.client.s.authProviders
      };
      this.pending++;
      const connectionCreatedTime = (0, utils_1.now)();
      this.emitAndLog(ConnectionPool.CONNECTION_CREATED, new connection_pool_events_1.ConnectionCreatedEvent(this, { id: connectOptions.id }));
      (0, connect_1.connect)(connectOptions).then((connection) => {
        if (this.poolState !== exports.PoolState.ready) {
          this.pending--;
          connection.destroy();
          callback(this.closed ? new errors_1.PoolClosedError(this) : new errors_1.PoolClearedError(this));
          return;
        }
        for (const event of [...constants_1.APM_EVENTS, connection_1.Connection.CLUSTER_TIME_RECEIVED]) {
          connection.on(event, (e) => this.emit(event, e));
        }
        if (this.loadBalanced) {
          connection.on(connection_1.Connection.PINNED, (pinType) => this.metrics.markPinned(pinType));
          connection.on(connection_1.Connection.UNPINNED, (pinType) => this.metrics.markUnpinned(pinType));
          const serviceId = connection.serviceId;
          if (serviceId) {
            let generation;
            const sid = serviceId.toHexString();
            if (generation = this.serviceGenerations.get(sid)) {
              connection.generation = generation;
            } else {
              this.serviceGenerations.set(sid, 0);
              connection.generation = 0;
            }
          }
        }
        connection.markAvailable();
        this.emitAndLog(ConnectionPool.CONNECTION_READY, new connection_pool_events_1.ConnectionReadyEvent(this, connection, connectionCreatedTime));
        this.pending--;
        callback(undefined, connection);
      }, (error) => {
        this.pending--;
        this.server.handleError(error);
        this.emitAndLog(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, { id: connectOptions.id, serviceId: undefined }, "error", error));
        if (error instanceof error_1.MongoNetworkError || error instanceof error_1.MongoServerError) {
          error.connectionGeneration = connectOptions.generation;
        }
        callback(error ?? new error_1.MongoRuntimeError("Connection creation failed without error"));
      });
    }
    ensureMinPoolSize() {
      const minPoolSize = this.options.minPoolSize;
      if (this.poolState !== exports.PoolState.ready || minPoolSize === 0) {
        return;
      }
      this.connections.prune((connection) => this.destroyConnectionIfPerished(connection));
      if (this.totalConnectionCount < minPoolSize && this.pendingConnectionCount < this.options.maxConnecting) {
        this.createConnection((err, connection) => {
          if (!err && connection) {
            this.connections.push(connection);
            process.nextTick(() => this.processWaitQueue());
          }
          if (this.poolState === exports.PoolState.ready) {
            (0, timers_1.clearTimeout)(this.minPoolSizeTimer);
            this.minPoolSizeTimer = (0, timers_1.setTimeout)(() => this.ensureMinPoolSize(), this.options.minPoolSizeCheckFrequencyMS);
          }
        });
      } else {
        (0, timers_1.clearTimeout)(this.minPoolSizeTimer);
        this.minPoolSizeTimer = (0, timers_1.setTimeout)(() => this.ensureMinPoolSize(), this.options.minPoolSizeCheckFrequencyMS);
      }
    }
    processWaitQueue() {
      if (this.processingWaitQueue) {
        return;
      }
      this.processingWaitQueue = true;
      while (this.waitQueueSize) {
        const waitQueueMember = this.waitQueue.first();
        if (!waitQueueMember) {
          this.waitQueue.shift();
          continue;
        }
        if (waitQueueMember.cancelled) {
          this.waitQueue.shift();
          continue;
        }
        if (this.poolState !== exports.PoolState.ready) {
          const reason = this.closed ? "poolClosed" : "connectionError";
          const error = this.closed ? new errors_1.PoolClosedError(this) : new errors_1.PoolClearedError(this);
          this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, reason, waitQueueMember.checkoutTime, error));
          this.waitQueue.shift();
          waitQueueMember.reject(error);
          continue;
        }
        if (!this.availableConnectionCount) {
          break;
        }
        const connection = this.connections.shift();
        if (!connection) {
          break;
        }
        if (!this.destroyConnectionIfPerished(connection)) {
          this.checkedOut.add(connection);
          this.emitAndLog(ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(this, connection, waitQueueMember.checkoutTime));
          this.waitQueue.shift();
          waitQueueMember.resolve(connection);
        }
      }
      const { maxPoolSize, maxConnecting } = this.options;
      while (this.waitQueueSize > 0 && this.pendingConnectionCount < maxConnecting && (maxPoolSize === 0 || this.totalConnectionCount < maxPoolSize)) {
        const waitQueueMember = this.waitQueue.shift();
        if (!waitQueueMember || waitQueueMember.cancelled) {
          continue;
        }
        this.createConnection((err, connection) => {
          if (waitQueueMember.cancelled) {
            if (!err && connection) {
              this.connections.push(connection);
            }
          } else {
            if (err) {
              this.emitAndLog(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, "connectionError", waitQueueMember.checkoutTime, err));
              waitQueueMember.reject(err);
            } else if (connection) {
              this.checkedOut.add(connection);
              this.emitAndLog(ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(this, connection, waitQueueMember.checkoutTime));
              waitQueueMember.resolve(connection);
            }
          }
          process.nextTick(() => this.processWaitQueue());
        });
      }
      this.processingWaitQueue = false;
    }
  }
  exports.ConnectionPool = ConnectionPool;
  ConnectionPool.CONNECTION_POOL_CREATED = constants_1.CONNECTION_POOL_CREATED;
  ConnectionPool.CONNECTION_POOL_CLOSED = constants_1.CONNECTION_POOL_CLOSED;
  ConnectionPool.CONNECTION_POOL_CLEARED = constants_1.CONNECTION_POOL_CLEARED;
  ConnectionPool.CONNECTION_POOL_READY = constants_1.CONNECTION_POOL_READY;
  ConnectionPool.CONNECTION_CREATED = constants_1.CONNECTION_CREATED;
  ConnectionPool.CONNECTION_READY = constants_1.CONNECTION_READY;
  ConnectionPool.CONNECTION_CLOSED = constants_1.CONNECTION_CLOSED;
  ConnectionPool.CONNECTION_CHECK_OUT_STARTED = constants_1.CONNECTION_CHECK_OUT_STARTED;
  ConnectionPool.CONNECTION_CHECK_OUT_FAILED = constants_1.CONNECTION_CHECK_OUT_FAILED;
  ConnectionPool.CONNECTION_CHECKED_OUT = constants_1.CONNECTION_CHECKED_OUT;
  ConnectionPool.CONNECTION_CHECKED_IN = constants_1.CONNECTION_CHECKED_IN;
});

// node_modules/mongodb/lib/sdam/server.js
var require_server = __commonJS((exports) => {
  function markServerUnknown(server, error) {
    if (server.loadBalanced) {
      return;
    }
    if (error instanceof error_1.MongoNetworkError && !(error instanceof error_1.MongoNetworkTimeoutError)) {
      server.monitor?.reset();
    }
    server.emit(Server.DESCRIPTION_RECEIVED, new server_description_1.ServerDescription(server.description.hostAddress, undefined, { error }));
  }
  function isPinnableCommand(cmd, session) {
    if (session) {
      return session.inTransaction() || session.transaction.isCommitted && "commitTransaction" in cmd || "aggregate" in cmd || "find" in cmd || "getMore" in cmd || "listCollections" in cmd || "listIndexes" in cmd || "bulkWrite" in cmd;
    }
    return false;
  }
  function connectionIsStale(pool, connection) {
    if (connection.serviceId) {
      return connection.generation !== pool.serviceGenerations.get(connection.serviceId.toHexString());
    }
    return connection.generation !== pool.generation;
  }
  function shouldHandleStateChangeError(server, err) {
    const etv = err.topologyVersion;
    const stv = server.description.topologyVersion;
    return (0, server_description_1.compareTopologyVersion)(stv, etv) < 0;
  }
  function inActiveTransaction(session, cmd) {
    return session && session.inTransaction() && !(0, transactions_1.isTransactionCommand)(cmd);
  }
  function isRetryableWritesEnabled(topology) {
    return topology.s.options.retryWrites !== false;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Server = undefined;
  var connection_1 = require_connection();
  var connection_pool_1 = require_connection_pool();
  var errors_1 = require_errors2();
  var constants_1 = require_constants2();
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var transactions_1 = require_transactions();
  var utils_1 = require_utils2();
  var write_concern_1 = require_write_concern();
  var common_1 = require_common();
  var monitor_1 = require_monitor();
  var server_description_1 = require_server_description();
  var stateTransition = (0, utils_1.makeStateMachine)({
    [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, common_1.STATE_CONNECTING],
    [common_1.STATE_CONNECTING]: [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED],
    [common_1.STATE_CONNECTED]: [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED],
    [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, common_1.STATE_CLOSED]
  });

  class Server extends mongo_types_1.TypedEventEmitter {
    constructor(topology, description, options) {
      super();
      this.serverApi = options.serverApi;
      const poolOptions = { hostAddress: description.hostAddress, ...options };
      this.topology = topology;
      this.pool = new connection_pool_1.ConnectionPool(this, poolOptions);
      this.s = {
        description,
        options,
        state: common_1.STATE_CLOSED,
        operationCount: 0
      };
      for (const event of [...constants_1.CMAP_EVENTS, ...constants_1.APM_EVENTS]) {
        this.pool.on(event, (e) => this.emit(event, e));
      }
      this.pool.on(connection_1.Connection.CLUSTER_TIME_RECEIVED, (clusterTime) => {
        this.clusterTime = clusterTime;
      });
      if (this.loadBalanced) {
        this.monitor = null;
        return;
      }
      this.monitor = new monitor_1.Monitor(this, this.s.options);
      for (const event of constants_1.HEARTBEAT_EVENTS) {
        this.monitor.on(event, (e) => this.emit(event, e));
      }
      this.monitor.on("resetServer", (error) => markServerUnknown(this, error));
      this.monitor.on(Server.SERVER_HEARTBEAT_SUCCEEDED, (event) => {
        this.emit(Server.DESCRIPTION_RECEIVED, new server_description_1.ServerDescription(this.description.hostAddress, event.reply, {
          roundTripTime: this.monitor?.roundTripTime,
          minRoundTripTime: this.monitor?.minRoundTripTime
        }));
        if (this.s.state === common_1.STATE_CONNECTING) {
          stateTransition(this, common_1.STATE_CONNECTED);
          this.emit(Server.CONNECT, this);
        }
      });
    }
    get clusterTime() {
      return this.topology.clusterTime;
    }
    set clusterTime(clusterTime) {
      this.topology.clusterTime = clusterTime;
    }
    get description() {
      return this.s.description;
    }
    get name() {
      return this.s.description.address;
    }
    get autoEncrypter() {
      if (this.s.options && this.s.options.autoEncrypter) {
        return this.s.options.autoEncrypter;
      }
      return;
    }
    get loadBalanced() {
      return this.topology.description.type === common_1.TopologyType.LoadBalanced;
    }
    connect() {
      if (this.s.state !== common_1.STATE_CLOSED) {
        return;
      }
      stateTransition(this, common_1.STATE_CONNECTING);
      if (!this.loadBalanced) {
        this.monitor?.connect();
      } else {
        stateTransition(this, common_1.STATE_CONNECTED);
        this.emit(Server.CONNECT, this);
      }
    }
    destroy() {
      if (this.s.state === common_1.STATE_CLOSED) {
        return;
      }
      stateTransition(this, common_1.STATE_CLOSING);
      if (!this.loadBalanced) {
        this.monitor?.close();
      }
      this.pool.close();
      stateTransition(this, common_1.STATE_CLOSED);
      this.emit("closed");
    }
    requestCheck() {
      if (!this.loadBalanced) {
        this.monitor?.requestCheck();
      }
    }
    async command(ns, cmd, { ...options }, responseType) {
      if (ns.db == null || typeof ns === "string") {
        throw new error_1.MongoInvalidArgumentError("Namespace must not be a string");
      }
      if (this.s.state === common_1.STATE_CLOSING || this.s.state === common_1.STATE_CLOSED) {
        throw new error_1.MongoServerClosedError;
      }
      options.directConnection = this.topology.s.options.directConnection;
      if (options.omitReadPreference) {
        delete options.readPreference;
      }
      if (this.description.iscryptd) {
        options.omitMaxTimeMS = true;
      }
      const session = options.session;
      let conn = session?.pinnedConnection;
      this.incrementOperationCount();
      if (conn == null) {
        try {
          conn = await this.pool.checkOut(options);
          if (this.loadBalanced && isPinnableCommand(cmd, session)) {
            session?.pin(conn);
          }
        } catch (checkoutError) {
          this.decrementOperationCount();
          if (!(checkoutError instanceof errors_1.PoolClearedError))
            this.handleError(checkoutError);
          throw checkoutError;
        }
      }
      let reauthPromise = null;
      try {
        try {
          const res = await conn.command(ns, cmd, options, responseType);
          (0, write_concern_1.throwIfWriteConcernError)(res);
          return res;
        } catch (commandError) {
          throw this.decorateCommandError(conn, cmd, options, commandError);
        }
      } catch (operationError) {
        if (operationError instanceof error_1.MongoError && operationError.code === error_1.MONGODB_ERROR_CODES.Reauthenticate) {
          reauthPromise = this.pool.reauthenticate(conn).catch((error) => {
            reauthPromise = null;
            throw error;
          });
          await (0, utils_1.abortable)(reauthPromise, options);
          reauthPromise = null;
          try {
            const res = await conn.command(ns, cmd, options, responseType);
            (0, write_concern_1.throwIfWriteConcernError)(res);
            return res;
          } catch (commandError) {
            throw this.decorateCommandError(conn, cmd, options, commandError);
          }
        } else {
          throw operationError;
        }
      } finally {
        this.decrementOperationCount();
        if (session?.pinnedConnection !== conn) {
          if (reauthPromise != null) {
            reauthPromise.finally(() => {
              this.pool.checkIn(conn);
            });
          } else {
            this.pool.checkIn(conn);
          }
        }
      }
    }
    handleError(error, connection) {
      if (!(error instanceof error_1.MongoError)) {
        return;
      }
      const isStaleError = error.connectionGeneration && error.connectionGeneration < this.pool.generation;
      if (isStaleError) {
        return;
      }
      const isNetworkNonTimeoutError = error instanceof error_1.MongoNetworkError && !(error instanceof error_1.MongoNetworkTimeoutError);
      const isNetworkTimeoutBeforeHandshakeError = error instanceof error_1.MongoNetworkError && error.beforeHandshake;
      const isAuthHandshakeError = error.hasErrorLabel(error_1.MongoErrorLabel.HandshakeError);
      if (isNetworkNonTimeoutError || isNetworkTimeoutBeforeHandshakeError || isAuthHandshakeError) {
        if (!this.loadBalanced) {
          error.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
          markServerUnknown(this, error);
        } else if (connection) {
          this.pool.clear({ serviceId: connection.serviceId });
        }
      } else {
        if ((0, error_1.isSDAMUnrecoverableError)(error)) {
          if (shouldHandleStateChangeError(this, error)) {
            const shouldClearPool = (0, utils_1.maxWireVersion)(this) <= 7 || (0, error_1.isNodeShuttingDownError)(error);
            if (this.loadBalanced && connection && shouldClearPool) {
              this.pool.clear({ serviceId: connection.serviceId });
            }
            if (!this.loadBalanced) {
              if (shouldClearPool) {
                error.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
              }
              markServerUnknown(this, error);
              process.nextTick(() => this.requestCheck());
            }
          }
        }
      }
    }
    decorateCommandError(connection, cmd, options, error) {
      if (typeof error !== "object" || error == null || !("name" in error)) {
        throw new error_1.MongoRuntimeError("An unexpected error type: " + typeof error);
      }
      if (error.name === "AbortError" && "cause" in error && error.cause instanceof error_1.MongoError) {
        error = error.cause;
      }
      if (!(error instanceof error_1.MongoError)) {
        return error;
      }
      if (connectionIsStale(this.pool, connection)) {
        return error;
      }
      const session = options?.session;
      if (error instanceof error_1.MongoNetworkError) {
        if (session && !session.hasEnded && session.serverSession) {
          session.serverSession.isDirty = true;
        }
        if (inActiveTransaction(session, cmd) && !error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
          error.addErrorLabel(error_1.MongoErrorLabel.TransientTransactionError);
        }
        if ((isRetryableWritesEnabled(this.topology) || (0, transactions_1.isTransactionCommand)(cmd)) && (0, utils_1.supportsRetryableWrites)(this) && !inActiveTransaction(session, cmd)) {
          error.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
        }
      } else {
        if ((isRetryableWritesEnabled(this.topology) || (0, transactions_1.isTransactionCommand)(cmd)) && (0, error_1.needsRetryableWriteLabel)(error, (0, utils_1.maxWireVersion)(this), this.description.type) && !inActiveTransaction(session, cmd)) {
          error.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);
        }
      }
      if (session && session.isPinned && error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
        session.unpin({ force: true });
      }
      this.handleError(error, connection);
      return error;
    }
    decrementOperationCount() {
      return this.s.operationCount -= 1;
    }
    incrementOperationCount() {
      return this.s.operationCount += 1;
    }
  }
  exports.Server = Server;
  Server.SERVER_HEARTBEAT_STARTED = constants_1.SERVER_HEARTBEAT_STARTED;
  Server.SERVER_HEARTBEAT_SUCCEEDED = constants_1.SERVER_HEARTBEAT_SUCCEEDED;
  Server.SERVER_HEARTBEAT_FAILED = constants_1.SERVER_HEARTBEAT_FAILED;
  Server.CONNECT = constants_1.CONNECT;
  Server.DESCRIPTION_RECEIVED = constants_1.DESCRIPTION_RECEIVED;
  Server.CLOSED = constants_1.CLOSED;
  Server.ENDED = constants_1.ENDED;
});

// node_modules/mongodb/lib/sdam/monitor.js
var require_monitor = __commonJS((exports) => {
  function isInCloseState(monitor) {
    return monitor.s.state === common_1.STATE_CLOSED || monitor.s.state === common_1.STATE_CLOSING;
  }
  function resetMonitorState(monitor) {
    monitor.monitorId?.stop();
    monitor.monitorId = undefined;
    monitor.rttPinger?.close();
    monitor.rttPinger = undefined;
    monitor.cancellationToken.emit("cancel");
    monitor.connection?.destroy();
    monitor.connection = null;
    monitor.clearRttSamples();
  }
  function useStreamingProtocol(monitor, topologyVersion) {
    if (topologyVersion == null)
      return false;
    const serverMonitoringMode = monitor.options.serverMonitoringMode;
    if (serverMonitoringMode === exports.ServerMonitoringMode.poll)
      return false;
    if (serverMonitoringMode === exports.ServerMonitoringMode.stream)
      return true;
    if (monitor.isRunningInFaasEnv)
      return false;
    return true;
  }
  function checkServer(monitor, callback) {
    let start;
    let awaited;
    const topologyVersion = monitor.server.description.topologyVersion;
    const isAwaitable = useStreamingProtocol(monitor, topologyVersion);
    monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_STARTED, monitor.server.topology.s.id, undefined, new events_1.ServerHeartbeatStartedEvent(monitor.address, isAwaitable));
    function onHeartbeatFailed(err) {
      monitor.connection?.destroy();
      monitor.connection = null;
      monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_FAILED, monitor.server.topology.s.id, undefined, new events_1.ServerHeartbeatFailedEvent(monitor.address, (0, utils_1.calculateDurationInMs)(start), err, awaited));
      const error = !(err instanceof error_1.MongoError) ? new error_1.MongoError(error_1.MongoError.buildErrorMessage(err), { cause: err }) : err;
      error.addErrorLabel(error_1.MongoErrorLabel.ResetPool);
      if (error instanceof error_1.MongoNetworkTimeoutError) {
        error.addErrorLabel(error_1.MongoErrorLabel.InterruptInUseConnections);
      }
      monitor.emit("resetServer", error);
      callback(err);
    }
    function onHeartbeatSucceeded(hello) {
      if (!("isWritablePrimary" in hello)) {
        hello.isWritablePrimary = hello[constants_1.LEGACY_HELLO_COMMAND];
      }
      const duration = isAwaitable && monitor.rttPinger ? monitor.rttPinger.latestRtt ?? (0, utils_1.calculateDurationInMs)(start) : (0, utils_1.calculateDurationInMs)(start);
      monitor.addRttSample(duration);
      monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, monitor.server.topology.s.id, hello.connectionId, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, hello, isAwaitable));
      if (isAwaitable) {
        monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_STARTED, monitor.server.topology.s.id, undefined, new events_1.ServerHeartbeatStartedEvent(monitor.address, true));
        start = (0, utils_1.now)();
      } else {
        monitor.rttPinger?.close();
        monitor.rttPinger = undefined;
        callback(undefined, hello);
      }
    }
    const { connection } = monitor;
    if (connection && !connection.closed) {
      const { serverApi, helloOk } = connection;
      const connectTimeoutMS = monitor.options.connectTimeoutMS;
      const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;
      const cmd = {
        [serverApi?.version || helloOk ? "hello" : constants_1.LEGACY_HELLO_COMMAND]: 1,
        ...isAwaitable && topologyVersion ? { maxAwaitTimeMS, topologyVersion: makeTopologyVersion(topologyVersion) } : {}
      };
      const options = isAwaitable ? {
        socketTimeoutMS: connectTimeoutMS ? connectTimeoutMS + maxAwaitTimeMS : 0,
        exhaustAllowed: true
      } : { socketTimeoutMS: connectTimeoutMS };
      if (isAwaitable && monitor.rttPinger == null) {
        monitor.rttPinger = new RTTPinger(monitor);
      }
      start = (0, utils_1.now)();
      if (isAwaitable) {
        awaited = true;
        return connection.exhaustCommand((0, utils_1.ns)("admin.$cmd"), cmd, options, (error, hello) => {
          if (error)
            return onHeartbeatFailed(error);
          return onHeartbeatSucceeded(hello);
        });
      }
      awaited = false;
      connection.command((0, utils_1.ns)("admin.$cmd"), cmd, options).then(onHeartbeatSucceeded, onHeartbeatFailed);
      return;
    }
    (async () => {
      const socket = await (0, connect_1.makeSocket)(monitor.connectOptions);
      const connection2 = (0, connect_1.makeConnection)(monitor.connectOptions, socket);
      start = (0, utils_1.now)();
      try {
        await (0, connect_1.performInitialHandshake)(connection2, monitor.connectOptions);
        return connection2;
      } catch (error) {
        connection2.destroy();
        throw error;
      }
    })().then((connection2) => {
      if (isInCloseState(monitor)) {
        connection2.destroy();
        return;
      }
      const duration = (0, utils_1.calculateDurationInMs)(start);
      monitor.addRttSample(duration);
      monitor.connection = connection2;
      monitor.emitAndLogHeartbeat(server_1.Server.SERVER_HEARTBEAT_SUCCEEDED, monitor.server.topology.s.id, connection2.hello?.connectionId, new events_1.ServerHeartbeatSucceededEvent(monitor.address, duration, connection2.hello, useStreamingProtocol(monitor, connection2.hello?.topologyVersion)));
      callback(undefined, connection2.hello);
    }, (error) => {
      monitor.connection = null;
      awaited = false;
      onHeartbeatFailed(error);
    });
  }
  function monitorServer(monitor) {
    return (callback) => {
      if (monitor.s.state === STATE_MONITORING) {
        process.nextTick(callback);
        return;
      }
      stateTransition(monitor, STATE_MONITORING);
      function done() {
        if (!isInCloseState(monitor)) {
          stateTransition(monitor, STATE_IDLE);
        }
        callback();
      }
      checkServer(monitor, (err, hello) => {
        if (err) {
          if (monitor.server.description.type === common_1.ServerType.Unknown) {
            return done();
          }
        }
        if (useStreamingProtocol(monitor, hello?.topologyVersion)) {
          (0, timers_1.setTimeout)(() => {
            if (!isInCloseState(monitor)) {
              monitor.monitorId?.wake();
            }
          }, 0);
        }
        done();
      });
    };
  }
  function makeTopologyVersion(tv) {
    return {
      processId: tv.processId,
      counter: bson_1.Long.isLong(tv.counter) ? tv.counter : bson_1.Long.fromNumber(tv.counter)
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RTTSampler = exports.MonitorInterval = exports.RTTPinger = exports.Monitor = exports.ServerMonitoringMode = undefined;
  var timers_1 = import.meta.require("timers");
  var bson_1 = require_bson2();
  var connect_1 = require_connect();
  var client_metadata_1 = require_client_metadata();
  var constants_1 = require_constants2();
  var error_1 = require_error();
  var mongo_logger_1 = require_mongo_logger();
  var mongo_types_1 = require_mongo_types();
  var utils_1 = require_utils2();
  var common_1 = require_common();
  var events_1 = require_events();
  var server_1 = require_server();
  var STATE_IDLE = "idle";
  var STATE_MONITORING = "monitoring";
  var stateTransition = (0, utils_1.makeStateMachine)({
    [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, STATE_IDLE, common_1.STATE_CLOSED],
    [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, STATE_MONITORING],
    [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, common_1.STATE_CLOSING],
    [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, common_1.STATE_CLOSING]
  });
  var INVALID_REQUEST_CHECK_STATES = new Set([common_1.STATE_CLOSING, common_1.STATE_CLOSED, STATE_MONITORING]);
  exports.ServerMonitoringMode = Object.freeze({
    auto: "auto",
    poll: "poll",
    stream: "stream"
  });

  class Monitor extends mongo_types_1.TypedEventEmitter {
    constructor(server, options) {
      super();
      this.component = mongo_logger_1.MongoLoggableComponent.TOPOLOGY;
      this.server = server;
      this.connection = null;
      this.cancellationToken = new mongo_types_1.CancellationToken;
      this.cancellationToken.setMaxListeners(Infinity);
      this.monitorId = undefined;
      this.s = {
        state: common_1.STATE_CLOSED
      };
      this.address = server.description.address;
      this.options = Object.freeze({
        connectTimeoutMS: options.connectTimeoutMS ?? 1e4,
        heartbeatFrequencyMS: options.heartbeatFrequencyMS ?? 1e4,
        minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS ?? 500,
        serverMonitoringMode: options.serverMonitoringMode
      });
      this.isRunningInFaasEnv = (0, client_metadata_1.getFAASEnv)() != null;
      this.mongoLogger = this.server.topology.client?.mongoLogger;
      this.rttSampler = new RTTSampler(10);
      const cancellationToken = this.cancellationToken;
      const connectOptions = {
        id: "<monitor>",
        generation: server.pool.generation,
        cancellationToken,
        hostAddress: server.description.hostAddress,
        ...options,
        raw: false,
        useBigInt64: false,
        promoteLongs: true,
        promoteValues: true,
        promoteBuffers: true
      };
      delete connectOptions.credentials;
      if (connectOptions.autoEncrypter) {
        delete connectOptions.autoEncrypter;
      }
      this.connectOptions = Object.freeze(connectOptions);
    }
    connect() {
      if (this.s.state !== common_1.STATE_CLOSED) {
        return;
      }
      const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
      const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
      this.monitorId = new MonitorInterval(monitorServer(this), {
        heartbeatFrequencyMS,
        minHeartbeatFrequencyMS,
        immediate: true
      });
    }
    requestCheck() {
      if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {
        return;
      }
      this.monitorId?.wake();
    }
    reset() {
      const topologyVersion = this.server.description.topologyVersion;
      if (isInCloseState(this) || topologyVersion == null) {
        return;
      }
      stateTransition(this, common_1.STATE_CLOSING);
      resetMonitorState(this);
      stateTransition(this, STATE_IDLE);
      const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;
      const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;
      this.monitorId = new MonitorInterval(monitorServer(this), {
        heartbeatFrequencyMS,
        minHeartbeatFrequencyMS
      });
    }
    close() {
      if (isInCloseState(this)) {
        return;
      }
      stateTransition(this, common_1.STATE_CLOSING);
      resetMonitorState(this);
      this.emit("close");
      stateTransition(this, common_1.STATE_CLOSED);
    }
    get roundTripTime() {
      return this.rttSampler.average();
    }
    get minRoundTripTime() {
      return this.rttSampler.min();
    }
    get latestRtt() {
      return this.rttSampler.last;
    }
    addRttSample(rtt) {
      this.rttSampler.addSample(rtt);
    }
    clearRttSamples() {
      this.rttSampler.clear();
    }
  }
  exports.Monitor = Monitor;

  class RTTPinger {
    constructor(monitor) {
      this.connection = undefined;
      this.cancellationToken = monitor.cancellationToken;
      this.closed = false;
      this.monitor = monitor;
      this.latestRtt = monitor.latestRtt ?? undefined;
      const heartbeatFrequencyMS = monitor.options.heartbeatFrequencyMS;
      this.monitorId = (0, timers_1.setTimeout)(() => this.measureRoundTripTime(), heartbeatFrequencyMS);
    }
    get roundTripTime() {
      return this.monitor.roundTripTime;
    }
    get minRoundTripTime() {
      return this.monitor.minRoundTripTime;
    }
    close() {
      this.closed = true;
      (0, timers_1.clearTimeout)(this.monitorId);
      this.connection?.destroy();
      this.connection = undefined;
    }
    measureAndReschedule(start, conn) {
      if (this.closed) {
        conn?.destroy();
        return;
      }
      if (this.connection == null) {
        this.connection = conn;
      }
      this.latestRtt = (0, utils_1.calculateDurationInMs)(start);
      this.monitorId = (0, timers_1.setTimeout)(() => this.measureRoundTripTime(), this.monitor.options.heartbeatFrequencyMS);
    }
    measureRoundTripTime() {
      const start = (0, utils_1.now)();
      if (this.closed) {
        return;
      }
      const connection = this.connection;
      if (connection == null) {
        (0, connect_1.connect)(this.monitor.connectOptions).then((connection2) => {
          this.measureAndReschedule(start, connection2);
        }, () => {
          this.connection = undefined;
        });
        return;
      }
      const commandName = connection.serverApi?.version || connection.helloOk ? "hello" : constants_1.LEGACY_HELLO_COMMAND;
      connection.command((0, utils_1.ns)("admin.$cmd"), { [commandName]: 1 }, undefined).then(() => this.measureAndReschedule(start), () => {
        this.connection?.destroy();
        this.connection = undefined;
        return;
      });
    }
  }
  exports.RTTPinger = RTTPinger;

  class MonitorInterval {
    constructor(fn, options = {}) {
      this.isExpeditedCallToFnScheduled = false;
      this.stopped = false;
      this.isExecutionInProgress = false;
      this.hasExecutedOnce = false;
      this._executeAndReschedule = () => {
        if (this.stopped)
          return;
        if (this.timerId) {
          (0, timers_1.clearTimeout)(this.timerId);
        }
        this.isExpeditedCallToFnScheduled = false;
        this.isExecutionInProgress = true;
        this.fn(() => {
          this.lastExecutionEnded = (0, utils_1.now)();
          this.isExecutionInProgress = false;
          this._reschedule(this.heartbeatFrequencyMS);
        });
      };
      this.fn = fn;
      this.lastExecutionEnded = -Infinity;
      this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 1000;
      this.minHeartbeatFrequencyMS = options.minHeartbeatFrequencyMS ?? 500;
      if (options.immediate) {
        this._executeAndReschedule();
      } else {
        this._reschedule(undefined);
      }
    }
    wake() {
      const currentTime = (0, utils_1.now)();
      const timeSinceLastCall = currentTime - this.lastExecutionEnded;
      if (timeSinceLastCall < 0) {
        return this._executeAndReschedule();
      }
      if (this.isExecutionInProgress) {
        return;
      }
      if (this.isExpeditedCallToFnScheduled) {
        return;
      }
      if (timeSinceLastCall < this.minHeartbeatFrequencyMS) {
        this.isExpeditedCallToFnScheduled = true;
        this._reschedule(this.minHeartbeatFrequencyMS - timeSinceLastCall);
        return;
      }
      this._executeAndReschedule();
    }
    stop() {
      this.stopped = true;
      if (this.timerId) {
        (0, timers_1.clearTimeout)(this.timerId);
        this.timerId = undefined;
      }
      this.lastExecutionEnded = -Infinity;
      this.isExpeditedCallToFnScheduled = false;
    }
    toString() {
      return JSON.stringify(this);
    }
    toJSON() {
      const currentTime = (0, utils_1.now)();
      const timeSinceLastCall = currentTime - this.lastExecutionEnded;
      return {
        timerId: this.timerId != null ? "set" : "cleared",
        lastCallTime: this.lastExecutionEnded,
        isExpeditedCheckScheduled: this.isExpeditedCallToFnScheduled,
        stopped: this.stopped,
        heartbeatFrequencyMS: this.heartbeatFrequencyMS,
        minHeartbeatFrequencyMS: this.minHeartbeatFrequencyMS,
        currentTime,
        timeSinceLastCall
      };
    }
    _reschedule(ms) {
      if (this.stopped)
        return;
      if (this.timerId) {
        (0, timers_1.clearTimeout)(this.timerId);
      }
      this.timerId = (0, timers_1.setTimeout)(this._executeAndReschedule, ms || this.heartbeatFrequencyMS);
    }
  }
  exports.MonitorInterval = MonitorInterval;

  class RTTSampler {
    constructor(windowSize = 10) {
      this.rttSamples = new Float64Array(windowSize);
      this.length = 0;
      this.writeIndex = 0;
    }
    addSample(sample) {
      this.rttSamples[this.writeIndex++] = sample;
      if (this.length < this.rttSamples.length) {
        this.length++;
      }
      this.writeIndex %= this.rttSamples.length;
    }
    min() {
      if (this.length < 2)
        return 0;
      let min = this.rttSamples[0];
      for (let i = 1;i < this.length; i++) {
        if (this.rttSamples[i] < min)
          min = this.rttSamples[i];
      }
      return min;
    }
    average() {
      if (this.length === 0)
        return 0;
      let sum = 0;
      for (let i = 0;i < this.length; i++) {
        sum += this.rttSamples[i];
      }
      return sum / this.length;
    }
    get last() {
      if (this.length === 0)
        return null;
      return this.rttSamples[this.writeIndex === 0 ? this.length - 1 : this.writeIndex - 1];
    }
    clear() {
      this.length = 0;
      this.writeIndex = 0;
    }
  }
  exports.RTTSampler = RTTSampler;
});

// node_modules/mongodb/lib/connection_string.js
var require_connection_string = __commonJS((exports) => {
  function retryDNSTimeoutFor(api) {
    return async function dnsReqRetryTimeout(lookupAddress) {
      try {
        return await dns.promises[api](lookupAddress);
      } catch (firstDNSError) {
        if (firstDNSError.code === dns.TIMEOUT) {
          return await dns.promises[api](lookupAddress);
        } else {
          throw firstDNSError;
        }
      }
    };
  }
  async function resolveSRVRecord(options) {
    if (typeof options.srvHost !== "string") {
      throw new error_1.MongoAPIError('Option "srvHost" must not be empty');
    }
    const lookupAddress = options.srvHost;
    const txtResolutionPromise = resolveTxt(lookupAddress);
    txtResolutionPromise.then(undefined, utils_1.squashError);
    const hostname = `_${options.srvServiceName}._tcp.${lookupAddress}`;
    const addresses = await resolveSrv(hostname);
    if (addresses.length === 0) {
      throw new error_1.MongoAPIError("No addresses found at host");
    }
    for (const { name } of addresses) {
      (0, utils_1.checkParentDomainMatch)(name, lookupAddress);
    }
    const hostAddresses = addresses.map((r) => utils_1.HostAddress.fromString(`${r.name}:${r.port ?? 27017}`));
    validateLoadBalancedOptions(hostAddresses, options, true);
    let record;
    try {
      record = await txtResolutionPromise;
    } catch (error) {
      if (error.code !== "ENODATA" && error.code !== "ENOTFOUND") {
        throw error;
      }
      return hostAddresses;
    }
    if (record.length > 1) {
      throw new error_1.MongoParseError("Multiple text records not allowed");
    }
    const txtRecordOptions = new url_1.URLSearchParams(record[0].join(""));
    const txtRecordOptionKeys = [...txtRecordOptions.keys()];
    if (txtRecordOptionKeys.some((key) => !VALID_TXT_RECORDS.includes(key))) {
      throw new error_1.MongoParseError(`Text record may only set any of: ${VALID_TXT_RECORDS.join(", ")}`);
    }
    if (VALID_TXT_RECORDS.some((option) => txtRecordOptions.get(option) === "")) {
      throw new error_1.MongoParseError("Cannot have empty URI params in DNS TXT Record");
    }
    const source = txtRecordOptions.get("authSource") ?? undefined;
    const replicaSet = txtRecordOptions.get("replicaSet") ?? undefined;
    const loadBalanced = txtRecordOptions.get("loadBalanced") ?? undefined;
    if (!options.userSpecifiedAuthSource && source && options.credentials && !providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(options.credentials.mechanism)) {
      options.credentials = mongo_credentials_1.MongoCredentials.merge(options.credentials, { source });
    }
    if (!options.userSpecifiedReplicaSet && replicaSet) {
      options.replicaSet = replicaSet;
    }
    if (loadBalanced === "true") {
      options.loadBalanced = true;
    }
    if (options.replicaSet && options.srvMaxHosts > 0) {
      throw new error_1.MongoParseError("Cannot combine replicaSet option with srvMaxHosts");
    }
    validateLoadBalancedOptions(hostAddresses, options, true);
    return hostAddresses;
  }
  function checkTLSOptions(allOptions) {
    if (!allOptions)
      return;
    const check = (a, b) => {
      if (allOptions.has(a) && allOptions.has(b)) {
        throw new error_1.MongoAPIError(`The '${a}' option cannot be used with the '${b}' option`);
      }
    };
    check("tlsInsecure", "tlsAllowInvalidCertificates");
    check("tlsInsecure", "tlsAllowInvalidHostnames");
    check("tlsInsecure", "tlsDisableCertificateRevocationCheck");
    check("tlsInsecure", "tlsDisableOCSPEndpointCheck");
    check("tlsAllowInvalidCertificates", "tlsDisableCertificateRevocationCheck");
    check("tlsAllowInvalidCertificates", "tlsDisableOCSPEndpointCheck");
    check("tlsDisableCertificateRevocationCheck", "tlsDisableOCSPEndpointCheck");
  }
  function getBoolean(name, value) {
    if (typeof value === "boolean")
      return value;
    switch (value) {
      case "true":
        return true;
      case "false":
        return false;
      default:
        throw new error_1.MongoParseError(`${name} must be either "true" or "false"`);
    }
  }
  function getIntFromOptions(name, value) {
    const parsedInt = (0, utils_1.parseInteger)(value);
    if (parsedInt != null) {
      return parsedInt;
    }
    throw new error_1.MongoParseError(`Expected ${name} to be stringified int value, got: ${value}`);
  }
  function getUIntFromOptions(name, value) {
    const parsedValue = getIntFromOptions(name, value);
    if (parsedValue < 0) {
      throw new error_1.MongoParseError(`${name} can only be a positive int value, got: ${value}`);
    }
    return parsedValue;
  }
  function* entriesFromString(value) {
    if (value === "") {
      return;
    }
    const keyValuePairs = value.split(",");
    for (const keyValue of keyValuePairs) {
      const [key, value2] = keyValue.split(/:(.*)/);
      if (value2 == null) {
        throw new error_1.MongoParseError("Cannot have undefined values in key value pairs");
      }
      yield [key, value2];
    }
  }
  function parseOptions(uri, mongoClient = undefined, options = {}) {
    if (mongoClient != null && !(mongoClient instanceof mongo_client_1.MongoClient)) {
      options = mongoClient;
      mongoClient = undefined;
    }
    if (options.useBigInt64 && typeof options.promoteLongs === "boolean" && !options.promoteLongs) {
      throw new error_1.MongoAPIError("Must request either bigint or Long for int64 deserialization");
    }
    if (options.useBigInt64 && typeof options.promoteValues === "boolean" && !options.promoteValues) {
      throw new error_1.MongoAPIError("Must request either bigint or Long for int64 deserialization");
    }
    const url = new mongodb_connection_string_url_1.default(uri);
    const { hosts, isSRV } = url;
    const mongoOptions = Object.create(null);
    mongoOptions.hosts = isSRV ? [] : hosts.map(utils_1.HostAddress.fromString);
    const urlOptions = new CaseInsensitiveMap;
    if (url.pathname !== "/" && url.pathname !== "") {
      const dbName = decodeURIComponent(url.pathname[0] === "/" ? url.pathname.slice(1) : url.pathname);
      if (dbName) {
        urlOptions.set("dbName", [dbName]);
      }
    }
    if (url.username !== "") {
      const auth = {
        username: decodeURIComponent(url.username)
      };
      if (typeof url.password === "string") {
        auth.password = decodeURIComponent(url.password);
      }
      urlOptions.set("auth", [auth]);
    }
    for (const key of url.searchParams.keys()) {
      const values = url.searchParams.getAll(key);
      const isReadPreferenceTags = /readPreferenceTags/i.test(key);
      if (!isReadPreferenceTags && values.length > 1) {
        throw new error_1.MongoInvalidArgumentError(`URI option "${key}" cannot appear more than once in the connection string`);
      }
      if (!isReadPreferenceTags && values.includes("")) {
        throw new error_1.MongoAPIError(`URI option "${key}" cannot be specified with no value`);
      }
      if (!urlOptions.has(key)) {
        urlOptions.set(key, values);
      }
    }
    const objectOptions = new CaseInsensitiveMap(Object.entries(options).filter(([, v]) => v != null));
    if (urlOptions.has("serverApi")) {
      throw new error_1.MongoParseError("URI cannot contain `serverApi`, it can only be passed to the client");
    }
    const uriMechanismProperties = urlOptions.get("authMechanismProperties");
    if (uriMechanismProperties) {
      for (const property of uriMechanismProperties) {
        if (/(^|,)ALLOWED_HOSTS:/.test(property)) {
          throw new error_1.MongoParseError("Auth mechanism property ALLOWED_HOSTS is not allowed in the connection string.");
        }
      }
    }
    if (objectOptions.has("loadBalanced")) {
      throw new error_1.MongoParseError("loadBalanced is only a valid option in the URI");
    }
    const allProvidedOptions = new CaseInsensitiveMap;
    const allProvidedKeys = new Set([...urlOptions.keys(), ...objectOptions.keys()]);
    for (const key of allProvidedKeys) {
      const values = [];
      const objectOptionValue = objectOptions.get(key);
      if (objectOptionValue != null) {
        values.push(objectOptionValue);
      }
      const urlValues = urlOptions.get(key) ?? [];
      values.push(...urlValues);
      allProvidedOptions.set(key, values);
    }
    if (allProvidedOptions.has("tls") || allProvidedOptions.has("ssl")) {
      const tlsAndSslOpts = (allProvidedOptions.get("tls") || []).concat(allProvidedOptions.get("ssl") || []).map(getBoolean.bind(null, "tls/ssl"));
      if (new Set(tlsAndSslOpts).size !== 1) {
        throw new error_1.MongoParseError("All values of tls/ssl must be the same.");
      }
    }
    checkTLSOptions(allProvidedOptions);
    const unsupportedOptions = (0, utils_1.setDifference)(allProvidedKeys, Array.from(Object.keys(exports.OPTIONS)).map((s) => s.toLowerCase()));
    if (unsupportedOptions.size !== 0) {
      const optionWord = unsupportedOptions.size > 1 ? "options" : "option";
      const isOrAre = unsupportedOptions.size > 1 ? "are" : "is";
      throw new error_1.MongoParseError(`${optionWord} ${Array.from(unsupportedOptions).join(", ")} ${isOrAre} not supported`);
    }
    for (const [key, descriptor] of Object.entries(exports.OPTIONS)) {
      const values = allProvidedOptions.get(key);
      if (!values || values.length === 0) {
        if (exports.DEFAULT_OPTIONS.has(key)) {
          setOption(mongoOptions, key, descriptor, [exports.DEFAULT_OPTIONS.get(key)]);
        }
      } else {
        const { deprecated } = descriptor;
        if (deprecated) {
          const deprecatedMsg = typeof deprecated === "string" ? `: ${deprecated}` : "";
          (0, utils_1.emitWarning)(`${key} is a deprecated option${deprecatedMsg}`);
        }
        setOption(mongoOptions, key, descriptor, values);
      }
    }
    if (mongoOptions.credentials) {
      const isGssapi = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_GSSAPI;
      const isX509 = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_X509;
      const isAws = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_AWS;
      const isOidc = mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_OIDC;
      if ((isGssapi || isX509) && allProvidedOptions.has("authSource") && mongoOptions.credentials.source !== "$external") {
        throw new error_1.MongoParseError(`authMechanism ${mongoOptions.credentials.mechanism} requires an authSource of '\$external'`);
      }
      if (!(isGssapi || isX509 || isAws || isOidc) && mongoOptions.dbName && !allProvidedOptions.has("authSource")) {
        mongoOptions.credentials = mongo_credentials_1.MongoCredentials.merge(mongoOptions.credentials, {
          source: mongoOptions.dbName
        });
      }
      if (isAws && mongoOptions.credentials.username && !mongoOptions.credentials.password) {
        throw new error_1.MongoMissingCredentialsError(`When using ${mongoOptions.credentials.mechanism} password must be set when a username is specified`);
      }
      mongoOptions.credentials.validate();
      if (mongoOptions.credentials.password === "" && mongoOptions.credentials.username === "" && mongoOptions.credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && Object.keys(mongoOptions.credentials.mechanismProperties).length === 0) {
        delete mongoOptions.credentials;
      }
    }
    if (!mongoOptions.dbName) {
      mongoOptions.dbName = "test";
    }
    validateLoadBalancedOptions(hosts, mongoOptions, isSRV);
    if (mongoClient && mongoOptions.autoEncryption) {
      encrypter_1.Encrypter.checkForMongoCrypt();
      mongoOptions.encrypter = new encrypter_1.Encrypter(mongoClient, uri, options);
      mongoOptions.autoEncrypter = mongoOptions.encrypter.autoEncrypter;
    }
    mongoOptions.userSpecifiedAuthSource = objectOptions.has("authSource") || urlOptions.has("authSource");
    mongoOptions.userSpecifiedReplicaSet = objectOptions.has("replicaSet") || urlOptions.has("replicaSet");
    if (isSRV) {
      mongoOptions.srvHost = hosts[0];
      if (mongoOptions.directConnection) {
        throw new error_1.MongoAPIError("SRV URI does not support directConnection");
      }
      if (mongoOptions.srvMaxHosts > 0 && typeof mongoOptions.replicaSet === "string") {
        throw new error_1.MongoParseError("Cannot use srvMaxHosts option with replicaSet");
      }
      const noUserSpecifiedTLS = !objectOptions.has("tls") && !urlOptions.has("tls");
      const noUserSpecifiedSSL = !objectOptions.has("ssl") && !urlOptions.has("ssl");
      if (noUserSpecifiedTLS && noUserSpecifiedSSL) {
        mongoOptions.tls = true;
      }
    } else {
      const userSpecifiedSrvOptions = urlOptions.has("srvMaxHosts") || objectOptions.has("srvMaxHosts") || urlOptions.has("srvServiceName") || objectOptions.has("srvServiceName");
      if (userSpecifiedSrvOptions) {
        throw new error_1.MongoParseError("Cannot use srvMaxHosts or srvServiceName with a non-srv connection string");
      }
    }
    if (mongoOptions.directConnection && mongoOptions.hosts.length !== 1) {
      throw new error_1.MongoParseError("directConnection option requires exactly one host");
    }
    if (!mongoOptions.proxyHost && (mongoOptions.proxyPort || mongoOptions.proxyUsername || mongoOptions.proxyPassword)) {
      throw new error_1.MongoParseError("Must specify proxyHost if other proxy options are passed");
    }
    if (mongoOptions.proxyUsername && !mongoOptions.proxyPassword || !mongoOptions.proxyUsername && mongoOptions.proxyPassword) {
      throw new error_1.MongoParseError("Can only specify both of proxy username/password or neither");
    }
    const proxyOptions = ["proxyHost", "proxyPort", "proxyUsername", "proxyPassword"].map((key) => urlOptions.get(key) ?? []);
    if (proxyOptions.some((options2) => options2.length > 1)) {
      throw new error_1.MongoParseError("Proxy options cannot be specified multiple times in the connection string");
    }
    mongoOptions.mongoLoggerOptions = mongo_logger_1.MongoLogger.resolveOptions({
      MONGODB_LOG_COMMAND: process.env.MONGODB_LOG_COMMAND,
      MONGODB_LOG_TOPOLOGY: process.env.MONGODB_LOG_TOPOLOGY,
      MONGODB_LOG_SERVER_SELECTION: process.env.MONGODB_LOG_SERVER_SELECTION,
      MONGODB_LOG_CONNECTION: process.env.MONGODB_LOG_CONNECTION,
      MONGODB_LOG_CLIENT: process.env.MONGODB_LOG_CLIENT,
      MONGODB_LOG_ALL: process.env.MONGODB_LOG_ALL,
      MONGODB_LOG_MAX_DOCUMENT_LENGTH: process.env.MONGODB_LOG_MAX_DOCUMENT_LENGTH,
      MONGODB_LOG_PATH: process.env.MONGODB_LOG_PATH
    }, {
      mongodbLogPath: mongoOptions.mongodbLogPath,
      mongodbLogComponentSeverities: mongoOptions.mongodbLogComponentSeverities,
      mongodbLogMaxDocumentLength: mongoOptions.mongodbLogMaxDocumentLength
    });
    mongoOptions.metadata = (0, client_metadata_1.makeClientMetadata)(mongoOptions);
    mongoOptions.extendedMetadata = (0, client_metadata_1.addContainerMetadata)(mongoOptions.metadata).then(undefined, utils_1.squashError);
    return mongoOptions;
  }
  function validateLoadBalancedOptions(hosts, mongoOptions, isSrv) {
    if (mongoOptions.loadBalanced) {
      if (hosts.length > 1) {
        throw new error_1.MongoParseError(LB_SINGLE_HOST_ERROR);
      }
      if (mongoOptions.replicaSet) {
        throw new error_1.MongoParseError(LB_REPLICA_SET_ERROR);
      }
      if (mongoOptions.directConnection) {
        throw new error_1.MongoParseError(LB_DIRECT_CONNECTION_ERROR);
      }
      if (isSrv && mongoOptions.srvMaxHosts > 0) {
        throw new error_1.MongoParseError("Cannot limit srv hosts with loadBalanced enabled");
      }
    }
    return;
  }
  function setOption(mongoOptions, key, descriptor, values) {
    const { target, type, transform } = descriptor;
    const name = target ?? key;
    switch (type) {
      case "boolean":
        mongoOptions[name] = getBoolean(name, values[0]);
        break;
      case "int":
        mongoOptions[name] = getIntFromOptions(name, values[0]);
        break;
      case "uint":
        mongoOptions[name] = getUIntFromOptions(name, values[0]);
        break;
      case "string":
        if (values[0] == null) {
          break;
        }
        mongoOptions[name] = String(values[0]);
        break;
      case "record":
        if (!(0, utils_1.isRecord)(values[0])) {
          throw new error_1.MongoParseError(`${name} must be an object`);
        }
        mongoOptions[name] = values[0];
        break;
      case "any":
        mongoOptions[name] = values[0];
        break;
      default: {
        if (!transform) {
          throw new error_1.MongoParseError("Descriptors missing a type must define a transform");
        }
        const transformValue = transform({ name, options: mongoOptions, values });
        mongoOptions[name] = transformValue;
        break;
      }
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_OPTIONS = exports.OPTIONS = undefined;
  exports.resolveSRVRecord = resolveSRVRecord;
  exports.parseOptions = parseOptions;
  var dns = import.meta.require("dns");
  var mongodb_connection_string_url_1 = require_lib2();
  var url_1 = import.meta.require("url");
  var mongo_credentials_1 = require_mongo_credentials();
  var providers_1 = require_providers();
  var client_metadata_1 = require_client_metadata();
  var compression_1 = require_compression();
  var encrypter_1 = require_encrypter();
  var error_1 = require_error();
  var mongo_client_1 = require_mongo_client();
  var mongo_logger_1 = require_mongo_logger();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var monitor_1 = require_monitor();
  var utils_1 = require_utils2();
  var write_concern_1 = require_write_concern();
  var VALID_TXT_RECORDS = ["authSource", "replicaSet", "loadBalanced"];
  var LB_SINGLE_HOST_ERROR = "loadBalanced option only supported with a single host in the URI";
  var LB_REPLICA_SET_ERROR = "loadBalanced option not supported with a replicaSet option";
  var LB_DIRECT_CONNECTION_ERROR = "loadBalanced option not supported when directConnection is provided";
  var resolveSrv = retryDNSTimeoutFor("resolveSrv");
  var resolveTxt = retryDNSTimeoutFor("resolveTxt");

  class CaseInsensitiveMap extends Map {
    constructor(entries = []) {
      super(entries.map(([k, v]) => [k.toLowerCase(), v]));
    }
    has(k) {
      return super.has(k.toLowerCase());
    }
    get(k) {
      return super.get(k.toLowerCase());
    }
    set(k, v) {
      return super.set(k.toLowerCase(), v);
    }
    delete(k) {
      return super.delete(k.toLowerCase());
    }
  }
  exports.OPTIONS = {
    appName: {
      type: "string"
    },
    auth: {
      target: "credentials",
      transform({ name, options, values: [value] }) {
        if (!(0, utils_1.isRecord)(value, ["username", "password"])) {
          throw new error_1.MongoParseError(`${name} must be an object with 'username' and 'password' properties`);
        }
        return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
          username: value.username,
          password: value.password
        });
      }
    },
    authMechanism: {
      target: "credentials",
      transform({ options, values: [value] }) {
        const mechanisms = Object.values(providers_1.AuthMechanism);
        const [mechanism] = mechanisms.filter((m) => m.match(RegExp(String.raw`\b${value}\b`, "i")));
        if (!mechanism) {
          throw new error_1.MongoParseError(`authMechanism one of ${mechanisms}, got ${value}`);
        }
        let source = options.credentials?.source;
        if (mechanism === providers_1.AuthMechanism.MONGODB_PLAIN || providers_1.AUTH_MECHS_AUTH_SRC_EXTERNAL.has(mechanism)) {
          source = "$external";
        }
        let password = options.credentials?.password;
        if (mechanism === providers_1.AuthMechanism.MONGODB_X509 && password === "") {
          password = undefined;
        }
        return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
          mechanism,
          source,
          password
        });
      }
    },
    authMechanismProperties: {
      target: "credentials",
      transform({ options, values }) {
        let mechanismProperties = Object.create(null);
        for (const optionValue of values) {
          if (typeof optionValue === "string") {
            for (const [key, value] of entriesFromString(optionValue)) {
              try {
                mechanismProperties[key] = getBoolean(key, value);
              } catch {
                mechanismProperties[key] = value;
              }
            }
          } else {
            if (!(0, utils_1.isRecord)(optionValue)) {
              throw new error_1.MongoParseError("AuthMechanismProperties must be an object");
            }
            mechanismProperties = { ...optionValue };
          }
        }
        return mongo_credentials_1.MongoCredentials.merge(options.credentials, {
          mechanismProperties
        });
      }
    },
    authSource: {
      target: "credentials",
      transform({ options, values: [value] }) {
        const source = String(value);
        return mongo_credentials_1.MongoCredentials.merge(options.credentials, { source });
      }
    },
    autoEncryption: {
      type: "record"
    },
    autoSelectFamily: {
      type: "boolean",
      default: true
    },
    autoSelectFamilyAttemptTimeout: {
      type: "uint"
    },
    bsonRegExp: {
      type: "boolean"
    },
    serverApi: {
      target: "serverApi",
      transform({ values: [version] }) {
        const serverApiToValidate = typeof version === "string" ? { version } : version;
        const versionToValidate = serverApiToValidate && serverApiToValidate.version;
        if (!versionToValidate) {
          throw new error_1.MongoParseError(`Invalid \`serverApi\` property; must specify a version from the following enum: ["${Object.values(mongo_client_1.ServerApiVersion).join('", "')}"]`);
        }
        if (!Object.values(mongo_client_1.ServerApiVersion).some((v) => v === versionToValidate)) {
          throw new error_1.MongoParseError(`Invalid server API version=${versionToValidate}; must be in the following enum: ["${Object.values(mongo_client_1.ServerApiVersion).join('", "')}"]`);
        }
        return serverApiToValidate;
      }
    },
    checkKeys: {
      type: "boolean"
    },
    compressors: {
      default: "none",
      target: "compressors",
      transform({ values }) {
        const compressionList = new Set;
        for (const compVal of values) {
          const compValArray = typeof compVal === "string" ? compVal.split(",") : compVal;
          if (!Array.isArray(compValArray)) {
            throw new error_1.MongoInvalidArgumentError("compressors must be an array or a comma-delimited list of strings");
          }
          for (const c of compValArray) {
            if (Object.keys(compression_1.Compressor).includes(String(c))) {
              compressionList.add(String(c));
            } else {
              throw new error_1.MongoInvalidArgumentError(`${c} is not a valid compression mechanism. Must be one of: ${Object.keys(compression_1.Compressor)}.`);
            }
          }
        }
        return [...compressionList];
      }
    },
    connectTimeoutMS: {
      default: 30000,
      type: "uint"
    },
    dbName: {
      type: "string"
    },
    directConnection: {
      default: false,
      type: "boolean"
    },
    driverInfo: {
      default: {},
      type: "record"
    },
    enableUtf8Validation: { type: "boolean", default: true },
    family: {
      transform({ name, values: [value] }) {
        const transformValue = getIntFromOptions(name, value);
        if (transformValue === 4 || transformValue === 6) {
          return transformValue;
        }
        throw new error_1.MongoParseError(`Option 'family' must be 4 or 6 got ${transformValue}.`);
      }
    },
    fieldsAsRaw: {
      type: "record"
    },
    forceServerObjectId: {
      default: false,
      type: "boolean"
    },
    fsync: {
      deprecated: "Please use journal instead",
      target: "writeConcern",
      transform({ name, options, values: [value] }) {
        const wc = write_concern_1.WriteConcern.fromOptions({
          writeConcern: {
            ...options.writeConcern,
            fsync: getBoolean(name, value)
          }
        });
        if (!wc)
          throw new error_1.MongoParseError(`Unable to make a writeConcern from fsync=${value}`);
        return wc;
      }
    },
    heartbeatFrequencyMS: {
      default: 1e4,
      type: "uint"
    },
    ignoreUndefined: {
      type: "boolean"
    },
    j: {
      deprecated: "Please use journal instead",
      target: "writeConcern",
      transform({ name, options, values: [value] }) {
        const wc = write_concern_1.WriteConcern.fromOptions({
          writeConcern: {
            ...options.writeConcern,
            journal: getBoolean(name, value)
          }
        });
        if (!wc)
          throw new error_1.MongoParseError(`Unable to make a writeConcern from journal=${value}`);
        return wc;
      }
    },
    journal: {
      target: "writeConcern",
      transform({ name, options, values: [value] }) {
        const wc = write_concern_1.WriteConcern.fromOptions({
          writeConcern: {
            ...options.writeConcern,
            journal: getBoolean(name, value)
          }
        });
        if (!wc)
          throw new error_1.MongoParseError(`Unable to make a writeConcern from journal=${value}`);
        return wc;
      }
    },
    loadBalanced: {
      default: false,
      type: "boolean"
    },
    localThresholdMS: {
      default: 15,
      type: "uint"
    },
    maxConnecting: {
      default: 2,
      transform({ name, values: [value] }) {
        const maxConnecting = getUIntFromOptions(name, value);
        if (maxConnecting === 0) {
          throw new error_1.MongoInvalidArgumentError("maxConnecting must be > 0 if specified");
        }
        return maxConnecting;
      }
    },
    maxIdleTimeMS: {
      default: 0,
      type: "uint"
    },
    maxPoolSize: {
      default: 100,
      type: "uint"
    },
    maxStalenessSeconds: {
      target: "readPreference",
      transform({ name, options, values: [value] }) {
        const maxStalenessSeconds = getUIntFromOptions(name, value);
        if (options.readPreference) {
          return read_preference_1.ReadPreference.fromOptions({
            readPreference: { ...options.readPreference, maxStalenessSeconds }
          });
        } else {
          return new read_preference_1.ReadPreference("secondary", undefined, { maxStalenessSeconds });
        }
      }
    },
    minInternalBufferSize: {
      type: "uint"
    },
    minPoolSize: {
      default: 0,
      type: "uint"
    },
    minHeartbeatFrequencyMS: {
      default: 500,
      type: "uint"
    },
    monitorCommands: {
      default: false,
      type: "boolean"
    },
    name: {
      target: "driverInfo",
      transform({ values: [value], options }) {
        return { ...options.driverInfo, name: String(value) };
      }
    },
    noDelay: {
      default: true,
      type: "boolean"
    },
    pkFactory: {
      default: utils_1.DEFAULT_PK_FACTORY,
      transform({ values: [value] }) {
        if ((0, utils_1.isRecord)(value, ["createPk"]) && typeof value.createPk === "function") {
          return value;
        }
        throw new error_1.MongoParseError(`Option pkFactory must be an object with a createPk function, got ${value}`);
      }
    },
    promoteBuffers: {
      type: "boolean"
    },
    promoteLongs: {
      type: "boolean"
    },
    promoteValues: {
      type: "boolean"
    },
    useBigInt64: {
      type: "boolean"
    },
    proxyHost: {
      type: "string"
    },
    proxyPassword: {
      type: "string"
    },
    proxyPort: {
      type: "uint"
    },
    proxyUsername: {
      type: "string"
    },
    raw: {
      default: false,
      type: "boolean"
    },
    readConcern: {
      transform({ values: [value], options }) {
        if (value instanceof read_concern_1.ReadConcern || (0, utils_1.isRecord)(value, ["level"])) {
          return read_concern_1.ReadConcern.fromOptions({ ...options.readConcern, ...value });
        }
        throw new error_1.MongoParseError(`ReadConcern must be an object, got ${JSON.stringify(value)}`);
      }
    },
    readConcernLevel: {
      target: "readConcern",
      transform({ values: [level], options }) {
        return read_concern_1.ReadConcern.fromOptions({
          ...options.readConcern,
          level
        });
      }
    },
    readPreference: {
      default: read_preference_1.ReadPreference.primary,
      transform({ values: [value], options }) {
        if (value instanceof read_preference_1.ReadPreference) {
          return read_preference_1.ReadPreference.fromOptions({
            readPreference: { ...options.readPreference, ...value },
            ...value
          });
        }
        if ((0, utils_1.isRecord)(value, ["mode"])) {
          const rp = read_preference_1.ReadPreference.fromOptions({
            readPreference: { ...options.readPreference, ...value },
            ...value
          });
          if (rp)
            return rp;
          else
            throw new error_1.MongoParseError(`Cannot make read preference from ${JSON.stringify(value)}`);
        }
        if (typeof value === "string") {
          const rpOpts = {
            hedge: options.readPreference?.hedge,
            maxStalenessSeconds: options.readPreference?.maxStalenessSeconds
          };
          return new read_preference_1.ReadPreference(value, options.readPreference?.tags, rpOpts);
        }
        throw new error_1.MongoParseError(`Unknown ReadPreference value: ${value}`);
      }
    },
    readPreferenceTags: {
      target: "readPreference",
      transform({ values, options }) {
        const tags = Array.isArray(values[0]) ? values[0] : values;
        const readPreferenceTags = [];
        for (const tag of tags) {
          const readPreferenceTag = Object.create(null);
          if (typeof tag === "string") {
            for (const [k, v] of entriesFromString(tag)) {
              readPreferenceTag[k] = v;
            }
          }
          if ((0, utils_1.isRecord)(tag)) {
            for (const [k, v] of Object.entries(tag)) {
              readPreferenceTag[k] = v;
            }
          }
          readPreferenceTags.push(readPreferenceTag);
        }
        return read_preference_1.ReadPreference.fromOptions({
          readPreference: options.readPreference,
          readPreferenceTags
        });
      }
    },
    replicaSet: {
      type: "string"
    },
    retryReads: {
      default: true,
      type: "boolean"
    },
    retryWrites: {
      default: true,
      type: "boolean"
    },
    serializeFunctions: {
      type: "boolean"
    },
    serverMonitoringMode: {
      default: "auto",
      transform({ values: [value] }) {
        if (!Object.values(monitor_1.ServerMonitoringMode).includes(value)) {
          throw new error_1.MongoParseError("serverMonitoringMode must be one of `auto`, `poll`, or `stream`");
        }
        return value;
      }
    },
    serverSelectionTimeoutMS: {
      default: 30000,
      type: "uint"
    },
    servername: {
      type: "string"
    },
    socketTimeoutMS: {
      default: 0,
      type: "uint"
    },
    srvMaxHosts: {
      type: "uint",
      default: 0
    },
    srvServiceName: {
      type: "string",
      default: "mongodb"
    },
    ssl: {
      target: "tls",
      type: "boolean"
    },
    timeoutMS: {
      type: "uint"
    },
    tls: {
      type: "boolean"
    },
    tlsAllowInvalidCertificates: {
      target: "rejectUnauthorized",
      transform({ name, values: [value] }) {
        return !getBoolean(name, value);
      }
    },
    tlsAllowInvalidHostnames: {
      target: "checkServerIdentity",
      transform({ name, values: [value] }) {
        return getBoolean(name, value) ? () => {
          return;
        } : undefined;
      }
    },
    tlsCAFile: {
      type: "string"
    },
    tlsCRLFile: {
      type: "string"
    },
    tlsCertificateKeyFile: {
      type: "string"
    },
    tlsCertificateKeyFilePassword: {
      target: "passphrase",
      type: "any"
    },
    tlsInsecure: {
      transform({ name, options, values: [value] }) {
        const tlsInsecure = getBoolean(name, value);
        if (tlsInsecure) {
          options.checkServerIdentity = () => {
            return;
          };
          options.rejectUnauthorized = false;
        } else {
          options.checkServerIdentity = options.tlsAllowInvalidHostnames ? () => {
            return;
          } : undefined;
          options.rejectUnauthorized = options.tlsAllowInvalidCertificates ? false : true;
        }
        return tlsInsecure;
      }
    },
    w: {
      target: "writeConcern",
      transform({ values: [value], options }) {
        return write_concern_1.WriteConcern.fromOptions({ writeConcern: { ...options.writeConcern, w: value } });
      }
    },
    waitQueueTimeoutMS: {
      default: 0,
      type: "uint"
    },
    writeConcern: {
      target: "writeConcern",
      transform({ values: [value], options }) {
        if ((0, utils_1.isRecord)(value) || value instanceof write_concern_1.WriteConcern) {
          return write_concern_1.WriteConcern.fromOptions({
            writeConcern: {
              ...options.writeConcern,
              ...value
            }
          });
        } else if (value === "majority" || typeof value === "number") {
          return write_concern_1.WriteConcern.fromOptions({
            writeConcern: {
              ...options.writeConcern,
              w: value
            }
          });
        }
        throw new error_1.MongoParseError(`Invalid WriteConcern cannot parse: ${JSON.stringify(value)}`);
      }
    },
    wtimeout: {
      deprecated: "Please use wtimeoutMS instead",
      target: "writeConcern",
      transform({ values: [value], options }) {
        const wc = write_concern_1.WriteConcern.fromOptions({
          writeConcern: {
            ...options.writeConcern,
            wtimeout: getUIntFromOptions("wtimeout", value)
          }
        });
        if (wc)
          return wc;
        throw new error_1.MongoParseError(`Cannot make WriteConcern from wtimeout`);
      }
    },
    wtimeoutMS: {
      target: "writeConcern",
      transform({ values: [value], options }) {
        const wc = write_concern_1.WriteConcern.fromOptions({
          writeConcern: {
            ...options.writeConcern,
            wtimeoutMS: getUIntFromOptions("wtimeoutMS", value)
          }
        });
        if (wc)
          return wc;
        throw new error_1.MongoParseError(`Cannot make WriteConcern from wtimeout`);
      }
    },
    zlibCompressionLevel: {
      default: 0,
      type: "int"
    },
    mongodbLogPath: {
      transform({ values: [value] }) {
        if (!(typeof value === "string" && ["stderr", "stdout"].includes(value) || value && typeof value === "object" && ("write" in value) && typeof value.write === "function")) {
          throw new error_1.MongoAPIError(`Option 'mongodbLogPath' must be of type 'stderr' | 'stdout' | MongoDBLogWritable`);
        }
        return value;
      }
    },
    mongodbLogComponentSeverities: {
      transform({ values: [value] }) {
        if (typeof value !== "object" || !value) {
          throw new error_1.MongoAPIError(`Option 'mongodbLogComponentSeverities' must be a non-null object`);
        }
        for (const [k, v] of Object.entries(value)) {
          if (typeof v !== "string" || typeof k !== "string") {
            throw new error_1.MongoAPIError(`User input for option 'mongodbLogComponentSeverities' object cannot include a non-string key or value`);
          }
          if (!Object.values(mongo_logger_1.MongoLoggableComponent).some((val) => val === k) && k !== "default") {
            throw new error_1.MongoAPIError(`User input for option 'mongodbLogComponentSeverities' contains invalid key: ${k}`);
          }
          if (!Object.values(mongo_logger_1.SeverityLevel).some((val) => val === v)) {
            throw new error_1.MongoAPIError(`Option 'mongodbLogComponentSeverities' does not support ${v} as a value for ${k}`);
          }
        }
        return value;
      }
    },
    mongodbLogMaxDocumentLength: { type: "uint" },
    connectionType: { type: "any" },
    srvPoller: { type: "any" },
    allowPartialTrustChain: { type: "any" },
    minDHSize: { type: "any" },
    pskCallback: { type: "any" },
    secureContext: { type: "any" },
    enableTrace: { type: "any" },
    requestCert: { type: "any" },
    rejectUnauthorized: { type: "any" },
    checkServerIdentity: { type: "any" },
    ALPNProtocols: { type: "any" },
    SNICallback: { type: "any" },
    session: { type: "any" },
    requestOCSP: { type: "any" },
    localAddress: { type: "any" },
    localPort: { type: "any" },
    hints: { type: "any" },
    lookup: { type: "any" },
    ca: { type: "any" },
    cert: { type: "any" },
    ciphers: { type: "any" },
    crl: { type: "any" },
    ecdhCurve: { type: "any" },
    key: { type: "any" },
    passphrase: { type: "any" },
    pfx: { type: "any" },
    secureProtocol: { type: "any" },
    index: { type: "any" },
    useNewUrlParser: {
      type: "boolean",
      deprecated: "useNewUrlParser has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version"
    },
    useUnifiedTopology: {
      type: "boolean",
      deprecated: "useUnifiedTopology has no effect since Node.js Driver version 4.0.0 and will be removed in the next major version"
    },
    __skipPingOnConnect: { type: "boolean" }
  };
  exports.DEFAULT_OPTIONS = new CaseInsensitiveMap(Object.entries(exports.OPTIONS).filter(([, descriptor]) => descriptor.default != null).map(([k, d]) => [k, d.default]));
});

// node_modules/mongodb/lib/cmap/auth/mongodb_aws.js
var require_mongodb_aws = __commonJS((exports) => {
  async function makeTempCredentials(credentials, awsCredentialFetcher) {
    function makeMongoCredentialsFromAWSTemp(creds) {
      if (!creds.AccessKeyId || !creds.SecretAccessKey) {
        throw new error_1.MongoMissingCredentialsError("Could not obtain temporary MONGODB-AWS credentials");
      }
      return new mongo_credentials_1.MongoCredentials({
        username: creds.AccessKeyId,
        password: creds.SecretAccessKey,
        source: credentials.source,
        mechanism: providers_1.AuthMechanism.MONGODB_AWS,
        mechanismProperties: {
          AWS_SESSION_TOKEN: creds.Token
        }
      });
    }
    const temporaryCredentials = await awsCredentialFetcher.getCredentials();
    return makeMongoCredentialsFromAWSTemp(temporaryCredentials);
  }
  function deriveRegion(host) {
    const parts = host.split(".");
    if (parts.length === 1 || parts[1] === "amazonaws") {
      return "us-east-1";
    }
    return parts[1];
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoDBAWS = undefined;
  var BSON = require_bson2();
  var deps_1 = require_deps();
  var error_1 = require_error();
  var utils_1 = require_utils2();
  var auth_provider_1 = require_auth_provider();
  var aws_temporary_credentials_1 = require_aws_temporary_credentials();
  var mongo_credentials_1 = require_mongo_credentials();
  var providers_1 = require_providers();
  var ASCII_N = 110;
  var bsonOptions = {
    useBigInt64: false,
    promoteLongs: true,
    promoteValues: true,
    promoteBuffers: false,
    bsonRegExp: false
  };

  class MongoDBAWS extends auth_provider_1.AuthProvider {
    constructor() {
      super();
      this.credentialFetcher = aws_temporary_credentials_1.AWSTemporaryCredentialProvider.isAWSSDKInstalled ? new aws_temporary_credentials_1.AWSSDKCredentialProvider : new aws_temporary_credentials_1.LegacyAWSTemporaryCredentialProvider;
    }
    async auth(authContext) {
      const { connection } = authContext;
      if (!authContext.credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      if ("kModuleError" in deps_1.aws4) {
        throw deps_1.aws4["kModuleError"];
      }
      const { sign } = deps_1.aws4;
      if ((0, utils_1.maxWireVersion)(connection) < 9) {
        throw new error_1.MongoCompatibilityError("MONGODB-AWS authentication requires MongoDB version 4.4 or later");
      }
      if (!authContext.credentials.username) {
        authContext.credentials = await makeTempCredentials(authContext.credentials, this.credentialFetcher);
      }
      const { credentials } = authContext;
      const accessKeyId = credentials.username;
      const secretAccessKey = credentials.password;
      const sessionToken = credentials.mechanismProperties.AWS_SESSION_TOKEN;
      const awsCredentials = accessKeyId && secretAccessKey && sessionToken ? { accessKeyId, secretAccessKey, sessionToken } : accessKeyId && secretAccessKey ? { accessKeyId, secretAccessKey } : undefined;
      const db = credentials.source;
      const nonce = await (0, utils_1.randomBytes)(32);
      const saslStart = {
        saslStart: 1,
        mechanism: "MONGODB-AWS",
        payload: BSON.serialize({ r: nonce, p: ASCII_N }, bsonOptions)
      };
      const saslStartResponse = await connection.command((0, utils_1.ns)(`${db}.\$cmd`), saslStart, undefined);
      const serverResponse = BSON.deserialize(saslStartResponse.payload.buffer, bsonOptions);
      const host = serverResponse.h;
      const serverNonce = serverResponse.s.buffer;
      if (serverNonce.length !== 64) {
        throw new error_1.MongoRuntimeError(`Invalid server nonce length ${serverNonce.length}, expected 64`);
      }
      if (!utils_1.ByteUtils.equals(serverNonce.subarray(0, nonce.byteLength), nonce)) {
        throw new error_1.MongoRuntimeError("Server nonce does not begin with client nonce");
      }
      if (host.length < 1 || host.length > 255 || host.indexOf("..") !== -1) {
        throw new error_1.MongoRuntimeError(`Server returned an invalid host: "${host}"`);
      }
      const body = "Action=GetCallerIdentity&Version=2011-06-15";
      const options = sign({
        method: "POST",
        host,
        region: deriveRegion(serverResponse.h),
        service: "sts",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          "Content-Length": body.length,
          "X-MongoDB-Server-Nonce": utils_1.ByteUtils.toBase64(serverNonce),
          "X-MongoDB-GS2-CB-Flag": "n"
        },
        path: "/",
        body
      }, awsCredentials);
      const payload = {
        a: options.headers.Authorization,
        d: options.headers["X-Amz-Date"]
      };
      if (sessionToken) {
        payload.t = sessionToken;
      }
      const saslContinue = {
        saslContinue: 1,
        conversationId: 1,
        payload: BSON.serialize(payload, bsonOptions)
      };
      await connection.command((0, utils_1.ns)(`${db}.\$cmd`), saslContinue, undefined);
    }
  }
  exports.MongoDBAWS = MongoDBAWS;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/command_builders.js
var require_command_builders = __commonJS((exports) => {
  function finishCommandDocument(token, conversationId) {
    if (conversationId != null) {
      return {
        saslContinue: 1,
        conversationId,
        payload: new bson_1.Binary(bson_1.BSON.serialize({ jwt: token }))
      };
    }
    return {
      saslStart: 1,
      mechanism: providers_1.AuthMechanism.MONGODB_OIDC,
      payload: new bson_1.Binary(bson_1.BSON.serialize({ jwt: token }))
    };
  }
  function startCommandDocument(credentials) {
    const payload = {};
    if (credentials.username) {
      payload.n = credentials.username;
    }
    return {
      saslStart: 1,
      autoAuthorize: 1,
      mechanism: providers_1.AuthMechanism.MONGODB_OIDC,
      payload: new bson_1.Binary(bson_1.BSON.serialize(payload))
    };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.finishCommandDocument = finishCommandDocument;
  exports.startCommandDocument = startCommandDocument;
  var bson_1 = require_bson2();
  var providers_1 = require_providers();
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/machine_workflow.js
var require_machine_workflow = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MachineWorkflow = undefined;
  var promises_1 = import.meta.require("timers/promises");
  var utils_1 = require_utils2();
  var command_builders_1 = require_command_builders();
  var THROTTLE_MS = 100;

  class MachineWorkflow {
    constructor(cache) {
      this.cache = cache;
      this.callback = this.withLock(this.getToken.bind(this));
      this.lastExecutionTime = Date.now() - THROTTLE_MS;
    }
    async execute(connection, credentials) {
      const token = await this.getTokenFromCacheOrEnv(connection, credentials);
      const command = (0, command_builders_1.finishCommandDocument)(token);
      await connection.command((0, utils_1.ns)(credentials.source), command, undefined);
    }
    async reauthenticate(connection, credentials) {
      if (this.cache.hasAccessToken) {
        if (connection.accessToken === this.cache.getAccessToken()) {
          this.cache.removeAccessToken();
          delete connection.accessToken;
        } else {
          connection.accessToken = this.cache.getAccessToken();
        }
      }
      await this.execute(connection, credentials);
    }
    async speculativeAuth(connection, credentials) {
      if (!this.cache.hasAccessToken) {
        return {};
      }
      const token = await this.getTokenFromCacheOrEnv(connection, credentials);
      const document2 = (0, command_builders_1.finishCommandDocument)(token);
      document2.db = credentials.source;
      return { speculativeAuthenticate: document2 };
    }
    async getTokenFromCacheOrEnv(connection, credentials) {
      if (this.cache.hasAccessToken) {
        return this.cache.getAccessToken();
      } else {
        const token = await this.callback(credentials);
        this.cache.put({ accessToken: token.access_token, expiresInSeconds: token.expires_in });
        connection.accessToken = token.access_token;
        return token.access_token;
      }
    }
    withLock(callback) {
      let lock = Promise.resolve();
      return async (credentials) => {
        await lock;
        lock = lock.catch(() => null).then(async () => {
          const difference = Date.now() - this.lastExecutionTime;
          if (difference <= THROTTLE_MS) {
            await (0, promises_1.setTimeout)(THROTTLE_MS - difference);
          }
          this.lastExecutionTime = Date.now();
          return await callback(credentials);
        });
        return await lock;
      };
    }
  }
  exports.MachineWorkflow = MachineWorkflow;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/azure_machine_workflow.js
var require_azure_machine_workflow = __commonJS((exports) => {
  async function getAzureTokenData(tokenAudience, username) {
    const url = new URL(azure_1.AZURE_BASE_URL);
    (0, azure_1.addAzureParams)(url, tokenAudience, username);
    const response = await (0, utils_1.get)(url, {
      headers: AZURE_HEADERS
    });
    if (response.status !== 200) {
      throw new error_1.MongoAzureError(`Status code ${response.status} returned from the Azure endpoint. Response body: ${response.body}`);
    }
    const result = JSON.parse(response.body);
    return {
      access_token: result.access_token,
      expires_in: Number(result.expires_in)
    };
  }
  function isEndpointResultValid(token) {
    if (token == null || typeof token !== "object")
      return false;
    return "access_token" in token && typeof token.access_token === "string" && "expires_in" in token && typeof token.expires_in === "number";
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AzureMachineWorkflow = undefined;
  var azure_1 = require_azure();
  var error_1 = require_error();
  var utils_1 = require_utils2();
  var machine_workflow_1 = require_machine_workflow();
  var AZURE_HEADERS = Object.freeze({ Metadata: "true", Accept: "application/json" });
  var ENDPOINT_RESULT_ERROR = "Azure endpoint did not return a value with only access_token and expires_in properties";
  var TOKEN_RESOURCE_MISSING_ERROR = "TOKEN_RESOURCE must be set in the auth mechanism properties when ENVIRONMENT is azure.";

  class AzureMachineWorkflow extends machine_workflow_1.MachineWorkflow {
    constructor(cache) {
      super(cache);
    }
    async getToken(credentials) {
      const tokenAudience = credentials?.mechanismProperties.TOKEN_RESOURCE;
      const username = credentials?.username;
      if (!tokenAudience) {
        throw new error_1.MongoAzureError(TOKEN_RESOURCE_MISSING_ERROR);
      }
      const response = await getAzureTokenData(tokenAudience, username);
      if (!isEndpointResultValid(response)) {
        throw new error_1.MongoAzureError(ENDPOINT_RESULT_ERROR);
      }
      return response;
    }
  }
  exports.AzureMachineWorkflow = AzureMachineWorkflow;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/gcp_machine_workflow.js
var require_gcp_machine_workflow = __commonJS((exports) => {
  async function getGcpTokenData(tokenAudience) {
    const url = new URL(GCP_BASE_URL);
    url.searchParams.append("audience", tokenAudience);
    const response = await (0, utils_1.get)(url, {
      headers: GCP_HEADERS
    });
    if (response.status !== 200) {
      throw new error_1.MongoGCPError(`Status code ${response.status} returned from the GCP endpoint. Response body: ${response.body}`);
    }
    return { access_token: response.body };
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GCPMachineWorkflow = undefined;
  var error_1 = require_error();
  var utils_1 = require_utils2();
  var machine_workflow_1 = require_machine_workflow();
  var GCP_BASE_URL = "http://metadata/computeMetadata/v1/instance/service-accounts/default/identity";
  var GCP_HEADERS = Object.freeze({ "Metadata-Flavor": "Google" });
  var TOKEN_RESOURCE_MISSING_ERROR = "TOKEN_RESOURCE must be set in the auth mechanism properties when ENVIRONMENT is gcp.";

  class GCPMachineWorkflow extends machine_workflow_1.MachineWorkflow {
    constructor(cache) {
      super(cache);
    }
    async getToken(credentials) {
      const tokenAudience = credentials?.mechanismProperties.TOKEN_RESOURCE;
      if (!tokenAudience) {
        throw new error_1.MongoGCPError(TOKEN_RESOURCE_MISSING_ERROR);
      }
      return await getGcpTokenData(tokenAudience);
    }
  }
  exports.GCPMachineWorkflow = GCPMachineWorkflow;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/k8s_machine_workflow.js
var require_k8s_machine_workflow = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.K8SMachineWorkflow = undefined;
  var promises_1 = import.meta.require("fs/promises");
  var machine_workflow_1 = require_machine_workflow();
  var FALLBACK_FILENAME = "/var/run/secrets/kubernetes.io/serviceaccount/token";
  var AZURE_FILENAME = "AZURE_FEDERATED_TOKEN_FILE";
  var AWS_FILENAME = "AWS_WEB_IDENTITY_TOKEN_FILE";

  class K8SMachineWorkflow extends machine_workflow_1.MachineWorkflow {
    constructor(cache) {
      super(cache);
    }
    async getToken() {
      let filename;
      if (process.env[AZURE_FILENAME]) {
        filename = process.env[AZURE_FILENAME];
      } else if (process.env[AWS_FILENAME]) {
        filename = process.env[AWS_FILENAME];
      } else {
        filename = FALLBACK_FILENAME;
      }
      const token = await (0, promises_1.readFile)(filename, "utf8");
      return { access_token: token };
    }
  }
  exports.K8SMachineWorkflow = K8SMachineWorkflow;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/token_cache.js
var require_token_cache = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TokenCache = undefined;
  var error_1 = require_error();

  class MongoOIDCError extends error_1.MongoDriverError {
  }

  class TokenCache {
    get hasAccessToken() {
      return !!this.accessToken;
    }
    get hasRefreshToken() {
      return !!this.refreshToken;
    }
    get hasIdpInfo() {
      return !!this.idpInfo;
    }
    getAccessToken() {
      if (!this.accessToken) {
        throw new MongoOIDCError("Attempted to get an access token when none exists.");
      }
      return this.accessToken;
    }
    getRefreshToken() {
      if (!this.refreshToken) {
        throw new MongoOIDCError("Attempted to get a refresh token when none exists.");
      }
      return this.refreshToken;
    }
    getIdpInfo() {
      if (!this.idpInfo) {
        throw new MongoOIDCError("Attempted to get IDP information when none exists.");
      }
      return this.idpInfo;
    }
    put(response, idpInfo) {
      this.accessToken = response.accessToken;
      this.refreshToken = response.refreshToken;
      this.expiresInSeconds = response.expiresInSeconds;
      if (idpInfo) {
        this.idpInfo = idpInfo;
      }
    }
    removeAccessToken() {
      this.accessToken = undefined;
    }
    removeRefreshToken() {
      this.refreshToken = undefined;
    }
  }
  exports.TokenCache = TokenCache;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/token_machine_workflow.js
var require_token_machine_workflow = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TokenMachineWorkflow = undefined;
  var fs = import.meta.require("fs");
  var error_1 = require_error();
  var machine_workflow_1 = require_machine_workflow();
  var TOKEN_MISSING_ERROR = "OIDC_TOKEN_FILE must be set in the environment.";

  class TokenMachineWorkflow extends machine_workflow_1.MachineWorkflow {
    constructor(cache) {
      super(cache);
    }
    async getToken() {
      const tokenFile = process.env.OIDC_TOKEN_FILE;
      if (!tokenFile) {
        throw new error_1.MongoAWSError(TOKEN_MISSING_ERROR);
      }
      const token = await fs.promises.readFile(tokenFile, "utf8");
      return { access_token: token };
    }
  }
  exports.TokenMachineWorkflow = TokenMachineWorkflow;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc.js
var require_mongodb_oidc = __commonJS((exports) => {
  function getCredentials(authContext) {
    const { credentials } = authContext;
    if (!credentials) {
      throw new error_1.MongoMissingCredentialsError(MISSING_CREDENTIALS_ERROR);
    }
    return credentials;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoDBOIDC = exports.OIDC_WORKFLOWS = exports.OIDC_VERSION = undefined;
  var error_1 = require_error();
  var auth_provider_1 = require_auth_provider();
  var azure_machine_workflow_1 = require_azure_machine_workflow();
  var gcp_machine_workflow_1 = require_gcp_machine_workflow();
  var k8s_machine_workflow_1 = require_k8s_machine_workflow();
  var token_cache_1 = require_token_cache();
  var token_machine_workflow_1 = require_token_machine_workflow();
  var MISSING_CREDENTIALS_ERROR = "AuthContext must provide credentials.";
  exports.OIDC_VERSION = 1;
  exports.OIDC_WORKFLOWS = new Map;
  exports.OIDC_WORKFLOWS.set("test", () => new token_machine_workflow_1.TokenMachineWorkflow(new token_cache_1.TokenCache));
  exports.OIDC_WORKFLOWS.set("azure", () => new azure_machine_workflow_1.AzureMachineWorkflow(new token_cache_1.TokenCache));
  exports.OIDC_WORKFLOWS.set("gcp", () => new gcp_machine_workflow_1.GCPMachineWorkflow(new token_cache_1.TokenCache));
  exports.OIDC_WORKFLOWS.set("k8s", () => new k8s_machine_workflow_1.K8SMachineWorkflow(new token_cache_1.TokenCache));

  class MongoDBOIDC extends auth_provider_1.AuthProvider {
    constructor(workflow) {
      super();
      if (!workflow) {
        throw new error_1.MongoInvalidArgumentError("No workflow provided to the OIDC auth provider.");
      }
      this.workflow = workflow;
    }
    async auth(authContext) {
      const { connection, reauthenticating, response } = authContext;
      if (response?.speculativeAuthenticate?.done && !reauthenticating) {
        return;
      }
      const credentials = getCredentials(authContext);
      if (reauthenticating) {
        await this.workflow.reauthenticate(connection, credentials);
      } else {
        await this.workflow.execute(connection, credentials, response);
      }
    }
    async prepare(handshakeDoc, authContext) {
      const { connection } = authContext;
      const credentials = getCredentials(authContext);
      const result = await this.workflow.speculativeAuth(connection, credentials);
      return { ...handshakeDoc, ...result };
    }
  }
  exports.MongoDBOIDC = MongoDBOIDC;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/callback_workflow.js
var require_callback_workflow = __commonJS((exports) => {
  function isCallbackResultInvalid(tokenResult) {
    if (tokenResult == null || typeof tokenResult !== "object")
      return true;
    if (!("accessToken" in tokenResult))
      return true;
    return !Object.getOwnPropertyNames(tokenResult).every((prop) => RESULT_PROPERTIES.includes(prop));
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CallbackWorkflow = exports.AUTOMATED_TIMEOUT_MS = exports.HUMAN_TIMEOUT_MS = undefined;
  var promises_1 = import.meta.require("timers/promises");
  var error_1 = require_error();
  var utils_1 = require_utils2();
  var command_builders_1 = require_command_builders();
  exports.HUMAN_TIMEOUT_MS = 300000;
  exports.AUTOMATED_TIMEOUT_MS = 60000;
  var RESULT_PROPERTIES = ["accessToken", "expiresInSeconds", "refreshToken"];
  var CALLBACK_RESULT_ERROR = "User provided OIDC callbacks must return a valid object with an accessToken.";
  var THROTTLE_MS = 100;

  class CallbackWorkflow {
    constructor(cache, callback) {
      this.cache = cache;
      this.callback = this.withLock(callback);
      this.lastExecutionTime = Date.now() - THROTTLE_MS;
    }
    async speculativeAuth(connection, credentials) {
      if (this.cache.hasAccessToken) {
        const accessToken = this.cache.getAccessToken();
        connection.accessToken = accessToken;
        const document2 = (0, command_builders_1.finishCommandDocument)(accessToken);
        document2.db = credentials.source;
        return { speculativeAuthenticate: document2 };
      }
      return {};
    }
    async reauthenticate(connection, credentials) {
      if (this.cache.hasAccessToken) {
        if (connection.accessToken === this.cache.getAccessToken()) {
          this.cache.removeAccessToken();
          delete connection.accessToken;
        } else {
          connection.accessToken = this.cache.getAccessToken();
        }
      }
      await this.execute(connection, credentials);
    }
    async startAuthentication(connection, credentials, response) {
      let result;
      if (response?.speculativeAuthenticate) {
        result = response.speculativeAuthenticate;
      } else {
        result = await connection.command((0, utils_1.ns)(credentials.source), (0, command_builders_1.startCommandDocument)(credentials), undefined);
      }
      return result;
    }
    async finishAuthentication(connection, credentials, token, conversationId) {
      await connection.command((0, utils_1.ns)(credentials.source), (0, command_builders_1.finishCommandDocument)(token, conversationId), undefined);
    }
    async executeAndValidateCallback(params) {
      const result = await this.callback(params);
      if (isCallbackResultInvalid(result)) {
        throw new error_1.MongoMissingCredentialsError(CALLBACK_RESULT_ERROR);
      }
      return result;
    }
    withLock(callback) {
      let lock = Promise.resolve();
      return async (params) => {
        await lock;
        lock = lock.catch(() => null).then(async () => {
          const difference = Date.now() - this.lastExecutionTime;
          if (difference <= THROTTLE_MS) {
            await (0, promises_1.setTimeout)(THROTTLE_MS - difference, { signal: params.timeoutContext });
          }
          this.lastExecutionTime = Date.now();
          return await callback(params);
        });
        return await lock;
      };
    }
  }
  exports.CallbackWorkflow = CallbackWorkflow;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/automated_callback_workflow.js
var require_automated_callback_workflow = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AutomatedCallbackWorkflow = undefined;
  var error_1 = require_error();
  var timeout_1 = require_timeout();
  var mongodb_oidc_1 = require_mongodb_oidc();
  var callback_workflow_1 = require_callback_workflow();

  class AutomatedCallbackWorkflow extends callback_workflow_1.CallbackWorkflow {
    constructor(cache, callback) {
      super(cache, callback);
    }
    async execute(connection, credentials) {
      if (this.cache.hasAccessToken) {
        const token = this.cache.getAccessToken();
        try {
          return await this.finishAuthentication(connection, credentials, token);
        } catch (error) {
          if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.AuthenticationFailed) {
            this.cache.removeAccessToken();
            return await this.execute(connection, credentials);
          } else {
            throw error;
          }
        }
      }
      const response = await this.fetchAccessToken(credentials);
      this.cache.put(response);
      connection.accessToken = response.accessToken;
      await this.finishAuthentication(connection, credentials, response.accessToken);
    }
    async fetchAccessToken(credentials) {
      const controller = new AbortController;
      const params = {
        timeoutContext: controller.signal,
        version: mongodb_oidc_1.OIDC_VERSION
      };
      if (credentials.username) {
        params.username = credentials.username;
      }
      const timeout = timeout_1.Timeout.expires(callback_workflow_1.AUTOMATED_TIMEOUT_MS);
      try {
        return await Promise.race([this.executeAndValidateCallback(params), timeout]);
      } catch (error) {
        if (timeout_1.TimeoutError.is(error)) {
          controller.abort();
          throw new error_1.MongoOIDCError(`OIDC callback timed out after ${callback_workflow_1.AUTOMATED_TIMEOUT_MS}ms.`);
        }
        throw error;
      } finally {
        timeout.clear();
      }
    }
  }
  exports.AutomatedCallbackWorkflow = AutomatedCallbackWorkflow;
});

// node_modules/mongodb/lib/cmap/auth/mongodb_oidc/human_callback_workflow.js
var require_human_callback_workflow = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HumanCallbackWorkflow = undefined;
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var timeout_1 = require_timeout();
  var mongodb_oidc_1 = require_mongodb_oidc();
  var callback_workflow_1 = require_callback_workflow();

  class HumanCallbackWorkflow extends callback_workflow_1.CallbackWorkflow {
    constructor(cache, callback) {
      super(cache, callback);
    }
    async execute(connection, credentials) {
      if (this.cache.hasAccessToken) {
        const token = this.cache.getAccessToken();
        connection.accessToken = token;
        try {
          return await this.finishAuthentication(connection, credentials, token);
        } catch (error) {
          if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.AuthenticationFailed) {
            this.cache.removeAccessToken();
            delete connection.accessToken;
            return await this.execute(connection, credentials);
          } else {
            throw error;
          }
        }
      }
      if (this.cache.hasRefreshToken) {
        const refreshToken = this.cache.getRefreshToken();
        const result = await this.fetchAccessToken(this.cache.getIdpInfo(), credentials, refreshToken);
        this.cache.put(result);
        connection.accessToken = result.accessToken;
        try {
          return await this.finishAuthentication(connection, credentials, result.accessToken);
        } catch (error) {
          if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.AuthenticationFailed) {
            this.cache.removeRefreshToken();
            delete connection.accessToken;
            return await this.execute(connection, credentials);
          } else {
            throw error;
          }
        }
      }
      const startResponse = await this.startAuthentication(connection, credentials);
      const conversationId = startResponse.conversationId;
      const idpInfo = bson_1.BSON.deserialize(startResponse.payload.buffer);
      const callbackResponse = await this.fetchAccessToken(idpInfo, credentials);
      this.cache.put(callbackResponse, idpInfo);
      connection.accessToken = callbackResponse.accessToken;
      return await this.finishAuthentication(connection, credentials, callbackResponse.accessToken, conversationId);
    }
    async fetchAccessToken(idpInfo, credentials, refreshToken) {
      const controller = new AbortController;
      const params = {
        timeoutContext: controller.signal,
        version: mongodb_oidc_1.OIDC_VERSION,
        idpInfo
      };
      if (credentials.username) {
        params.username = credentials.username;
      }
      if (refreshToken) {
        params.refreshToken = refreshToken;
      }
      const timeout = timeout_1.Timeout.expires(callback_workflow_1.HUMAN_TIMEOUT_MS);
      try {
        return await Promise.race([this.executeAndValidateCallback(params), timeout]);
      } catch (error) {
        if (timeout_1.TimeoutError.is(error)) {
          controller.abort();
          throw new error_1.MongoOIDCError(`OIDC callback timed out after ${callback_workflow_1.HUMAN_TIMEOUT_MS}ms.`);
        }
        throw error;
      } finally {
        timeout.clear();
      }
    }
  }
  exports.HumanCallbackWorkflow = HumanCallbackWorkflow;
});

// node_modules/mongodb/lib/cmap/auth/plain.js
var require_plain = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Plain = undefined;
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var utils_1 = require_utils2();
  var auth_provider_1 = require_auth_provider();

  class Plain extends auth_provider_1.AuthProvider {
    async auth(authContext) {
      const { connection, credentials } = authContext;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      const { username, password } = credentials;
      const payload = new bson_1.Binary(Buffer.from(`\0${username}\0${password}`));
      const command = {
        saslStart: 1,
        mechanism: "PLAIN",
        payload,
        autoAuthorize: 1
      };
      await connection.command((0, utils_1.ns)("$external.$cmd"), command, undefined);
    }
  }
  exports.Plain = Plain;
});

// node_modules/@mongodb-js/saslprep/dist/index.js
var require_dist = __commonJS((exports, module) => {
  function toCodePoints(input) {
    const codepoints = [];
    const size = input.length;
    for (let i = 0;i < size; i += 1) {
      const before = input.charCodeAt(i);
      if (before >= 55296 && before <= 56319 && size > i + 1) {
        const next = input.charCodeAt(i + 1);
        if (next >= 56320 && next <= 57343) {
          codepoints.push((before - 55296) * 1024 + next - 56320 + 65536);
          i += 1;
          continue;
        }
      }
      codepoints.push(before);
    }
    return codepoints;
  }
  function saslprep({ unassigned_code_points, commonly_mapped_to_nothing, non_ASCII_space_characters, prohibited_characters, bidirectional_r_al, bidirectional_l }, input, opts = {}) {
    const mapping2space = non_ASCII_space_characters;
    const mapping2nothing = commonly_mapped_to_nothing;
    if (typeof input !== "string") {
      throw new TypeError("Expected string.");
    }
    if (input.length === 0) {
      return "";
    }
    const mapped_input = toCodePoints(input).map((character) => mapping2space.get(character) ? 32 : character).filter((character) => !mapping2nothing.get(character));
    const normalized_input = String.fromCodePoint.apply(null, mapped_input).normalize("NFKC");
    const normalized_map = toCodePoints(normalized_input);
    const hasProhibited = normalized_map.some((character) => prohibited_characters.get(character));
    if (hasProhibited) {
      throw new Error("Prohibited character, see https://tools.ietf.org/html/rfc4013#section-2.3");
    }
    if (opts.allowUnassigned !== true) {
      const hasUnassigned = normalized_map.some((character) => unassigned_code_points.get(character));
      if (hasUnassigned) {
        throw new Error("Unassigned code point, see https://tools.ietf.org/html/rfc4013#section-2.5");
      }
    }
    const hasBidiRAL = normalized_map.some((character) => bidirectional_r_al.get(character));
    const hasBidiL = normalized_map.some((character) => bidirectional_l.get(character));
    if (hasBidiRAL && hasBidiL) {
      throw new Error("String must not contain RandALCat and LCat at the same time," + " see https://tools.ietf.org/html/rfc3454#section-6");
    }
    const isFirstBidiRAL = bidirectional_r_al.get(getCodePoint(first(normalized_input)));
    const isLastBidiRAL = bidirectional_r_al.get(getCodePoint(last(normalized_input)));
    if (hasBidiRAL && !(isFirstBidiRAL && isLastBidiRAL)) {
      throw new Error("Bidirectional RandALCat character must be the first and the last" + " character of the string, see https://tools.ietf.org/html/rfc3454#section-6");
    }
    return normalized_input;
  }
  var getCodePoint = (character) => character.codePointAt(0);
  var first = (x) => x[0];
  var last = (x) => x[x.length - 1];
  saslprep.saslprep = saslprep;
  saslprep.default = saslprep;
  module.exports = saslprep;
});

// node_modules/memory-pager/index.js
var require_memory_pager = __commonJS((exports, module) => {
  function Pager(pageSize, opts) {
    if (!(this instanceof Pager))
      return new Pager(pageSize, opts);
    this.length = 0;
    this.updates = [];
    this.path = new Uint16Array(4);
    this.pages = new Array(32768);
    this.maxPages = this.pages.length;
    this.level = 0;
    this.pageSize = pageSize || 1024;
    this.deduplicate = opts ? opts.deduplicate : null;
    this.zeros = this.deduplicate ? alloc(this.deduplicate.length) : null;
  }
  function grow(pager, index) {
    while (pager.maxPages < index) {
      var old = pager.pages;
      pager.pages = new Array(32768);
      pager.pages[0] = old;
      pager.level++;
      pager.maxPages *= 32768;
    }
  }
  function truncate(buf, len) {
    if (buf.length === len)
      return buf;
    if (buf.length > len)
      return buf.slice(0, len);
    var cpy = alloc(len);
    buf.copy(cpy);
    return cpy;
  }
  function alloc(size) {
    if (Buffer.alloc)
      return Buffer.alloc(size);
    var buf = new Buffer(size);
    buf.fill(0);
    return buf;
  }
  function copy(buf) {
    var cpy = Buffer.allocUnsafe ? Buffer.allocUnsafe(buf.length) : new Buffer(buf.length);
    buf.copy(cpy);
    return cpy;
  }
  function Page(i, buf) {
    this.offset = i * buf.length;
    this.buffer = buf;
    this.updated = false;
    this.deduplicate = 0;
  }
  function factor(n, out) {
    n = (n - (out[0] = n & 32767)) / 32768;
    n = (n - (out[1] = n & 32767)) / 32768;
    out[3] = (n - (out[2] = n & 32767)) / 32768 & 32767;
  }
  module.exports = Pager;
  Pager.prototype.updated = function(page) {
    while (this.deduplicate && page.buffer[page.deduplicate] === this.deduplicate[page.deduplicate]) {
      page.deduplicate++;
      if (page.deduplicate === this.deduplicate.length) {
        page.deduplicate = 0;
        if (page.buffer.equals && page.buffer.equals(this.deduplicate))
          page.buffer = this.deduplicate;
        break;
      }
    }
    if (page.updated || !this.updates)
      return;
    page.updated = true;
    this.updates.push(page);
  };
  Pager.prototype.lastUpdate = function() {
    if (!this.updates || !this.updates.length)
      return null;
    var page = this.updates.pop();
    page.updated = false;
    return page;
  };
  Pager.prototype._array = function(i, noAllocate) {
    if (i >= this.maxPages) {
      if (noAllocate)
        return;
      grow(this, i);
    }
    factor(i, this.path);
    var arr = this.pages;
    for (var j = this.level;j > 0; j--) {
      var p = this.path[j];
      var next = arr[p];
      if (!next) {
        if (noAllocate)
          return;
        next = arr[p] = new Array(32768);
      }
      arr = next;
    }
    return arr;
  };
  Pager.prototype.get = function(i, noAllocate) {
    var arr = this._array(i, noAllocate);
    var first = this.path[0];
    var page = arr && arr[first];
    if (!page && !noAllocate) {
      page = arr[first] = new Page(i, alloc(this.pageSize));
      if (i >= this.length)
        this.length = i + 1;
    }
    if (page && page.buffer === this.deduplicate && this.deduplicate && !noAllocate) {
      page.buffer = copy(page.buffer);
      page.deduplicate = 0;
    }
    return page;
  };
  Pager.prototype.set = function(i, buf) {
    var arr = this._array(i, false);
    var first = this.path[0];
    if (i >= this.length)
      this.length = i + 1;
    if (!buf || this.zeros && buf.equals && buf.equals(this.zeros)) {
      arr[first] = undefined;
      return;
    }
    if (this.deduplicate && buf.equals && buf.equals(this.deduplicate)) {
      buf = this.deduplicate;
    }
    var page = arr[first];
    var b = truncate(buf, this.pageSize);
    if (page)
      page.buffer = b;
    else
      arr[first] = new Page(i, b);
  };
  Pager.prototype.toBuffer = function() {
    var list = new Array(this.length);
    var empty = alloc(this.pageSize);
    var ptr = 0;
    while (ptr < list.length) {
      var arr = this._array(ptr, true);
      for (var i = 0;i < 32768 && ptr < list.length; i++) {
        list[ptr++] = arr && arr[i] ? arr[i].buffer : empty;
      }
    }
    return Buffer.concat(list);
  };
});

// node_modules/sparse-bitfield/index.js
var require_sparse_bitfield = __commonJS((exports, module) => {
  function Bitfield(opts) {
    if (!(this instanceof Bitfield))
      return new Bitfield(opts);
    if (!opts)
      opts = {};
    if (Buffer.isBuffer(opts))
      opts = { buffer: opts };
    this.pageOffset = opts.pageOffset || 0;
    this.pageSize = opts.pageSize || 1024;
    this.pages = opts.pages || pager(this.pageSize);
    this.byteLength = this.pages.length * this.pageSize;
    this.length = 8 * this.byteLength;
    if (!powerOfTwo(this.pageSize))
      throw new Error("The page size should be a power of two");
    this._trackUpdates = !!opts.trackUpdates;
    this._pageMask = this.pageSize - 1;
    if (opts.buffer) {
      for (var i = 0;i < opts.buffer.length; i += this.pageSize) {
        this.pages.set(i / this.pageSize, opts.buffer.slice(i, i + this.pageSize));
      }
      this.byteLength = opts.buffer.length;
      this.length = 8 * this.byteLength;
    }
  }
  function alloc(n) {
    if (Buffer.alloc)
      return Buffer.alloc(n);
    var b = new Buffer(n);
    b.fill(0);
    return b;
  }
  function powerOfTwo(x) {
    return !(x & x - 1);
  }
  var pager = require_memory_pager();
  module.exports = Bitfield;
  Bitfield.prototype.get = function(i) {
    var o = i & 7;
    var j = (i - o) / 8;
    return !!(this.getByte(j) & 128 >> o);
  };
  Bitfield.prototype.getByte = function(i) {
    var o = i & this._pageMask;
    var j = (i - o) / this.pageSize;
    var page = this.pages.get(j, true);
    return page ? page.buffer[o + this.pageOffset] : 0;
  };
  Bitfield.prototype.set = function(i, v) {
    var o = i & 7;
    var j = (i - o) / 8;
    var b = this.getByte(j);
    return this.setByte(j, v ? b | 128 >> o : b & (255 ^ 128 >> o));
  };
  Bitfield.prototype.toBuffer = function() {
    var all = alloc(this.pages.length * this.pageSize);
    for (var i = 0;i < this.pages.length; i++) {
      var next = this.pages.get(i, true);
      var allOffset = i * this.pageSize;
      if (next)
        next.buffer.copy(all, allOffset, this.pageOffset, this.pageOffset + this.pageSize);
    }
    return all;
  };
  Bitfield.prototype.setByte = function(i, b) {
    var o = i & this._pageMask;
    var j = (i - o) / this.pageSize;
    var page = this.pages.get(j, false);
    o += this.pageOffset;
    if (page.buffer[o] === b)
      return false;
    page.buffer[o] = b;
    if (i >= this.byteLength) {
      this.byteLength = i + 1;
      this.length = this.byteLength * 8;
    }
    if (this._trackUpdates)
      this.pages.updated(page);
    return true;
  };
});

// node_modules/@mongodb-js/saslprep/dist/memory-code-points.js
var require_memory_code_points = __commonJS((exports) => {
  function createMemoryCodePoints(data) {
    let offset = 0;
    function read() {
      const size = data.readUInt32BE(offset);
      offset += 4;
      const codepoints = data.slice(offset, offset + size);
      offset += size;
      return (0, sparse_bitfield_1.default)({ buffer: codepoints });
    }
    const unassigned_code_points = read();
    const commonly_mapped_to_nothing = read();
    const non_ASCII_space_characters = read();
    const prohibited_characters = read();
    const bidirectional_r_al = read();
    const bidirectional_l = read();
    return {
      unassigned_code_points,
      commonly_mapped_to_nothing,
      non_ASCII_space_characters,
      prohibited_characters,
      bidirectional_r_al,
      bidirectional_l
    };
  }
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createMemoryCodePoints = undefined;
  var sparse_bitfield_1 = __importDefault(require_sparse_bitfield());
  exports.createMemoryCodePoints = createMemoryCodePoints;
});

// node_modules/@mongodb-js/saslprep/dist/code-points-data.js
var require_code_points_data = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var zlib_1 = import.meta.require("zlib");
  exports.default = (0, zlib_1.gunzipSync)(Buffer.from("H4sIAAAAAAACA+3dTYgcaRkA4LemO9Mhxm0FITnE9Cwr4jHgwgZ22B6YywqCJ0HQg5CL4sGTuOjCtGSF4CkHEW856MlTQHD3EJnWkU0Owh5VxE3LHlYQdNxd2U6mU59UV/d09fw4M2EySSXPAzNdP1/9fX/99bzVNZEN4jisRDulVFnQmLxm1aXF9Id/2/xMxNJ4XZlg576yuYlGt9gupV6xoFf8jhu9YvulVrFlp5XSx+lfvYhORGPXvqIRWSxERKtIm8bKFd10WNfKDS5Fo9jJWrq2+M2IlW+8uHgl/+BsROfPF4v5L7148Ur68Sha6dqZpYiVVy8tvLCWXo80Sf/lS89dGX2wHGvpzoXVn75/YWH5wmqe8uika82ViJXTy83Ve2k5Urozm38wm4/ls6t5uT6yfsTSJ7J3T0VKt8c5ExEXI8aFkH729c3eT+7EC6ca8cVULZUiYacX0R5PNWNxlh9L1y90q5kyzrpyy+9WcvOV6URntqw7La9sNVstXyczWVaWYbaaTYqzOHpr7pyiNT3/YzKuT63Z/FqKZlFTiuXtFM2vVOtIq7jiyKJbWZaOWD0euz0yoV2Z7kY0xq2x0YhfzVpmM5px9nTEH7JZ0ot5u39p0ma75Z472/s/H+2yr2inYyuq7fMvJivH2rM72N/Z3lyL31F2b1ya1P0zn816k2KP6JU9UzseucdQH5YqVeH/lFajSN2udg+TLJ9rksNxlvV2lki19rXKI43TPLejFu4ov7k3nMbhyhfY3Xb37f8BAGCf0eMTOH5szf154KmnNgKcnLb+Fzi2AfXktbN7fJelwTAiO/W5uQ2KINXRYu+znqo/WTAdLadURHmy3qciazd3bra4T3w16/f7t7Ms9U5gfJu10955sx1r3vmhBAAAAAAAgId20J1iZbDowNvIjuH427Gr5l/eiC+8OplZON8sVjx/qr9y+Pj+YRItT+NqAM+kkZs3AAAAAID6yfx1FwCAI97/dCh1/ub6SA0AAAAAAAAAgNoT/wcAAAAAAACA+hP/BwAAAAAAAID6E/8HAAAAAAAAgPoT/wcAAAAAAACA+hP/BwAAAAAAAID6E/8HAAAAAAAAgPoT/wcAAAAAAACA+hP/BwAAAAAAAID6E/8HAAAAAAAAgPoT/wcAAAAAAACA+hutp5SiQpYAAAAAAAAAQO2MIpZiT804flnAE2fhwjOeAZXr76kOAAAAAAAA8FjNf4N/l0NE3U/vuVQskLpSd4/Yh2xu9xTu0tFeeNYsLI2f/VMdNxTzj6Je9E/+6pp6Nn3awW3A54goe4Bss6v+PGsjQGMAAAAAAOBp5XEgwH6e7J7rwEQHRb/XvAMAAAAAAAA8yzoDeQDwVGjIAgAAAAAAAACoPfF/AAAAAAAAAKg/8X8AAAAAAAAAqD/xfwAAAAAAAACoP/F/AAAAAAAAAKg/8X8AAAAAAAAAqD/xfwAAAAAAAACoP/F/AAAAAAAAAKg/8X8AAAAAAAAAqD/xfwAAAAAAAACoP/F/AAAAAAAAAKg/8X8AAAAAAAAAqL/GSkSkClkCAAAAAAAAALXTSAAAAAAAAABA3Y1kAQAAAAAAAADUX8RSXZ9dsHC9+M8Fg2Ex/em1lAZpEBGttcrVjZqLEa+k0XpKw9mG4zWx4ukPUMhkAQAAAAAAABzBqbSe3//rXOS9HxGdo4TqR2XkutCdBu+LaPZw/lBbO7cbHnh2C7N7AIo4evEznllqLqWUp/LnYOtpM2bnOH66wI1+9GO4sOuISwv/TOlumu56FDv3NZhc4mR9v7zYIrafr40j/Cccvj9Xns3t3mu99E7qxUv3bqS0/ouNH/08++RGemfQ+nsx/5uNXsQPGulynPvv3ZTW37zd+1ovrqaYpP/122X6Xpx779Z3zr/3YOPKW1lkaRDf31pPaf3j/msRsVGkL+d/f+/m4sJsPm1cfSsr16e8m9Ldj/KsnyIuR3nXw83Is3EhxLd/2V773ks3m/cj/THKUummdP9qKhIOImuOU0Xjwb3y+oqt735rpTetVbF9n8R4x9crRfO77TKqVOZpDclv5bfK18lMnk+q0K18UpxF/RrGXE0Zxtqx3tWSj+vxbL4XaasfKb0dRbtLW73JsfPGg177H+OmGKlfvS1msllt7JEJm9XOJqXR+Fkfo1H66uy5H1v3Xx5+uJmGLw9jro2u7Loj4PnuR6+f+e3d261+eazNhzrL7X83MohoHpS4PddV8ki1it61//pw1g7z6p1U/26Nm2llST57B5rUvuG0XqSU/rPd7jYrqWcbd+beJQ77BgPMDwn37/8BAGCf0eMTOH4cPlufv9VGgJOzqf8Fjm1APXkd7B7f5dF57GPMaWy/MTvjvNvtXj6h8W2+GXvnzXaseeeHEgAAAAAAAB7aQXeKlcGiadBoEOeLb2dtpGOL2MyOtf391a3P/zD96c3JzIP3t4oV797vrh8+vn+YRL5bBuj/AQAAAABqJvfHXQAAHkX82zfXAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACeAgkAAAAAAAAAqLuRLAAAAAAAAACA2hv9D1iu/VAYaAYA", "base64"));
});

// node_modules/@mongodb-js/saslprep/dist/node.js
var require_node = __commonJS((exports, module) => {
  function saslprep(input, opts) {
    return (0, index_1.default)(codePoints, input, opts);
  }
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  var index_1 = __importDefault(require_dist());
  var memory_code_points_1 = require_memory_code_points();
  var code_points_data_1 = __importDefault(require_code_points_data());
  var codePoints = (0, memory_code_points_1.createMemoryCodePoints)(code_points_data_1.default);
  saslprep.saslprep = saslprep;
  saslprep.default = saslprep;
  module.exports = saslprep;
});

// node_modules/mongodb/lib/cmap/auth/scram.js
var require_scram = __commonJS((exports) => {
  function cleanUsername(username) {
    return username.replace("=", "=3D").replace(",", "=2C");
  }
  function clientFirstMessageBare(username, nonce) {
    return Buffer.concat([
      Buffer.from("n=", "utf8"),
      Buffer.from(username, "utf8"),
      Buffer.from(",r=", "utf8"),
      Buffer.from(nonce.toString("base64"), "utf8")
    ]);
  }
  function makeFirstMessage(cryptoMethod, credentials, nonce) {
    const username = cleanUsername(credentials.username);
    const mechanism = cryptoMethod === "sha1" ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA256;
    return {
      saslStart: 1,
      mechanism,
      payload: new bson_1.Binary(Buffer.concat([Buffer.from("n,,", "utf8"), clientFirstMessageBare(username, nonce)])),
      autoAuthorize: 1,
      options: { skipEmptyExchange: true }
    };
  }
  async function executeScram(cryptoMethod, authContext) {
    const { connection, credentials } = authContext;
    if (!credentials) {
      throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
    }
    if (!authContext.nonce) {
      throw new error_1.MongoInvalidArgumentError("AuthContext must contain a valid nonce property");
    }
    const nonce = authContext.nonce;
    const db = credentials.source;
    const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);
    const response = await connection.command((0, utils_1.ns)(`${db}.\$cmd`), saslStartCmd, undefined);
    await continueScramConversation(cryptoMethod, response, authContext);
  }
  async function continueScramConversation(cryptoMethod, response, authContext) {
    const connection = authContext.connection;
    const credentials = authContext.credentials;
    if (!credentials) {
      throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
    }
    if (!authContext.nonce) {
      throw new error_1.MongoInvalidArgumentError("Unable to continue SCRAM without valid nonce");
    }
    const nonce = authContext.nonce;
    const db = credentials.source;
    const username = cleanUsername(credentials.username);
    const password = credentials.password;
    const processedPassword = cryptoMethod === "sha256" ? (0, saslprep_1.saslprep)(password) : passwordDigest(username, password);
    const payload = Buffer.isBuffer(response.payload) ? new bson_1.Binary(response.payload) : response.payload;
    const dict = parsePayload(payload);
    const iterations = parseInt(dict.i, 10);
    if (iterations && iterations < 4096) {
      throw new error_1.MongoRuntimeError(`Server returned an invalid iteration count ${iterations}`);
    }
    const salt = dict.s;
    const rnonce = dict.r;
    if (rnonce.startsWith("nonce")) {
      throw new error_1.MongoRuntimeError(`Server returned an invalid nonce: ${rnonce}`);
    }
    const withoutProof = `c=biws,r=${rnonce}`;
    const saltedPassword = HI(processedPassword, Buffer.from(salt, "base64"), iterations, cryptoMethod);
    const clientKey = HMAC(cryptoMethod, saltedPassword, "Client Key");
    const serverKey = HMAC(cryptoMethod, saltedPassword, "Server Key");
    const storedKey = H(cryptoMethod, clientKey);
    const authMessage = [
      clientFirstMessageBare(username, nonce),
      payload.toString("utf8"),
      withoutProof
    ].join(",");
    const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);
    const clientProof = `p=${xor(clientKey, clientSignature)}`;
    const clientFinal = [withoutProof, clientProof].join(",");
    const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);
    const saslContinueCmd = {
      saslContinue: 1,
      conversationId: response.conversationId,
      payload: new bson_1.Binary(Buffer.from(clientFinal))
    };
    const r = await connection.command((0, utils_1.ns)(`${db}.\$cmd`), saslContinueCmd, undefined);
    const parsedResponse = parsePayload(r.payload);
    if (!compareDigest(Buffer.from(parsedResponse.v, "base64"), serverSignature)) {
      throw new error_1.MongoRuntimeError("Server returned an invalid signature");
    }
    if (r.done !== false) {
      return;
    }
    const retrySaslContinueCmd = {
      saslContinue: 1,
      conversationId: r.conversationId,
      payload: Buffer.alloc(0)
    };
    await connection.command((0, utils_1.ns)(`${db}.\$cmd`), retrySaslContinueCmd, undefined);
  }
  function parsePayload(payload) {
    const payloadStr = payload.toString("utf8");
    const dict = {};
    const parts = payloadStr.split(",");
    for (let i = 0;i < parts.length; i++) {
      const valueParts = (parts[i].match(/^([^=]*)=(.*)$/) ?? []).slice(1);
      dict[valueParts[0]] = valueParts[1];
    }
    return dict;
  }
  function passwordDigest(username, password) {
    if (typeof username !== "string") {
      throw new error_1.MongoInvalidArgumentError("Username must be a string");
    }
    if (typeof password !== "string") {
      throw new error_1.MongoInvalidArgumentError("Password must be a string");
    }
    if (password.length === 0) {
      throw new error_1.MongoInvalidArgumentError("Password cannot be empty");
    }
    let md5;
    try {
      md5 = crypto3.createHash("md5");
    } catch (err) {
      if (crypto3.getFips()) {
        throw new Error("Auth mechanism SCRAM-SHA-1 is not supported in FIPS mode");
      }
      throw err;
    }
    md5.update(`${username}:mongo:${password}`, "utf8");
    return md5.digest("hex");
  }
  function xor(a, b) {
    if (!Buffer.isBuffer(a)) {
      a = Buffer.from(a);
    }
    if (!Buffer.isBuffer(b)) {
      b = Buffer.from(b);
    }
    const length = Math.max(a.length, b.length);
    const res = [];
    for (let i = 0;i < length; i += 1) {
      res.push(a[i] ^ b[i]);
    }
    return Buffer.from(res).toString("base64");
  }
  function H(method, text) {
    return crypto3.createHash(method).update(text).digest();
  }
  function HMAC(method, key, text) {
    return crypto3.createHmac(method, key).update(text).digest();
  }
  function _hiCachePurge() {
    _hiCache = {};
    _hiCacheCount = 0;
  }
  function HI(data, salt, iterations, cryptoMethod) {
    const key = [data, salt.toString("base64"), iterations].join("_");
    if (_hiCache[key] != null) {
      return _hiCache[key];
    }
    const saltedData = crypto3.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod);
    if (_hiCacheCount >= 200) {
      _hiCachePurge();
    }
    _hiCache[key] = saltedData;
    _hiCacheCount += 1;
    return saltedData;
  }
  function compareDigest(lhs, rhs) {
    if (lhs.length !== rhs.length) {
      return false;
    }
    if (typeof crypto3.timingSafeEqual === "function") {
      return crypto3.timingSafeEqual(lhs, rhs);
    }
    let result = 0;
    for (let i = 0;i < lhs.length; i++) {
      result |= lhs[i] ^ rhs[i];
    }
    return result === 0;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ScramSHA256 = exports.ScramSHA1 = undefined;
  var saslprep_1 = require_node();
  var crypto3 = import.meta.require("crypto");
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var utils_1 = require_utils2();
  var auth_provider_1 = require_auth_provider();
  var providers_1 = require_providers();

  class ScramSHA extends auth_provider_1.AuthProvider {
    constructor(cryptoMethod) {
      super();
      this.cryptoMethod = cryptoMethod || "sha1";
    }
    async prepare(handshakeDoc, authContext) {
      const cryptoMethod = this.cryptoMethod;
      const credentials = authContext.credentials;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      const nonce = await (0, utils_1.randomBytes)(24);
      authContext.nonce = nonce;
      const request = {
        ...handshakeDoc,
        speculativeAuthenticate: {
          ...makeFirstMessage(cryptoMethod, credentials, nonce),
          db: credentials.source
        }
      };
      return request;
    }
    async auth(authContext) {
      const { reauthenticating, response } = authContext;
      if (response?.speculativeAuthenticate && !reauthenticating) {
        return await continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext);
      }
      return await executeScram(this.cryptoMethod, authContext);
    }
  }
  var _hiCache = {};
  var _hiCacheCount = 0;
  var hiLengthMap = {
    sha256: 32,
    sha1: 20
  };

  class ScramSHA1 extends ScramSHA {
    constructor() {
      super("sha1");
    }
  }
  exports.ScramSHA1 = ScramSHA1;

  class ScramSHA256 extends ScramSHA {
    constructor() {
      super("sha256");
    }
  }
  exports.ScramSHA256 = ScramSHA256;
});

// node_modules/mongodb/lib/cmap/auth/x509.js
var require_x509 = __commonJS((exports) => {
  function x509AuthenticateCommand(credentials) {
    const command = { authenticate: 1, mechanism: "MONGODB-X509" };
    if (credentials.username) {
      command.user = credentials.username;
    }
    return command;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.X509 = undefined;
  var error_1 = require_error();
  var utils_1 = require_utils2();
  var auth_provider_1 = require_auth_provider();

  class X509 extends auth_provider_1.AuthProvider {
    async prepare(handshakeDoc, authContext) {
      const { credentials } = authContext;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      return { ...handshakeDoc, speculativeAuthenticate: x509AuthenticateCommand(credentials) };
    }
    async auth(authContext) {
      const connection = authContext.connection;
      const credentials = authContext.credentials;
      if (!credentials) {
        throw new error_1.MongoMissingCredentialsError("AuthContext must provide credentials.");
      }
      const response = authContext.response;
      if (response?.speculativeAuthenticate) {
        return;
      }
      await connection.command((0, utils_1.ns)("$external.$cmd"), x509AuthenticateCommand(credentials), undefined);
    }
  }
  exports.X509 = X509;
});

// node_modules/mongodb/lib/mongo_client_auth_providers.js
var require_mongo_client_auth_providers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoClientAuthProviders = undefined;
  var gssapi_1 = require_gssapi();
  var mongodb_aws_1 = require_mongodb_aws();
  var mongodb_oidc_1 = require_mongodb_oidc();
  var automated_callback_workflow_1 = require_automated_callback_workflow();
  var human_callback_workflow_1 = require_human_callback_workflow();
  var token_cache_1 = require_token_cache();
  var plain_1 = require_plain();
  var providers_1 = require_providers();
  var scram_1 = require_scram();
  var x509_1 = require_x509();
  var error_1 = require_error();
  var AUTH_PROVIDERS = new Map([
    [providers_1.AuthMechanism.MONGODB_AWS, () => new mongodb_aws_1.MongoDBAWS],
    [
      providers_1.AuthMechanism.MONGODB_CR,
      () => {
        throw new error_1.MongoInvalidArgumentError("MONGODB-CR is no longer a supported auth mechanism in MongoDB 4.0+");
      }
    ],
    [providers_1.AuthMechanism.MONGODB_GSSAPI, () => new gssapi_1.GSSAPI],
    [providers_1.AuthMechanism.MONGODB_OIDC, (workflow) => new mongodb_oidc_1.MongoDBOIDC(workflow)],
    [providers_1.AuthMechanism.MONGODB_PLAIN, () => new plain_1.Plain],
    [providers_1.AuthMechanism.MONGODB_SCRAM_SHA1, () => new scram_1.ScramSHA1],
    [providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, () => new scram_1.ScramSHA256],
    [providers_1.AuthMechanism.MONGODB_X509, () => new x509_1.X509]
  ]);

  class MongoClientAuthProviders {
    constructor() {
      this.existingProviders = new Map;
    }
    getOrCreateProvider(name, authMechanismProperties) {
      const authProvider = this.existingProviders.get(name);
      if (authProvider) {
        return authProvider;
      }
      const providerFunction = AUTH_PROVIDERS.get(name);
      if (!providerFunction) {
        throw new error_1.MongoInvalidArgumentError(`authMechanism ${name} not supported`);
      }
      let provider;
      if (name === providers_1.AuthMechanism.MONGODB_OIDC) {
        provider = providerFunction(this.getWorkflow(authMechanismProperties));
      } else {
        provider = providerFunction();
      }
      this.existingProviders.set(name, provider);
      return provider;
    }
    getWorkflow(authMechanismProperties) {
      if (authMechanismProperties.OIDC_HUMAN_CALLBACK) {
        return new human_callback_workflow_1.HumanCallbackWorkflow(new token_cache_1.TokenCache, authMechanismProperties.OIDC_HUMAN_CALLBACK);
      } else if (authMechanismProperties.OIDC_CALLBACK) {
        return new automated_callback_workflow_1.AutomatedCallbackWorkflow(new token_cache_1.TokenCache, authMechanismProperties.OIDC_CALLBACK);
      } else {
        const environment = authMechanismProperties.ENVIRONMENT;
        const workflow = mongodb_oidc_1.OIDC_WORKFLOWS.get(environment)?.();
        if (!workflow) {
          throw new error_1.MongoInvalidArgumentError(`Could not load workflow for environment ${authMechanismProperties.ENVIRONMENT}`);
        }
        return workflow;
      }
    }
  }
  exports.MongoClientAuthProviders = MongoClientAuthProviders;
});

// node_modules/mongodb/lib/beta.js
var require_beta = __commonJS((exports) => {
  function __exportStar(mod) {
    for (const key of Object.keys(mod)) {
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
          return mod[key];
        }
      });
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_lib3(), exports);
});

// node_modules/mongodb/lib/operations/client_bulk_write/client_bulk_write.js
var require_client_bulk_write = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ClientBulkWriteOperation = undefined;
  var beta_1 = require_beta();
  var responses_1 = require_responses();
  var utils_1 = require_utils2();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class ClientBulkWriteOperation extends command_1.CommandOperation {
    get commandName() {
      return "bulkWrite";
    }
    constructor(commandBuilder, options) {
      super(undefined, options);
      this.commandBuilder = commandBuilder;
      this.options = options;
      this.ns = new utils_1.MongoDBNamespace("admin", "$cmd");
    }
    resetBatch() {
      return this.commandBuilder.resetBatch();
    }
    get canRetryWrite() {
      return this.commandBuilder.isBatchRetryable;
    }
    async execute(server, session, timeoutContext) {
      let command;
      if (server.description.type === beta_1.ServerType.LoadBalancer) {
        if (session) {
          let connection;
          if (!session.pinnedConnection) {
            connection = await server.pool.checkOut({ timeoutContext });
            session.pin(connection);
          } else {
            connection = session.pinnedConnection;
          }
          command = this.commandBuilder.buildBatch(connection.hello?.maxMessageSizeBytes, connection.hello?.maxWriteBatchSize, connection.hello?.maxBsonObjectSize);
        } else {
          throw new beta_1.MongoClientBulkWriteExecutionError("Session provided to the client bulk write operation must be present.");
        }
      } else {
        if (!server.description.maxWriteBatchSize || !server.description.maxMessageSizeBytes || !server.description.maxBsonObjectSize) {
          throw new beta_1.MongoClientBulkWriteExecutionError("In order to execute a client bulk write, both maxWriteBatchSize, maxMessageSizeBytes and maxBsonObjectSize must be provided by the servers hello response.");
        }
        command = this.commandBuilder.buildBatch(server.description.maxMessageSizeBytes, server.description.maxWriteBatchSize, server.description.maxBsonObjectSize);
      }
      if (!this.canRetryWrite) {
        this.options.willRetryWrite = false;
      }
      return await super.executeCommand(server, session, command, timeoutContext, responses_1.ClientBulkWriteCursorResponse);
    }
  }
  exports.ClientBulkWriteOperation = ClientBulkWriteOperation;
  (0, operation_1.defineAspects)(ClientBulkWriteOperation, [
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.SKIP_COLLATION,
    operation_1.Aspect.CURSOR_CREATING,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.COMMAND_BATCHING
  ]);
});

// node_modules/mongodb/lib/cursor/client_bulk_write_cursor.js
var require_client_bulk_write_cursor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ClientBulkWriteCursor = undefined;
  var client_bulk_write_1 = require_client_bulk_write();
  var execute_operation_1 = require_execute_operation();
  var utils_1 = require_utils2();
  var abstract_cursor_1 = require_abstract_cursor();

  class ClientBulkWriteCursor extends abstract_cursor_1.AbstractCursor {
    constructor(client, commandBuilder, options = {}) {
      super(client, new utils_1.MongoDBNamespace("admin", "$cmd"), options);
      this.commandBuilder = commandBuilder;
      this.clientBulkWriteOptions = options;
    }
    get response() {
      if (this.cursorResponse)
        return this.cursorResponse;
      return null;
    }
    get operations() {
      return this.commandBuilder.lastOperations;
    }
    clone() {
      const clonedOptions = (0, utils_1.mergeOptions)({}, this.clientBulkWriteOptions);
      delete clonedOptions.session;
      return new ClientBulkWriteCursor(this.client, this.commandBuilder, {
        ...clonedOptions
      });
    }
    async _initialize(session) {
      const clientBulkWriteOperation = new client_bulk_write_1.ClientBulkWriteOperation(this.commandBuilder, {
        ...this.clientBulkWriteOptions,
        ...this.cursorOptions,
        session
      });
      const response = await (0, execute_operation_1.executeOperation)(this.client, clientBulkWriteOperation, this.timeoutContext);
      this.cursorResponse = response;
      return { server: clientBulkWriteOperation.server, session, response };
    }
  }
  exports.ClientBulkWriteCursor = ClientBulkWriteCursor;
});

// node_modules/mongodb/lib/operations/client_bulk_write/command_builder.js
var require_command_builder = __commonJS((exports) => {
  function validateBufferSize(name, buffer, maxBsonObjectSize) {
    if (buffer.length > maxBsonObjectSize) {
      throw new error_1.MongoInvalidArgumentError(`Client bulk write operation ${name} of length ${buffer.length} exceeds the max bson object size of ${maxBsonObjectSize}`);
    }
  }
  function createDeleteOperation(model, index, multi) {
    const document2 = {
      delete: index,
      multi,
      filter: model.filter
    };
    if (model.hint) {
      document2.hint = model.hint;
    }
    if (model.collation) {
      document2.collation = model.collation;
    }
    return document2;
  }
  function validateUpdate(update) {
    if (!(0, utils_1.hasAtomicOperators)(update)) {
      throw new error_1.MongoAPIError("Client bulk write update models must only contain atomic modifiers (start with $) and must not be empty.");
    }
  }
  function createUpdateOperation(model, index, multi) {
    validateUpdate(model.update);
    const document2 = {
      update: index,
      multi,
      filter: model.filter,
      updateMods: model.update
    };
    if (model.hint) {
      document2.hint = model.hint;
    }
    if (model.upsert) {
      document2.upsert = model.upsert;
    }
    if (model.arrayFilters) {
      document2.arrayFilters = model.arrayFilters;
    }
    if (model.collation) {
      document2.collation = model.collation;
    }
    return document2;
  }
  function buildOperation(model, index, pkFactory) {
    switch (model.name) {
      case "insertOne":
        return (0, exports.buildInsertOneOperation)(model, index, pkFactory);
      case "deleteOne":
        return (0, exports.buildDeleteOneOperation)(model, index);
      case "deleteMany":
        return (0, exports.buildDeleteManyOperation)(model, index);
      case "updateOne":
        return (0, exports.buildUpdateOneOperation)(model, index);
      case "updateMany":
        return (0, exports.buildUpdateManyOperation)(model, index);
      case "replaceOne":
        return (0, exports.buildReplaceOneOperation)(model, index);
    }
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buildReplaceOneOperation = exports.buildUpdateManyOperation = exports.buildUpdateOneOperation = exports.buildDeleteManyOperation = exports.buildDeleteOneOperation = exports.buildInsertOneOperation = exports.ClientBulkWriteCommandBuilder = undefined;
  exports.buildOperation = buildOperation;
  var bson_1 = require_bson2();
  var commands_1 = require_commands();
  var error_1 = require_error();
  var utils_1 = require_utils2();
  var MESSAGE_OVERHEAD_BYTES = 1000;

  class ClientBulkWriteCommandBuilder {
    constructor(models, options, pkFactory) {
      this.models = models;
      this.options = options;
      this.pkFactory = pkFactory ?? utils_1.DEFAULT_PK_FACTORY;
      this.currentModelIndex = 0;
      this.previousModelIndex = 0;
      this.lastOperations = [];
      this.isBatchRetryable = true;
    }
    get errorsOnly() {
      if ("verboseResults" in this.options) {
        return !this.options.verboseResults;
      }
      return true;
    }
    hasNextBatch() {
      return this.currentModelIndex < this.models.length;
    }
    resetBatch() {
      this.currentModelIndex = this.previousModelIndex;
      return true;
    }
    buildBatch(maxMessageSizeBytes, maxWriteBatchSize, maxBsonObjectSize) {
      this.isBatchRetryable = true;
      let commandLength = 0;
      let currentNamespaceIndex = 0;
      const command = this.baseCommand();
      const namespaces = new Map;
      this.previousModelIndex = this.currentModelIndex;
      while (this.currentModelIndex < this.models.length) {
        const model = this.models[this.currentModelIndex];
        const ns = model.namespace;
        const nsIndex = namespaces.get(ns);
        if (model.name === "deleteMany" || model.name === "updateMany") {
          this.isBatchRetryable = false;
        }
        if (nsIndex != null) {
          const operation = buildOperation(model, nsIndex, this.pkFactory);
          let operationBuffer;
          try {
            operationBuffer = bson_1.BSON.serialize(operation);
          } catch (cause) {
            throw new error_1.MongoInvalidArgumentError(`Could not serialize operation to BSON`, { cause });
          }
          validateBufferSize("ops", operationBuffer, maxBsonObjectSize);
          if (commandLength + operationBuffer.length < maxMessageSizeBytes && command.ops.documents.length < maxWriteBatchSize) {
            commandLength = MESSAGE_OVERHEAD_BYTES + command.ops.push(operation, operationBuffer);
            this.currentModelIndex++;
          } else {
            break;
          }
        } else {
          namespaces.set(ns, currentNamespaceIndex);
          const nsInfo = { ns };
          const operation = buildOperation(model, currentNamespaceIndex, this.pkFactory);
          let nsInfoBuffer;
          let operationBuffer;
          try {
            nsInfoBuffer = bson_1.BSON.serialize(nsInfo);
            operationBuffer = bson_1.BSON.serialize(operation);
          } catch (cause) {
            throw new error_1.MongoInvalidArgumentError(`Could not serialize ns info to BSON`, { cause });
          }
          validateBufferSize("nsInfo", nsInfoBuffer, maxBsonObjectSize);
          validateBufferSize("ops", operationBuffer, maxBsonObjectSize);
          if (commandLength + nsInfoBuffer.length + operationBuffer.length < maxMessageSizeBytes && command.ops.documents.length < maxWriteBatchSize) {
            commandLength = MESSAGE_OVERHEAD_BYTES + command.nsInfo.push(nsInfo, nsInfoBuffer) + command.ops.push(operation, operationBuffer);
            currentNamespaceIndex++;
            this.currentModelIndex++;
          } else {
            break;
          }
        }
      }
      this.lastOperations = command.ops.documents;
      return command;
    }
    baseCommand() {
      const command = {
        bulkWrite: 1,
        errorsOnly: this.errorsOnly,
        ordered: this.options.ordered ?? true,
        ops: new commands_1.DocumentSequence("ops"),
        nsInfo: new commands_1.DocumentSequence("nsInfo")
      };
      if (this.options.bypassDocumentValidation != null) {
        command.bypassDocumentValidation = this.options.bypassDocumentValidation;
      }
      if (this.options.let) {
        command.let = this.options.let;
      }
      if (this.options.comment !== undefined) {
        command.comment = this.options.comment;
      }
      return command;
    }
  }
  exports.ClientBulkWriteCommandBuilder = ClientBulkWriteCommandBuilder;
  var buildInsertOneOperation = (model, index, pkFactory) => {
    const document2 = {
      insert: index,
      document: model.document
    };
    document2.document._id = model.document._id ?? pkFactory.createPk();
    return document2;
  };
  exports.buildInsertOneOperation = buildInsertOneOperation;
  var buildDeleteOneOperation = (model, index) => {
    return createDeleteOperation(model, index, false);
  };
  exports.buildDeleteOneOperation = buildDeleteOneOperation;
  var buildDeleteManyOperation = (model, index) => {
    return createDeleteOperation(model, index, true);
  };
  exports.buildDeleteManyOperation = buildDeleteManyOperation;
  var buildUpdateOneOperation = (model, index) => {
    return createUpdateOperation(model, index, false);
  };
  exports.buildUpdateOneOperation = buildUpdateOneOperation;
  var buildUpdateManyOperation = (model, index) => {
    return createUpdateOperation(model, index, true);
  };
  exports.buildUpdateManyOperation = buildUpdateManyOperation;
  var buildReplaceOneOperation = (model, index) => {
    if ((0, utils_1.hasAtomicOperators)(model.replacement)) {
      throw new error_1.MongoAPIError("Client bulk write replace models must not contain atomic modifiers (start with $) and must not be empty.");
    }
    const document2 = {
      update: index,
      multi: false,
      filter: model.filter,
      updateMods: model.replacement
    };
    if (model.hint) {
      document2.hint = model.hint;
    }
    if (model.upsert) {
      document2.upsert = model.upsert;
    }
    if (model.collation) {
      document2.collation = model.collation;
    }
    return document2;
  };
  exports.buildReplaceOneOperation = buildReplaceOneOperation;
});

// node_modules/mongodb/lib/operations/client_bulk_write/results_merger.js
var require_results_merger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ClientBulkWriteResultsMerger = undefined;
  var __1 = require_lib3();
  var error_1 = require_error();
  var UNACKNOWLEDGED = {
    acknowledged: false,
    insertedCount: 0,
    upsertedCount: 0,
    matchedCount: 0,
    modifiedCount: 0,
    deletedCount: 0,
    insertResults: undefined,
    updateResults: undefined,
    deleteResults: undefined
  };

  class ClientBulkWriteResultsMerger {
    static unacknowledged() {
      return UNACKNOWLEDGED;
    }
    constructor(options) {
      this.options = options;
      this.currentBatchOffset = 0;
      this.writeConcernErrors = [];
      this.writeErrors = new Map;
      this.result = {
        acknowledged: true,
        insertedCount: 0,
        upsertedCount: 0,
        matchedCount: 0,
        modifiedCount: 0,
        deletedCount: 0,
        insertResults: undefined,
        updateResults: undefined,
        deleteResults: undefined
      };
      if (options.verboseResults) {
        this.result.insertResults = new Map;
        this.result.updateResults = new Map;
        this.result.deleteResults = new Map;
      }
    }
    get bulkWriteResult() {
      return {
        acknowledged: this.result.acknowledged,
        insertedCount: this.result.insertedCount,
        upsertedCount: this.result.upsertedCount,
        matchedCount: this.result.matchedCount,
        modifiedCount: this.result.modifiedCount,
        deletedCount: this.result.deletedCount,
        insertResults: this.result.insertResults,
        updateResults: this.result.updateResults,
        deleteResults: this.result.deleteResults
      };
    }
    async merge(cursor) {
      let writeConcernErrorResult;
      try {
        for await (const document2 of cursor) {
          if (document2.ok === 1) {
            if (this.options.verboseResults) {
              this.processDocument(cursor, document2);
            }
          } else {
            if (this.options.ordered) {
              const error = new error_1.MongoClientBulkWriteError({
                message: "Mongo client ordered bulk write encountered a write error."
              });
              error.writeErrors.set(document2.idx + this.currentBatchOffset, {
                code: document2.code,
                message: document2.errmsg
              });
              error.partialResult = this.result;
              throw error;
            } else {
              this.writeErrors.set(document2.idx + this.currentBatchOffset, {
                code: document2.code,
                message: document2.errmsg
              });
            }
          }
        }
      } catch (error) {
        if (error instanceof __1.MongoWriteConcernError) {
          const result = error.result;
          writeConcernErrorResult = {
            insertedCount: result.nInserted,
            upsertedCount: result.nUpserted,
            matchedCount: result.nMatched,
            modifiedCount: result.nModified,
            deletedCount: result.nDeleted,
            writeConcernError: result.writeConcernError
          };
          if (this.options.verboseResults && result.cursor.firstBatch) {
            for (const document2 of result.cursor.firstBatch) {
              if (document2.ok === 1) {
                this.processDocument(cursor, document2);
              }
            }
          }
        } else {
          throw error;
        }
      } finally {
        if (cursor.response) {
          const response = cursor.response;
          this.incrementCounts(response);
        }
        this.currentBatchOffset += cursor.operations.length;
      }
      if (writeConcernErrorResult) {
        const writeConcernError = writeConcernErrorResult.writeConcernError;
        this.incrementCounts(writeConcernErrorResult);
        this.writeConcernErrors.push({
          code: writeConcernError.code,
          message: writeConcernError.errmsg
        });
      }
      return this.result;
    }
    processDocument(cursor, document2) {
      const operation = cursor.operations[document2.idx];
      if ("insert" in operation) {
        this.result.insertResults?.set(document2.idx + this.currentBatchOffset, {
          insertedId: operation.document._id
        });
      }
      if ("update" in operation) {
        const result = {
          matchedCount: document2.n,
          modifiedCount: document2.nModified ?? 0,
          didUpsert: document2.upserted != null
        };
        if (document2.upserted) {
          result.upsertedId = document2.upserted._id;
        }
        this.result.updateResults?.set(document2.idx + this.currentBatchOffset, result);
      }
      if ("delete" in operation) {
        this.result.deleteResults?.set(document2.idx + this.currentBatchOffset, {
          deletedCount: document2.n
        });
      }
    }
    incrementCounts(document2) {
      this.result.insertedCount += document2.insertedCount;
      this.result.upsertedCount += document2.upsertedCount;
      this.result.matchedCount += document2.matchedCount;
      this.result.modifiedCount += document2.modifiedCount;
      this.result.deletedCount += document2.deletedCount;
    }
  }
  exports.ClientBulkWriteResultsMerger = ClientBulkWriteResultsMerger;
});

// node_modules/mongodb/lib/operations/client_bulk_write/executor.js
var require_executor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ClientBulkWriteExecutor = undefined;
  var abstract_cursor_1 = require_abstract_cursor();
  var client_bulk_write_cursor_1 = require_client_bulk_write_cursor();
  var error_1 = require_error();
  var timeout_1 = require_timeout();
  var utils_1 = require_utils2();
  var write_concern_1 = require_write_concern();
  var execute_operation_1 = require_execute_operation();
  var client_bulk_write_1 = require_client_bulk_write();
  var command_builder_1 = require_command_builder();
  var results_merger_1 = require_results_merger();

  class ClientBulkWriteExecutor {
    constructor(client, operations, options) {
      if (operations.length === 0) {
        throw new error_1.MongoClientBulkWriteExecutionError("No client bulk write models were provided.");
      }
      this.client = client;
      this.operations = operations;
      this.options = {
        ordered: true,
        bypassDocumentValidation: false,
        verboseResults: false,
        ...options
      };
      if (!this.options.writeConcern) {
        this.options.writeConcern = write_concern_1.WriteConcern.fromOptions(this.client.s.options);
      }
      if (this.options.writeConcern?.w === 0) {
        if (this.options.verboseResults) {
          throw new error_1.MongoInvalidArgumentError("Cannot request unacknowledged write concern and verbose results");
        }
        if (this.options.ordered) {
          throw new error_1.MongoInvalidArgumentError("Cannot request unacknowledged write concern and ordered writes");
        }
      }
    }
    async execute() {
      const pkFactory = this.client.s.options.pkFactory;
      const commandBuilder = new command_builder_1.ClientBulkWriteCommandBuilder(this.operations, this.options, pkFactory);
      const resolvedOptions = (0, utils_1.resolveTimeoutOptions)(this.client, this.options);
      const context = timeout_1.TimeoutContext.create(resolvedOptions);
      if (this.options.writeConcern?.w === 0) {
        while (commandBuilder.hasNextBatch()) {
          const operation = new client_bulk_write_1.ClientBulkWriteOperation(commandBuilder, this.options);
          await (0, execute_operation_1.executeOperation)(this.client, operation, context);
        }
        return results_merger_1.ClientBulkWriteResultsMerger.unacknowledged();
      } else {
        const resultsMerger = new results_merger_1.ClientBulkWriteResultsMerger(this.options);
        while (commandBuilder.hasNextBatch()) {
          const cursorContext = new abstract_cursor_1.CursorTimeoutContext(context, Symbol());
          const options = {
            ...this.options,
            timeoutContext: cursorContext,
            ...resolvedOptions.timeoutMS != null && { timeoutMode: abstract_cursor_1.CursorTimeoutMode.LIFETIME }
          };
          const cursor = new client_bulk_write_cursor_1.ClientBulkWriteCursor(this.client, commandBuilder, options);
          try {
            await resultsMerger.merge(cursor);
          } catch (error) {
            if (error instanceof error_1.MongoServerError && !(error instanceof error_1.MongoClientBulkWriteError)) {
              const bulkWriteError = new error_1.MongoClientBulkWriteError({
                message: "Mongo client bulk write encountered an error during execution"
              });
              bulkWriteError.cause = error;
              bulkWriteError.partialResult = resultsMerger.bulkWriteResult;
              throw bulkWriteError;
            } else {
              throw error;
            }
          }
        }
        if (resultsMerger.writeConcernErrors.length > 0 || resultsMerger.writeErrors.size > 0) {
          const error = new error_1.MongoClientBulkWriteError({
            message: "Mongo client bulk write encountered errors during execution."
          });
          error.writeConcernErrors = resultsMerger.writeConcernErrors;
          error.writeErrors = resultsMerger.writeErrors;
          error.partialResult = resultsMerger.bulkWriteResult;
          throw error;
        }
        return resultsMerger.bulkWriteResult;
      }
    }
  }
  exports.ClientBulkWriteExecutor = ClientBulkWriteExecutor;
});

// node_modules/mongodb/lib/sdam/server_selection_events.js
var require_server_selection_events = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WaitingForSuitableServerEvent = exports.ServerSelectionSucceededEvent = exports.ServerSelectionFailedEvent = exports.ServerSelectionStartedEvent = exports.ServerSelectionEvent = undefined;
  var utils_1 = require_utils2();
  var constants_1 = require_constants2();

  class ServerSelectionEvent {
    constructor(selector, topologyDescription, operation) {
      this.selector = selector;
      this.operation = operation;
      this.topologyDescription = topologyDescription;
    }
  }
  exports.ServerSelectionEvent = ServerSelectionEvent;

  class ServerSelectionStartedEvent extends ServerSelectionEvent {
    constructor(selector, topologyDescription, operation) {
      super(selector, topologyDescription, operation);
      this.name = constants_1.SERVER_SELECTION_STARTED;
      this.message = "Server selection started";
    }
  }
  exports.ServerSelectionStartedEvent = ServerSelectionStartedEvent;

  class ServerSelectionFailedEvent extends ServerSelectionEvent {
    constructor(selector, topologyDescription, error, operation) {
      super(selector, topologyDescription, operation);
      this.name = constants_1.SERVER_SELECTION_FAILED;
      this.message = "Server selection failed";
      this.failure = error;
    }
  }
  exports.ServerSelectionFailedEvent = ServerSelectionFailedEvent;

  class ServerSelectionSucceededEvent extends ServerSelectionEvent {
    constructor(selector, topologyDescription, address, operation) {
      super(selector, topologyDescription, operation);
      this.name = constants_1.SERVER_SELECTION_SUCCEEDED;
      this.message = "Server selection succeeded";
      const { host, port } = utils_1.HostAddress.fromString(address).toHostPort();
      this.serverHost = host;
      this.serverPort = port;
    }
  }
  exports.ServerSelectionSucceededEvent = ServerSelectionSucceededEvent;

  class WaitingForSuitableServerEvent extends ServerSelectionEvent {
    constructor(selector, topologyDescription, remainingTimeMS, operation) {
      super(selector, topologyDescription, operation);
      this.name = constants_1.WAITING_FOR_SUITABLE_SERVER;
      this.message = "Waiting for suitable server to become available";
      this.remainingTimeMS = remainingTimeMS;
    }
  }
  exports.WaitingForSuitableServerEvent = WaitingForSuitableServerEvent;
});

// node_modules/mongodb/lib/sdam/srv_polling.js
var require_srv_polling = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SrvPoller = exports.SrvPollingEvent = undefined;
  var dns = import.meta.require("dns");
  var timers_1 = import.meta.require("timers");
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var utils_1 = require_utils2();

  class SrvPollingEvent {
    constructor(srvRecords) {
      this.srvRecords = srvRecords;
    }
    hostnames() {
      return new Set(this.srvRecords.map((r) => utils_1.HostAddress.fromSrvRecord(r).toString()));
    }
  }
  exports.SrvPollingEvent = SrvPollingEvent;

  class SrvPoller extends mongo_types_1.TypedEventEmitter {
    constructor(options) {
      super();
      if (!options || !options.srvHost) {
        throw new error_1.MongoRuntimeError("Options for SrvPoller must exist and include srvHost");
      }
      this.srvHost = options.srvHost;
      this.srvMaxHosts = options.srvMaxHosts ?? 0;
      this.srvServiceName = options.srvServiceName ?? "mongodb";
      this.rescanSrvIntervalMS = 60000;
      this.heartbeatFrequencyMS = options.heartbeatFrequencyMS ?? 1e4;
      this.haMode = false;
      this.generation = 0;
      this._timeout = undefined;
    }
    get srvAddress() {
      return `_${this.srvServiceName}._tcp.${this.srvHost}`;
    }
    get intervalMS() {
      return this.haMode ? this.heartbeatFrequencyMS : this.rescanSrvIntervalMS;
    }
    start() {
      if (!this._timeout) {
        this.schedule();
      }
    }
    stop() {
      if (this._timeout) {
        (0, timers_1.clearTimeout)(this._timeout);
        this.generation += 1;
        this._timeout = undefined;
      }
    }
    schedule() {
      if (this._timeout) {
        (0, timers_1.clearTimeout)(this._timeout);
      }
      this._timeout = (0, timers_1.setTimeout)(() => {
        this._poll().then(undefined, utils_1.squashError);
      }, this.intervalMS);
    }
    success(srvRecords) {
      this.haMode = false;
      this.schedule();
      this.emit(SrvPoller.SRV_RECORD_DISCOVERY, new SrvPollingEvent(srvRecords));
    }
    failure() {
      this.haMode = true;
      this.schedule();
    }
    async _poll() {
      const generation = this.generation;
      let srvRecords;
      try {
        srvRecords = await dns.promises.resolveSrv(this.srvAddress);
      } catch {
        this.failure();
        return;
      }
      if (generation !== this.generation) {
        return;
      }
      const finalAddresses = [];
      for (const record of srvRecords) {
        try {
          (0, utils_1.checkParentDomainMatch)(record.name, this.srvHost);
          finalAddresses.push(record);
        } catch (error) {
          (0, utils_1.squashError)(error);
        }
      }
      if (!finalAddresses.length) {
        this.failure();
        return;
      }
      this.success(finalAddresses);
    }
  }
  exports.SrvPoller = SrvPoller;
  SrvPoller.SRV_RECORD_DISCOVERY = "srvRecordDiscovery";
});

// node_modules/mongodb/lib/sdam/topology.js
var require_topology = __commonJS((exports) => {
  function destroyServer(server, topology) {
    for (const event of constants_1.LOCAL_SERVER_EVENTS) {
      server.removeAllListeners(event);
    }
    server.destroy();
    topology.emitAndLog(Topology.SERVER_CLOSED, new events_1.ServerClosedEvent(topology.s.id, server.description.address));
    for (const event of constants_1.SERVER_RELAY_EVENTS) {
      server.removeAllListeners(event);
    }
  }
  function topologyTypeFromOptions(options) {
    if (options?.directConnection) {
      return common_1.TopologyType.Single;
    }
    if (options?.replicaSet) {
      return common_1.TopologyType.ReplicaSetNoPrimary;
    }
    if (options?.loadBalanced) {
      return common_1.TopologyType.LoadBalanced;
    }
    return common_1.TopologyType.Unknown;
  }
  function createAndConnectServer(topology, serverDescription) {
    topology.emitAndLog(Topology.SERVER_OPENING, new events_1.ServerOpeningEvent(topology.s.id, serverDescription.address));
    const server = new server_1.Server(topology, serverDescription, topology.s.options);
    for (const event of constants_1.SERVER_RELAY_EVENTS) {
      server.on(event, (e) => topology.emit(event, e));
    }
    server.on(server_1.Server.DESCRIPTION_RECEIVED, (description) => topology.serverUpdateHandler(description));
    server.connect();
    return server;
  }
  function updateServers(topology, incomingServerDescription) {
    if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {
      const server = topology.s.servers.get(incomingServerDescription.address);
      if (server) {
        server.s.description = incomingServerDescription;
        if (incomingServerDescription.error instanceof error_1.MongoError && incomingServerDescription.error.hasErrorLabel(error_1.MongoErrorLabel.ResetPool)) {
          const interruptInUseConnections = incomingServerDescription.error.hasErrorLabel(error_1.MongoErrorLabel.InterruptInUseConnections);
          server.pool.clear({ interruptInUseConnections });
        } else if (incomingServerDescription.error == null) {
          const newTopologyType = topology.s.description.type;
          const shouldMarkPoolReady = incomingServerDescription.isDataBearing || incomingServerDescription.type !== common_1.ServerType.Unknown && newTopologyType === common_1.TopologyType.Single;
          if (shouldMarkPoolReady) {
            server.pool.ready();
          }
        }
      }
    }
    for (const serverDescription of topology.description.servers.values()) {
      if (!topology.s.servers.has(serverDescription.address)) {
        const server = createAndConnectServer(topology, serverDescription);
        topology.s.servers.set(serverDescription.address, server);
      }
    }
    for (const entry of topology.s.servers) {
      const serverAddress = entry[0];
      if (topology.description.hasServer(serverAddress)) {
        continue;
      }
      if (!topology.s.servers.has(serverAddress)) {
        continue;
      }
      const server = topology.s.servers.get(serverAddress);
      topology.s.servers.delete(serverAddress);
      if (server) {
        destroyServer(server, topology);
      }
    }
  }
  function drainWaitQueue(queue, drainError) {
    while (queue.length) {
      const waitQueueMember = queue.shift();
      if (!waitQueueMember) {
        continue;
      }
      if (!waitQueueMember.cancelled) {
        if (waitQueueMember.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
          waitQueueMember.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionFailedEvent(waitQueueMember.serverSelector, waitQueueMember.topologyDescription, drainError, waitQueueMember.operationName));
        }
        waitQueueMember.reject(drainError);
      }
    }
  }
  function processWaitQueue(topology) {
    if (topology.s.state === common_1.STATE_CLOSED) {
      drainWaitQueue(topology.waitQueue, new error_1.MongoTopologyClosedError);
      return;
    }
    const isSharded = topology.description.type === common_1.TopologyType.Sharded;
    const serverDescriptions = Array.from(topology.description.servers.values());
    const membersToProcess = topology.waitQueue.length;
    for (let i = 0;i < membersToProcess; ++i) {
      const waitQueueMember = topology.waitQueue.shift();
      if (!waitQueueMember) {
        continue;
      }
      if (waitQueueMember.cancelled) {
        continue;
      }
      let selectedDescriptions;
      try {
        const serverSelector = waitQueueMember.serverSelector;
        const previousServer = waitQueueMember.previousServer;
        selectedDescriptions = serverSelector ? serverSelector(topology.description, serverDescriptions, previousServer ? [previousServer] : []) : serverDescriptions;
      } catch (selectorError) {
        if (topology.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
          topology.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionFailedEvent(waitQueueMember.serverSelector, topology.description, selectorError, waitQueueMember.operationName));
        }
        waitQueueMember.reject(selectorError);
        continue;
      }
      let selectedServer;
      if (selectedDescriptions.length === 0) {
        if (!waitQueueMember.waitingLogged) {
          if (topology.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.INFORMATIONAL)) {
            topology.client.mongoLogger?.info(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.WaitingForSuitableServerEvent(waitQueueMember.serverSelector, topology.description, topology.s.serverSelectionTimeoutMS !== 0 ? topology.s.serverSelectionTimeoutMS - ((0, utils_1.now)() - waitQueueMember.startTime) : -1, waitQueueMember.operationName));
          }
          waitQueueMember.waitingLogged = true;
        }
        topology.waitQueue.push(waitQueueMember);
        continue;
      } else if (selectedDescriptions.length === 1) {
        selectedServer = topology.s.servers.get(selectedDescriptions[0].address);
      } else {
        const descriptions = (0, utils_1.shuffle)(selectedDescriptions, 2);
        const server1 = topology.s.servers.get(descriptions[0].address);
        const server2 = topology.s.servers.get(descriptions[1].address);
        selectedServer = server1 && server2 && server1.s.operationCount < server2.s.operationCount ? server1 : server2;
      }
      if (!selectedServer) {
        const serverSelectionError = new error_1.MongoServerSelectionError("server selection returned a server description but the server was not found in the topology", topology.description);
        if (topology.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
          topology.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionFailedEvent(waitQueueMember.serverSelector, topology.description, serverSelectionError, waitQueueMember.operationName));
        }
        waitQueueMember.reject(serverSelectionError);
        return;
      }
      const transaction = waitQueueMember.transaction;
      if (isSharded && transaction && transaction.isActive && selectedServer) {
        transaction.pinServer(selectedServer);
      }
      if (topology.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
        topology.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionSucceededEvent(waitQueueMember.serverSelector, waitQueueMember.topologyDescription, selectedServer.pool.address, waitQueueMember.operationName));
      }
      waitQueueMember.resolve(selectedServer);
    }
    if (topology.waitQueue.length > 0) {
      for (const [, server] of topology.s.servers) {
        process.nextTick(function scheduleServerCheck() {
          return server.requestCheck();
        });
      }
    }
  }
  function isStaleServerDescription(topologyDescription, incomingServerDescription) {
    const currentServerDescription = topologyDescription.servers.get(incomingServerDescription.address);
    const currentTopologyVersion = currentServerDescription?.topologyVersion;
    return (0, server_description_1.compareTopologyVersion)(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServerCapabilities = exports.Topology = undefined;
  var connection_string_1 = require_connection_string();
  var constants_1 = require_constants2();
  var error_1 = require_error();
  var mongo_logger_1 = require_mongo_logger();
  var mongo_types_1 = require_mongo_types();
  var read_preference_1 = require_read_preference();
  var timeout_1 = require_timeout();
  var utils_1 = require_utils2();
  var common_1 = require_common();
  var events_1 = require_events();
  var server_1 = require_server();
  var server_description_1 = require_server_description();
  var server_selection_1 = require_server_selection();
  var server_selection_events_1 = require_server_selection_events();
  var srv_polling_1 = require_srv_polling();
  var topology_description_1 = require_topology_description();
  var globalTopologyCounter = 0;
  var stateTransition = (0, utils_1.makeStateMachine)({
    [common_1.STATE_CLOSED]: [common_1.STATE_CLOSED, common_1.STATE_CONNECTING],
    [common_1.STATE_CONNECTING]: [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED],
    [common_1.STATE_CONNECTED]: [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED],
    [common_1.STATE_CLOSING]: [common_1.STATE_CLOSING, common_1.STATE_CLOSED]
  });

  class Topology extends mongo_types_1.TypedEventEmitter {
    constructor(client, seeds, options) {
      super();
      this.client = client;
      options = options ?? {
        hosts: [utils_1.HostAddress.fromString("localhost:27017")],
        ...Object.fromEntries(connection_string_1.DEFAULT_OPTIONS.entries())
      };
      if (typeof seeds === "string") {
        seeds = [utils_1.HostAddress.fromString(seeds)];
      } else if (!Array.isArray(seeds)) {
        seeds = [seeds];
      }
      const seedlist = [];
      for (const seed of seeds) {
        if (typeof seed === "string") {
          seedlist.push(utils_1.HostAddress.fromString(seed));
        } else if (seed instanceof utils_1.HostAddress) {
          seedlist.push(seed);
        } else {
          throw new error_1.MongoRuntimeError(`Topology cannot be constructed from ${JSON.stringify(seed)}`);
        }
      }
      const topologyType = topologyTypeFromOptions(options);
      const topologyId = globalTopologyCounter++;
      const selectedHosts = options.srvMaxHosts == null || options.srvMaxHosts === 0 || options.srvMaxHosts >= seedlist.length ? seedlist : (0, utils_1.shuffle)(seedlist, options.srvMaxHosts);
      const serverDescriptions = new Map;
      for (const hostAddress of selectedHosts) {
        serverDescriptions.set(hostAddress.toString(), new server_description_1.ServerDescription(hostAddress));
      }
      this.waitQueue = new utils_1.List;
      this.s = {
        id: topologyId,
        options,
        seedlist,
        state: common_1.STATE_CLOSED,
        description: new topology_description_1.TopologyDescription(topologyType, serverDescriptions, options.replicaSet, undefined, undefined, undefined, options),
        serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,
        heartbeatFrequencyMS: options.heartbeatFrequencyMS,
        minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS,
        servers: new Map,
        credentials: options?.credentials,
        clusterTime: undefined,
        detectShardedTopology: (ev) => this.detectShardedTopology(ev),
        detectSrvRecords: (ev) => this.detectSrvRecords(ev)
      };
      this.mongoLogger = client.mongoLogger;
      this.component = "topology";
      if (options.srvHost && !options.loadBalanced) {
        this.s.srvPoller = options.srvPoller ?? new srv_polling_1.SrvPoller({
          heartbeatFrequencyMS: this.s.heartbeatFrequencyMS,
          srvHost: options.srvHost,
          srvMaxHosts: options.srvMaxHosts,
          srvServiceName: options.srvServiceName
        });
        this.on(Topology.TOPOLOGY_DESCRIPTION_CHANGED, this.s.detectShardedTopology);
      }
      this.connectionLock = undefined;
    }
    detectShardedTopology(event) {
      const previousType = event.previousDescription.type;
      const newType = event.newDescription.type;
      const transitionToSharded = previousType !== common_1.TopologyType.Sharded && newType === common_1.TopologyType.Sharded;
      const srvListeners = this.s.srvPoller?.listeners(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY);
      const listeningToSrvPolling = !!srvListeners?.includes(this.s.detectSrvRecords);
      if (transitionToSharded && !listeningToSrvPolling) {
        this.s.srvPoller?.on(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);
        this.s.srvPoller?.start();
      }
    }
    detectSrvRecords(ev) {
      const previousTopologyDescription = this.s.description;
      this.s.description = this.s.description.updateFromSrvPollingEvent(ev, this.s.options.srvMaxHosts);
      if (this.s.description === previousTopologyDescription) {
        return;
      }
      updateServers(this);
      this.emitAndLog(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
    }
    get description() {
      return this.s.description;
    }
    get loadBalanced() {
      return this.s.options.loadBalanced;
    }
    get serverApi() {
      return this.s.options.serverApi;
    }
    get capabilities() {
      return new ServerCapabilities(this.lastHello());
    }
    async connect(options) {
      this.connectionLock ??= this._connect(options);
      try {
        await this.connectionLock;
        return this;
      } finally {
        this.connectionLock = undefined;
      }
    }
    async _connect(options) {
      options = options ?? {};
      if (this.s.state === common_1.STATE_CONNECTED) {
        return this;
      }
      stateTransition(this, common_1.STATE_CONNECTING);
      this.emitAndLog(Topology.TOPOLOGY_OPENING, new events_1.TopologyOpeningEvent(this.s.id));
      this.emitAndLog(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, new topology_description_1.TopologyDescription(common_1.TopologyType.Unknown), this.s.description));
      const serverDescriptions = Array.from(this.s.description.servers.values());
      this.s.servers = new Map(serverDescriptions.map((serverDescription) => [
        serverDescription.address,
        createAndConnectServer(this, serverDescription)
      ]));
      if (this.s.options.loadBalanced) {
        for (const description of serverDescriptions) {
          const newDescription = new server_description_1.ServerDescription(description.hostAddress, undefined, {
            loadBalanced: this.s.options.loadBalanced
          });
          this.serverUpdateHandler(newDescription);
        }
      }
      const serverSelectionTimeoutMS = this.client.s.options.serverSelectionTimeoutMS;
      const readPreference = options.readPreference ?? read_preference_1.ReadPreference.primary;
      const timeoutContext = timeout_1.TimeoutContext.create({
        timeoutMS: undefined,
        serverSelectionTimeoutMS,
        waitQueueTimeoutMS: this.client.s.options.waitQueueTimeoutMS
      });
      const selectServerOptions = {
        operationName: "ping",
        ...options,
        timeoutContext
      };
      try {
        const server = await this.selectServer((0, server_selection_1.readPreferenceServerSelector)(readPreference), selectServerOptions);
        const skipPingOnConnect = this.s.options.__skipPingOnConnect === true;
        if (!skipPingOnConnect && this.s.credentials) {
          await server.command((0, utils_1.ns)("admin.$cmd"), { ping: 1 }, { timeoutContext });
          stateTransition(this, common_1.STATE_CONNECTED);
          this.emit(Topology.OPEN, this);
          this.emit(Topology.CONNECT, this);
          return this;
        }
        stateTransition(this, common_1.STATE_CONNECTED);
        this.emit(Topology.OPEN, this);
        this.emit(Topology.CONNECT, this);
        return this;
      } catch (error) {
        this.close();
        throw error;
      }
    }
    close() {
      if (this.s.state === common_1.STATE_CLOSED || this.s.state === common_1.STATE_CLOSING) {
        return;
      }
      for (const server of this.s.servers.values()) {
        destroyServer(server, this);
      }
      this.s.servers.clear();
      stateTransition(this, common_1.STATE_CLOSING);
      drainWaitQueue(this.waitQueue, new error_1.MongoTopologyClosedError);
      if (this.s.srvPoller) {
        this.s.srvPoller.stop();
        this.s.srvPoller.removeListener(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);
      }
      this.removeListener(Topology.TOPOLOGY_DESCRIPTION_CHANGED, this.s.detectShardedTopology);
      stateTransition(this, common_1.STATE_CLOSED);
      this.emitAndLog(Topology.TOPOLOGY_CLOSED, new events_1.TopologyClosedEvent(this.s.id));
    }
    async selectServer(selector, options) {
      let serverSelector;
      if (typeof selector !== "function") {
        if (typeof selector === "string") {
          serverSelector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.fromString(selector));
        } else {
          let readPreference;
          if (selector instanceof read_preference_1.ReadPreference) {
            readPreference = selector;
          } else {
            read_preference_1.ReadPreference.translate(options);
            readPreference = options.readPreference || read_preference_1.ReadPreference.primary;
          }
          serverSelector = (0, server_selection_1.readPreferenceServerSelector)(readPreference);
        }
      } else {
        serverSelector = selector;
      }
      options = { serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS, ...options };
      if (this.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
        this.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionStartedEvent(selector, this.description, options.operationName));
      }
      let timeout;
      if (options.timeoutContext)
        timeout = options.timeoutContext.serverSelectionTimeout;
      else {
        timeout = timeout_1.Timeout.expires(options.serverSelectionTimeoutMS ?? 0);
      }
      const isSharded = this.description.type === common_1.TopologyType.Sharded;
      const session = options.session;
      const transaction = session && session.transaction;
      if (isSharded && transaction && transaction.server) {
        if (this.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
          this.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionSucceededEvent(selector, this.description, transaction.server.pool.address, options.operationName));
        }
        if (options.timeoutContext?.clearServerSelectionTimeout)
          timeout?.clear();
        return transaction.server;
      }
      const { promise: serverPromise, resolve, reject } = (0, utils_1.promiseWithResolvers)();
      const waitQueueMember = {
        serverSelector,
        topologyDescription: this.description,
        mongoLogger: this.client.mongoLogger,
        transaction,
        resolve,
        reject,
        cancelled: false,
        startTime: (0, utils_1.now)(),
        operationName: options.operationName,
        waitingLogged: false,
        previousServer: options.previousServer
      };
      const abortListener = (0, utils_1.addAbortListener)(options.signal, function() {
        waitQueueMember.cancelled = true;
        reject(this.reason);
      });
      this.waitQueue.push(waitQueueMember);
      processWaitQueue(this);
      try {
        timeout?.throwIfExpired();
        const server = await (timeout ? Promise.race([serverPromise, timeout]) : serverPromise);
        if (options.timeoutContext?.csotEnabled() && server.description.minRoundTripTime !== 0) {
          options.timeoutContext.minRoundTripTime = server.description.minRoundTripTime;
        }
        return server;
      } catch (error) {
        if (timeout_1.TimeoutError.is(error)) {
          waitQueueMember.cancelled = true;
          const timeoutError = new error_1.MongoServerSelectionError(`Server selection timed out after ${timeout?.duration} ms`, this.description);
          if (this.client.mongoLogger?.willLog(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, mongo_logger_1.SeverityLevel.DEBUG)) {
            this.client.mongoLogger?.debug(mongo_logger_1.MongoLoggableComponent.SERVER_SELECTION, new server_selection_events_1.ServerSelectionFailedEvent(selector, this.description, timeoutError, options.operationName));
          }
          if (options.timeoutContext?.csotEnabled()) {
            throw new error_1.MongoOperationTimeoutError("Timed out during server selection", {
              cause: timeoutError
            });
          }
          throw timeoutError;
        }
        throw error;
      } finally {
        abortListener?.[utils_1.kDispose]();
        if (options.timeoutContext?.clearServerSelectionTimeout)
          timeout?.clear();
      }
    }
    serverUpdateHandler(serverDescription) {
      if (!this.s.description.hasServer(serverDescription.address)) {
        return;
      }
      if (isStaleServerDescription(this.s.description, serverDescription)) {
        return;
      }
      const previousTopologyDescription = this.s.description;
      const previousServerDescription = this.s.description.servers.get(serverDescription.address);
      if (!previousServerDescription) {
        return;
      }
      const clusterTime = serverDescription.$clusterTime;
      if (clusterTime) {
        (0, common_1._advanceClusterTime)(this, clusterTime);
      }
      const equalDescriptions = previousServerDescription && previousServerDescription.equals(serverDescription);
      this.s.description = this.s.description.update(serverDescription);
      if (this.s.description.compatibilityError) {
        this.emit(Topology.ERROR, new error_1.MongoCompatibilityError(this.s.description.compatibilityError));
        return;
      }
      if (!equalDescriptions) {
        const newDescription = this.s.description.servers.get(serverDescription.address);
        if (newDescription) {
          this.emit(Topology.SERVER_DESCRIPTION_CHANGED, new events_1.ServerDescriptionChangedEvent(this.s.id, serverDescription.address, previousServerDescription, newDescription));
        }
      }
      updateServers(this, serverDescription);
      if (this.waitQueue.length > 0) {
        processWaitQueue(this);
      }
      if (!equalDescriptions) {
        this.emitAndLog(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));
      }
    }
    auth(credentials, callback) {
      if (typeof credentials === "function")
        callback = credentials, credentials = undefined;
      if (typeof callback === "function")
        callback(undefined, true);
    }
    get clientMetadata() {
      return this.s.options.metadata;
    }
    isConnected() {
      return this.s.state === common_1.STATE_CONNECTED;
    }
    isDestroyed() {
      return this.s.state === common_1.STATE_CLOSED;
    }
    lastHello() {
      const serverDescriptions = Array.from(this.description.servers.values());
      if (serverDescriptions.length === 0)
        return {};
      const sd = serverDescriptions.filter((sd2) => sd2.type !== common_1.ServerType.Unknown)[0];
      const result = sd || { maxWireVersion: this.description.commonWireVersion };
      return result;
    }
    get commonWireVersion() {
      return this.description.commonWireVersion;
    }
    get logicalSessionTimeoutMinutes() {
      return this.description.logicalSessionTimeoutMinutes;
    }
    get clusterTime() {
      return this.s.clusterTime;
    }
    set clusterTime(clusterTime) {
      this.s.clusterTime = clusterTime;
    }
  }
  exports.Topology = Topology;
  Topology.SERVER_OPENING = constants_1.SERVER_OPENING;
  Topology.SERVER_CLOSED = constants_1.SERVER_CLOSED;
  Topology.SERVER_DESCRIPTION_CHANGED = constants_1.SERVER_DESCRIPTION_CHANGED;
  Topology.TOPOLOGY_OPENING = constants_1.TOPOLOGY_OPENING;
  Topology.TOPOLOGY_CLOSED = constants_1.TOPOLOGY_CLOSED;
  Topology.TOPOLOGY_DESCRIPTION_CHANGED = constants_1.TOPOLOGY_DESCRIPTION_CHANGED;
  Topology.ERROR = constants_1.ERROR;
  Topology.OPEN = constants_1.OPEN;
  Topology.CONNECT = constants_1.CONNECT;
  Topology.CLOSE = constants_1.CLOSE;
  Topology.TIMEOUT = constants_1.TIMEOUT;

  class ServerCapabilities {
    constructor(hello) {
      this.minWireVersion = hello.minWireVersion || 0;
      this.maxWireVersion = hello.maxWireVersion || 0;
    }
    get hasAggregationCursor() {
      return this.maxWireVersion >= 1;
    }
    get hasWriteCommands() {
      return this.maxWireVersion >= 2;
    }
    get hasTextSearch() {
      return this.minWireVersion >= 0;
    }
    get hasAuthCommands() {
      return this.maxWireVersion >= 1;
    }
    get hasListCollectionsCommand() {
      return this.maxWireVersion >= 3;
    }
    get hasListIndexesCommand() {
      return this.maxWireVersion >= 3;
    }
    get supportsSnapshotReads() {
      return this.maxWireVersion >= 13;
    }
    get commandsTakeWriteConcern() {
      return this.maxWireVersion >= 5;
    }
    get commandsTakeCollation() {
      return this.maxWireVersion >= 5;
    }
  }
  exports.ServerCapabilities = ServerCapabilities;
});

// node_modules/mongodb/lib/mongo_client.js
var require_mongo_client = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoClient = exports.ServerApiVersion = undefined;
  var fs_1 = import.meta.require("fs");
  var bson_1 = require_bson2();
  var change_stream_1 = require_change_stream();
  var mongo_credentials_1 = require_mongo_credentials();
  var providers_1 = require_providers();
  var connection_string_1 = require_connection_string();
  var constants_1 = require_constants2();
  var db_1 = require_db();
  var error_1 = require_error();
  var mongo_client_auth_providers_1 = require_mongo_client_auth_providers();
  var mongo_logger_1 = require_mongo_logger();
  var mongo_types_1 = require_mongo_types();
  var executor_1 = require_executor();
  var execute_operation_1 = require_execute_operation();
  var run_command_1 = require_run_command();
  var read_preference_1 = require_read_preference();
  var resource_management_1 = require_resource_management();
  var server_selection_1 = require_server_selection();
  var topology_1 = require_topology();
  var sessions_1 = require_sessions();
  var utils_1 = require_utils2();
  exports.ServerApiVersion = Object.freeze({
    v1: "1"
  });

  class MongoClient extends mongo_types_1.TypedEventEmitter {
    constructor(url, options) {
      super();
      this.options = (0, connection_string_1.parseOptions)(url, this, options);
      const shouldSetLogger = Object.values(this.options.mongoLoggerOptions.componentSeverities).some((value) => value !== mongo_logger_1.SeverityLevel.OFF);
      this.mongoLogger = shouldSetLogger ? new mongo_logger_1.MongoLogger(this.options.mongoLoggerOptions) : undefined;
      const client = this;
      this.s = {
        url,
        bsonOptions: (0, bson_1.resolveBSONOptions)(this.options),
        namespace: (0, utils_1.ns)("admin"),
        hasBeenClosed: false,
        sessionPool: new sessions_1.ServerSessionPool(this),
        activeSessions: new Set,
        activeCursors: new Set,
        authProviders: new mongo_client_auth_providers_1.MongoClientAuthProviders,
        get options() {
          return client.options;
        },
        get readConcern() {
          return client.options.readConcern;
        },
        get writeConcern() {
          return client.options.writeConcern;
        },
        get readPreference() {
          return client.options.readPreference;
        },
        get isMongoClient() {
          return true;
        }
      };
      this.checkForNonGenuineHosts();
    }
    async asyncDispose() {
      await this.close();
    }
    checkForNonGenuineHosts() {
      const documentDBHostnames = this.options.hosts.filter((hostAddress) => (0, utils_1.isHostMatch)(utils_1.DOCUMENT_DB_CHECK, hostAddress.host));
      const srvHostIsDocumentDB = (0, utils_1.isHostMatch)(utils_1.DOCUMENT_DB_CHECK, this.options.srvHost);
      const cosmosDBHostnames = this.options.hosts.filter((hostAddress) => (0, utils_1.isHostMatch)(utils_1.COSMOS_DB_CHECK, hostAddress.host));
      const srvHostIsCosmosDB = (0, utils_1.isHostMatch)(utils_1.COSMOS_DB_CHECK, this.options.srvHost);
      if (documentDBHostnames.length !== 0 || srvHostIsDocumentDB) {
        this.mongoLogger?.info("client", utils_1.DOCUMENT_DB_MSG);
      } else if (cosmosDBHostnames.length !== 0 || srvHostIsCosmosDB) {
        this.mongoLogger?.info("client", utils_1.COSMOS_DB_MSG);
      }
    }
    get serverApi() {
      return this.options.serverApi && Object.freeze({ ...this.options.serverApi });
    }
    get monitorCommands() {
      return this.options.monitorCommands;
    }
    set monitorCommands(value) {
      this.options.monitorCommands = value;
    }
    get autoEncrypter() {
      return this.options.autoEncrypter;
    }
    get readConcern() {
      return this.s.readConcern;
    }
    get writeConcern() {
      return this.s.writeConcern;
    }
    get readPreference() {
      return this.s.readPreference;
    }
    get bsonOptions() {
      return this.s.bsonOptions;
    }
    get timeoutMS() {
      return this.s.options.timeoutMS;
    }
    async bulkWrite(models, options) {
      if (this.autoEncrypter) {
        throw new error_1.MongoInvalidArgumentError("MongoClient bulkWrite does not currently support automatic encryption.");
      }
      return await new executor_1.ClientBulkWriteExecutor(this, models, (0, utils_1.resolveOptions)(this, options)).execute();
    }
    async connect() {
      if (this.connectionLock) {
        return await this.connectionLock;
      }
      try {
        this.connectionLock = this._connect();
        await this.connectionLock;
      } finally {
        this.connectionLock = undefined;
      }
      return this;
    }
    async _connect() {
      if (this.topology && this.topology.isConnected()) {
        return this;
      }
      const options = this.options;
      if (options.tls) {
        if (typeof options.tlsCAFile === "string") {
          options.ca ??= await fs_1.promises.readFile(options.tlsCAFile);
        }
        if (typeof options.tlsCRLFile === "string") {
          options.crl ??= await fs_1.promises.readFile(options.tlsCRLFile);
        }
        if (typeof options.tlsCertificateKeyFile === "string") {
          if (!options.key || !options.cert) {
            const contents = await fs_1.promises.readFile(options.tlsCertificateKeyFile);
            options.key ??= contents;
            options.cert ??= contents;
          }
        }
      }
      if (typeof options.srvHost === "string") {
        const hosts = await (0, connection_string_1.resolveSRVRecord)(options);
        for (const [index, host] of hosts.entries()) {
          options.hosts[index] = host;
        }
      }
      if (options.credentials?.mechanism === providers_1.AuthMechanism.MONGODB_OIDC) {
        const allowedHosts = options.credentials?.mechanismProperties?.ALLOWED_HOSTS || mongo_credentials_1.DEFAULT_ALLOWED_HOSTS;
        const isServiceAuth = !!options.credentials?.mechanismProperties?.ENVIRONMENT;
        if (!isServiceAuth) {
          for (const host of options.hosts) {
            if (!(0, utils_1.hostMatchesWildcards)(host.toHostPort().host, allowedHosts)) {
              throw new error_1.MongoInvalidArgumentError(`Host '${host}' is not valid for OIDC authentication with ALLOWED_HOSTS of '${allowedHosts.join(",")}'`);
            }
          }
        }
      }
      this.topology = new topology_1.Topology(this, options.hosts, options);
      this.topology.once(topology_1.Topology.OPEN, () => this.emit("open", this));
      for (const event of constants_1.MONGO_CLIENT_EVENTS) {
        this.topology.on(event, (...args) => this.emit(event, ...args));
      }
      const topologyConnect = async () => {
        try {
          await this.topology?.connect(options);
        } catch (error) {
          this.topology?.close();
          throw error;
        }
      };
      if (this.autoEncrypter) {
        await this.autoEncrypter?.init();
        await topologyConnect();
        await options.encrypter.connectInternalClient();
      } else {
        await topologyConnect();
      }
      return this;
    }
    async close(force = false) {
      if (this.closeLock) {
        return await this.closeLock;
      }
      try {
        this.closeLock = this._close(force);
        await this.closeLock;
      } finally {
        this.closeLock = undefined;
      }
    }
    async _close(force = false) {
      Object.defineProperty(this.s, "hasBeenClosed", {
        value: true,
        enumerable: true,
        configurable: false,
        writable: false
      });
      const activeCursorCloses = Array.from(this.s.activeCursors, (cursor) => cursor.close());
      this.s.activeCursors.clear();
      await Promise.all(activeCursorCloses);
      const activeSessionEnds = Array.from(this.s.activeSessions, (session) => session.endSession());
      this.s.activeSessions.clear();
      await Promise.all(activeSessionEnds);
      if (this.topology == null) {
        return;
      }
      const selector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.primaryPreferred);
      const topologyDescription = this.topology.description;
      const serverDescriptions = Array.from(topologyDescription.servers.values());
      const servers = selector(topologyDescription, serverDescriptions);
      if (servers.length !== 0) {
        const endSessions = Array.from(this.s.sessionPool.sessions, ({ id }) => id);
        if (endSessions.length !== 0) {
          try {
            await (0, execute_operation_1.executeOperation)(this, new run_command_1.RunAdminCommandOperation({ endSessions }, { readPreference: read_preference_1.ReadPreference.primaryPreferred, noResponse: true }));
          } catch (error) {
            (0, utils_1.squashError)(error);
          }
        }
      }
      const topology = this.topology;
      this.topology = undefined;
      topology.close();
      const { encrypter } = this.options;
      if (encrypter) {
        await encrypter.close(this, force);
      }
    }
    db(dbName, options) {
      options = options ?? {};
      if (!dbName) {
        dbName = this.s.options.dbName;
      }
      const finalOptions = Object.assign({}, this.options, options);
      const db = new db_1.Db(this, dbName, finalOptions);
      return db;
    }
    static async connect(url, options) {
      const client = new this(url, options);
      return await client.connect();
    }
    startSession(options) {
      const session = new sessions_1.ClientSession(this, this.s.sessionPool, { explicit: true, ...options }, this.options);
      this.s.activeSessions.add(session);
      session.once("ended", () => {
        this.s.activeSessions.delete(session);
      });
      return session;
    }
    async withSession(optionsOrExecutor, executor) {
      const options = {
        owner: Symbol(),
        ...typeof optionsOrExecutor === "object" ? optionsOrExecutor : {}
      };
      const withSessionCallback = typeof optionsOrExecutor === "function" ? optionsOrExecutor : executor;
      if (withSessionCallback == null) {
        throw new error_1.MongoInvalidArgumentError("Missing required callback parameter");
      }
      const session = this.startSession(options);
      try {
        return await withSessionCallback(session);
      } finally {
        try {
          await session.endSession();
        } catch (error) {
          (0, utils_1.squashError)(error);
        }
      }
    }
    watch(pipeline = [], options = {}) {
      if (!Array.isArray(pipeline)) {
        options = pipeline;
        pipeline = [];
      }
      return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));
    }
  }
  exports.MongoClient = MongoClient;
  (0, resource_management_1.configureResourceManagement)(MongoClient.prototype);
});

// node_modules/mongodb/lib/resource_management.js
var require_resource_management = __commonJS((exports) => {
  function configureResourceManagement(target) {
    Symbol.asyncDispose && Object.defineProperty(target, Symbol.asyncDispose, {
      value: async function asyncDispose() {
        await this.asyncDispose();
      },
      enumerable: false,
      configurable: true,
      writable: true
    });
  }
  function configureExplicitResourceManagement() {
    const { MongoClient } = require_mongo_client();
    const { ClientSession } = require_sessions();
    const { AbstractCursor } = require_abstract_cursor();
    const { ChangeStream } = require_change_stream();
    configureResourceManagement(MongoClient.prototype);
    configureResourceManagement(ClientSession.prototype);
    configureResourceManagement(AbstractCursor.prototype);
    configureResourceManagement(ChangeStream.prototype);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.configureResourceManagement = configureResourceManagement;
  exports.configureExplicitResourceManagement = configureExplicitResourceManagement;
});

// node_modules/mongodb/lib/cursor/abstract_cursor.js
var require_abstract_cursor = __commonJS((exports) => {
  function removeActiveCursor() {
    this.client.s.activeCursors.delete(this);
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CursorTimeoutContext = exports.AbstractCursor = exports.CursorTimeoutMode = exports.CURSOR_FLAGS = undefined;
  var stream_1 = import.meta.require("stream");
  var bson_1 = require_bson2();
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var execute_operation_1 = require_execute_operation();
  var get_more_1 = require_get_more();
  var kill_cursors_1 = require_kill_cursors();
  var read_concern_1 = require_read_concern();
  var read_preference_1 = require_read_preference();
  var resource_management_1 = require_resource_management();
  var sessions_1 = require_sessions();
  var timeout_1 = require_timeout();
  var utils_1 = require_utils2();
  exports.CURSOR_FLAGS = [
    "tailable",
    "oplogReplay",
    "noCursorTimeout",
    "awaitData",
    "exhaust",
    "partial"
  ];
  exports.CursorTimeoutMode = Object.freeze({
    ITERATION: "iteration",
    LIFETIME: "cursorLifetime"
  });

  class AbstractCursor extends mongo_types_1.TypedEventEmitter {
    constructor(client, namespace, options = {}) {
      super();
      this.documents = null;
      this.hasEmittedClose = false;
      if (!client.s.isMongoClient) {
        throw new error_1.MongoRuntimeError("Cursor must be constructed with MongoClient");
      }
      this.cursorClient = client;
      this.cursorNamespace = namespace;
      this.cursorId = null;
      this.initialized = false;
      this.isClosed = false;
      this.isKilled = false;
      this.cursorOptions = {
        readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference ? options.readPreference : read_preference_1.ReadPreference.primary,
        ...(0, bson_1.pluckBSONSerializeOptions)(options),
        timeoutMS: options?.timeoutContext?.csotEnabled() ? options.timeoutContext.timeoutMS : options.timeoutMS,
        tailable: options.tailable,
        awaitData: options.awaitData
      };
      if (this.cursorOptions.timeoutMS != null) {
        if (options.timeoutMode == null) {
          if (options.tailable) {
            if (options.awaitData) {
              if (options.maxAwaitTimeMS != null && options.maxAwaitTimeMS >= this.cursorOptions.timeoutMS)
                throw new error_1.MongoInvalidArgumentError("Cannot specify maxAwaitTimeMS >= timeoutMS for a tailable awaitData cursor");
            }
            this.cursorOptions.timeoutMode = exports.CursorTimeoutMode.ITERATION;
          } else {
            this.cursorOptions.timeoutMode = exports.CursorTimeoutMode.LIFETIME;
          }
        } else {
          if (options.tailable && options.timeoutMode === exports.CursorTimeoutMode.LIFETIME) {
            throw new error_1.MongoInvalidArgumentError("Cannot set tailable cursor's timeoutMode to LIFETIME");
          }
          this.cursorOptions.timeoutMode = options.timeoutMode;
        }
      } else {
        if (options.timeoutMode != null)
          throw new error_1.MongoInvalidArgumentError("Cannot set timeoutMode without setting timeoutMS");
      }
      this.cursorOptions.omitMaxTimeMS = this.cursorOptions.timeoutMS != null && (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && !this.cursorOptions.tailable || this.cursorOptions.tailable && !this.cursorOptions.awaitData);
      const readConcern = read_concern_1.ReadConcern.fromOptions(options);
      if (readConcern) {
        this.cursorOptions.readConcern = readConcern;
      }
      if (typeof options.batchSize === "number") {
        this.cursorOptions.batchSize = options.batchSize;
      }
      if (options.comment !== undefined) {
        this.cursorOptions.comment = options.comment;
      }
      if (typeof options.maxTimeMS === "number") {
        this.cursorOptions.maxTimeMS = options.maxTimeMS;
      }
      if (typeof options.maxAwaitTimeMS === "number") {
        this.cursorOptions.maxAwaitTimeMS = options.maxAwaitTimeMS;
      }
      if (options.session instanceof sessions_1.ClientSession) {
        this.cursorSession = options.session;
      } else {
        this.cursorSession = this.cursorClient.startSession({ owner: this, explicit: false });
      }
      this.deserializationOptions = {
        ...this.cursorOptions,
        validation: {
          utf8: options?.enableUtf8Validation === false ? false : true
        }
      };
      this.timeoutContext = options.timeoutContext;
      this.signal = options.signal;
      this.abortListener = (0, utils_1.addAbortListener)(this.signal, () => void this.close().then(undefined, utils_1.squashError));
      this.trackCursor();
    }
    get id() {
      return this.cursorId ?? undefined;
    }
    get isDead() {
      return (this.cursorId?.isZero() ?? false) || this.isClosed || this.isKilled;
    }
    get client() {
      return this.cursorClient;
    }
    get server() {
      return this.selectedServer;
    }
    get namespace() {
      return this.cursorNamespace;
    }
    get readPreference() {
      return this.cursorOptions.readPreference;
    }
    get readConcern() {
      return this.cursorOptions.readConcern;
    }
    get session() {
      return this.cursorSession;
    }
    set session(clientSession) {
      this.cursorSession = clientSession;
    }
    get closed() {
      return this.isClosed && (this.documents?.length ?? 0) === 0;
    }
    get killed() {
      return this.isKilled;
    }
    get loadBalanced() {
      return !!this.cursorClient.topology?.loadBalanced;
    }
    async asyncDispose() {
      await this.close();
    }
    trackCursor() {
      this.cursorClient.s.activeCursors.add(this);
      if (!this.listeners("close").includes(removeActiveCursor)) {
        this.once("close", removeActiveCursor);
      }
    }
    bufferedCount() {
      return this.documents?.length ?? 0;
    }
    readBufferedDocuments(number) {
      const bufferedDocs = [];
      const documentsToRead = Math.min(number ?? this.documents?.length ?? 0, this.documents?.length ?? 0);
      for (let count = 0;count < documentsToRead; count++) {
        const document2 = this.documents?.shift(this.deserializationOptions);
        if (document2 != null) {
          bufferedDocs.push(document2);
        }
      }
      return bufferedDocs;
    }
    async* [Symbol.asyncIterator]() {
      this.signal?.throwIfAborted();
      if (this.closed) {
        return;
      }
      try {
        while (true) {
          if (this.isKilled) {
            return;
          }
          if (this.closed) {
            return;
          }
          if (this.cursorId != null && this.isDead && (this.documents?.length ?? 0) === 0) {
            return;
          }
          const document2 = await this.next();
          if (document2 === null) {
            return;
          }
          yield document2;
          this.signal?.throwIfAborted();
        }
      } finally {
        if (!this.isClosed) {
          try {
            await this.close();
          } catch (error) {
            (0, utils_1.squashError)(error);
          }
        }
      }
    }
    stream(options) {
      const readable = new ReadableCursorStream(this);
      const abortListener = (0, utils_1.addAbortListener)(this.signal, function() {
        readable.destroy(this.reason);
      });
      readable.once("end", () => {
        abortListener?.[utils_1.kDispose]();
      });
      if (options?.transform) {
        const transform = options.transform;
        const transformedStream = readable.pipe(new stream_1.Transform({
          objectMode: true,
          highWaterMark: 1,
          transform(chunk, _2, callback) {
            try {
              const transformed = transform(chunk);
              callback(undefined, transformed);
            } catch (err) {
              callback(err);
            }
          }
        }));
        readable.on("error", (err) => transformedStream.emit("error", err));
        return transformedStream;
      }
      return readable;
    }
    async hasNext() {
      this.signal?.throwIfAborted();
      if (this.cursorId === bson_1.Long.ZERO) {
        return false;
      }
      if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && this.cursorId != null) {
        this.timeoutContext?.refresh();
      }
      try {
        do {
          if ((this.documents?.length ?? 0) !== 0) {
            return true;
          }
          await this.fetchBatch();
        } while (!this.isDead || (this.documents?.length ?? 0) !== 0);
      } finally {
        if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION) {
          this.timeoutContext?.clear();
        }
      }
      return false;
    }
    async next() {
      this.signal?.throwIfAborted();
      if (this.cursorId === bson_1.Long.ZERO) {
        throw new error_1.MongoCursorExhaustedError;
      }
      if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && this.cursorId != null) {
        this.timeoutContext?.refresh();
      }
      try {
        do {
          const doc = this.documents?.shift(this.deserializationOptions);
          if (doc != null) {
            if (this.transform != null)
              return await this.transformDocument(doc);
            return doc;
          }
          await this.fetchBatch();
        } while (!this.isDead || (this.documents?.length ?? 0) !== 0);
      } finally {
        if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION) {
          this.timeoutContext?.clear();
        }
      }
      return null;
    }
    async tryNext() {
      this.signal?.throwIfAborted();
      if (this.cursorId === bson_1.Long.ZERO) {
        throw new error_1.MongoCursorExhaustedError;
      }
      if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION && this.cursorId != null) {
        this.timeoutContext?.refresh();
      }
      try {
        let doc = this.documents?.shift(this.deserializationOptions);
        if (doc != null) {
          if (this.transform != null)
            return await this.transformDocument(doc);
          return doc;
        }
        await this.fetchBatch();
        doc = this.documents?.shift(this.deserializationOptions);
        if (doc != null) {
          if (this.transform != null)
            return await this.transformDocument(doc);
          return doc;
        }
      } finally {
        if (this.cursorOptions.timeoutMode === exports.CursorTimeoutMode.ITERATION) {
          this.timeoutContext?.clear();
        }
      }
      return null;
    }
    async forEach(iterator) {
      this.signal?.throwIfAborted();
      if (typeof iterator !== "function") {
        throw new error_1.MongoInvalidArgumentError('Argument "iterator" must be a function');
      }
      for await (const document2 of this) {
        const result = iterator(document2);
        if (result === false) {
          break;
        }
      }
    }
    async close(options) {
      await this.cleanup(options?.timeoutMS);
    }
    async toArray() {
      this.signal?.throwIfAborted();
      const array = [];
      for await (const document2 of this) {
        array.push(document2);
        const docs = this.readBufferedDocuments();
        if (this.transform != null) {
          for (const doc of docs) {
            array.push(await this.transformDocument(doc));
          }
        } else {
          array.push(...docs);
        }
      }
      return array;
    }
    addCursorFlag(flag, value) {
      this.throwIfInitialized();
      if (!exports.CURSOR_FLAGS.includes(flag)) {
        throw new error_1.MongoInvalidArgumentError(`Flag ${flag} is not one of ${exports.CURSOR_FLAGS}`);
      }
      if (typeof value !== "boolean") {
        throw new error_1.MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);
      }
      this.cursorOptions[flag] = value;
      return this;
    }
    map(transform) {
      this.throwIfInitialized();
      const oldTransform = this.transform;
      if (oldTransform) {
        this.transform = (doc) => {
          return transform(oldTransform(doc));
        };
      } else {
        this.transform = transform;
      }
      return this;
    }
    withReadPreference(readPreference) {
      this.throwIfInitialized();
      if (readPreference instanceof read_preference_1.ReadPreference) {
        this.cursorOptions.readPreference = readPreference;
      } else if (typeof readPreference === "string") {
        this.cursorOptions.readPreference = read_preference_1.ReadPreference.fromString(readPreference);
      } else {
        throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);
      }
      return this;
    }
    withReadConcern(readConcern) {
      this.throwIfInitialized();
      const resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({ readConcern });
      if (resolvedReadConcern) {
        this.cursorOptions.readConcern = resolvedReadConcern;
      }
      return this;
    }
    maxTimeMS(value) {
      this.throwIfInitialized();
      if (typeof value !== "number") {
        throw new error_1.MongoInvalidArgumentError("Argument for maxTimeMS must be a number");
      }
      this.cursorOptions.maxTimeMS = value;
      return this;
    }
    batchSize(value) {
      this.throwIfInitialized();
      if (this.cursorOptions.tailable) {
        throw new error_1.MongoTailableCursorError("Tailable cursor does not support batchSize");
      }
      if (typeof value !== "number") {
        throw new error_1.MongoInvalidArgumentError('Operation "batchSize" requires an integer');
      }
      this.cursorOptions.batchSize = value;
      return this;
    }
    rewind() {
      if (this.timeoutContext && this.timeoutContext.owner !== this) {
        throw new error_1.MongoAPIError(`Cannot rewind cursor that does not own its timeout context.`);
      }
      if (!this.initialized) {
        return;
      }
      this.cursorId = null;
      this.documents?.clear();
      this.timeoutContext?.clear();
      this.timeoutContext = undefined;
      this.isClosed = false;
      this.isKilled = false;
      this.initialized = false;
      this.hasEmittedClose = false;
      this.trackCursor();
      if (this.cursorSession.explicit === false) {
        if (!this.cursorSession.hasEnded) {
          this.cursorSession.endSession().then(undefined, utils_1.squashError);
        }
        this.cursorSession = this.cursorClient.startSession({ owner: this, explicit: false });
      }
    }
    async getMore(batchSize) {
      if (this.cursorId == null) {
        throw new error_1.MongoRuntimeError("Unexpected null cursor id. A cursor creating command should have set this");
      }
      if (this.selectedServer == null) {
        throw new error_1.MongoRuntimeError("Unexpected null selectedServer. A cursor creating command should have set this");
      }
      const getMoreOptions = {
        ...this.cursorOptions,
        session: this.cursorSession,
        batchSize
      };
      const getMoreOperation = new get_more_1.GetMoreOperation(this.cursorNamespace, this.cursorId, this.selectedServer, getMoreOptions);
      return await (0, execute_operation_1.executeOperation)(this.cursorClient, getMoreOperation, this.timeoutContext);
    }
    async cursorInit() {
      if (this.cursorOptions.timeoutMS != null) {
        this.timeoutContext ??= new CursorTimeoutContext(timeout_1.TimeoutContext.create({
          serverSelectionTimeoutMS: this.client.s.options.serverSelectionTimeoutMS,
          timeoutMS: this.cursorOptions.timeoutMS
        }), this);
      }
      try {
        const state = await this._initialize(this.cursorSession);
        this.cursorOptions.omitMaxTimeMS = this.cursorOptions.timeoutMS != null;
        const response = state.response;
        this.selectedServer = state.server;
        this.cursorId = response.id;
        this.cursorNamespace = response.ns ?? this.namespace;
        this.documents = response;
        this.initialized = true;
      } catch (error) {
        this.initialized = true;
        await this.cleanup(undefined, error);
        throw error;
      }
      if (this.isDead) {
        await this.cleanup();
      }
      return;
    }
    async fetchBatch() {
      if (this.isClosed) {
        return;
      }
      if (this.isDead) {
        await this.cleanup();
        return;
      }
      if (this.cursorId == null) {
        await this.cursorInit();
        if ((this.documents?.length ?? 0) !== 0 || this.isDead)
          return;
      }
      const batchSize = this.cursorOptions.batchSize || 1000;
      try {
        const response = await this.getMore(batchSize);
        this.cursorId = response.id;
        this.documents = response;
      } catch (error) {
        try {
          await this.cleanup(undefined, error);
        } catch (cleanupError) {
          (0, utils_1.squashError)(cleanupError);
        }
        throw error;
      }
      if (this.isDead) {
        await this.cleanup();
      }
    }
    async cleanup(timeoutMS, error) {
      this.abortListener?.[utils_1.kDispose]();
      this.isClosed = true;
      const timeoutContextForKillCursors = () => {
        if (timeoutMS != null) {
          this.timeoutContext?.clear();
          return new CursorTimeoutContext(timeout_1.TimeoutContext.create({
            serverSelectionTimeoutMS: this.client.s.options.serverSelectionTimeoutMS,
            timeoutMS
          }), this);
        } else {
          return this.timeoutContext?.refreshed();
        }
      };
      try {
        if (!this.isKilled && this.cursorId && !this.cursorId.isZero() && this.cursorNamespace && this.selectedServer && !this.cursorSession.hasEnded) {
          this.isKilled = true;
          const cursorId = this.cursorId;
          this.cursorId = bson_1.Long.ZERO;
          await (0, execute_operation_1.executeOperation)(this.cursorClient, new kill_cursors_1.KillCursorsOperation(cursorId, this.cursorNamespace, this.selectedServer, {
            session: this.cursorSession
          }), timeoutContextForKillCursors());
        }
      } catch (error2) {
        (0, utils_1.squashError)(error2);
      } finally {
        try {
          if (this.cursorSession?.owner === this) {
            await this.cursorSession.endSession({ error });
          }
          if (!this.cursorSession?.inTransaction()) {
            (0, sessions_1.maybeClearPinnedConnection)(this.cursorSession, { error });
          }
        } finally {
          this.emitClose();
        }
      }
    }
    emitClose() {
      try {
        if (!this.hasEmittedClose && ((this.documents?.length ?? 0) === 0 || this.isClosed)) {
          this.emit("close");
        }
      } finally {
        this.hasEmittedClose = true;
      }
    }
    async transformDocument(document2) {
      if (this.transform == null)
        return document2;
      try {
        const transformedDocument = this.transform(document2);
        if (transformedDocument === null) {
          const TRANSFORM_TO_NULL_ERROR = "Cursor returned a `null` document, but the cursor is not exhausted.  Mapping documents to `null` is not supported in the cursor transform.";
          throw new error_1.MongoAPIError(TRANSFORM_TO_NULL_ERROR);
        }
        return transformedDocument;
      } catch (transformError) {
        try {
          await this.close();
        } catch (closeError) {
          (0, utils_1.squashError)(closeError);
        }
        throw transformError;
      }
    }
    throwIfInitialized() {
      if (this.initialized)
        throw new error_1.MongoCursorInUseError;
    }
  }
  exports.AbstractCursor = AbstractCursor;
  AbstractCursor.CLOSE = "close";

  class ReadableCursorStream extends stream_1.Readable {
    constructor(cursor) {
      super({
        objectMode: true,
        autoDestroy: false,
        highWaterMark: 1
      });
      this._readInProgress = false;
      this._cursor = cursor;
    }
    _read(size) {
      if (!this._readInProgress) {
        this._readInProgress = true;
        this._readNext();
      }
    }
    _destroy(error, callback) {
      this._cursor.close().then(() => callback(error), (closeError) => callback(closeError));
    }
    _readNext() {
      if (this._cursor.id === bson_1.Long.ZERO) {
        this.push(null);
        return;
      }
      this._cursor.next().then((result) => {
        if (result == null) {
          this.push(null);
        } else if (this.destroyed) {
          this._cursor.close().then(undefined, utils_1.squashError);
        } else {
          if (this.push(result)) {
            return this._readNext();
          }
          this._readInProgress = false;
        }
      }, (err) => {
        if (err.message.match(/server is closed/)) {
          this._cursor.close().then(undefined, utils_1.squashError);
          return this.push(null);
        }
        if (err.message.match(/operation was interrupted/)) {
          return this.push(null);
        }
        return this.destroy(err);
      });
    }
  }
  (0, resource_management_1.configureResourceManagement)(AbstractCursor.prototype);

  class CursorTimeoutContext extends timeout_1.TimeoutContext {
    constructor(timeoutContext, owner) {
      super();
      this.timeoutContext = timeoutContext;
      this.owner = owner;
    }
    get serverSelectionTimeout() {
      return this.timeoutContext.serverSelectionTimeout;
    }
    get connectionCheckoutTimeout() {
      return this.timeoutContext.connectionCheckoutTimeout;
    }
    get clearServerSelectionTimeout() {
      return this.timeoutContext.clearServerSelectionTimeout;
    }
    get timeoutForSocketWrite() {
      return this.timeoutContext.timeoutForSocketWrite;
    }
    get timeoutForSocketRead() {
      return this.timeoutContext.timeoutForSocketRead;
    }
    csotEnabled() {
      return this.timeoutContext.csotEnabled();
    }
    refresh() {
      if (typeof this.owner !== "symbol")
        return this.timeoutContext.refresh();
    }
    clear() {
      if (typeof this.owner !== "symbol")
        return this.timeoutContext.clear();
    }
    get maxTimeMS() {
      return this.timeoutContext.maxTimeMS;
    }
    get timeoutMS() {
      return this.timeoutContext.csotEnabled() ? this.timeoutContext.timeoutMS : null;
    }
    refreshed() {
      return new CursorTimeoutContext(this.timeoutContext.refreshed(), this.owner);
    }
    addMaxTimeMSToCommand(command, options) {
      this.timeoutContext.addMaxTimeMSToCommand(command, options);
    }
    getSocketTimeoutMS() {
      return this.timeoutContext.getSocketTimeoutMS();
    }
  }
  exports.CursorTimeoutContext = CursorTimeoutContext;
});

// node_modules/mongodb/lib/explain.js
var require_explain = __commonJS((exports) => {
  function validateExplainTimeoutOptions(options, explain) {
    const { maxTimeMS, timeoutMS } = options;
    if (timeoutMS != null && (maxTimeMS != null || explain?.maxTimeMS != null)) {
      throw new error_1.MongoAPIError("Cannot use maxTimeMS with timeoutMS for explain commands.");
    }
  }
  function decorateWithExplain(command, explain) {
    const { verbosity, maxTimeMS } = explain;
    const baseCommand = { explain: command, verbosity };
    if (typeof maxTimeMS === "number") {
      baseCommand.maxTimeMS = maxTimeMS;
    }
    return baseCommand;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExplainableCursor = exports.Explain = exports.ExplainVerbosity = undefined;
  exports.validateExplainTimeoutOptions = validateExplainTimeoutOptions;
  exports.decorateWithExplain = decorateWithExplain;
  var abstract_cursor_1 = require_abstract_cursor();
  var error_1 = require_error();
  exports.ExplainVerbosity = Object.freeze({
    queryPlanner: "queryPlanner",
    queryPlannerExtended: "queryPlannerExtended",
    executionStats: "executionStats",
    allPlansExecution: "allPlansExecution"
  });

  class Explain {
    constructor(verbosity, maxTimeMS) {
      if (typeof verbosity === "boolean") {
        this.verbosity = verbosity ? exports.ExplainVerbosity.allPlansExecution : exports.ExplainVerbosity.queryPlanner;
      } else {
        this.verbosity = verbosity;
      }
      this.maxTimeMS = maxTimeMS;
    }
    static fromOptions({ explain } = {}) {
      if (explain == null)
        return;
      if (typeof explain === "boolean" || typeof explain === "string") {
        return new Explain(explain);
      }
      const { verbosity, maxTimeMS } = explain;
      return new Explain(verbosity, maxTimeMS);
    }
  }
  exports.Explain = Explain;

  class ExplainableCursor extends abstract_cursor_1.AbstractCursor {
    resolveExplainTimeoutOptions(verbosity, options) {
      let explain;
      let timeout;
      if (verbosity == null && options == null) {
        explain = undefined;
        timeout = undefined;
      } else if (verbosity != null && options == null) {
        explain = typeof verbosity !== "object" ? verbosity : ("verbosity" in verbosity) ? verbosity : undefined;
        timeout = typeof verbosity === "object" && "timeoutMS" in verbosity ? verbosity : undefined;
      } else {
        explain = verbosity;
        timeout = options;
      }
      return { timeout, explain };
    }
  }
  exports.ExplainableCursor = ExplainableCursor;
});

// node_modules/mongodb/lib/operations/command.js
var require_command = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CommandOperation = undefined;
  var error_1 = require_error();
  var explain_1 = require_explain();
  var read_concern_1 = require_read_concern();
  var server_selection_1 = require_server_selection();
  var utils_1 = require_utils2();
  var write_concern_1 = require_write_concern();
  var operation_1 = require_operation();

  class CommandOperation extends operation_1.AbstractOperation {
    constructor(parent, options) {
      super(options);
      this.options = options ?? {};
      const dbNameOverride = options?.dbName || options?.authdb;
      if (dbNameOverride) {
        this.ns = new utils_1.MongoDBNamespace(dbNameOverride, "$cmd");
      } else {
        this.ns = parent ? parent.s.namespace.withCollection("$cmd") : new utils_1.MongoDBNamespace("admin", "$cmd");
      }
      this.readConcern = read_concern_1.ReadConcern.fromOptions(options);
      this.writeConcern = write_concern_1.WriteConcern.fromOptions(options);
      if (this.hasAspect(operation_1.Aspect.EXPLAINABLE)) {
        this.explain = explain_1.Explain.fromOptions(options);
        if (this.explain)
          (0, explain_1.validateExplainTimeoutOptions)(this.options, this.explain);
      } else if (options?.explain != null) {
        throw new error_1.MongoInvalidArgumentError(`Option "explain" is not supported on this command`);
      }
    }
    get canRetryWrite() {
      if (this.hasAspect(operation_1.Aspect.EXPLAINABLE)) {
        return this.explain == null;
      }
      return super.canRetryWrite;
    }
    async executeCommand(server, session, cmd, timeoutContext, responseType) {
      this.server = server;
      const options = {
        ...this.options,
        ...this.bsonOptions,
        timeoutContext,
        readPreference: this.readPreference,
        session
      };
      const serverWireVersion = (0, utils_1.maxWireVersion)(server);
      const inTransaction = this.session && this.session.inTransaction();
      if (this.readConcern && (0, utils_1.commandSupportsReadConcern)(cmd) && !inTransaction) {
        Object.assign(cmd, { readConcern: this.readConcern });
      }
      if (this.trySecondaryWrite && serverWireVersion < server_selection_1.MIN_SECONDARY_WRITE_WIRE_VERSION) {
        options.omitReadPreference = true;
      }
      if (this.writeConcern && this.hasAspect(operation_1.Aspect.WRITE_OPERATION) && !inTransaction) {
        write_concern_1.WriteConcern.apply(cmd, this.writeConcern);
      }
      if (options.collation && typeof options.collation === "object" && !this.hasAspect(operation_1.Aspect.SKIP_COLLATION)) {
        Object.assign(cmd, { collation: options.collation });
      }
      if (typeof options.maxTimeMS === "number") {
        cmd.maxTimeMS = options.maxTimeMS;
      }
      if (this.hasAspect(operation_1.Aspect.EXPLAINABLE) && this.explain) {
        cmd = (0, explain_1.decorateWithExplain)(cmd, this.explain);
      }
      return await server.command(this.ns, cmd, options, responseType);
    }
  }
  exports.CommandOperation = CommandOperation;
});

// node_modules/mongodb/lib/operations/list_databases.js
var require_list_databases = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListDatabasesOperation = undefined;
  var utils_1 = require_utils2();
  var command_1 = require_command();
  var operation_1 = require_operation();

  class ListDatabasesOperation extends command_1.CommandOperation {
    constructor(db, options) {
      super(db, options);
      this.options = options ?? {};
      this.ns = new utils_1.MongoDBNamespace("admin", "$cmd");
    }
    get commandName() {
      return "listDatabases";
    }
    async execute(server, session, timeoutContext) {
      const cmd = { listDatabases: 1 };
      if (typeof this.options.nameOnly === "boolean") {
        cmd.nameOnly = this.options.nameOnly;
      }
      if (this.options.filter) {
        cmd.filter = this.options.filter;
      }
      if (typeof this.options.authorizedDatabases === "boolean") {
        cmd.authorizedDatabases = this.options.authorizedDatabases;
      }
      if ((0, utils_1.maxWireVersion)(server) >= 9 && this.options.comment !== undefined) {
        cmd.comment = this.options.comment;
      }
      return await super.executeCommand(server, session, cmd, timeoutContext);
    }
  }
  exports.ListDatabasesOperation = ListDatabasesOperation;
  (0, operation_1.defineAspects)(ListDatabasesOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE]);
});

// node_modules/mongodb/lib/operations/validate_collection.js
var require_validate_collection = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValidateCollectionOperation = undefined;
  var error_1 = require_error();
  var command_1 = require_command();

  class ValidateCollectionOperation extends command_1.CommandOperation {
    constructor(admin, collectionName, options) {
      const command = { validate: collectionName };
      const keys = Object.keys(options);
      for (let i = 0;i < keys.length; i++) {
        if (Object.prototype.hasOwnProperty.call(options, keys[i]) && keys[i] !== "session") {
          command[keys[i]] = options[keys[i]];
        }
      }
      super(admin.s.db, options);
      this.options = options;
      this.command = command;
      this.collectionName = collectionName;
    }
    get commandName() {
      return "validate";
    }
    async execute(server, session, timeoutContext) {
      const collectionName = this.collectionName;
      const doc = await super.executeCommand(server, session, this.command, timeoutContext);
      if (doc.result != null && typeof doc.result !== "string")
        throw new error_1.MongoUnexpectedServerResponseError("Error with validation data");
      if (doc.result != null && doc.result.match(/exception|corrupt/) != null)
        throw new error_1.MongoUnexpectedServerResponseError(`Invalid collection ${collectionName}`);
      if (doc.valid != null && !doc.valid)
        throw new error_1.MongoUnexpectedServerResponseError(`Invalid collection ${collectionName}`);
      return doc;
    }
  }
  exports.ValidateCollectionOperation = ValidateCollectionOperation;
});

// node_modules/mongodb/lib/admin.js
var require_admin = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Admin = undefined;
  var bson_1 = require_bson2();
  var execute_operation_1 = require_execute_operation();
  var list_databases_1 = require_list_databases();
  var remove_user_1 = require_remove_user();
  var run_command_1 = require_run_command();
  var validate_collection_1 = require_validate_collection();

  class Admin {
    constructor(db) {
      this.s = { db };
    }
    async command(command, options) {
      return await (0, execute_operation_1.executeOperation)(this.s.db.client, new run_command_1.RunAdminCommandOperation(command, {
        ...(0, bson_1.resolveBSONOptions)(options),
        session: options?.session,
        readPreference: options?.readPreference,
        timeoutMS: options?.timeoutMS ?? this.s.db.timeoutMS
      }));
    }
    async buildInfo(options) {
      return await this.command({ buildinfo: 1 }, options);
    }
    async serverInfo(options) {
      return await this.command({ buildinfo: 1 }, options);
    }
    async serverStatus(options) {
      return await this.command({ serverStatus: 1 }, options);
    }
    async ping(options) {
      return await this.command({ ping: 1 }, options);
    }
    async removeUser(username, options) {
      return await (0, execute_operation_1.executeOperation)(this.s.db.client, new remove_user_1.RemoveUserOperation(this.s.db, username, { dbName: "admin", ...options }));
    }
    async validateCollection(collectionName, options = {}) {
      return await (0, execute_operation_1.executeOperation)(this.s.db.client, new validate_collection_1.ValidateCollectionOperation(this, collectionName, options));
    }
    async listDatabases(options) {
      return await (0, execute_operation_1.executeOperation)(this.s.db.client, new list_databases_1.ListDatabasesOperation(this.s.db, { timeoutMS: this.s.db.timeoutMS, ...options }));
    }
    async replSetGetStatus(options) {
      return await this.command({ replSetGetStatus: 1 }, options);
    }
  }
  exports.Admin = Admin;
});

// node_modules/mongodb/lib/gridfs/download.js
var require_download = __commonJS((exports) => {
  function throwIfInitialized(stream) {
    if (stream.s.init) {
      throw new error_1.MongoGridFSStreamError("Options cannot be changed after the stream is initialized");
    }
  }
  function doRead(stream) {
    if (stream.destroyed)
      return;
    if (!stream.s.cursor)
      return;
    if (!stream.s.file)
      return;
    const handleReadResult = (doc) => {
      if (stream.destroyed)
        return;
      if (!doc) {
        stream.push(null);
        stream.s.cursor?.close().then(undefined, (error) => stream.destroy(error));
        return;
      }
      if (!stream.s.file)
        return;
      const bytesRemaining = stream.s.file.length - stream.s.bytesRead;
      const expectedN = stream.s.expected++;
      const expectedLength = Math.min(stream.s.file.chunkSize, bytesRemaining);
      if (doc.n > expectedN) {
        return stream.destroy(new error_1.MongoGridFSChunkError(`ChunkIsMissing: Got unexpected n: ${doc.n}, expected: ${expectedN}`));
      }
      if (doc.n < expectedN) {
        return stream.destroy(new error_1.MongoGridFSChunkError(`ExtraChunk: Got unexpected n: ${doc.n}, expected: ${expectedN}`));
      }
      let buf = Buffer.isBuffer(doc.data) ? doc.data : doc.data.buffer;
      if (buf.byteLength !== expectedLength) {
        if (bytesRemaining <= 0) {
          return stream.destroy(new error_1.MongoGridFSChunkError(`ExtraChunk: Got unexpected n: ${doc.n}, expected file length ${stream.s.file.length} bytes but already read ${stream.s.bytesRead} bytes`));
        }
        return stream.destroy(new error_1.MongoGridFSChunkError(`ChunkIsWrongSize: Got unexpected length: ${buf.byteLength}, expected: ${expectedLength}`));
      }
      stream.s.bytesRead += buf.byteLength;
      if (buf.byteLength === 0) {
        return stream.push(null);
      }
      let sliceStart = null;
      let sliceEnd = null;
      if (stream.s.bytesToSkip != null) {
        sliceStart = stream.s.bytesToSkip;
        stream.s.bytesToSkip = 0;
      }
      const atEndOfStream = expectedN === stream.s.expectedEnd - 1;
      const bytesLeftToRead = stream.s.options.end - stream.s.bytesToSkip;
      if (atEndOfStream && stream.s.bytesToTrim != null) {
        sliceEnd = stream.s.file.chunkSize - stream.s.bytesToTrim;
      } else if (stream.s.options.end && bytesLeftToRead < doc.data.byteLength) {
        sliceEnd = bytesLeftToRead;
      }
      if (sliceStart != null || sliceEnd != null) {
        buf = buf.slice(sliceStart || 0, sliceEnd || buf.byteLength);
      }
      stream.push(buf);
      return;
    };
    stream.s.cursor.next().then(handleReadResult, (error) => {
      if (stream.destroyed)
        return;
      stream.destroy(error);
    });
  }
  function init(stream) {
    const findOneOptions = {};
    if (stream.s.readPreference) {
      findOneOptions.readPreference = stream.s.readPreference;
    }
    if (stream.s.options && stream.s.options.sort) {
      findOneOptions.sort = stream.s.options.sort;
    }
    if (stream.s.options && stream.s.options.skip) {
      findOneOptions.skip = stream.s.options.skip;
    }
    const handleReadResult = (doc) => {
      if (stream.destroyed)
        return;
      if (!doc) {
        const identifier = stream.s.filter._id ? stream.s.filter._id.toString() : stream.s.filter.filename;
        const errmsg = `FileNotFound: file ${identifier} was not found`;
        const err = new error_1.MongoRuntimeError(errmsg);
        err.code = "ENOENT";
        return stream.destroy(err);
      }
      if (doc.length <= 0) {
        stream.push(null);
        return;
      }
      if (stream.destroyed) {
        stream.destroy();
        return;
      }
      try {
        stream.s.bytesToSkip = handleStartOption(stream, doc, stream.s.options);
      } catch (error) {
        return stream.destroy(error);
      }
      const filter = { files_id: doc._id };
      if (stream.s.options && stream.s.options.start != null) {
        const skip = Math.floor(stream.s.options.start / doc.chunkSize);
        if (skip > 0) {
          filter["n"] = { $gte: skip };
        }
      }
      let remainingTimeMS2;
      try {
        remainingTimeMS2 = stream.s.timeoutContext?.getRemainingTimeMSOrThrow(`Download timed out after ${stream.s.timeoutContext?.timeoutMS}ms`);
      } catch (error) {
        return stream.destroy(error);
      }
      stream.s.cursor = stream.s.chunks.find(filter, {
        timeoutMode: stream.s.options.timeoutMS != null ? abstract_cursor_1.CursorTimeoutMode.LIFETIME : undefined,
        timeoutMS: remainingTimeMS2
      }).sort({ n: 1 });
      if (stream.s.readPreference) {
        stream.s.cursor.withReadPreference(stream.s.readPreference);
      }
      stream.s.expectedEnd = Math.ceil(doc.length / doc.chunkSize);
      stream.s.file = doc;
      try {
        stream.s.bytesToTrim = handleEndOption(stream, doc, stream.s.cursor, stream.s.options);
      } catch (error) {
        return stream.destroy(error);
      }
      stream.emit(GridFSBucketReadStream.FILE, doc);
      return;
    };
    let remainingTimeMS;
    try {
      remainingTimeMS = stream.s.timeoutContext?.getRemainingTimeMSOrThrow(`Download timed out after ${stream.s.timeoutContext?.timeoutMS}ms`);
    } catch (error) {
      if (!stream.destroyed)
        stream.destroy(error);
      return;
    }
    findOneOptions.timeoutMS = remainingTimeMS;
    stream.s.files.findOne(stream.s.filter, findOneOptions).then(handleReadResult, (error) => {
      if (stream.destroyed)
        return;
      stream.destroy(error);
    });
  }
  function waitForFile(stream, callback) {
    if (stream.s.file) {
      return callback();
    }
    if (!stream.s.init) {
      init(stream);
      stream.s.init = true;
    }
    stream.once("file", () => {
      callback();
    });
  }
  function handleStartOption(stream, doc, options) {
    if (options && options.start != null) {
      if (options.start > doc.length) {
        throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be more than the length of the file (${doc.length})`);
      }
      if (options.start < 0) {
        throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be negative`);
      }
      if (options.end != null && options.end < options.start) {
        throw new error_1.MongoInvalidArgumentError(`Stream start (${options.start}) must not be greater than stream end (${options.end})`);
      }
      stream.s.bytesRead = Math.floor(options.start / doc.chunkSize) * doc.chunkSize;
      stream.s.expected = Math.floor(options.start / doc.chunkSize);
      return options.start - stream.s.bytesRead;
    }
    throw new error_1.MongoInvalidArgumentError("Start option must be defined");
  }
  function handleEndOption(stream, doc, cursor, options) {
    if (options && options.end != null) {
      if (options.end > doc.length) {
        throw new error_1.MongoInvalidArgumentError(`Stream end (${options.end}) must not be more than the length of the file (${doc.length})`);
      }
      if (options.start == null || options.start < 0) {
        throw new error_1.MongoInvalidArgumentError(`Stream end (${options.end}) must not be negative`);
      }
      const start = options.start != null ? Math.floor(options.start / doc.chunkSize) : 0;
      cursor.limit(Math.ceil(options.end / doc.chunkSize) - start);
      stream.s.expectedEnd = Math.ceil(options.end / doc.chunkSize);
      return Math.ceil(options.end / doc.chunkSize) * doc.chunkSize - options.end;
    }
    throw new error_1.MongoInvalidArgumentError("End option must be defined");
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GridFSBucketReadStream = undefined;
  var stream_1 = import.meta.require("stream");
  var abstract_cursor_1 = require_abstract_cursor();
  var error_1 = require_error();
  var timeout_1 = require_timeout();

  class GridFSBucketReadStream extends stream_1.Readable {
    constructor(chunks, files, readPreference, filter, options) {
      super({ emitClose: true });
      this.s = {
        bytesToTrim: 0,
        bytesToSkip: 0,
        bytesRead: 0,
        chunks,
        expected: 0,
        files,
        filter,
        init: false,
        expectedEnd: 0,
        options: {
          start: 0,
          end: 0,
          ...options
        },
        readPreference,
        timeoutContext: options?.timeoutMS != null ? new timeout_1.CSOTTimeoutContext({ timeoutMS: options.timeoutMS, serverSelectionTimeoutMS: 0 }) : undefined
      };
    }
    _read() {
      if (this.destroyed)
        return;
      waitForFile(this, () => doRead(this));
    }
    start(start = 0) {
      throwIfInitialized(this);
      this.s.options.start = start;
      return this;
    }
    end(end = 0) {
      throwIfInitialized(this);
      this.s.options.end = end;
      return this;
    }
    async abort() {
      this.push(null);
      this.destroy();
      const remainingTimeMS = this.s.timeoutContext?.getRemainingTimeMSOrThrow();
      await this.s.cursor?.close({ timeoutMS: remainingTimeMS });
    }
  }
  exports.GridFSBucketReadStream = GridFSBucketReadStream;
  GridFSBucketReadStream.FILE = "file";
});

// node_modules/mongodb/lib/gridfs/upload.js
var require_upload = __commonJS((exports) => {
  function handleError(stream, error, callback) {
    if (stream.state.errored) {
      process.nextTick(callback);
      return;
    }
    stream.state.errored = true;
    process.nextTick(callback, error);
  }
  function createChunkDoc(filesId, n, data) {
    return {
      _id: new bson_1.ObjectId,
      files_id: filesId,
      n,
      data
    };
  }
  async function checkChunksIndex(stream) {
    const index = { files_id: 1, n: 1 };
    let remainingTimeMS;
    remainingTimeMS = stream.timeoutContext?.getRemainingTimeMSOrThrow(`Upload timed out after ${stream.timeoutContext?.timeoutMS}ms`);
    let indexes;
    try {
      indexes = await stream.chunks.listIndexes({
        timeoutMode: remainingTimeMS != null ? abstract_cursor_1.CursorTimeoutMode.LIFETIME : undefined,
        timeoutMS: remainingTimeMS
      }).toArray();
    } catch (error) {
      if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
        indexes = [];
      } else {
        throw error;
      }
    }
    const hasChunksIndex = !!indexes.find((index2) => {
      const keys = Object.keys(index2.key);
      if (keys.length === 2 && index2.key.files_id === 1 && index2.key.n === 1) {
        return true;
      }
      return false;
    });
    if (!hasChunksIndex) {
      remainingTimeMS = stream.timeoutContext?.getRemainingTimeMSOrThrow(`Upload timed out after ${stream.timeoutContext?.timeoutMS}ms`);
      await stream.chunks.createIndex(index, {
        ...stream.writeConcern,
        background: true,
        unique: true,
        timeoutMS: remainingTimeMS
      });
    }
  }
  function checkDone(stream, callback) {
    if (stream.done) {
      return process.nextTick(callback);
    }
    if (stream.state.streamEnd && stream.state.outstandingRequests === 0 && !stream.state.errored) {
      stream.done = true;
      const gridFSFile = createFilesDoc(stream.id, stream.length, stream.chunkSizeBytes, stream.filename, stream.options.contentType, stream.options.aliases, stream.options.metadata);
      if (isAborted(stream, callback)) {
        return;
      }
      const remainingTimeMS = stream.timeoutContext?.remainingTimeMS;
      if (remainingTimeMS != null && remainingTimeMS <= 0) {
        return handleError(stream, new error_1.MongoOperationTimeoutError(`Upload timed out after ${stream.timeoutContext?.timeoutMS}ms`), callback);
      }
      stream.files.insertOne(gridFSFile, { writeConcern: stream.writeConcern, timeoutMS: remainingTimeMS }).then(() => {
        stream.gridFSFile = gridFSFile;
        callback();
      }, (error) => {
        return handleError(stream, error, callback);
      });
      return;
    }
    process.nextTick(callback);
  }
  async function checkIndexes(stream) {
    let remainingTimeMS = stream.timeoutContext?.getRemainingTimeMSOrThrow(`Upload timed out after ${stream.timeoutContext?.timeoutMS}ms`);
    const doc = await stream.files.findOne({}, {
      projection: { _id: 1 },
      timeoutMS: remainingTimeMS
    });
    if (doc != null) {
      return;
    }
    const index = { filename: 1, uploadDate: 1 };
    let indexes;
    remainingTimeMS = stream.timeoutContext?.getRemainingTimeMSOrThrow(`Upload timed out after ${stream.timeoutContext?.timeoutMS}ms`);
    const listIndexesOptions = {
      timeoutMode: remainingTimeMS != null ? abstract_cursor_1.CursorTimeoutMode.LIFETIME : undefined,
      timeoutMS: remainingTimeMS
    };
    try {
      indexes = await stream.files.listIndexes(listIndexesOptions).toArray();
    } catch (error) {
      if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {
        indexes = [];
      } else {
        throw error;
      }
    }
    const hasFileIndex = !!indexes.find((index2) => {
      const keys = Object.keys(index2.key);
      if (keys.length === 2 && index2.key.filename === 1 && index2.key.uploadDate === 1) {
        return true;
      }
      return false;
    });
    if (!hasFileIndex) {
      remainingTimeMS = stream.timeoutContext?.getRemainingTimeMSOrThrow(`Upload timed out after ${stream.timeoutContext?.timeoutMS}ms`);
      await stream.files.createIndex(index, { background: false, timeoutMS: remainingTimeMS });
    }
    await checkChunksIndex(stream);
  }
  function createFilesDoc(_id, length, chunkSize, filename, contentType, aliases, metadata) {
    const ret = {
      _id,
      length,
      chunkSize,
      uploadDate: new Date,
      filename
    };
    if (contentType) {
      ret.contentType = contentType;
    }
    if (aliases) {
      ret.aliases = aliases;
    }
    if (metadata) {
      ret.metadata = metadata;
    }
    return ret;
  }
  function doWrite(stream, chunk, encoding, callback) {
    if (isAborted(stream, callback)) {
      return;
    }
    const inputBuf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);
    stream.length += inputBuf.length;
    if (stream.pos + inputBuf.length < stream.chunkSizeBytes) {
      inputBuf.copy(stream.bufToStore, stream.pos);
      stream.pos += inputBuf.length;
      process.nextTick(callback);
      return;
    }
    let inputBufRemaining = inputBuf.length;
    let spaceRemaining = stream.chunkSizeBytes - stream.pos;
    let numToCopy = Math.min(spaceRemaining, inputBuf.length);
    let outstandingRequests = 0;
    while (inputBufRemaining > 0) {
      const inputBufPos = inputBuf.length - inputBufRemaining;
      inputBuf.copy(stream.bufToStore, stream.pos, inputBufPos, inputBufPos + numToCopy);
      stream.pos += numToCopy;
      spaceRemaining -= numToCopy;
      let doc;
      if (spaceRemaining === 0) {
        doc = createChunkDoc(stream.id, stream.n, Buffer.from(stream.bufToStore));
        const remainingTimeMS = stream.timeoutContext?.remainingTimeMS;
        if (remainingTimeMS != null && remainingTimeMS <= 0) {
          return handleError(stream, new error_1.MongoOperationTimeoutError(`Upload timed out after ${stream.timeoutContext?.timeoutMS}ms`), callback);
        }
        ++stream.state.outstandingRequests;
        ++outstandingRequests;
        if (isAborted(stream, callback)) {
          return;
        }
        stream.chunks.insertOne(doc, { writeConcern: stream.writeConcern, timeoutMS: remainingTimeMS }).then(() => {
          --stream.state.outstandingRequests;
          --outstandingRequests;
          if (!outstandingRequests) {
            checkDone(stream, callback);
          }
        }, (error) => {
          return handleError(stream, error, callback);
        });
        spaceRemaining = stream.chunkSizeBytes;
        stream.pos = 0;
        ++stream.n;
      }
      inputBufRemaining -= numToCopy;
      numToCopy = Math.min(spaceRemaining, inputBufRemaining);
    }
  }
  function writeRemnant(stream, callback) {
    if (stream.pos === 0) {
      return checkDone(stream, callback);
    }
    const remnant = Buffer.alloc(stream.pos);
    stream.bufToStore.copy(remnant, 0, 0, stream.pos);
    const doc = createChunkDoc(stream.id, stream.n, remnant);
    if (isAborted(stream, callback)) {
      return;
    }
    const remainingTimeMS = stream.timeoutContext?.remainingTimeMS;
    if (remainingTimeMS != null && remainingTimeMS <= 0) {
      return handleError(stream, new error_1.MongoOperationTimeoutError(`Upload timed out after ${stream.timeoutContext?.timeoutMS}ms`), callback);
    }
    ++stream.state.outstandingRequests;
    stream.chunks.insertOne(doc, { writeConcern: stream.writeConcern, timeoutMS: remainingTimeMS }).then(() => {
      --stream.state.outstandingRequests;
      checkDone(stream, callback);
    }, (error) => {
      return handleError(stream, error, callback);
    });
  }
  function isAborted(stream, callback) {
    if (stream.state.aborted) {
      process.nextTick(callback, new error_1.MongoAPIError("Stream has been aborted"));
      return true;
    }
    return false;
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GridFSBucketWriteStream = undefined;
  var stream_1 = import.meta.require("stream");
  var bson_1 = require_bson2();
  var abstract_cursor_1 = require_abstract_cursor();
  var error_1 = require_error();
  var timeout_1 = require_timeout();
  var utils_1 = require_utils2();
  var write_concern_1 = require_write_concern();

  class GridFSBucketWriteStream extends stream_1.Writable {
    constructor(bucket, filename, options) {
      super();
      this.gridFSFile = null;
      options = options ?? {};
      this.bucket = bucket;
      this.chunks = bucket.s._chunksCollection;
      this.filename = filename;
      this.files = bucket.s._filesCollection;
      this.options = options;
      this.writeConcern = write_concern_1.WriteConcern.fromOptions(options) || bucket.s.options.writeConcern;
      this.done = false;
      this.id = options.id ? options.id : new bson_1.ObjectId;
      this.chunkSizeBytes = options.chunkSizeBytes || this.bucket.s.options.chunkSizeBytes;
      this.bufToStore = Buffer.alloc(this.chunkSizeBytes);
      this.length = 0;
      this.n = 0;
      this.pos = 0;
      this.state = {
        streamEnd: false,
        outstandingRequests: 0,
        errored: false,
        aborted: false
      };
      if (options.timeoutMS != null)
        this.timeoutContext = new timeout_1.CSOTTimeoutContext({
          timeoutMS: options.timeoutMS,
          serverSelectionTimeoutMS: (0, utils_1.resolveTimeoutOptions)(this.bucket.s.db.client, {}).serverSelectionTimeoutMS
        });
    }
    _construct(callback) {
      if (!this.bucket.s.calledOpenUploadStream) {
        this.bucket.s.calledOpenUploadStream = true;
        checkIndexes(this).then(() => {
          this.bucket.s.checkedIndexes = true;
          this.bucket.emit("index");
          callback();
        }, (error) => {
          if (error instanceof error_1.MongoOperationTimeoutError) {
            return handleError(this, error, callback);
          }
          (0, utils_1.squashError)(error);
          callback();
        });
      } else {
        return process.nextTick(callback);
      }
    }
    _write(chunk, encoding, callback) {
      doWrite(this, chunk, encoding, callback);
    }
    _final(callback) {
      if (this.state.streamEnd) {
        return process.nextTick(callback);
      }
      this.state.streamEnd = true;
      writeRemnant(this, callback);
    }
    async abort() {
      if (this.state.streamEnd) {
        throw new error_1.MongoAPIError("Cannot abort a stream that has already completed");
      }
      if (this.state.aborted) {
        throw new error_1.MongoAPIError("Cannot call abort() on a stream twice");
      }
      this.state.aborted = true;
      const remainingTimeMS = this.timeoutContext?.getRemainingTimeMSOrThrow(`Upload timed out after ${this.timeoutContext?.timeoutMS}ms`);
      await this.chunks.deleteMany({ files_id: this.id }, { timeoutMS: remainingTimeMS });
    }
  }
  exports.GridFSBucketWriteStream = GridFSBucketWriteStream;
});

// node_modules/mongodb/lib/gridfs/index.js
var require_gridfs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GridFSBucket = undefined;
  var error_1 = require_error();
  var mongo_types_1 = require_mongo_types();
  var timeout_1 = require_timeout();
  var utils_1 = require_utils2();
  var write_concern_1 = require_write_concern();
  var download_1 = require_download();
  var upload_1 = require_upload();
  var DEFAULT_GRIDFS_BUCKET_OPTIONS = {
    bucketName: "fs",
    chunkSizeBytes: 255 * 1024
  };

  class GridFSBucket extends mongo_types_1.TypedEventEmitter {
    constructor(db, options) {
      super();
      this.setMaxListeners(0);
      const privateOptions = (0, utils_1.resolveOptions)(db, {
        ...DEFAULT_GRIDFS_BUCKET_OPTIONS,
        ...options,
        writeConcern: write_concern_1.WriteConcern.fromOptions(options)
      });
      this.s = {
        db,
        options: privateOptions,
        _chunksCollection: db.collection(privateOptions.bucketName + ".chunks"),
        _filesCollection: db.collection(privateOptions.bucketName + ".files"),
        checkedIndexes: false,
        calledOpenUploadStream: false
      };
    }
    openUploadStream(filename, options) {
      return new upload_1.GridFSBucketWriteStream(this, filename, {
        timeoutMS: this.s.options.timeoutMS,
        ...options
      });
    }
    openUploadStreamWithId(id, filename, options) {
      return new upload_1.GridFSBucketWriteStream(this, filename, {
        timeoutMS: this.s.options.timeoutMS,
        ...options,
        id
      });
    }
    openDownloadStream(id, options) {
      return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, { _id: id }, { timeoutMS: this.s.options.timeoutMS, ...options });
    }
    async delete(id, options) {
      const { timeoutMS } = (0, utils_1.resolveOptions)(this.s.db, options);
      let timeoutContext = undefined;
      if (timeoutMS) {
        timeoutContext = new timeout_1.CSOTTimeoutContext({
          timeoutMS,
          serverSelectionTimeoutMS: this.s.db.client.s.options.serverSelectionTimeoutMS
        });
      }
      const { deletedCount } = await this.s._filesCollection.deleteOne({ _id: id }, { timeoutMS: timeoutContext?.remainingTimeMS });
      const remainingTimeMS = timeoutContext?.remainingTimeMS;
      if (remainingTimeMS != null && remainingTimeMS <= 0)
        throw new error_1.MongoOperationTimeoutError(`Timed out after ${timeoutMS}ms`);
      await this.s._chunksCollection.deleteMany({ files_id: id }, { timeoutMS: remainingTimeMS });
      if (deletedCount === 0) {
        throw new error_1.MongoRuntimeError(`File not found for id ${id}`);
      }
    }
    find(filter = {}, options = {}) {
      return this.s._filesCollection.find(filter, options);
    }
    openDownloadStreamByName(filename, options) {
      let sort = { uploadDate: -1 };
      let skip = undefined;
      if (options && options.revision != null) {
        if (options.revision >= 0) {
          sort = { uploadDate: 1 };
          skip = options.revision;
        } else {
          skip = -options.revision - 1;
        }
      }
      return new download_1.GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, { filename }, { timeoutMS: this.s.options.timeoutMS, ...options, sort, skip });
    }
    async rename(id, filename, options) {
      const filter = { _id: id };
      const update = { $set: { filename } };
      const { matchedCount } = await this.s._filesCollection.updateOne(filter, update, options);
      if (matchedCount === 0) {
        throw new error_1.MongoRuntimeError(`File with id ${id} not found`);
      }
    }
    async drop(options) {
      const { timeoutMS } = (0, utils_1.resolveOptions)(this.s.db, options);
      let timeoutContext = undefined;
      if (timeoutMS) {
        timeoutContext = new timeout_1.CSOTTimeoutContext({
          timeoutMS,
          serverSelectionTimeoutMS: this.s.db.client.s.options.serverSelectionTimeoutMS
        });
      }
      if (timeoutContext) {
        await this.s._filesCollection.drop({ timeoutMS: timeoutContext.remainingTimeMS });
        const remainingTimeMS = timeoutContext.getRemainingTimeMSOrThrow(`Timed out after ${timeoutMS}ms`);
        await this.s._chunksCollection.drop({ timeoutMS: remainingTimeMS });
      } else {
        await this.s._filesCollection.drop();
        await this.s._chunksCollection.drop();
      }
    }
  }
  exports.GridFSBucket = GridFSBucket;
  GridFSBucket.INDEX = "index";
});

// node_modules/mongodb/lib/index.js
var require_lib3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MongoServerError = exports.MongoServerClosedError = exports.MongoRuntimeError = exports.MongoParseError = exports.MongoOperationTimeoutError = exports.MongoOIDCError = exports.MongoNotConnectedError = exports.MongoNetworkTimeoutError = exports.MongoNetworkError = exports.MongoMissingDependencyError = exports.MongoMissingCredentialsError = exports.MongoKerberosError = exports.MongoInvalidArgumentError = exports.MongoGridFSStreamError = exports.MongoGridFSChunkError = exports.MongoGCPError = exports.MongoExpiredSessionError = exports.MongoError = exports.MongoDriverError = exports.MongoDecompressionError = exports.MongoCursorInUseError = exports.MongoCursorExhaustedError = exports.MongoCompatibilityError = exports.MongoClientBulkWriteExecutionError = exports.MongoClientBulkWriteError = exports.MongoClientBulkWriteCursorError = exports.MongoChangeStreamError = exports.MongoBatchReExecutionError = exports.MongoAzureError = exports.MongoAWSError = exports.MongoAPIError = exports.ChangeStreamCursor = exports.ClientEncryption = exports.MongoBulkWriteError = exports.UUID = exports.Timestamp = exports.ObjectId = exports.MinKey = exports.MaxKey = exports.Long = exports.Int32 = exports.Double = exports.Decimal128 = exports.DBRef = exports.Code = exports.BSONType = exports.BSONSymbol = exports.BSONRegExp = exports.Binary = exports.BSON = undefined;
  exports.CommandStartedEvent = exports.CommandFailedEvent = exports.WriteConcern = exports.ReadPreference = exports.ReadConcern = exports.TopologyType = exports.ServerType = exports.ReadPreferenceMode = exports.ReadConcernLevel = exports.ProfilingLevel = exports.ReturnDocument = exports.SeverityLevel = exports.MongoLoggableComponent = exports.ServerApiVersion = exports.ExplainVerbosity = exports.MongoErrorLabel = exports.CursorTimeoutMode = exports.CURSOR_FLAGS = exports.Compressor = exports.AuthMechanism = exports.GSSAPICanonicalizationValue = exports.AutoEncryptionLoggerLevel = exports.BatchType = exports.UnorderedBulkOperation = exports.OrderedBulkOperation = exports.MongoClient = exports.ListIndexesCursor = exports.ListCollectionsCursor = exports.GridFSBucketWriteStream = exports.GridFSBucketReadStream = exports.GridFSBucket = exports.FindCursor = exports.ExplainableCursor = exports.Db = exports.Collection = exports.ClientSession = exports.ChangeStream = exports.CancellationToken = exports.AggregationCursor = exports.Admin = exports.AbstractCursor = exports.configureExplicitResourceManagement = exports.MongoWriteConcernError = exports.MongoUnexpectedServerResponseError = exports.MongoTransactionError = exports.MongoTopologyClosedError = exports.MongoTailableCursorError = exports.MongoSystemError = exports.MongoStalePrimaryError = exports.MongoServerSelectionError = undefined;
  exports.MongoClientAuthProviders = exports.MongoCryptKMSRequestNetworkTimeoutError = exports.MongoCryptInvalidArgumentError = exports.MongoCryptError = exports.MongoCryptCreateEncryptedCollectionError = exports.MongoCryptCreateDataKeyError = exports.MongoCryptAzureKMSRequestError = exports.SrvPollingEvent = exports.WaitingForSuitableServerEvent = exports.ServerSelectionSucceededEvent = exports.ServerSelectionStartedEvent = exports.ServerSelectionFailedEvent = exports.ServerSelectionEvent = exports.TopologyOpeningEvent = exports.TopologyDescriptionChangedEvent = exports.TopologyClosedEvent = exports.ServerOpeningEvent = exports.ServerHeartbeatSucceededEvent = exports.ServerHeartbeatStartedEvent = exports.ServerHeartbeatFailedEvent = exports.ServerDescriptionChangedEvent = exports.ServerClosedEvent = exports.ConnectionReadyEvent = exports.ConnectionPoolReadyEvent = exports.ConnectionPoolMonitoringEvent = exports.ConnectionPoolCreatedEvent = exports.ConnectionPoolClosedEvent = exports.ConnectionPoolClearedEvent = exports.ConnectionCreatedEvent = exports.ConnectionClosedEvent = exports.ConnectionCheckOutStartedEvent = exports.ConnectionCheckOutFailedEvent = exports.ConnectionCheckedOutEvent = exports.ConnectionCheckedInEvent = exports.CommandSucceededEvent = undefined;
  var admin_1 = require_admin();
  Object.defineProperty(exports, "Admin", { enumerable: true, get: function() {
    return admin_1.Admin;
  } });
  var ordered_1 = require_ordered();
  Object.defineProperty(exports, "OrderedBulkOperation", { enumerable: true, get: function() {
    return ordered_1.OrderedBulkOperation;
  } });
  var unordered_1 = require_unordered();
  Object.defineProperty(exports, "UnorderedBulkOperation", { enumerable: true, get: function() {
    return unordered_1.UnorderedBulkOperation;
  } });
  var change_stream_1 = require_change_stream();
  Object.defineProperty(exports, "ChangeStream", { enumerable: true, get: function() {
    return change_stream_1.ChangeStream;
  } });
  var collection_1 = require_collection2();
  Object.defineProperty(exports, "Collection", { enumerable: true, get: function() {
    return collection_1.Collection;
  } });
  var abstract_cursor_1 = require_abstract_cursor();
  Object.defineProperty(exports, "AbstractCursor", { enumerable: true, get: function() {
    return abstract_cursor_1.AbstractCursor;
  } });
  var aggregation_cursor_1 = require_aggregation_cursor();
  Object.defineProperty(exports, "AggregationCursor", { enumerable: true, get: function() {
    return aggregation_cursor_1.AggregationCursor;
  } });
  var find_cursor_1 = require_find_cursor();
  Object.defineProperty(exports, "FindCursor", { enumerable: true, get: function() {
    return find_cursor_1.FindCursor;
  } });
  var list_collections_cursor_1 = require_list_collections_cursor();
  Object.defineProperty(exports, "ListCollectionsCursor", { enumerable: true, get: function() {
    return list_collections_cursor_1.ListCollectionsCursor;
  } });
  var list_indexes_cursor_1 = require_list_indexes_cursor();
  Object.defineProperty(exports, "ListIndexesCursor", { enumerable: true, get: function() {
    return list_indexes_cursor_1.ListIndexesCursor;
  } });
  var db_1 = require_db();
  Object.defineProperty(exports, "Db", { enumerable: true, get: function() {
    return db_1.Db;
  } });
  var explain_1 = require_explain();
  Object.defineProperty(exports, "ExplainableCursor", { enumerable: true, get: function() {
    return explain_1.ExplainableCursor;
  } });
  var gridfs_1 = require_gridfs();
  Object.defineProperty(exports, "GridFSBucket", { enumerable: true, get: function() {
    return gridfs_1.GridFSBucket;
  } });
  var download_1 = require_download();
  Object.defineProperty(exports, "GridFSBucketReadStream", { enumerable: true, get: function() {
    return download_1.GridFSBucketReadStream;
  } });
  var upload_1 = require_upload();
  Object.defineProperty(exports, "GridFSBucketWriteStream", { enumerable: true, get: function() {
    return upload_1.GridFSBucketWriteStream;
  } });
  var mongo_client_1 = require_mongo_client();
  Object.defineProperty(exports, "MongoClient", { enumerable: true, get: function() {
    return mongo_client_1.MongoClient;
  } });
  var mongo_types_1 = require_mongo_types();
  Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
    return mongo_types_1.CancellationToken;
  } });
  var sessions_1 = require_sessions();
  Object.defineProperty(exports, "ClientSession", { enumerable: true, get: function() {
    return sessions_1.ClientSession;
  } });
  var bson_1 = require_bson2();
  Object.defineProperty(exports, "BSON", { enumerable: true, get: function() {
    return bson_1.BSON;
  } });
  var bson_2 = require_bson2();
  Object.defineProperty(exports, "Binary", { enumerable: true, get: function() {
    return bson_2.Binary;
  } });
  Object.defineProperty(exports, "BSONRegExp", { enumerable: true, get: function() {
    return bson_2.BSONRegExp;
  } });
  Object.defineProperty(exports, "BSONSymbol", { enumerable: true, get: function() {
    return bson_2.BSONSymbol;
  } });
  Object.defineProperty(exports, "BSONType", { enumerable: true, get: function() {
    return bson_2.BSONType;
  } });
  Object.defineProperty(exports, "Code", { enumerable: true, get: function() {
    return bson_2.Code;
  } });
  Object.defineProperty(exports, "DBRef", { enumerable: true, get: function() {
    return bson_2.DBRef;
  } });
  Object.defineProperty(exports, "Decimal128", { enumerable: true, get: function() {
    return bson_2.Decimal128;
  } });
  Object.defineProperty(exports, "Double", { enumerable: true, get: function() {
    return bson_2.Double;
  } });
  Object.defineProperty(exports, "Int32", { enumerable: true, get: function() {
    return bson_2.Int32;
  } });
  Object.defineProperty(exports, "Long", { enumerable: true, get: function() {
    return bson_2.Long;
  } });
  Object.defineProperty(exports, "MaxKey", { enumerable: true, get: function() {
    return bson_2.MaxKey;
  } });
  Object.defineProperty(exports, "MinKey", { enumerable: true, get: function() {
    return bson_2.MinKey;
  } });
  Object.defineProperty(exports, "ObjectId", { enumerable: true, get: function() {
    return bson_2.ObjectId;
  } });
  Object.defineProperty(exports, "Timestamp", { enumerable: true, get: function() {
    return bson_2.Timestamp;
  } });
  Object.defineProperty(exports, "UUID", { enumerable: true, get: function() {
    return bson_2.UUID;
  } });
  var common_1 = require_common2();
  Object.defineProperty(exports, "MongoBulkWriteError", { enumerable: true, get: function() {
    return common_1.MongoBulkWriteError;
  } });
  var client_encryption_1 = require_client_encryption();
  Object.defineProperty(exports, "ClientEncryption", { enumerable: true, get: function() {
    return client_encryption_1.ClientEncryption;
  } });
  var change_stream_cursor_1 = require_change_stream_cursor();
  Object.defineProperty(exports, "ChangeStreamCursor", { enumerable: true, get: function() {
    return change_stream_cursor_1.ChangeStreamCursor;
  } });
  var error_1 = require_error();
  Object.defineProperty(exports, "MongoAPIError", { enumerable: true, get: function() {
    return error_1.MongoAPIError;
  } });
  Object.defineProperty(exports, "MongoAWSError", { enumerable: true, get: function() {
    return error_1.MongoAWSError;
  } });
  Object.defineProperty(exports, "MongoAzureError", { enumerable: true, get: function() {
    return error_1.MongoAzureError;
  } });
  Object.defineProperty(exports, "MongoBatchReExecutionError", { enumerable: true, get: function() {
    return error_1.MongoBatchReExecutionError;
  } });
  Object.defineProperty(exports, "MongoChangeStreamError", { enumerable: true, get: function() {
    return error_1.MongoChangeStreamError;
  } });
  Object.defineProperty(exports, "MongoClientBulkWriteCursorError", { enumerable: true, get: function() {
    return error_1.MongoClientBulkWriteCursorError;
  } });
  Object.defineProperty(exports, "MongoClientBulkWriteError", { enumerable: true, get: function() {
    return error_1.MongoClientBulkWriteError;
  } });
  Object.defineProperty(exports, "MongoClientBulkWriteExecutionError", { enumerable: true, get: function() {
    return error_1.MongoClientBulkWriteExecutionError;
  } });
  Object.defineProperty(exports, "MongoCompatibilityError", { enumerable: true, get: function() {
    return error_1.MongoCompatibilityError;
  } });
  Object.defineProperty(exports, "MongoCursorExhaustedError", { enumerable: true, get: function() {
    return error_1.MongoCursorExhaustedError;
  } });
  Object.defineProperty(exports, "MongoCursorInUseError", { enumerable: true, get: function() {
    return error_1.MongoCursorInUseError;
  } });
  Object.defineProperty(exports, "MongoDecompressionError", { enumerable: true, get: function() {
    return error_1.MongoDecompressionError;
  } });
  Object.defineProperty(exports, "MongoDriverError", { enumerable: true, get: function() {
    return error_1.MongoDriverError;
  } });
  Object.defineProperty(exports, "MongoError", { enumerable: true, get: function() {
    return error_1.MongoError;
  } });
  Object.defineProperty(exports, "MongoExpiredSessionError", { enumerable: true, get: function() {
    return error_1.MongoExpiredSessionError;
  } });
  Object.defineProperty(exports, "MongoGCPError", { enumerable: true, get: function() {
    return error_1.MongoGCPError;
  } });
  Object.defineProperty(exports, "MongoGridFSChunkError", { enumerable: true, get: function() {
    return error_1.MongoGridFSChunkError;
  } });
  Object.defineProperty(exports, "MongoGridFSStreamError", { enumerable: true, get: function() {
    return error_1.MongoGridFSStreamError;
  } });
  Object.defineProperty(exports, "MongoInvalidArgumentError", { enumerable: true, get: function() {
    return error_1.MongoInvalidArgumentError;
  } });
  Object.defineProperty(exports, "MongoKerberosError", { enumerable: true, get: function() {
    return error_1.MongoKerberosError;
  } });
  Object.defineProperty(exports, "MongoMissingCredentialsError", { enumerable: true, get: function() {
    return error_1.MongoMissingCredentialsError;
  } });
  Object.defineProperty(exports, "MongoMissingDependencyError", { enumerable: true, get: function() {
    return error_1.MongoMissingDependencyError;
  } });
  Object.defineProperty(exports, "MongoNetworkError", { enumerable: true, get: function() {
    return error_1.MongoNetworkError;
  } });
  Object.defineProperty(exports, "MongoNetworkTimeoutError", { enumerable: true, get: function() {
    return error_1.MongoNetworkTimeoutError;
  } });
  Object.defineProperty(exports, "MongoNotConnectedError", { enumerable: true, get: function() {
    return error_1.MongoNotConnectedError;
  } });
  Object.defineProperty(exports, "MongoOIDCError", { enumerable: true, get: function() {
    return error_1.MongoOIDCError;
  } });
  Object.defineProperty(exports, "MongoOperationTimeoutError", { enumerable: true, get: function() {
    return error_1.MongoOperationTimeoutError;
  } });
  Object.defineProperty(exports, "MongoParseError", { enumerable: true, get: function() {
    return error_1.MongoParseError;
  } });
  Object.defineProperty(exports, "MongoRuntimeError", { enumerable: true, get: function() {
    return error_1.MongoRuntimeError;
  } });
  Object.defineProperty(exports, "MongoServerClosedError", { enumerable: true, get: function() {
    return error_1.MongoServerClosedError;
  } });
  Object.defineProperty(exports, "MongoServerError", { enumerable: true, get: function() {
    return error_1.MongoServerError;
  } });
  Object.defineProperty(exports, "MongoServerSelectionError", { enumerable: true, get: function() {
    return error_1.MongoServerSelectionError;
  } });
  Object.defineProperty(exports, "MongoStalePrimaryError", { enumerable: true, get: function() {
    return error_1.MongoStalePrimaryError;
  } });
  Object.defineProperty(exports, "MongoSystemError", { enumerable: true, get: function() {
    return error_1.MongoSystemError;
  } });
  Object.defineProperty(exports, "MongoTailableCursorError", { enumerable: true, get: function() {
    return error_1.MongoTailableCursorError;
  } });
  Object.defineProperty(exports, "MongoTopologyClosedError", { enumerable: true, get: function() {
    return error_1.MongoTopologyClosedError;
  } });
  Object.defineProperty(exports, "MongoTransactionError", { enumerable: true, get: function() {
    return error_1.MongoTransactionError;
  } });
  Object.defineProperty(exports, "MongoUnexpectedServerResponseError", { enumerable: true, get: function() {
    return error_1.MongoUnexpectedServerResponseError;
  } });
  Object.defineProperty(exports, "MongoWriteConcernError", { enumerable: true, get: function() {
    return error_1.MongoWriteConcernError;
  } });
  var resource_management_1 = require_resource_management();
  Object.defineProperty(exports, "configureExplicitResourceManagement", { enumerable: true, get: function() {
    return resource_management_1.configureExplicitResourceManagement;
  } });
  var common_2 = require_common2();
  Object.defineProperty(exports, "BatchType", { enumerable: true, get: function() {
    return common_2.BatchType;
  } });
  var auto_encrypter_1 = require_auto_encrypter();
  Object.defineProperty(exports, "AutoEncryptionLoggerLevel", { enumerable: true, get: function() {
    return auto_encrypter_1.AutoEncryptionLoggerLevel;
  } });
  var gssapi_1 = require_gssapi();
  Object.defineProperty(exports, "GSSAPICanonicalizationValue", { enumerable: true, get: function() {
    return gssapi_1.GSSAPICanonicalizationValue;
  } });
  var providers_1 = require_providers();
  Object.defineProperty(exports, "AuthMechanism", { enumerable: true, get: function() {
    return providers_1.AuthMechanism;
  } });
  var compression_1 = require_compression();
  Object.defineProperty(exports, "Compressor", { enumerable: true, get: function() {
    return compression_1.Compressor;
  } });
  var abstract_cursor_2 = require_abstract_cursor();
  Object.defineProperty(exports, "CURSOR_FLAGS", { enumerable: true, get: function() {
    return abstract_cursor_2.CURSOR_FLAGS;
  } });
  Object.defineProperty(exports, "CursorTimeoutMode", { enumerable: true, get: function() {
    return abstract_cursor_2.CursorTimeoutMode;
  } });
  var error_2 = require_error();
  Object.defineProperty(exports, "MongoErrorLabel", { enumerable: true, get: function() {
    return error_2.MongoErrorLabel;
  } });
  var explain_2 = require_explain();
  Object.defineProperty(exports, "ExplainVerbosity", { enumerable: true, get: function() {
    return explain_2.ExplainVerbosity;
  } });
  var mongo_client_2 = require_mongo_client();
  Object.defineProperty(exports, "ServerApiVersion", { enumerable: true, get: function() {
    return mongo_client_2.ServerApiVersion;
  } });
  var mongo_logger_1 = require_mongo_logger();
  Object.defineProperty(exports, "MongoLoggableComponent", { enumerable: true, get: function() {
    return mongo_logger_1.MongoLoggableComponent;
  } });
  Object.defineProperty(exports, "SeverityLevel", { enumerable: true, get: function() {
    return mongo_logger_1.SeverityLevel;
  } });
  var find_and_modify_1 = require_find_and_modify();
  Object.defineProperty(exports, "ReturnDocument", { enumerable: true, get: function() {
    return find_and_modify_1.ReturnDocument;
  } });
  var set_profiling_level_1 = require_set_profiling_level();
  Object.defineProperty(exports, "ProfilingLevel", { enumerable: true, get: function() {
    return set_profiling_level_1.ProfilingLevel;
  } });
  var read_concern_1 = require_read_concern();
  Object.defineProperty(exports, "ReadConcernLevel", { enumerable: true, get: function() {
    return read_concern_1.ReadConcernLevel;
  } });
  var read_preference_1 = require_read_preference();
  Object.defineProperty(exports, "ReadPreferenceMode", { enumerable: true, get: function() {
    return read_preference_1.ReadPreferenceMode;
  } });
  var common_3 = require_common();
  Object.defineProperty(exports, "ServerType", { enumerable: true, get: function() {
    return common_3.ServerType;
  } });
  Object.defineProperty(exports, "TopologyType", { enumerable: true, get: function() {
    return common_3.TopologyType;
  } });
  var read_concern_2 = require_read_concern();
  Object.defineProperty(exports, "ReadConcern", { enumerable: true, get: function() {
    return read_concern_2.ReadConcern;
  } });
  var read_preference_2 = require_read_preference();
  Object.defineProperty(exports, "ReadPreference", { enumerable: true, get: function() {
    return read_preference_2.ReadPreference;
  } });
  var write_concern_1 = require_write_concern();
  Object.defineProperty(exports, "WriteConcern", { enumerable: true, get: function() {
    return write_concern_1.WriteConcern;
  } });
  var command_monitoring_events_1 = require_command_monitoring_events();
  Object.defineProperty(exports, "CommandFailedEvent", { enumerable: true, get: function() {
    return command_monitoring_events_1.CommandFailedEvent;
  } });
  Object.defineProperty(exports, "CommandStartedEvent", { enumerable: true, get: function() {
    return command_monitoring_events_1.CommandStartedEvent;
  } });
  Object.defineProperty(exports, "CommandSucceededEvent", { enumerable: true, get: function() {
    return command_monitoring_events_1.CommandSucceededEvent;
  } });
  var connection_pool_events_1 = require_connection_pool_events();
  Object.defineProperty(exports, "ConnectionCheckedInEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionCheckedInEvent;
  } });
  Object.defineProperty(exports, "ConnectionCheckedOutEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionCheckedOutEvent;
  } });
  Object.defineProperty(exports, "ConnectionCheckOutFailedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionCheckOutFailedEvent;
  } });
  Object.defineProperty(exports, "ConnectionCheckOutStartedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionCheckOutStartedEvent;
  } });
  Object.defineProperty(exports, "ConnectionClosedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionClosedEvent;
  } });
  Object.defineProperty(exports, "ConnectionCreatedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionCreatedEvent;
  } });
  Object.defineProperty(exports, "ConnectionPoolClearedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionPoolClearedEvent;
  } });
  Object.defineProperty(exports, "ConnectionPoolClosedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionPoolClosedEvent;
  } });
  Object.defineProperty(exports, "ConnectionPoolCreatedEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionPoolCreatedEvent;
  } });
  Object.defineProperty(exports, "ConnectionPoolMonitoringEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionPoolMonitoringEvent;
  } });
  Object.defineProperty(exports, "ConnectionPoolReadyEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionPoolReadyEvent;
  } });
  Object.defineProperty(exports, "ConnectionReadyEvent", { enumerable: true, get: function() {
    return connection_pool_events_1.ConnectionReadyEvent;
  } });
  var events_1 = require_events();
  Object.defineProperty(exports, "ServerClosedEvent", { enumerable: true, get: function() {
    return events_1.ServerClosedEvent;
  } });
  Object.defineProperty(exports, "ServerDescriptionChangedEvent", { enumerable: true, get: function() {
    return events_1.ServerDescriptionChangedEvent;
  } });
  Object.defineProperty(exports, "ServerHeartbeatFailedEvent", { enumerable: true, get: function() {
    return events_1.ServerHeartbeatFailedEvent;
  } });
  Object.defineProperty(exports, "ServerHeartbeatStartedEvent", { enumerable: true, get: function() {
    return events_1.ServerHeartbeatStartedEvent;
  } });
  Object.defineProperty(exports, "ServerHeartbeatSucceededEvent", { enumerable: true, get: function() {
    return events_1.ServerHeartbeatSucceededEvent;
  } });
  Object.defineProperty(exports, "ServerOpeningEvent", { enumerable: true, get: function() {
    return events_1.ServerOpeningEvent;
  } });
  Object.defineProperty(exports, "TopologyClosedEvent", { enumerable: true, get: function() {
    return events_1.TopologyClosedEvent;
  } });
  Object.defineProperty(exports, "TopologyDescriptionChangedEvent", { enumerable: true, get: function() {
    return events_1.TopologyDescriptionChangedEvent;
  } });
  Object.defineProperty(exports, "TopologyOpeningEvent", { enumerable: true, get: function() {
    return events_1.TopologyOpeningEvent;
  } });
  var server_selection_events_1 = require_server_selection_events();
  Object.defineProperty(exports, "ServerSelectionEvent", { enumerable: true, get: function() {
    return server_selection_events_1.ServerSelectionEvent;
  } });
  Object.defineProperty(exports, "ServerSelectionFailedEvent", { enumerable: true, get: function() {
    return server_selection_events_1.ServerSelectionFailedEvent;
  } });
  Object.defineProperty(exports, "ServerSelectionStartedEvent", { enumerable: true, get: function() {
    return server_selection_events_1.ServerSelectionStartedEvent;
  } });
  Object.defineProperty(exports, "ServerSelectionSucceededEvent", { enumerable: true, get: function() {
    return server_selection_events_1.ServerSelectionSucceededEvent;
  } });
  Object.defineProperty(exports, "WaitingForSuitableServerEvent", { enumerable: true, get: function() {
    return server_selection_events_1.WaitingForSuitableServerEvent;
  } });
  var srv_polling_1 = require_srv_polling();
  Object.defineProperty(exports, "SrvPollingEvent", { enumerable: true, get: function() {
    return srv_polling_1.SrvPollingEvent;
  } });
  var errors_1 = require_errors();
  Object.defineProperty(exports, "MongoCryptAzureKMSRequestError", { enumerable: true, get: function() {
    return errors_1.MongoCryptAzureKMSRequestError;
  } });
  Object.defineProperty(exports, "MongoCryptCreateDataKeyError", { enumerable: true, get: function() {
    return errors_1.MongoCryptCreateDataKeyError;
  } });
  Object.defineProperty(exports, "MongoCryptCreateEncryptedCollectionError", { enumerable: true, get: function() {
    return errors_1.MongoCryptCreateEncryptedCollectionError;
  } });
  Object.defineProperty(exports, "MongoCryptError", { enumerable: true, get: function() {
    return errors_1.MongoCryptError;
  } });
  Object.defineProperty(exports, "MongoCryptInvalidArgumentError", { enumerable: true, get: function() {
    return errors_1.MongoCryptInvalidArgumentError;
  } });
  Object.defineProperty(exports, "MongoCryptKMSRequestNetworkTimeoutError", { enumerable: true, get: function() {
    return errors_1.MongoCryptKMSRequestNetworkTimeoutError;
  } });
  var mongo_client_auth_providers_1 = require_mongo_client_auth_providers();
  Object.defineProperty(exports, "MongoClientAuthProviders", { enumerable: true, get: function() {
    return mongo_client_auth_providers_1.MongoClientAuthProviders;
  } });
});

// node_modules/mongoose/lib/helpers/getConstructorName.js
var require_getConstructorName = __commonJS((exports, module) => {
  module.exports = function getConstructorName(val) {
    if (val == null) {
      return;
    }
    if (typeof val.constructor !== "function") {
      return;
    }
    return val.constructor.name;
  };
});

// node_modules/mongoose/lib/options.js
var require_options = __commonJS((exports) => {
  /*!
   * ignore
   */
  exports.internalToObjectOptions = {
    transform: false,
    virtuals: false,
    getters: false,
    _skipDepopulateTopLevel: true,
    depopulate: true,
    flattenDecimals: false,
    useProjection: false,
    versionKey: true,
    flattenObjectIds: false
  };
});

// node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js
var require_collection3 = __commonJS((exports, module) => {
  function NativeCollection(name, conn, options) {
    this.collection = null;
    this.Promise = options.Promise || Promise;
    this.modelName = options.modelName;
    delete options.modelName;
    this._closed = false;
    MongooseCollection.apply(this, arguments);
  }
  function iter(i) {
    NativeCollection.prototype[i] = function() {
      const collection = this._getCollection();
      const args = Array.from(arguments);
      const _this = this;
      const globalDebug = _this && _this.conn && _this.conn.base && _this.conn.base.options && _this.conn.base.options.debug;
      const connectionDebug = _this && _this.conn && _this.conn.options && _this.conn.options.debug;
      const debug = connectionDebug == null ? globalDebug : connectionDebug;
      const lastArg = arguments[arguments.length - 1];
      const opId = new ObjectId2;
      if (this.conn.$wasForceClosed) {
        const error = new MongooseError("Connection was force closed");
        if (args.length > 0 && typeof args[args.length - 1] === "function") {
          args[args.length - 1](error);
          return;
        } else {
          throw error;
        }
      }
      let _args = args;
      let callback = null;
      if (this._shouldBufferCommands() && this.buffer) {
        this.conn.emit("buffer", {
          _id: opId,
          modelName: _this.modelName,
          collectionName: _this.name,
          method: i,
          args
        });
        let callback2;
        let _args2 = args;
        let promise = null;
        let timeout = null;
        if (syncCollectionMethods[i] && typeof lastArg === "function") {
          this.addQueue(i, _args2);
          callback2 = lastArg;
        } else if (syncCollectionMethods[i]) {
          promise = new this.Promise((resolve, reject) => {
            callback2 = function collectionOperationCallback(err, res) {
              if (timeout != null) {
                clearTimeout(timeout);
              }
              if (err != null) {
                return reject(err);
              }
              resolve(res);
            };
            _args2 = args.concat([callback2]);
            this.addQueue(i, _args2);
          });
        } else if (typeof lastArg === "function") {
          callback2 = function collectionOperationCallback() {
            if (timeout != null) {
              clearTimeout(timeout);
            }
            return lastArg.apply(this, arguments);
          };
          _args2 = args.slice(0, args.length - 1).concat([callback2]);
        } else {
          promise = new Promise((resolve, reject) => {
            callback2 = function collectionOperationCallback(err, res) {
              if (timeout != null) {
                clearTimeout(timeout);
              }
              if (err != null) {
                return reject(err);
              }
              resolve(res);
            };
            _args2 = args.concat([callback2]);
            this.addQueue(i, _args2);
          });
        }
        const bufferTimeoutMS = this._getBufferTimeoutMS();
        timeout = setTimeout(() => {
          const removed = this.removeQueue(i, _args2);
          if (removed) {
            const message = "Operation `" + this.name + "." + i + "()` buffering timed out after " + bufferTimeoutMS + "ms";
            const err = new MongooseError(message);
            this.conn.emit("buffer-end", { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, error: err });
            callback2(err);
          }
        }, bufferTimeoutMS);
        if (!syncCollectionMethods[i] && typeof lastArg === "function") {
          this.addQueue(i, _args2);
          return;
        }
        return promise;
      } else if (!syncCollectionMethods[i] && typeof lastArg === "function") {
        callback = function collectionOperationCallback(err, res) {
          if (err != null) {
            _this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, error: err });
          } else {
            _this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, result: res });
          }
          return lastArg.apply(this, arguments);
        };
        _args = args.slice(0, args.length - 1).concat([callback]);
      }
      if (debug) {
        if (typeof debug === "function") {
          let argsToAdd = null;
          if (typeof args[args.length - 1] == "function") {
            argsToAdd = args.slice(0, args.length - 1);
          } else {
            argsToAdd = args;
          }
          debug.apply(_this, [_this.name, i].concat(argsToAdd));
        } else if (debug instanceof stream.Writable) {
          this.$printToStream(_this.name, i, args, debug);
        } else {
          const color = debug.color == null ? true : debug.color;
          const shell = debug.shell == null ? false : debug.shell;
          this.$print(_this.name, i, args, color, shell);
        }
      }
      this.conn.emit("operation-start", { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, params: _args });
      try {
        if (collection == null) {
          const message = "Cannot call `" + this.name + "." + i + "()` before initial connection " + "is complete if `bufferCommands = false`. Make sure you `await mongoose.connect()` if " + "you have `bufferCommands = false`.";
          throw new MongooseError(message);
        }
        if (syncCollectionMethods[i] && typeof lastArg === "function") {
          const result = collection[i].apply(collection, _args.slice(0, _args.length - 1));
          this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, result });
          return lastArg.call(this, null, result);
        }
        const ret = collection[i].apply(collection, _args);
        if (ret != null && typeof ret.then === "function") {
          return ret.then((result) => {
            if (typeof lastArg === "function") {
              lastArg(null, result);
            } else {
              this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, result });
            }
            return result;
          }, (error) => {
            if (typeof lastArg === "function") {
              lastArg(error);
              return;
            } else {
              this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, error });
            }
            throw error;
          });
        }
        return ret;
      } catch (error) {
        if (typeof lastArg === "function") {
          return lastArg(error);
        } else {
          this.conn.emit("operation-end", { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, error });
          throw error;
        }
      }
    };
  }
  function inspectable(representation) {
    const ret = {
      inspect: function() {
        return representation;
      }
    };
    if (util.inspect.custom) {
      ret[util.inspect.custom] = ret.inspect;
    }
    return ret;
  }
  function map(o) {
    return format(o, true);
  }
  function formatObjectId(x, key) {
    x[key] = inspectable('ObjectId("' + x[key].toHexString() + '")');
  }
  function formatDate(x, key, shell) {
    if (shell) {
      x[key] = inspectable('ISODate("' + x[key].toUTCString() + '")');
    } else {
      x[key] = inspectable('new Date("' + x[key].toUTCString() + '")');
    }
  }
  function format(obj, sub, color, shell) {
    if (obj && typeof obj.toBSON === "function") {
      obj = obj.toBSON();
    }
    if (obj == null) {
      return obj;
    }
    const clone = require_clone2();
    let x = clone(obj, internalToObjectOptions);
    const constructorName = getConstructorName(x);
    if (constructorName === "Binary") {
      x = "BinData(" + x.sub_type + ', "' + x.toString("base64") + '")';
    } else if (constructorName === "ObjectId") {
      x = inspectable('ObjectId("' + x.toHexString() + '")');
    } else if (constructorName === "Date") {
      x = inspectable('new Date("' + x.toUTCString() + '")');
    } else if (constructorName === "Object") {
      const keys = Object.keys(x);
      const numKeys = keys.length;
      let key;
      for (let i = 0;i < numKeys; ++i) {
        key = keys[i];
        if (x[key]) {
          let error;
          if (typeof x[key].toBSON === "function") {
            try {
              x[key] = x[key].toBSON();
            } catch (_error) {
              error = _error;
            }
          }
          const _constructorName = getConstructorName(x[key]);
          if (_constructorName === "Binary") {
            x[key] = "BinData(" + x[key].sub_type + ', "' + x[key].buffer.toString("base64") + '")';
          } else if (_constructorName === "Object") {
            x[key] = format(x[key], true);
          } else if (_constructorName === "ObjectId") {
            formatObjectId(x, key);
          } else if (_constructorName === "Date") {
            formatDate(x, key, shell);
          } else if (_constructorName === "ClientSession") {
            x[key] = inspectable('ClientSession("' + (x[key] && x[key].id && x[key].id.id && x[key].id.id.buffer || "").toString("hex") + '")');
          } else if (Array.isArray(x[key])) {
            x[key] = x[key].map(map);
          } else if (error != null) {
            throw error;
          }
        }
      }
    }
    if (sub) {
      return x;
    }
    return util.inspect(x, false, 10, color).replace(/\n/g, "").replace(/\s{2,}/g, " ");
  }
  /*!
   * Module dependencies.
   */
  var MongooseCollection = require_collection();
  var MongooseError = require_mongooseError();
  var Collection = require_lib3().Collection;
  var ObjectId2 = require_objectid();
  var getConstructorName = require_getConstructorName();
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var stream = import.meta.require("stream");
  var util = import.meta.require("util");
  /*!
   * Inherit from abstract Collection.
   */
  Object.setPrototypeOf(NativeCollection.prototype, MongooseCollection.prototype);
  NativeCollection.prototype.onOpen = function() {
    this.collection = this.conn.db.collection(this.name);
    MongooseCollection.prototype.onOpen.call(this);
    return this.collection;
  };
  NativeCollection.prototype.onClose = function(force) {
    MongooseCollection.prototype.onClose.call(this, force);
  };
  NativeCollection.prototype._getCollection = function _getCollection() {
    if (this.collection) {
      return this.collection;
    }
    if (this.conn.db != null) {
      this.collection = this.conn.db.collection(this.name);
      return this.collection;
    }
    return null;
  };
  /*!
   * ignore
   */
  var syncCollectionMethods = { watch: true, find: true, aggregate: true };
  for (const key of Object.getOwnPropertyNames(Collection.prototype)) {
    const descriptor = Object.getOwnPropertyDescriptor(Collection.prototype, key);
    if (descriptor.get !== undefined) {
      continue;
    }
    if (typeof Collection.prototype[key] !== "function") {
      continue;
    }
    iter(key);
  }
  NativeCollection.prototype.$print = function(name, i, args, color, shell) {
    const moduleName = color ? "\x1B[0;36mMongoose:\x1B[0m " : "Mongoose: ";
    const functionCall = [name, i].join(".");
    const _args = [];
    for (let j = args.length - 1;j >= 0; --j) {
      if (this.$format(args[j]) || _args.length) {
        _args.unshift(this.$format(args[j], color, shell));
      }
    }
    const params = "(" + _args.join(", ") + ")";
    console.info(moduleName + functionCall + params);
  };
  NativeCollection.prototype.$printToStream = function(name, i, args, stream2) {
    const functionCall = [name, i].join(".");
    const _args = [];
    for (let j = args.length - 1;j >= 0; --j) {
      if (this.$format(args[j]) || _args.length) {
        _args.unshift(this.$format(args[j]));
      }
    }
    const params = "(" + _args.join(", ") + ")";
    stream2.write(functionCall + params, "utf8");
  };
  NativeCollection.prototype.$format = function(arg, color, shell) {
    const type = typeof arg;
    if (type === "function" || type === "undefined")
      return "";
    return format(arg, false, color, shell);
  };
  NativeCollection.prototype.getIndexes = NativeCollection.prototype.indexInformation;
  /*!
   * Module exports.
   */
  module.exports = NativeCollection;
});

// node_modules/mongoose/lib/cursor/changeStream.js
var require_changeStream = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var EventEmitter = import.meta.require("events").EventEmitter;
  var MongooseError = require_mongooseError();
  /*!
   * ignore
   */
  var driverChangeStreamEvents = ["close", "change", "end", "error", "resumeTokenChanged"];
  /*!
   * ignore
   */

  class ChangeStream extends EventEmitter {
    constructor(changeStreamThunk, pipeline, options) {
      super();
      this.driverChangeStream = null;
      this.closed = false;
      this.bindedEvents = false;
      this.pipeline = pipeline;
      this.options = options;
      this.errored = false;
      if (options && options.hydrate && !options.model) {
        throw new Error("Cannot create change stream with `hydrate: true` " + "unless calling `Model.watch()`");
      }
      let syncError = null;
      this.$driverChangeStreamPromise = new Promise((resolve, reject) => {
        try {
          changeStreamThunk((err, driverChangeStream) => {
            if (err != null) {
              this.errored = true;
              this.emit("error", err);
              return reject(err);
            }
            this.driverChangeStream = driverChangeStream;
            this.emit("ready");
            resolve();
          });
        } catch (err) {
          syncError = err;
          this.errored = true;
          this.emit("error", err);
          reject(err);
        }
      });
      if (syncError != null) {
        throw syncError;
      }
    }
    _bindEvents() {
      if (this.bindedEvents) {
        return;
      }
      this.bindedEvents = true;
      if (this.driverChangeStream == null) {
        this.$driverChangeStreamPromise.then(() => {
          this.driverChangeStream.on("close", () => {
            this.closed = true;
          });
          driverChangeStreamEvents.forEach((ev) => {
            this.driverChangeStream.on(ev, (data) => {
              if (data != null && data.fullDocument != null && this.options && this.options.hydrate) {
                data.fullDocument = this.options.model.hydrate(data.fullDocument);
              }
              this.emit(ev, data);
            });
          });
        }, () => {
        });
        return;
      }
      this.driverChangeStream.on("close", () => {
        this.closed = true;
      });
      driverChangeStreamEvents.forEach((ev) => {
        this.driverChangeStream.on(ev, (data) => {
          if (data != null && data.fullDocument != null && this.options && this.options.hydrate) {
            data.fullDocument = this.options.model.hydrate(data.fullDocument);
          }
          this.emit(ev, data);
        });
      });
    }
    hasNext(cb) {
      if (this.errored) {
        throw new MongooseError("Cannot call hasNext() on errored ChangeStream");
      }
      return this.driverChangeStream.hasNext(cb);
    }
    next(cb) {
      if (this.errored) {
        throw new MongooseError("Cannot call next() on errored ChangeStream");
      }
      if (this.options && this.options.hydrate) {
        if (cb != null) {
          const originalCb = cb;
          cb = (err, data) => {
            if (err != null) {
              return originalCb(err);
            }
            if (data.fullDocument != null) {
              data.fullDocument = this.options.model.hydrate(data.fullDocument);
            }
            return originalCb(null, data);
          };
        }
        let maybePromise = this.driverChangeStream.next(cb);
        if (maybePromise && typeof maybePromise.then === "function") {
          maybePromise = maybePromise.then((data) => {
            if (data.fullDocument != null) {
              data.fullDocument = this.options.model.hydrate(data.fullDocument);
            }
            return data;
          });
        }
        return maybePromise;
      }
      return this.driverChangeStream.next(cb);
    }
    addListener(event, handler) {
      if (this.errored) {
        throw new MongooseError("Cannot call addListener() on errored ChangeStream");
      }
      this._bindEvents();
      return super.addListener(event, handler);
    }
    on(event, handler) {
      if (this.errored) {
        throw new MongooseError("Cannot call on() on errored ChangeStream");
      }
      this._bindEvents();
      return super.on(event, handler);
    }
    once(event, handler) {
      if (this.errored) {
        throw new MongooseError("Cannot call once() on errored ChangeStream");
      }
      this._bindEvents();
      return super.once(event, handler);
    }
    _queue(cb) {
      this.once("ready", () => cb());
    }
    close() {
      this.closed = true;
      if (this.driverChangeStream) {
        return this.driverChangeStream.close();
      } else {
        return this.$driverChangeStreamPromise.then(() => this.driverChangeStream.close(), () => {
        });
      }
    }
  }
  /*!
   * ignore
   */
  module.exports = ChangeStream;
});

// node_modules/kareem/index.js
var require_kareem = __commonJS((exports, module) => {
  function Kareem() {
    this._pres = new Map;
    this._posts = new Map;
  }
  function _handleWrapError(instance, error, name, context, args, options, callback) {
    if (options.useErrorHandlers) {
      return instance.execPost(name, context, args, { error }, function(error2) {
        return typeof callback === "function" && callback(error2);
      });
    } else {
      return typeof callback === "function" && callback(error);
    }
  }
  function callMiddlewareFunction(fn, context, args, next) {
    let maybePromiseLike;
    try {
      maybePromiseLike = fn.apply(context, args);
    } catch (error) {
      return next(error);
    }
    if (isPromiseLike(maybePromiseLike)) {
      maybePromiseLike.then(() => next(), (err) => next(err));
    }
  }
  function isPromiseLike(v) {
    return typeof v === "object" && v !== null && typeof v.then === "function";
  }
  function decorateNextFn(fn) {
    let called = false;
    const _this = this;
    return function() {
      if (called) {
        return;
      }
      called = true;
      return nextTick(() => fn.apply(_this, arguments));
    };
  }
  function isErrorHandlingMiddleware(post, numArgs) {
    if (post.errorHandler) {
      return true;
    }
    return post.fn.length === numArgs + 2;
  }
  Kareem.skipWrappedFunction = function skipWrappedFunction() {
    if (!(this instanceof Kareem.skipWrappedFunction)) {
      return new Kareem.skipWrappedFunction(...arguments);
    }
    this.args = [...arguments];
  };
  Kareem.overwriteResult = function overwriteResult() {
    if (!(this instanceof Kareem.overwriteResult)) {
      return new Kareem.overwriteResult(...arguments);
    }
    this.args = [...arguments];
  };
  Kareem.prototype.execPre = function(name, context, args, callback) {
    if (arguments.length === 3) {
      callback = args;
      args = [];
    }
    const pres = this._pres.get(name) || [];
    const numPres = pres.length;
    const numAsyncPres = pres.numAsync || 0;
    let currentPre = 0;
    let asyncPresLeft = numAsyncPres;
    let done = false;
    const $args = args;
    let shouldSkipWrappedFunction = null;
    if (!numPres) {
      return nextTick(function() {
        callback(null);
      });
    }
    function next() {
      if (currentPre >= numPres) {
        return;
      }
      const pre = pres[currentPre];
      if (pre.isAsync) {
        const args2 = [
          decorateNextFn(_next),
          decorateNextFn(function(error) {
            if (error) {
              if (done) {
                return;
              }
              if (error instanceof Kareem.skipWrappedFunction) {
                shouldSkipWrappedFunction = error;
              } else {
                done = true;
                return callback(error);
              }
            }
            if (--asyncPresLeft === 0 && currentPre >= numPres) {
              return callback(shouldSkipWrappedFunction);
            }
          })
        ];
        callMiddlewareFunction(pre.fn, context, args2, args2[0]);
      } else if (pre.fn.length > 0) {
        const args2 = [decorateNextFn(_next)];
        const _args = arguments.length >= 2 ? arguments : [null].concat($args);
        for (let i = 1;i < _args.length; ++i) {
          if (i === _args.length - 1 && typeof _args[i] === "function") {
            continue;
          }
          args2.push(_args[i]);
        }
        callMiddlewareFunction(pre.fn, context, args2, args2[0]);
      } else {
        let maybePromiseLike = null;
        try {
          maybePromiseLike = pre.fn.call(context);
        } catch (err) {
          if (err != null) {
            return callback(err);
          }
        }
        if (isPromiseLike(maybePromiseLike)) {
          maybePromiseLike.then(() => _next(), (err) => _next(err));
        } else {
          if (++currentPre >= numPres) {
            if (asyncPresLeft > 0) {
              return;
            } else {
              return nextTick(function() {
                callback(shouldSkipWrappedFunction);
              });
            }
          }
          next();
        }
      }
    }
    next.apply(null, [null].concat(args));
    function _next(error) {
      if (error) {
        if (done) {
          return;
        }
        if (error instanceof Kareem.skipWrappedFunction) {
          shouldSkipWrappedFunction = error;
        } else {
          done = true;
          return callback(error);
        }
      }
      if (++currentPre >= numPres) {
        if (asyncPresLeft > 0) {
          return;
        } else {
          return callback(shouldSkipWrappedFunction);
        }
      }
      next.apply(context, arguments);
    }
  };
  Kareem.prototype.execPreSync = function(name, context, args) {
    const pres = this._pres.get(name) || [];
    const numPres = pres.length;
    for (let i = 0;i < numPres; ++i) {
      pres[i].fn.apply(context, args || []);
    }
  };
  Kareem.prototype.execPost = function(name, context, args, options, callback) {
    if (arguments.length < 5) {
      callback = options;
      options = null;
    }
    const posts = this._posts.get(name) || [];
    const numPosts = posts.length;
    let currentPost = 0;
    let firstError = null;
    if (options && options.error) {
      firstError = options.error;
    }
    if (!numPosts) {
      return nextTick(function() {
        callback.apply(null, [firstError].concat(args));
      });
    }
    function next() {
      const post = posts[currentPost].fn;
      let numArgs = 0;
      const argLength = args.length;
      const newArgs = [];
      for (let i = 0;i < argLength; ++i) {
        numArgs += args[i] && args[i]._kareemIgnore ? 0 : 1;
        if (!args[i] || !args[i]._kareemIgnore) {
          newArgs.push(args[i]);
        }
      }
      if (firstError) {
        if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {
          const _cb = decorateNextFn(function(error) {
            if (error) {
              if (error instanceof Kareem.overwriteResult) {
                args = error.args;
                if (++currentPost >= numPosts) {
                  return callback.call(null, firstError);
                }
                return next();
              }
              firstError = error;
            }
            if (++currentPost >= numPosts) {
              return callback.call(null, firstError);
            }
            next();
          });
          callMiddlewareFunction(post, context, [firstError].concat(newArgs).concat([_cb]), _cb);
        } else {
          if (++currentPost >= numPosts) {
            return callback.call(null, firstError);
          }
          next();
        }
      } else {
        const _cb = decorateNextFn(function(error) {
          if (error) {
            if (error instanceof Kareem.overwriteResult) {
              args = error.args;
              if (++currentPost >= numPosts) {
                return callback.apply(null, [null].concat(args));
              }
              return next();
            }
            firstError = error;
            return next();
          }
          if (++currentPost >= numPosts) {
            return callback.apply(null, [null].concat(args));
          }
          next();
        });
        if (isErrorHandlingMiddleware(posts[currentPost], numArgs)) {
          if (++currentPost >= numPosts) {
            return callback.apply(null, [null].concat(args));
          }
          return next();
        }
        if (post.length === numArgs + 1) {
          callMiddlewareFunction(post, context, newArgs.concat([_cb]), _cb);
        } else {
          let error;
          let maybePromiseLike;
          try {
            maybePromiseLike = post.apply(context, newArgs);
          } catch (err) {
            error = err;
            firstError = err;
          }
          if (isPromiseLike(maybePromiseLike)) {
            return maybePromiseLike.then((res) => {
              _cb(res instanceof Kareem.overwriteResult ? res : null);
            }, (err) => _cb(err));
          }
          if (maybePromiseLike instanceof Kareem.overwriteResult) {
            args = maybePromiseLike.args;
          }
          if (++currentPost >= numPosts) {
            return callback.apply(null, [error].concat(args));
          }
          next();
        }
      }
    }
    next();
  };
  Kareem.prototype.execPostSync = function(name, context, args) {
    const posts = this._posts.get(name) || [];
    const numPosts = posts.length;
    for (let i = 0;i < numPosts; ++i) {
      const res = posts[i].fn.apply(context, args || []);
      if (res instanceof Kareem.overwriteResult) {
        args = res.args;
      }
    }
    return args;
  };
  Kareem.prototype.createWrapperSync = function(name, fn) {
    const _this = this;
    return function syncWrapper() {
      _this.execPreSync(name, this, arguments);
      const toReturn = fn.apply(this, arguments);
      const result = _this.execPostSync(name, this, [toReturn]);
      return result[0];
    };
  };
  Kareem.prototype.wrap = function(name, fn, context, args, options) {
    const lastArg = args.length > 0 ? args[args.length - 1] : null;
    const argsWithoutCb = Array.from(args);
    typeof lastArg === "function" && argsWithoutCb.pop();
    const _this = this;
    options = options || {};
    const checkForPromise = options.checkForPromise;
    this.execPre(name, context, args, function(error) {
      if (error && !(error instanceof Kareem.skipWrappedFunction)) {
        const numCallbackParams = options.numCallbackParams || 0;
        const errorArgs = options.contextParameter ? [context] : [];
        for (let i = errorArgs.length;i < numCallbackParams; ++i) {
          errorArgs.push(null);
        }
        return _handleWrapError(_this, error, name, context, errorArgs, options, lastArg);
      }
      const numParameters = fn.length;
      let ret;
      if (error instanceof Kareem.skipWrappedFunction) {
        ret = error.args[0];
        return _cb(null, ...error.args);
      } else {
        try {
          ret = fn.apply(context, argsWithoutCb.concat(_cb));
        } catch (err) {
          return _cb(err);
        }
      }
      if (checkForPromise) {
        if (isPromiseLike(ret)) {
          return ret.then((res) => _cb(null, res), (err) => _cb(err));
        }
        if (numParameters < argsWithoutCb.length + 1) {
          return _cb(null, ret);
        }
      }
      function _cb() {
        const argsWithoutError = Array.from(arguments);
        argsWithoutError.shift();
        if (options.nullResultByDefault && argsWithoutError.length === 0) {
          argsWithoutError.push(null);
        }
        if (arguments[0]) {
          return _handleWrapError(_this, arguments[0], name, context, argsWithoutError, options, lastArg);
        } else {
          _this.execPost(name, context, argsWithoutError, function() {
            if (lastArg === null) {
              return;
            }
            arguments[0] ? lastArg(arguments[0]) : lastArg.apply(context, arguments);
          });
        }
      }
    });
  };
  Kareem.prototype.filter = function(fn) {
    const clone = this.clone();
    const pres = Array.from(clone._pres.keys());
    for (const name of pres) {
      const hooks = this._pres.get(name).map((h) => Object.assign({}, h, { name })).filter(fn);
      if (hooks.length === 0) {
        clone._pres.delete(name);
        continue;
      }
      hooks.numAsync = hooks.filter((h) => h.isAsync).length;
      clone._pres.set(name, hooks);
    }
    const posts = Array.from(clone._posts.keys());
    for (const name of posts) {
      const hooks = this._posts.get(name).map((h) => Object.assign({}, h, { name })).filter(fn);
      if (hooks.length === 0) {
        clone._posts.delete(name);
        continue;
      }
      clone._posts.set(name, hooks);
    }
    return clone;
  };
  Kareem.prototype.hasHooks = function(name) {
    return this._pres.has(name) || this._posts.has(name);
  };
  Kareem.prototype.createWrapper = function(name, fn, context, options) {
    const _this = this;
    if (!this.hasHooks(name)) {
      return function() {
        nextTick(() => fn.apply(this, arguments));
      };
    }
    return function() {
      const _context = context || this;
      _this.wrap(name, fn, _context, Array.from(arguments), options);
    };
  };
  Kareem.prototype.pre = function(name, isAsync, fn, error, unshift) {
    let options = {};
    if (typeof isAsync === "object" && isAsync !== null) {
      options = isAsync;
      isAsync = options.isAsync;
    } else if (typeof arguments[1] !== "boolean") {
      fn = isAsync;
      isAsync = false;
    }
    const pres = this._pres.get(name) || [];
    this._pres.set(name, pres);
    if (isAsync) {
      pres.numAsync = pres.numAsync || 0;
      ++pres.numAsync;
    }
    if (typeof fn !== "function") {
      throw new Error('pre() requires a function, got "' + typeof fn + '"');
    }
    if (unshift) {
      pres.unshift(Object.assign({}, options, { fn, isAsync }));
    } else {
      pres.push(Object.assign({}, options, { fn, isAsync }));
    }
    return this;
  };
  Kareem.prototype.post = function(name, options, fn, unshift) {
    const posts = this._posts.get(name) || [];
    if (typeof options === "function") {
      unshift = !!fn;
      fn = options;
      options = {};
    }
    if (typeof fn !== "function") {
      throw new Error('post() requires a function, got "' + typeof fn + '"');
    }
    if (unshift) {
      posts.unshift(Object.assign({}, options, { fn }));
    } else {
      posts.push(Object.assign({}, options, { fn }));
    }
    this._posts.set(name, posts);
    return this;
  };
  Kareem.prototype.clone = function() {
    const n = new Kareem;
    for (const key of this._pres.keys()) {
      const clone = this._pres.get(key).slice();
      clone.numAsync = this._pres.get(key).numAsync;
      n._pres.set(key, clone);
    }
    for (const key of this._posts.keys()) {
      n._posts.set(key, this._posts.get(key).slice());
    }
    return n;
  };
  Kareem.prototype.merge = function(other, clone) {
    clone = arguments.length === 1 ? true : clone;
    const ret = clone ? this.clone() : this;
    for (const key of other._pres.keys()) {
      const sourcePres = ret._pres.get(key) || [];
      const deduplicated = other._pres.get(key).filter((p) => sourcePres.map((_p) => _p.fn).indexOf(p.fn) === -1);
      const combined = sourcePres.concat(deduplicated);
      combined.numAsync = sourcePres.numAsync || 0;
      combined.numAsync += deduplicated.filter((p) => p.isAsync).length;
      ret._pres.set(key, combined);
    }
    for (const key of other._posts.keys()) {
      const sourcePosts = ret._posts.get(key) || [];
      const deduplicated = other._posts.get(key).filter((p) => sourcePosts.indexOf(p) === -1);
      ret._posts.set(key, sourcePosts.concat(deduplicated));
    }
    return ret;
  };
  var nextTick = typeof process === "object" && process !== null && process.nextTick || function nextTick(cb) {
    setTimeout(cb, 0);
  };
  module.exports = Kareem;
});

// node_modules/mongoose/lib/error/messages.js
var require_messages = __commonJS((exports, module) => {
  var msg = module.exports = exports = {};
  msg.DocumentNotFoundError = null;
  msg.general = {};
  msg.general.default = "Validator failed for path `{PATH}` with value `{VALUE}`";
  msg.general.required = "Path `{PATH}` is required.";
  msg.Number = {};
  msg.Number.min = "Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).";
  msg.Number.max = "Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).";
  msg.Number.enum = "`{VALUE}` is not a valid enum value for path `{PATH}`.";
  msg.Date = {};
  msg.Date.min = "Path `{PATH}` ({VALUE}) is before minimum allowed value ({MIN}).";
  msg.Date.max = "Path `{PATH}` ({VALUE}) is after maximum allowed value ({MAX}).";
  msg.String = {};
  msg.String.enum = "`{VALUE}` is not a valid enum value for path `{PATH}`.";
  msg.String.match = "Path `{PATH}` is invalid ({VALUE}).";
  msg.String.minlength = "Path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).";
  msg.String.maxlength = "Path `{PATH}` (`{VALUE}`) is longer than the maximum allowed length ({MAXLENGTH}).";
});

// node_modules/mongoose/lib/error/notFound.js
var require_notFound = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();
  var util = import.meta.require("util");

  class DocumentNotFoundError extends MongooseError {
    constructor(filter, model, numAffected, result) {
      let msg;
      const messages = MongooseError.messages;
      if (messages.DocumentNotFoundError != null) {
        msg = typeof messages.DocumentNotFoundError === "function" ? messages.DocumentNotFoundError(filter, model) : messages.DocumentNotFoundError;
      } else {
        msg = 'No document found for query "' + util.inspect(filter) + '" on model "' + model + '"';
      }
      super(msg);
      this.result = result;
      this.numAffected = numAffected;
      this.filter = filter;
      this.query = filter;
    }
  }
  Object.defineProperty(DocumentNotFoundError.prototype, "name", {
    value: "DocumentNotFoundError"
  });
  /*!
   * exports
   */
  module.exports = DocumentNotFoundError;
});

// node_modules/mongoose/lib/error/cast.js
var require_cast = __commonJS((exports, module) => {
  function getStringValue(value) {
    let stringValue = util.inspect(value);
    stringValue = stringValue.replace(/^'|'$/g, '"');
    if (!stringValue.startsWith('"')) {
      stringValue = '"' + stringValue + '"';
    }
    return stringValue;
  }
  function getValueType(value) {
    if (value == null) {
      return "" + value;
    }
    const t = typeof value;
    if (t !== "object") {
      return t;
    }
    if (typeof value.constructor !== "function") {
      return t;
    }
    return value.constructor.name;
  }
  function getMessageFormat(schemaType) {
    const messageFormat = schemaType && schemaType._castErrorMessage || null;
    if (typeof messageFormat === "string" || typeof messageFormat === "function") {
      return messageFormat;
    }
  }
  function formatMessage(model, kind, value, path, messageFormat, valueType, reason) {
    if (typeof messageFormat === "string") {
      const stringValue = getStringValue(value);
      let ret = messageFormat.replace("{KIND}", kind).replace("{VALUE}", stringValue).replace("{PATH}", path);
      if (model != null) {
        ret = ret.replace("{MODEL}", model.modelName);
      }
      return ret;
    } else if (typeof messageFormat === "function") {
      return messageFormat(value, path, model, kind);
    } else {
      const stringValue = getStringValue(value);
      const valueTypeMsg = valueType ? " (type " + valueType + ")" : "";
      let ret = "Cast to " + kind + " failed for value " + stringValue + valueTypeMsg + ' at path "' + path + '"';
      if (model != null) {
        ret += ' for model "' + model.modelName + '"';
      }
      if (reason != null && typeof reason.constructor === "function" && reason.constructor.name !== "AssertionError" && reason.constructor.name !== "Error") {
        ret += ' because of "' + reason.constructor.name + '"';
      }
      return ret;
    }
  }
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();
  var util = import.meta.require("util");

  class CastError extends MongooseError {
    constructor(type, value, path, reason, schemaType) {
      if (arguments.length > 0) {
        const valueType = getValueType(value);
        const messageFormat = getMessageFormat(schemaType);
        const msg = formatMessage(null, type, value, path, messageFormat, valueType, reason);
        super(msg);
        this.init(type, value, path, reason, schemaType);
      } else {
        super(formatMessage());
      }
    }
    toJSON() {
      return {
        stringValue: this.stringValue,
        valueType: this.valueType,
        kind: this.kind,
        value: this.value,
        path: this.path,
        reason: this.reason,
        name: this.name,
        message: this.message
      };
    }
    init(type, value, path, reason, schemaType) {
      /*!
         * ignore
         */
      this.stringValue = getStringValue(value);
      this.messageFormat = getMessageFormat(schemaType);
      this.kind = type;
      this.value = value;
      this.path = path;
      this.reason = reason;
      this.valueType = getValueType(value);
    }
    copy(other) {
      this.messageFormat = other.messageFormat;
      this.stringValue = other.stringValue;
      this.kind = other.kind;
      this.value = other.value;
      this.path = other.path;
      this.reason = other.reason;
      this.message = other.message;
      this.valueType = other.valueType;
    }
    setModel(model) {
      /*!
         * ignore
         */
      this.message = formatMessage(model, this.kind, this.value, this.path, this.messageFormat, this.valueType);
    }
  }
  Object.defineProperty(CastError.prototype, "name", {
    value: "CastError"
  });
  /*!
   * ignore
   */
  /*!
   * exports
   */
  module.exports = CastError;
});

// node_modules/mongoose/lib/helpers/error/combinePathErrors.js
var require_combinePathErrors = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  module.exports = function combinePathErrors(err) {
    const keys = Object.keys(err.errors || {});
    const len = keys.length;
    const msgs = [];
    let key;
    for (let i = 0;i < len; ++i) {
      key = keys[i];
      if (err === err.errors[key]) {
        continue;
      }
      msgs.push(key + ": " + err.errors[key].message);
    }
    return msgs.join(", ");
  };
});

// node_modules/mongoose/lib/error/validation.js
var require_validation = __commonJS((exports, module) => {
  /*!
   * Module requirements
   */
  var MongooseError = require_mongooseError();
  var getConstructorName = require_getConstructorName();
  var util = import.meta.require("util");
  var combinePathErrors = require_combinePathErrors();

  class ValidationError extends MongooseError {
    constructor(instance) {
      let _message;
      if (getConstructorName(instance) === "model") {
        _message = instance.constructor.modelName + " validation failed";
      } else {
        _message = "Validation failed";
      }
      super(_message);
      this.errors = {};
      this._message = _message;
      if (instance) {
        instance.$errors = this.errors;
      }
    }
    toString() {
      return this.name + ": " + combinePathErrors(this);
    }
    inspect() {
      return Object.assign(new Error(this.message), this);
    }
    addError(path, error) {
      if (error instanceof ValidationError) {
        const { errors } = error;
        for (const errorPath of Object.keys(errors)) {
          this.addError(`${path}.${errorPath}`, errors[errorPath]);
        }
        return;
      }
      this.errors[path] = error;
      this.message = this._message + ": " + combinePathErrors(this);
    }
  }
  if (util.inspect.custom) {
    ValidationError.prototype[util.inspect.custom] = ValidationError.prototype.inspect;
  }
  Object.defineProperty(ValidationError.prototype, "toJSON", {
    enumerable: false,
    writable: false,
    configurable: true,
    value: function() {
      return Object.assign({}, this, { name: this.name, message: this.message });
    }
  });
  Object.defineProperty(ValidationError.prototype, "name", {
    value: "ValidationError"
  });
  /*!
   * Module exports
   */
  module.exports = ValidationError;
});

// node_modules/mongoose/lib/error/validator.js
var require_validator = __commonJS((exports, module) => {
  function formatMessage(msg, properties, doc) {
    if (typeof msg === "function") {
      return msg(properties, doc);
    }
    const propertyNames = Object.keys(properties);
    for (const propertyName of propertyNames) {
      if (propertyName === "message") {
        continue;
      }
      msg = msg.replace("{" + propertyName.toUpperCase() + "}", properties[propertyName]);
    }
    return msg;
  }
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class ValidatorError extends MongooseError {
    constructor(properties, doc) {
      let msg = properties.message;
      if (!msg) {
        msg = MongooseError.messages.general.default;
      }
      const message = formatMessage(msg, properties, doc);
      super(message);
      properties = Object.assign({}, properties, { message });
      this.properties = properties;
      this.kind = properties.type;
      this.path = properties.path;
      this.value = properties.value;
      this.reason = properties.reason;
    }
    toString() {
      return this.message;
    }
    toJSON() {
      return Object.assign({ name: this.name, message: this.message }, this);
    }
  }
  Object.defineProperty(ValidatorError.prototype, "name", {
    value: "ValidatorError"
  });
  Object.defineProperty(ValidatorError.prototype, "properties", {
    enumerable: false,
    writable: true,
    value: null
  });
  ValidatorError.prototype.formatMessage = formatMessage;
  /*!
   * exports
   */
  module.exports = ValidatorError;
});

// node_modules/mongoose/lib/error/version.js
var require_version = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class VersionError extends MongooseError {
    constructor(doc, currentVersion, modifiedPaths) {
      const modifiedPathsStr = modifiedPaths.join(", ");
      super('No matching document found for id "' + doc._doc._id + '" version ' + currentVersion + ' modifiedPaths "' + modifiedPathsStr + '"');
      this.version = currentVersion;
      this.modifiedPaths = modifiedPaths;
    }
  }
  Object.defineProperty(VersionError.prototype, "name", {
    value: "VersionError"
  });
  /*!
   * exports
   */
  module.exports = VersionError;
});

// node_modules/mongoose/lib/error/parallelSave.js
var require_parallelSave = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class ParallelSaveError extends MongooseError {
    constructor(doc) {
      const msg = "Can\'t save() the same doc multiple times in parallel. Document: ";
      super(msg + doc._doc._id);
    }
  }
  Object.defineProperty(ParallelSaveError.prototype, "name", {
    value: "ParallelSaveError"
  });
  /*!
   * exports
   */
  module.exports = ParallelSaveError;
});

// node_modules/mongoose/lib/error/overwriteModel.js
var require_overwriteModel = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class OverwriteModelError extends MongooseError {
    constructor(name) {
      super("Cannot overwrite `" + name + "` model once compiled.");
    }
  }
  Object.defineProperty(OverwriteModelError.prototype, "name", {
    value: "OverwriteModelError"
  });
  /*!
   * exports
   */
  module.exports = OverwriteModelError;
});

// node_modules/mongoose/lib/error/missingSchema.js
var require_missingSchema = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class MissingSchemaError extends MongooseError {
    constructor(name) {
      const msg = 'Schema hasn\'t been registered for model "' + name + '".\n' + "Use mongoose.model(name, schema)";
      super(msg);
    }
  }
  Object.defineProperty(MissingSchemaError.prototype, "name", {
    value: "MissingSchemaError"
  });
  /*!
   * exports
   */
  module.exports = MissingSchemaError;
});

// node_modules/mongoose/lib/helpers/topology/allServersUnknown.js
var require_allServersUnknown = __commonJS((exports, module) => {
  var getConstructorName = require_getConstructorName();
  module.exports = function allServersUnknown(topologyDescription) {
    if (getConstructorName(topologyDescription) !== "TopologyDescription") {
      return false;
    }
    const servers = Array.from(topologyDescription.servers.values());
    return servers.length > 0 && servers.every((server) => server.type === "Unknown");
  };
});

// node_modules/mongoose/lib/helpers/topology/isAtlas.js
var require_isAtlas = __commonJS((exports, module) => {
  var getConstructorName = require_getConstructorName();
  module.exports = function isAtlas(topologyDescription) {
    if (getConstructorName(topologyDescription) !== "TopologyDescription") {
      return false;
    }
    if (topologyDescription.servers.size === 0) {
      return false;
    }
    for (const server of topologyDescription.servers.values()) {
      if (server.host.endsWith(".mongodb.net") === false || server.port !== 27017) {
        return false;
      }
    }
    return true;
  };
});

// node_modules/mongoose/lib/helpers/topology/isSSLError.js
var require_isSSLError = __commonJS((exports, module) => {
  var getConstructorName = require_getConstructorName();
  var nonSSLMessage = "Client network socket disconnected before secure TLS " + "connection was established";
  module.exports = function isSSLError(topologyDescription) {
    if (getConstructorName(topologyDescription) !== "TopologyDescription") {
      return false;
    }
    const descriptions = Array.from(topologyDescription.servers.values());
    return descriptions.length > 0 && descriptions.every((descr) => descr.error && descr.error.message.indexOf(nonSSLMessage) !== -1);
  };
});

// node_modules/mongoose/lib/error/serverSelection.js
var require_serverSelection = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();
  var allServersUnknown = require_allServersUnknown();
  var isAtlas = require_isAtlas();
  var isSSLError = require_isSSLError();
  /*!
   * ignore
   */
  var atlasMessage = "Could not connect to any servers in your MongoDB Atlas cluster. " + "One common reason is that you\'re trying to access the database from " + "an IP that isn\'t whitelisted. Make sure your current IP address is on your Atlas " + "cluster\'s IP whitelist: https://www.mongodb.com/docs/atlas/security-whitelist/";
  var sslMessage = "Mongoose is connecting with SSL enabled, but the server is " + "not accepting SSL connections. Please ensure that the MongoDB server you are " + "connecting to is configured to accept SSL connections. Learn more: " + "https://mongoosejs.com/docs/tutorials/ssl.html";

  class MongooseServerSelectionError extends MongooseError {
    assimilateError(err) {
      const reason = err.reason;
      const isAtlasWhitelistError = isAtlas(reason) && allServersUnknown(reason) && err.message.indexOf("bad auth") === -1 && err.message.indexOf("Authentication failed") === -1;
      if (isAtlasWhitelistError) {
        this.message = atlasMessage;
      } else if (isSSLError(reason)) {
        this.message = sslMessage;
      } else {
        this.message = err.message;
      }
      for (const key in err) {
        if (key !== "name") {
          this[key] = err[key];
        }
      }
      return this;
    }
  }
  Object.defineProperty(MongooseServerSelectionError.prototype, "name", {
    value: "MongooseServerSelectionError"
  });
  module.exports = MongooseServerSelectionError;
});

// node_modules/mongoose/lib/error/divergentArray.js
var require_divergentArray = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class DivergentArrayError extends MongooseError {
    constructor(paths) {
      const msg = "For your own good, using `document.save()` to update an array " + "which was selected using an $elemMatch projection OR " + "populated using skip, limit, query conditions, or exclusion of " + "the _id field when the operation results in a $pop or $set of " + "the entire array is not supported. The following " + "path(s) would have been modified unsafely:\n" + "  " + paths.join("\n  ") + "\n" + "Use Model.updateOne() to update these arrays instead.";
      super(msg);
    }
  }
  Object.defineProperty(DivergentArrayError.prototype, "name", {
    value: "DivergentArrayError"
  });
  /*!
   * exports
   */
  module.exports = DivergentArrayError;
});

// node_modules/mongoose/lib/error/strict.js
var require_strict = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class StrictModeError extends MongooseError {
    constructor(path, msg, immutable) {
      msg = msg || "Field `" + path + "` is not in schema and strict " + "mode is set to throw.";
      super(msg);
      this.isImmutableError = !!immutable;
      this.path = path;
    }
  }
  Object.defineProperty(StrictModeError.prototype, "name", {
    value: "StrictModeError"
  });
  module.exports = StrictModeError;
});

// node_modules/mongoose/lib/error/strictPopulate.js
var require_strictPopulate = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class StrictPopulateError extends MongooseError {
    constructor(path, msg) {
      msg = msg || "Cannot populate path `" + path + "` because it is not in your schema. " + "Set the `strictPopulate` option to false to override.";
      super(msg);
      this.path = path;
    }
  }
  Object.defineProperty(StrictPopulateError.prototype, "name", {
    value: "StrictPopulateError"
  });
  module.exports = StrictPopulateError;
});

// node_modules/mongoose/lib/error/index.js
var require_error2 = __commonJS((exports, module) => {
  var MongooseError = require_mongooseError();
  /*!
   * Module exports.
   */
  module.exports = exports = MongooseError;
  MongooseError.messages = require_messages();
  MongooseError.Messages = MongooseError.messages;
  MongooseError.DocumentNotFoundError = require_notFound();
  MongooseError.CastError = require_cast();
  MongooseError.ValidationError = require_validation();
  MongooseError.ValidatorError = require_validator();
  MongooseError.VersionError = require_version();
  MongooseError.ParallelSaveError = require_parallelSave();
  MongooseError.OverwriteModelError = require_overwriteModel();
  MongooseError.MissingSchemaError = require_missingSchema();
  MongooseError.MongooseServerSelectionError = require_serverSelection();
  MongooseError.DivergentArrayError = require_divergentArray();
  MongooseError.StrictModeError = require_strict();
  MongooseError.StrictPopulateError = require_strictPopulate();
});

// node_modules/mongoose/lib/options/propertyOptions.js
var require_propertyOptions = __commonJS((exports, module) => {
  module.exports = Object.freeze({
    enumerable: true,
    configurable: true,
    writable: true,
    value: undefined
  });
});

// node_modules/mongoose/lib/options/schemaTypeOptions.js
var require_schemaTypeOptions = __commonJS((exports, module) => {
  var clone = require_clone2();

  class SchemaTypeOptions {
    constructor(obj) {
      if (obj == null) {
        return this;
      }
      Object.assign(this, clone(obj));
    }
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaTypeOptions.prototype, "type", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "validate", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "cast", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "required", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "default", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "ref", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "refPath", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "select", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "index", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "unique", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "immutable", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "sparse", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "text", opts);
  Object.defineProperty(SchemaTypeOptions.prototype, "transform", opts);
  module.exports = SchemaTypeOptions;
});

// node_modules/mongoose/lib/cast/boolean.js
var require_boolean = __commonJS((exports, module) => {
  var CastError = require_cast();
  module.exports = function castBoolean(value, path) {
    if (module.exports.convertToTrue.has(value)) {
      return true;
    }
    if (module.exports.convertToFalse.has(value)) {
      return false;
    }
    if (value == null) {
      return value;
    }
    throw new CastError("boolean", value, path);
  };
  module.exports.convertToTrue = new Set([true, "true", 1, "1", "yes"]);
  module.exports.convertToFalse = new Set([false, "false", 0, "0", "no"]);
});

// node_modules/mongoose/lib/schema/operators/exists.js
var require_exists = __commonJS((exports, module) => {
  var castBoolean = require_boolean();
  /*!
   * ignore
   */
  module.exports = function(val) {
    const path = this != null ? this.path : null;
    return castBoolean(val, path);
  };
});

// node_modules/mongoose/lib/schema/operators/type.js
var require_type = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  module.exports = function(val) {
    if (Array.isArray(val)) {
      if (!val.every((v) => typeof v === "number" || typeof v === "string")) {
        throw new Error("$type array values must be strings or numbers");
      }
      return val;
    }
    if (typeof val !== "number" && typeof val !== "string") {
      throw new Error("$type parameter must be number, string, or array of numbers and strings");
    }
    return val;
  };
});

// node_modules/mongoose/lib/helpers/schematype/handleImmutable.js
var require_handleImmutable = __commonJS((exports, module) => {
  function createImmutableSetter(path, immutable) {
    return function immutableSetter(v, _priorVal, _doc, options) {
      if (this == null || this.$__ == null) {
        return v;
      }
      if (this.isNew) {
        return v;
      }
      if (options && options.overwriteImmutable) {
        return v;
      }
      const _immutable = typeof immutable === "function" ? immutable.call(this, this) : immutable;
      if (!_immutable) {
        return v;
      }
      const _value = this.$__.priorDoc != null ? this.$__.priorDoc.$__getValue(path) : this.$__getValue(path);
      if (this.$__.strictMode === "throw" && v !== _value) {
        throw new StrictModeError(path, "Path `" + path + "` is immutable " + "and strict mode is set to throw.", true);
      }
      return _value;
    };
  }
  var StrictModeError = require_strict();
  /*!
   * ignore
   */
  module.exports = function(schematype) {
    if (schematype.$immutable) {
      schematype.$immutableSetter = createImmutableSetter(schematype.path, schematype.options.immutable);
      schematype.set(schematype.$immutableSetter);
    } else if (schematype.$immutableSetter) {
      schematype.setters = schematype.setters.filter((fn) => fn !== schematype.$immutableSetter);
      delete schematype.$immutableSetter;
    }
  };
});

// node_modules/mongoose/lib/helpers/isAsyncFunction.js
var require_isAsyncFunction = __commonJS((exports, module) => {
  module.exports = function isAsyncFunction(v) {
    return typeof v === "function" && v.constructor && v.constructor.name === "AsyncFunction";
  };
});

// node_modules/mongoose/lib/helpers/isSimpleValidator.js
var require_isSimpleValidator = __commonJS((exports, module) => {
  module.exports = function isSimpleValidator(obj) {
    const keys = Object.keys(obj);
    let result = true;
    for (let i = 0, len = keys.length;i < len; ++i) {
      if (typeof obj[keys[i]] === "object" && obj[keys[i]] !== null) {
        result = false;
        break;
      }
    }
    return result;
  };
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
});

// node_modules/mpath/lib/stringToParts.js
var require_stringToParts = __commonJS((exports, module) => {
  module.exports = function stringToParts(str) {
    const result = [];
    let curPropertyName = "";
    let state = "DEFAULT";
    for (let i = 0;i < str.length; ++i) {
      if (state === "IN_SQUARE_BRACKETS" && !/\d/.test(str[i]) && str[i] !== "]") {
        state = "DEFAULT";
        curPropertyName = result[result.length - 1] + "[" + curPropertyName;
        result.splice(result.length - 1, 1);
      }
      if (str[i] === "[") {
        if (state !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS") {
          result.push(curPropertyName);
          curPropertyName = "";
        }
        state = "IN_SQUARE_BRACKETS";
      } else if (str[i] === "]") {
        if (state === "IN_SQUARE_BRACKETS") {
          state = "IMMEDIATELY_AFTER_SQUARE_BRACKETS";
          result.push(curPropertyName);
          curPropertyName = "";
        } else {
          state = "DEFAULT";
          curPropertyName += str[i];
        }
      } else if (str[i] === ".") {
        if (state !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS") {
          result.push(curPropertyName);
          curPropertyName = "";
        }
        state = "DEFAULT";
      } else {
        curPropertyName += str[i];
      }
    }
    if (state !== "IMMEDIATELY_AFTER_SQUARE_BRACKETS") {
      result.push(curPropertyName);
    }
    return result;
  };
});

// node_modules/mpath/lib/index.js
var require_lib4 = __commonJS((exports) => {
  function _setArray(obj, val, part, lookup, special, map) {
    for (var item, j = 0;j < obj.length && j < val.length; ++j) {
      item = obj[j];
      if (Array.isArray(item) && Array.isArray(val[j])) {
        _setArray(item, val[j], part, lookup, special, map);
      } else if (item) {
        if (lookup) {
          lookup(item, part, map(val[j]));
        } else {
          if (item[special])
            item = item[special];
          item[part] = map(val[j]);
        }
      }
    }
  }
  function K(v) {
    return v;
  }
  var stringToParts = require_stringToParts();
  var ignoreProperties = ["__proto__", "constructor", "prototype"];
  exports.get = function(path, o, special, map) {
    var lookup;
    if (typeof special == "function") {
      if (special.length < 2) {
        map = special;
        special = undefined;
      } else {
        lookup = special;
        special = undefined;
      }
    }
    map || (map = K);
    var parts = typeof path == "string" ? stringToParts(path) : path;
    if (!Array.isArray(parts)) {
      throw new TypeError("Invalid `path`. Must be either string or array");
    }
    var obj = o, part;
    for (var i = 0;i < parts.length; ++i) {
      part = parts[i];
      if (typeof parts[i] !== "string" && typeof parts[i] !== "number") {
        throw new TypeError("Each segment of path to `get()` must be a string or number, got " + typeof parts[i]);
      }
      if (Array.isArray(obj) && !/^\d+$/.test(part)) {
        var paths = parts.slice(i);
        return [].concat(obj).map(function(item) {
          return item ? exports.get(paths, item, special || lookup, map) : map(undefined);
        });
      }
      if (lookup) {
        obj = lookup(obj, part);
      } else {
        var _from = special && obj[special] ? obj[special] : obj;
        obj = _from instanceof Map ? _from.get(part) : _from[part];
      }
      if (!obj)
        return map(obj);
    }
    return map(obj);
  };
  exports.has = function(path, o) {
    var parts = typeof path === "string" ? stringToParts(path) : path;
    if (!Array.isArray(parts)) {
      throw new TypeError("Invalid `path`. Must be either string or array");
    }
    var len = parts.length;
    var cur = o;
    for (var i = 0;i < len; ++i) {
      if (typeof parts[i] !== "string" && typeof parts[i] !== "number") {
        throw new TypeError("Each segment of path to `has()` must be a string or number, got " + typeof parts[i]);
      }
      if (cur == null || typeof cur !== "object" || !(parts[i] in cur)) {
        return false;
      }
      cur = cur[parts[i]];
    }
    return true;
  };
  exports.unset = function(path, o) {
    var parts = typeof path === "string" ? stringToParts(path) : path;
    if (!Array.isArray(parts)) {
      throw new TypeError("Invalid `path`. Must be either string or array");
    }
    var len = parts.length;
    var cur = o;
    for (var i = 0;i < len; ++i) {
      if (cur == null || typeof cur !== "object" || !(parts[i] in cur)) {
        return false;
      }
      if (typeof parts[i] !== "string" && typeof parts[i] !== "number") {
        throw new TypeError("Each segment of path to `unset()` must be a string or number, got " + typeof parts[i]);
      }
      if (ignoreProperties.indexOf(parts[i]) !== -1) {
        return false;
      }
      if (i === len - 1) {
        delete cur[parts[i]];
        return true;
      }
      cur = cur instanceof Map ? cur.get(parts[i]) : cur[parts[i]];
    }
    return true;
  };
  exports.set = function(path, val, o, special, map, _copying) {
    var lookup;
    if (typeof special == "function") {
      if (special.length < 2) {
        map = special;
        special = undefined;
      } else {
        lookup = special;
        special = undefined;
      }
    }
    map || (map = K);
    var parts = typeof path == "string" ? stringToParts(path) : path;
    if (!Array.isArray(parts)) {
      throw new TypeError("Invalid `path`. Must be either string or array");
    }
    if (o == null)
      return;
    for (var i = 0;i < parts.length; ++i) {
      if (typeof parts[i] !== "string" && typeof parts[i] !== "number") {
        throw new TypeError("Each segment of path to `set()` must be a string or number, got " + typeof parts[i]);
      }
      if (ignoreProperties.indexOf(parts[i]) !== -1) {
        return;
      }
    }
    var copy = _copying || /\$/.test(path) && _copying !== false, obj = o, part;
    for (var i = 0, len = parts.length - 1;i < len; ++i) {
      part = parts[i];
      if (part == "$") {
        if (i == len - 1) {
          break;
        } else {
          continue;
        }
      }
      if (Array.isArray(obj) && !/^\d+$/.test(part)) {
        var paths = parts.slice(i);
        if (!copy && Array.isArray(val)) {
          for (var j = 0;j < obj.length && j < val.length; ++j) {
            exports.set(paths, val[j], obj[j], special || lookup, map, copy);
          }
        } else {
          for (var j = 0;j < obj.length; ++j) {
            exports.set(paths, val, obj[j], special || lookup, map, copy);
          }
        }
        return;
      }
      if (lookup) {
        obj = lookup(obj, part);
      } else {
        var _to = special && obj[special] ? obj[special] : obj;
        obj = _to instanceof Map ? _to.get(part) : _to[part];
      }
      if (!obj)
        return;
    }
    part = parts[len];
    if (special && obj[special]) {
      obj = obj[special];
    }
    if (Array.isArray(obj) && !/^\d+$/.test(part)) {
      if (!copy && Array.isArray(val)) {
        _setArray(obj, val, part, lookup, special, map);
      } else {
        for (var j = 0;j < obj.length; ++j) {
          var item = obj[j];
          if (item) {
            if (lookup) {
              lookup(item, part, map(val));
            } else {
              if (item[special])
                item = item[special];
              item[part] = map(val);
            }
          }
        }
      }
    } else {
      if (lookup) {
        lookup(obj, part, map(val));
      } else if (obj instanceof Map) {
        obj.set(part, map(val));
      } else {
        obj[part] = map(val);
      }
    }
  };
  /*!
   * Split a string path into components delimited by '.' or
   * '[\d+]'
   *
   * #### Example:
   *     stringToParts('foo[0].bar.1'); // ['foo', '0', 'bar', '1']
   */
  exports.stringToParts = stringToParts;
  /*!
   * Recursively set nested arrays
   */
  /*!
   * Returns the value passed to it.
   */
});

// node_modules/mpath/index.js
var require_mpath = __commonJS((exports, module) => {
  module.exports = exports = require_lib4();
});

// node_modules/mongoose/lib/options/populateOptions.js
var require_populateOptions = __commonJS((exports, module) => {
  var clone = require_clone2();

  class PopulateOptions {
    constructor(obj) {
      this._docs = {};
      this._childDocs = [];
      if (obj == null) {
        return;
      }
      obj = clone(obj);
      Object.assign(this, obj);
      if (typeof obj.subPopulate === "object") {
        this.populate = obj.subPopulate;
      }
      if (obj.perDocumentLimit != null && obj.limit != null) {
        throw new Error("Can not use `limit` and `perDocumentLimit` at the same time. Path: `" + obj.path + "`.");
      }
    }
  }
  module.exports = PopulateOptions;
});

// node_modules/mongoose/lib/types/documentArray/isMongooseDocumentArray.js
var require_isMongooseDocumentArray = __commonJS((exports) => {
  exports.isMongooseDocumentArray = function(mongooseDocumentArray) {
    return Array.isArray(mongooseDocumentArray) && mongooseDocumentArray.isMongooseDocumentArray;
  };
});

// node_modules/mongoose/lib/helpers/promiseOrCallback.js
var require_promiseOrCallback = __commonJS((exports, module) => {
  var immediate = require_immediate();
  var emittedSymbol = Symbol("mongoose#emitted");
  module.exports = function promiseOrCallback(callback, fn, ee, Promise2) {
    if (typeof callback === "function") {
      try {
        return fn(function(error) {
          if (error != null) {
            if (ee != null && ee.listeners != null && ee.listeners("error").length > 0 && !error[emittedSymbol]) {
              error[emittedSymbol] = true;
              ee.emit("error", error);
            }
            try {
              callback(error);
            } catch (error2) {
              return immediate(() => {
                throw error2;
              });
            }
            return;
          }
          callback.apply(this, arguments);
        });
      } catch (error) {
        if (ee != null && ee.listeners != null && ee.listeners("error").length > 0 && !error[emittedSymbol]) {
          error[emittedSymbol] = true;
          ee.emit("error", error);
        }
        return callback(error);
      }
    }
    Promise2 = Promise2 || global.Promise;
    return new Promise2((resolve, reject) => {
      fn(function(error, res) {
        if (error != null) {
          if (ee != null && ee.listeners != null && ee.listeners("error").length > 0 && !error[emittedSymbol]) {
            error[emittedSymbol] = true;
            ee.emit("error", error);
          }
          return reject(error);
        }
        if (arguments.length > 2) {
          return resolve(Array.prototype.slice.call(arguments, 1));
        }
        resolve(res);
      });
    });
  };
});

// node_modules/mongoose/lib/helpers/schema/merge.js
var require_merge = __commonJS((exports, module) => {
  module.exports = function merge(s1, s2, skipConflictingPaths) {
    const paths = Object.keys(s2.tree);
    const pathsToAdd = {};
    for (const key of paths) {
      if (skipConflictingPaths && (s1.paths[key] || s1.nested[key] || s1.singleNestedPaths[key])) {
        continue;
      }
      pathsToAdd[key] = s2.tree[key];
    }
    s1.options._isMerging = true;
    s1.add(pathsToAdd, null);
    delete s1.options._isMerging;
    s1.callQueue = s1.callQueue.concat(s2.callQueue);
    s1.method(s2.methods);
    s1.static(s2.statics);
    for (const [option, value] of Object.entries(s2._userProvidedOptions)) {
      if (!(option in s1._userProvidedOptions)) {
        s1.set(option, value);
      }
    }
    for (const query in s2.query) {
      s1.query[query] = s2.query[query];
    }
    for (const virtual in s2.virtuals) {
      s1.virtuals[virtual] = s2.virtuals[virtual].clone();
    }
    s1._indexes = s1._indexes.concat(s2._indexes || []);
    s1.s.hooks.merge(s2.s.hooks, false);
  };
});

// node_modules/mongoose/lib/stateMachine.js
var require_stateMachine = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var utils = require_utils4();
  var StateMachine = module.exports = exports = function StateMachine() {
  };
  StateMachine.ctor = function() {
    const states = [...arguments];
    const ctor = function() {
      StateMachine.apply(this, arguments);
      this.paths = {};
      this.states = {};
    };
    ctor.prototype = new StateMachine;
    ctor.prototype.constructor = ctor;
    ctor.prototype.stateNames = states;
    states.forEach(function(state) {
      ctor.prototype[state] = function(path) {
        this._changeState(path, state);
      };
    });
    return ctor;
  };
  StateMachine.prototype._changeState = function _changeState(path, nextState) {
    const prevState = this.paths[path];
    if (prevState === nextState) {
      return;
    }
    const prevBucket = this.states[prevState];
    if (prevBucket)
      delete prevBucket[path];
    this.paths[path] = nextState;
    this.states[nextState] = this.states[nextState] || {};
    this.states[nextState][path] = true;
  };
  /*!
   * ignore
   */
  StateMachine.prototype.clear = function clear(state) {
    if (this.states[state] == null) {
      return;
    }
    const keys = Object.keys(this.states[state]);
    let i = keys.length;
    let path;
    while (i--) {
      path = keys[i];
      delete this.states[state][path];
      delete this.paths[path];
    }
  };
  /*!
   * ignore
   */
  StateMachine.prototype.clearPath = function clearPath(path) {
    const state = this.paths[path];
    if (!state) {
      return;
    }
    delete this.paths[path];
    delete this.states[state][path];
  };
  StateMachine.prototype.getStatePaths = function getStatePaths(state) {
    if (this.states[state] != null) {
      return this.states[state];
    }
    return {};
  };
  StateMachine.prototype.some = function some() {
    const _this = this;
    const what = arguments.length ? arguments : this.stateNames;
    return Array.prototype.some.call(what, function(state) {
      if (_this.states[state] == null) {
        return false;
      }
      return Object.keys(_this.states[state]).length;
    });
  };
  StateMachine.prototype._iter = function _iter(iterMethod) {
    return function() {
      let states = [...arguments];
      const callback = states.pop();
      if (!states.length)
        states = this.stateNames;
      const _this = this;
      const paths = states.reduce(function(paths2, state) {
        if (_this.states[state] == null) {
          return paths2;
        }
        return paths2.concat(Object.keys(_this.states[state]));
      }, []);
      return paths[iterMethod](function(path, i, paths2) {
        return callback(path, i, paths2);
      });
    };
  };
  StateMachine.prototype.forEach = function forEach() {
    this.forEach = this._iter("forEach");
    return this.forEach.apply(this, arguments);
  };
  StateMachine.prototype.map = function map() {
    this.map = this._iter("map");
    return this.map.apply(this, arguments);
  };
  StateMachine.prototype.clone = function clone() {
    const result = new this.constructor;
    result.paths = { ...this.paths };
    for (const state of this.stateNames) {
      if (!(state in this.states)) {
        continue;
      }
      result.states[state] = this.states[state] == null ? this.states[state] : { ...this.states[state] };
    }
    return result;
  };
});

// node_modules/mongoose/lib/internal.js
var require_internal = __commonJS((exports, module) => {
  function InternalCache() {
    this.activePaths = new ActiveRoster;
  }
  /*!
   * Dependencies
   */
  var StateMachine = require_stateMachine();
  var ActiveRoster = StateMachine.ctor("require", "modify", "init", "default", "ignore");
  module.exports = exports = InternalCache;
  InternalCache.prototype.strictMode = true;
  InternalCache.prototype.fullPath = undefined;
  InternalCache.prototype.selected = undefined;
  InternalCache.prototype.shardval = undefined;
  InternalCache.prototype.saveError = undefined;
  InternalCache.prototype.validationError = undefined;
  InternalCache.prototype.adhocPaths = undefined;
  InternalCache.prototype.removing = undefined;
  InternalCache.prototype.inserting = undefined;
  InternalCache.prototype.saving = undefined;
  InternalCache.prototype.version = undefined;
  InternalCache.prototype._id = undefined;
  InternalCache.prototype.ownerDocument = undefined;
  InternalCache.prototype.populate = undefined;
  InternalCache.prototype.populated = undefined;
  InternalCache.prototype.primitiveAtomics = undefined;
  InternalCache.prototype.wasPopulated = false;
  InternalCache.prototype.scope = undefined;
  InternalCache.prototype.session = null;
  InternalCache.prototype.pathsToScopes = null;
  InternalCache.prototype.cachedRequired = null;
});

// node_modules/mongoose/lib/types/buffer.js
var require_buffer = __commonJS((exports, module) => {
  function MongooseBuffer(value, encode, offset) {
    let val = value;
    if (value == null) {
      val = 0;
    }
    let encoding;
    let path;
    let doc;
    if (Array.isArray(encode)) {
      path = encode[0];
      doc = encode[1];
    } else {
      encoding = encode;
    }
    let buf;
    if (typeof val === "number" || val instanceof Number) {
      buf = Buffer.alloc(val);
    } else {
      buf = Buffer.from(val, encoding, offset);
    }
    utils.decorate(buf, MongooseBuffer.mixin);
    buf.isMongooseBuffer = true;
    buf[MongooseBuffer.pathSymbol] = path;
    buf[parentSymbol] = doc;
    buf._subtype = 0;
    return buf;
  }
  /*!
   * Module dependencies.
   */
  var Binary = require_bson().Binary;
  var utils = require_utils4();
  var pathSymbol = Symbol.for("mongoose#Buffer#_path");
  var parentSymbol = Symbol.for("mongoose#Buffer#_parent");
  MongooseBuffer.pathSymbol = pathSymbol;
  /*!
   * Inherit from Buffer.
   */
  MongooseBuffer.mixin = {
    _subtype: undefined,
    _markModified: function() {
      const parent = this[parentSymbol];
      if (parent) {
        parent.markModified(this[MongooseBuffer.pathSymbol]);
      }
      return this;
    },
    write: function() {
      const written = Buffer.prototype.write.apply(this, arguments);
      if (written > 0) {
        this._markModified();
      }
      return written;
    },
    copy: function(target) {
      const ret = Buffer.prototype.copy.apply(this, arguments);
      if (target && target.isMongooseBuffer) {
        target._markModified();
      }
      return ret;
    }
  };
  /*!
   * Compile other Buffer methods marking this buffer as modified.
   */
  utils.each([
    "writeUInt8",
    "writeUInt16",
    "writeUInt32",
    "writeInt8",
    "writeInt16",
    "writeInt32",
    "writeFloat",
    "writeDouble",
    "fill",
    "utf8Write",
    "binaryWrite",
    "asciiWrite",
    "set",
    "writeUInt16LE",
    "writeUInt16BE",
    "writeUInt32LE",
    "writeUInt32BE",
    "writeInt16LE",
    "writeInt16BE",
    "writeInt32LE",
    "writeInt32BE",
    "writeFloatLE",
    "writeFloatBE",
    "writeDoubleLE",
    "writeDoubleBE"
  ], function(method) {
    if (!Buffer.prototype[method]) {
      return;
    }
    MongooseBuffer.mixin[method] = function() {
      const ret = Buffer.prototype[method].apply(this, arguments);
      this._markModified();
      return ret;
    };
  });
  MongooseBuffer.mixin.toObject = function(options) {
    const subtype = typeof options === "number" ? options : this._subtype || 0;
    return new Binary(Buffer.from(this), subtype);
  };
  MongooseBuffer.mixin.$toObject = MongooseBuffer.mixin.toObject;
  MongooseBuffer.mixin.toBSON = function() {
    return new Binary(this, this._subtype || 0);
  };
  MongooseBuffer.mixin.equals = function(other) {
    if (!Buffer.isBuffer(other)) {
      return false;
    }
    if (this.length !== other.length) {
      return false;
    }
    for (let i = 0;i < this.length; ++i) {
      if (this[i] !== other[i]) {
        return false;
      }
    }
    return true;
  };
  MongooseBuffer.mixin.subtype = function(subtype) {
    if (typeof subtype !== "number") {
      throw new TypeError("Invalid subtype. Expected a number");
    }
    if (this._subtype !== subtype) {
      this._markModified();
    }
    this._subtype = subtype;
  };
  /*!
   * Module exports.
   */
  MongooseBuffer.Binary = Binary;
  module.exports = MongooseBuffer;
});

// node_modules/mongoose/lib/schema/symbols.js
var require_symbols2 = __commonJS((exports) => {
  exports.schemaMixedSymbol = Symbol.for("mongoose:schema_mixed");
  exports.builtInMiddleware = Symbol.for("mongoose:built-in-middleware");
});

// node_modules/mongoose/lib/schema/mixed.js
var require_mixed = __commonJS((exports, module) => {
  function SchemaMixed(path, options) {
    if (options && options.default) {
      const def = options.default;
      if (Array.isArray(def) && def.length === 0) {
        options.default = Array;
      } else if (!options.shared && isObject(def) && Object.keys(def).length === 0) {
        options.default = function() {
          return {};
        };
      }
    }
    SchemaType.call(this, path, options, "Mixed");
    this[symbols.schemaMixedSymbol] = true;
  }
  /*!
   * Module dependencies.
   */
  var SchemaType = require_schemaType();
  var symbols = require_symbols2();
  var isObject = require_isObject2();
  var utils = require_utils4();
  SchemaMixed.schemaName = "Mixed";
  SchemaMixed.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaMixed.prototype = Object.create(SchemaType.prototype);
  SchemaMixed.prototype.constructor = SchemaMixed;
  SchemaMixed.get = SchemaType.get;
  SchemaMixed.set = SchemaType.set;
  SchemaMixed.setters = [];
  SchemaMixed.prototype.cast = function(val) {
    if (val instanceof Error) {
      return utils.errorToPOJO(val);
    }
    return val;
  };
  SchemaMixed.prototype.castForQuery = function($cond, val) {
    return val;
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaMixed;
});

// node_modules/mongoose/lib/modifiedPathsSnapshot.js
var require_modifiedPathsSnapshot = __commonJS((exports, module) => {
  module.exports = class ModifiedPathsSnapshot {
    constructor(subdocSnapshot, activePaths, version) {
      this.subdocSnapshot = subdocSnapshot;
      this.activePaths = activePaths;
      this.version = version;
    }
  };
});

// node_modules/mongoose/lib/error/objectExpected.js
var require_objectExpected = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class ObjectExpectedError extends MongooseError {
    constructor(path, val) {
      const typeDescription = Array.isArray(val) ? "array" : "primitive value";
      super("Tried to set nested object field `" + path + `\` to ${typeDescription} \`` + val + "`");
      this.path = path;
    }
  }
  Object.defineProperty(ObjectExpectedError.prototype, "name", {
    value: "ObjectExpectedError"
  });
  module.exports = ObjectExpectedError;
});

// node_modules/mongoose/lib/error/objectParameter.js
var require_objectParameter = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class ObjectParameterError extends MongooseError {
    constructor(value, paramName, fnName) {
      super('Parameter "' + paramName + '" to ' + fnName + '() must be an object, got "' + value.toString() + '" (type ' + typeof value + ")");
    }
  }
  Object.defineProperty(ObjectParameterError.prototype, "name", {
    value: "ObjectParameterError"
  });
  module.exports = ObjectParameterError;
});

// node_modules/mongoose/lib/error/parallelValidate.js
var require_parallelValidate = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class ParallelValidateError extends MongooseError {
    constructor(doc) {
      const msg = "Can\'t validate() the same doc multiple times in parallel. Document: ";
      super(msg + doc._doc._id);
    }
  }
  Object.defineProperty(ParallelValidateError.prototype, "name", {
    value: "ParallelValidateError"
  });
  /*!
   * exports
   */
  module.exports = ParallelValidateError;
});

// node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js
var require_hasIncludedChildren = __commonJS((exports, module) => {
  module.exports = function hasIncludedChildren(fields) {
    const hasIncludedChildren = {};
    const keys = Object.keys(fields);
    for (const key of keys) {
      if (key.indexOf(".") === -1) {
        hasIncludedChildren[key] = 1;
        continue;
      }
      const parts = key.split(".");
      let c = parts[0];
      for (let i = 0;i < parts.length; ++i) {
        hasIncludedChildren[c] = 1;
        if (i + 1 < parts.length) {
          c = c + "." + parts[i + 1];
        }
      }
    }
    return hasIncludedChildren;
  };
});

// node_modules/mongoose/lib/helpers/projection/isNestedProjection.js
var require_isNestedProjection = __commonJS((exports, module) => {
  module.exports = function isNestedProjection(val) {
    if (val == null || typeof val !== "object") {
      return false;
    }
    return val.$slice == null && val.$elemMatch == null && val.$meta == null && val.$ == null;
  };
});

// node_modules/mongoose/lib/helpers/document/applyDefaults.js
var require_applyDefaults = __commonJS((exports, module) => {
  function applyChangeTracking(doc, fullPath, skipParentChangeTracking) {
    doc.$__.activePaths.default(fullPath);
    if (!skipParentChangeTracking && doc.$isSubdocument && doc.$isSingleNested && doc.$parent() != null) {
      doc.$parent().$__.activePaths.default(doc.$__pathRelativeToParent(fullPath));
    }
  }
  var isNestedProjection = require_isNestedProjection();
  module.exports = function applyDefaults(doc, fields, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip, options) {
    const paths = Object.keys(doc.$__schema.paths);
    const plen = paths.length;
    const skipParentChangeTracking = options && options.skipParentChangeTracking;
    for (let i = 0;i < plen; ++i) {
      let def;
      let curPath = "";
      const p = paths[i];
      if (p === "_id" && doc.$__.skipId) {
        continue;
      }
      const type = doc.$__schema.paths[p];
      const path = type.splitPath();
      const len = path.length;
      if (path[len - 1] === "$*") {
        continue;
      }
      let included = false;
      let doc_ = doc._doc;
      for (let j = 0;j < len; ++j) {
        if (doc_ == null) {
          break;
        }
        const piece = path[j];
        curPath += (!curPath.length ? "" : ".") + piece;
        if (exclude === true) {
          if (curPath in fields) {
            break;
          }
        } else if (exclude === false && fields && !included) {
          const hasSubpaths = type.$isSingleNested || type.$isMongooseDocumentArray;
          if (curPath in fields && !isNestedProjection(fields[curPath]) || j === len - 1 && hasSubpaths && hasIncludedChildren != null && hasIncludedChildren[curPath]) {
            included = true;
          } else if (hasIncludedChildren != null && !hasIncludedChildren[curPath]) {
            break;
          }
        }
        if (j === len - 1) {
          if (doc_[piece] !== undefined) {
            break;
          }
          if (isBeforeSetters != null) {
            if (typeof type.defaultValue === "function") {
              if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {
                break;
              }
              if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {
                break;
              }
            } else if (!isBeforeSetters) {
              continue;
            }
          }
          if (pathsToSkip && pathsToSkip[curPath]) {
            break;
          }
          if (fields && exclude !== null) {
            if (exclude === true) {
              if (p in fields) {
                continue;
              }
              try {
                def = type.getDefault(doc, false);
              } catch (err) {
                doc.invalidate(p, err);
                break;
              }
              if (typeof def !== "undefined") {
                doc_[piece] = def;
                applyChangeTracking(doc, p, skipParentChangeTracking);
              }
            } else if (included) {
              try {
                def = type.getDefault(doc, false);
              } catch (err) {
                doc.invalidate(p, err);
                break;
              }
              if (typeof def !== "undefined") {
                doc_[piece] = def;
                applyChangeTracking(doc, p, skipParentChangeTracking);
              }
            }
          } else {
            try {
              def = type.getDefault(doc, false);
            } catch (err) {
              doc.invalidate(p, err);
              break;
            }
            if (typeof def !== "undefined") {
              doc_[piece] = def;
              applyChangeTracking(doc, p, skipParentChangeTracking);
            }
          }
        } else {
          doc_ = doc_[piece];
        }
      }
    }
  };
  /*!
   * ignore
   */
});

// node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js
var require_cleanModifiedSubpaths = __commonJS((exports, module) => {
  function cleanParent(doc, path, seen = new Set) {
    if (seen.has(doc)) {
      throw new Error("Infinite subdocument loop: subdoc with _id " + doc._id + " is a parent of itself");
    }
    const parent = doc.$parent();
    const newPath = doc.$__pathRelativeToParent(undefined, false) + "." + path;
    parent.$__.activePaths.clearPath(newPath);
    if (parent.$isSubdocument) {
      cleanParent(parent, newPath, seen);
    }
  }
  /*!
   * ignore
   */
  module.exports = function cleanModifiedSubpaths(doc, path, options) {
    options = options || {};
    const skipDocArrays = options.skipDocArrays;
    let deleted = 0;
    if (!doc) {
      return deleted;
    }
    for (const modifiedPath of Object.keys(doc.$__.activePaths.getStatePaths("modify"))) {
      if (skipDocArrays) {
        const schemaType = doc.$__schema.path(modifiedPath);
        if (schemaType && schemaType.$isMongooseDocumentArray) {
          continue;
        }
      }
      if (modifiedPath.startsWith(path + ".")) {
        doc.$__.activePaths.clearPath(modifiedPath);
        ++deleted;
        if (doc.$isSubdocument) {
          cleanParent(doc, modifiedPath);
        }
      }
    }
    return deleted;
  };
});

// node_modules/mongoose/lib/helpers/document/compile.js
var require_compile = __commonJS((exports) => {
  function compile(tree, proto, prefix, options) {
    Document = Document || require_document2();
    const typeKey = options.typeKey;
    for (const key of Object.keys(tree)) {
      const limb = tree[key];
      const hasSubprops = isPOJO(limb) && Object.keys(limb).length > 0 && (!limb[typeKey] || typeKey === "type" && isPOJO(limb.type) && limb.type.type);
      const subprops = hasSubprops ? limb : null;
      defineKey({ prop: key, subprops, prototype: proto, prefix, options });
    }
  }
  function defineKey({ prop, subprops, prototype, prefix, options }) {
    Document = Document || require_document2();
    const path = (prefix ? prefix + "." : "") + prop;
    prefix = prefix || "";
    const useGetOptions = prefix ? Object.freeze({}) : noDottedPathGetOptions;
    if (subprops) {
      Object.defineProperty(prototype, prop, {
        enumerable: true,
        configurable: true,
        get: function() {
          const _this = this;
          if (!this.$__.getters) {
            this.$__.getters = {};
          }
          if (!this.$__.getters[path]) {
            const nested = Object.create(Document.prototype, getOwnPropertyDescriptors(this));
            if (!prefix) {
              nested.$__[scopeSymbol] = this;
            }
            nested.$__.nestedPath = path;
            Object.defineProperty(nested, "schema", {
              enumerable: false,
              configurable: true,
              writable: false,
              value: prototype.schema
            });
            Object.defineProperty(nested, "$__schema", {
              enumerable: false,
              configurable: true,
              writable: false,
              value: prototype.schema
            });
            Object.defineProperty(nested, documentSchemaSymbol, {
              enumerable: false,
              configurable: true,
              writable: false,
              value: prototype.schema
            });
            Object.defineProperty(nested, "toObject", {
              enumerable: false,
              configurable: true,
              writable: false,
              value: function() {
                return clone(_this.get(path, null, {
                  virtuals: this && this.schema && this.schema.options && this.schema.options.toObject && this.schema.options.toObject.virtuals || null
                }));
              }
            });
            Object.defineProperty(nested, "$__get", {
              enumerable: false,
              configurable: true,
              writable: false,
              value: function() {
                return _this.get(path, null, {
                  virtuals: this && this.schema && this.schema.options && this.schema.options.toObject && this.schema.options.toObject.virtuals || null
                });
              }
            });
            Object.defineProperty(nested, "toJSON", {
              enumerable: false,
              configurable: true,
              writable: false,
              value: function() {
                return _this.get(path, null, {
                  virtuals: this && this.schema && this.schema.options && this.schema.options.toJSON && this.schema.options.toJSON.virtuals || null
                });
              }
            });
            Object.defineProperty(nested, "$__isNested", {
              enumerable: false,
              configurable: true,
              writable: false,
              value: true
            });
            Object.defineProperty(nested, "$isEmpty", {
              enumerable: false,
              configurable: true,
              writable: false,
              value: function() {
                return Object.keys(this.get(path, null, _isEmptyOptions) || {}).length === 0;
              }
            });
            Object.defineProperty(nested, "$__parent", {
              enumerable: false,
              configurable: true,
              writable: false,
              value: this
            });
            compile(subprops, nested, path, options);
            this.$__.getters[path] = nested;
          }
          return this.$__.getters[path];
        },
        set: function(v) {
          if (v != null && v.$__isNested) {
            v = v.$__get();
          } else if (v instanceof Document && !v.$__isNested) {
            v = v.$toObject(internalToObjectOptions);
          }
          const doc = this.$__[scopeSymbol] || this;
          doc.$set(path, v);
        }
      });
    } else {
      Object.defineProperty(prototype, prop, {
        enumerable: true,
        configurable: true,
        get: function() {
          return this[getSymbol].call(this.$__[scopeSymbol] || this, path, null, useGetOptions);
        },
        set: function(v) {
          this.$set.call(this.$__[scopeSymbol] || this, path, v);
        }
      });
    }
  }
  function getOwnPropertyDescriptors(object) {
    const result = {};
    Object.getOwnPropertyNames(object).forEach(function(key) {
      const skip = [
        "isNew",
        "$__",
        "$errors",
        "errors",
        "_doc",
        "$locals",
        "$op",
        "__parentArray",
        "__index",
        "$isDocumentArrayElement"
      ].indexOf(key) === -1;
      if (skip) {
        return;
      }
      result[key] = Object.getOwnPropertyDescriptor(object, key);
      result[key].enumerable = false;
    });
    return result;
  }
  var clone = require_clone2();
  var documentSchemaSymbol = require_symbols().documentSchemaSymbol;
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var utils = require_utils4();
  var Document;
  var getSymbol = require_symbols().getSymbol;
  var scopeSymbol = require_symbols().scopeSymbol;
  var isPOJO = utils.isPOJO;
  /*!
   * exports
   */
  exports.compile = compile;
  exports.defineKey = defineKey;
  var _isEmptyOptions = Object.freeze({
    minimize: true,
    virtuals: false,
    getters: false,
    transform: false
  });
  var noDottedPathGetOptions = Object.freeze({
    noDottedPath: true
  });
});

// node_modules/mongoose/lib/helpers/firstKey.js
var require_firstKey = __commonJS((exports, module) => {
  module.exports = function firstKey(obj) {
    if (obj == null) {
      return null;
    }
    return Object.keys(obj)[0];
  };
});

// node_modules/mongoose/lib/helpers/common.js
var require_common3 = __commonJS((exports) => {
  function flatten(update, path, options, schema) {
    let keys;
    if (update && isMongooseObject(update) && !Buffer.isBuffer(update)) {
      keys = Object.keys(update.toObject({ transform: false, virtuals: false }) || {});
    } else {
      keys = Object.keys(update || {});
    }
    const numKeys = keys.length;
    const result = {};
    path = path ? path + "." : "";
    for (let i = 0;i < numKeys; ++i) {
      const key = keys[i];
      const val = update[key];
      result[path + key] = val;
      const keySchema = schema && schema.path && schema.path(path + key);
      const isNested = schema && schema.nested && schema.nested[path + key];
      if (keySchema && keySchema.instance === "Mixed")
        continue;
      if (shouldFlatten(val)) {
        if (options && options.skipArrays && Array.isArray(val)) {
          continue;
        }
        const flat = flatten(val, path + key, options, schema);
        for (const k in flat) {
          result[k] = flat[k];
        }
        if (Array.isArray(val)) {
          result[path + key] = val;
        }
      }
      if (isNested) {
        const paths = Object.keys(schema.paths);
        for (const p of paths) {
          if (p.startsWith(path + key + ".") && !result.hasOwnProperty(p)) {
            result[p] = undefined;
          }
        }
      }
    }
    return result;
  }
  function modifiedPaths(update, path, result, recursion = null) {
    if (update == null || typeof update !== "object") {
      return;
    }
    if (recursion == null) {
      recursion = {
        raw: { update, path },
        trace: new WeakSet
      };
    }
    if (recursion.trace.has(update)) {
      throw new MongooseError(`a circular reference in the update value, updateValue:
${util.inspect(recursion.raw.update, { showHidden: false, depth: 1 })}
updatePath: '${recursion.raw.path}'`);
    }
    recursion.trace.add(update);
    const keys = Object.keys(update || {});
    const numKeys = keys.length;
    result = result || {};
    path = path ? path + "." : "";
    for (let i = 0;i < numKeys; ++i) {
      const key = keys[i];
      let val = update[key];
      const _path = path + key;
      result[_path] = true;
      if (!Buffer.isBuffer(val) && isMongooseObject(val)) {
        val = val.toObject({ transform: false, virtuals: false });
      }
      if (shouldFlatten(val)) {
        modifiedPaths(val, path + key, result, recursion);
      }
    }
    recursion.trace.delete(update);
    return result;
  }
  function shouldFlatten(val) {
    return val && typeof val === "object" && !(val instanceof Date) && !isBsonType(val, "ObjectId") && (!Array.isArray(val) || val.length !== 0) && !(val instanceof Buffer) && !isBsonType(val, "Decimal128") && !(val instanceof Binary);
  }
  /*!
   * Module dependencies.
   */
  var Binary = require_bson().Binary;
  var isBsonType = require_isBsonType();
  var isMongooseObject = require_isMongooseObject();
  var MongooseError = require_error2();
  var util = import.meta.require("util");
  exports.flatten = flatten;
  exports.modifiedPaths = modifiedPaths;
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
});

// node_modules/mongoose/lib/helpers/get.js
var require_get2 = __commonJS((exports, module) => {
  function getProperty(obj, prop) {
    if (obj == null) {
      return obj;
    }
    if (obj instanceof Map) {
      return obj.get(prop);
    }
    return obj[prop];
  }
  module.exports = function get(obj, path, def) {
    let parts;
    let isPathArray = false;
    if (typeof path === "string") {
      if (path.indexOf(".") === -1) {
        const _v = getProperty(obj, path);
        if (_v == null) {
          return def;
        }
        return _v;
      }
      parts = path.split(".");
    } else {
      isPathArray = true;
      parts = path;
      if (parts.length === 1) {
        const _v = getProperty(obj, parts[0]);
        if (_v == null) {
          return def;
        }
        return _v;
      }
    }
    let rest = path;
    let cur = obj;
    for (const part of parts) {
      if (cur == null) {
        return def;
      }
      if (!isPathArray && cur[rest] != null) {
        return cur[rest];
      }
      cur = getProperty(cur, part);
      if (!isPathArray) {
        rest = rest.substr(part.length + 1);
      }
    }
    return cur == null ? def : cur;
  };
});

// node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js
var require_areDiscriminatorValuesEqual = __commonJS((exports, module) => {
  var isBsonType = require_isBsonType();
  module.exports = function areDiscriminatorValuesEqual(a, b) {
    if (typeof a === "string" && typeof b === "string") {
      return a === b;
    }
    if (typeof a === "number" && typeof b === "number") {
      return a === b;
    }
    if (isBsonType(a, "ObjectId") && isBsonType(b, "ObjectId")) {
      return a.toString() === b.toString();
    }
    return false;
  };
});

// node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js
var require_getSchemaDiscriminatorByValue = __commonJS((exports, module) => {
  var areDiscriminatorValuesEqual = require_areDiscriminatorValuesEqual();
  module.exports = function getSchemaDiscriminatorByValue(schema, value) {
    if (schema == null || schema.discriminators == null) {
      return null;
    }
    for (const key of Object.keys(schema.discriminators)) {
      const discriminatorSchema = schema.discriminators[key];
      if (discriminatorSchema.discriminatorMapping == null) {
        continue;
      }
      if (areDiscriminatorValuesEqual(discriminatorSchema.discriminatorMapping.value, value)) {
        return discriminatorSchema;
      }
    }
    return null;
  };
});

// node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js
var require_getEmbeddedDiscriminatorPath = __commonJS((exports, module) => {
  var get = require_get2();
  var getSchemaDiscriminatorByValue = require_getSchemaDiscriminatorByValue();
  module.exports = function getEmbeddedDiscriminatorPath(doc, path, options) {
    options = options || {};
    const typeOnly = options.typeOnly;
    const parts = Array.isArray(path) ? path : path.indexOf(".") === -1 ? [path] : path.split(".");
    let schemaType = null;
    let type = "adhocOrUndefined";
    const schema = getSchemaDiscriminatorByValue(doc.schema, doc.get(doc.schema.options.discriminatorKey)) || doc.schema;
    for (let i = 0;i < parts.length; ++i) {
      const subpath = parts.slice(0, i + 1).join(".");
      schemaType = schema.path(subpath);
      if (schemaType == null) {
        type = "adhocOrUndefined";
        continue;
      }
      if (schemaType.instance === "Mixed") {
        return typeOnly ? "real" : schemaType;
      }
      type = schema.pathType(subpath);
      if ((schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) && schemaType.schema.discriminators != null) {
        const discriminators = schemaType.schema.discriminators;
        const discriminatorKey = doc.get(subpath + "." + get(schemaType, "schema.options.discriminatorKey"));
        if (discriminatorKey == null || discriminators[discriminatorKey] == null) {
          continue;
        }
        const rest = parts.slice(i + 1).join(".");
        return getEmbeddedDiscriminatorPath(doc.get(subpath), rest, options);
      }
    }
    return typeOnly ? type : schemaType;
  };
});

// node_modules/mongoose/lib/helpers/schema/getKeysInSchemaOrder.js
var require_getKeysInSchemaOrder = __commonJS((exports, module) => {
  var get = require_get2();
  module.exports = function getKeysInSchemaOrder(schema, val, path) {
    const schemaKeys = path != null ? Object.keys(get(schema.tree, path, {})) : Object.keys(schema.tree);
    const valKeys = new Set(Object.keys(val));
    let keys;
    if (valKeys.size > 1) {
      keys = new Set;
      for (const key of schemaKeys) {
        if (valKeys.has(key)) {
          keys.add(key);
        }
      }
      for (const key of valKeys) {
        if (!keys.has(key)) {
          keys.add(key);
        }
      }
      keys = Array.from(keys);
    } else {
      keys = Array.from(valKeys);
    }
    return keys;
  };
});

// node_modules/mongoose/lib/helpers/schema/getSubdocumentStrictValue.js
var require_getSubdocumentStrictValue = __commonJS((exports, module) => {
  module.exports = function getSubdocumentStrictValue(schema, parts) {
    if (parts.length === 1) {
      return;
    }
    let cur = parts[0];
    let strict = undefined;
    for (let i = 0;i < parts.length - 1; ++i) {
      const curSchemaType = schema.path(cur);
      if (curSchemaType && curSchemaType.schema) {
        strict = curSchemaType.schema.options.strict;
        schema = curSchemaType.schema;
        cur = curSchemaType.$isMongooseDocumentArray && !isNaN(parts[i + 1]) ? "" : parts[i + 1];
      } else {
        cur += cur.length ? "." + parts[i + 1] : parts[i + 1];
      }
    }
    return strict;
  };
});

// node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js
var require_handleSpreadDoc = __commonJS((exports, module) => {
  var utils = require_utils4();
  var keysToSkip = new Set(["__index", "__parentArray", "_doc"]);
  module.exports = function handleSpreadDoc(v, includeExtraKeys) {
    if (utils.isPOJO(v) && v.$__ != null && v._doc != null) {
      if (includeExtraKeys) {
        const extraKeys = {};
        for (const key of Object.keys(v)) {
          if (typeof key === "symbol") {
            continue;
          }
          if (key[0] === "$") {
            continue;
          }
          if (keysToSkip.has(key)) {
            continue;
          }
          extraKeys[key] = v[key];
        }
        return { ...v._doc, ...extraKeys };
      }
      return v._doc;
    }
    return v;
  };
});

// node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js
var require_isDefiningProjection = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  module.exports = function isDefiningProjection(val) {
    if (val == null) {
      return true;
    }
    if (typeof val === "object") {
      return !("$meta" in val) && !("$slice" in val);
    }
    return true;
  };
});

// node_modules/mongoose/lib/helpers/projection/isExclusive.js
var require_isExclusive = __commonJS((exports, module) => {
  var isDefiningProjection = require_isDefiningProjection();
  var isPOJO = require_isPOJO();
  /*!
   * ignore
   */
  module.exports = function isExclusive(projection) {
    if (projection == null) {
      return null;
    }
    const keys = Object.keys(projection);
    let exclude = null;
    if (keys.length === 1 && keys[0] === "_id") {
      exclude = !projection._id;
    } else {
      for (let ki = 0;ki < keys.length; ++ki) {
        const key = keys[ki];
        if (key !== "_id" && isDefiningProjection(projection[key])) {
          exclude = isPOJO(projection[key]) ? isExclusive(projection[key]) ?? exclude : !projection[key];
          if (exclude != null) {
            break;
          }
        }
      }
    }
    return exclude;
  };
});

// node_modules/mongoose/lib/helpers/projection/isPathExcluded.js
var require_isPathExcluded = __commonJS((exports, module) => {
  var isDefiningProjection = require_isDefiningProjection();
  module.exports = function isPathExcluded(projection, path) {
    if (projection == null) {
      return false;
    }
    if (path === "_id") {
      return projection._id === 0;
    }
    const paths = Object.keys(projection);
    let type = null;
    for (const _path of paths) {
      if (isDefiningProjection(projection[_path])) {
        type = projection[path] === 1 ? "inclusive" : "exclusive";
        break;
      }
    }
    if (type === "inclusive") {
      return projection[path] !== 1;
    }
    if (type === "exclusive") {
      return projection[path] === 0;
    }
    return false;
  };
});

// node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js
var require_markArraySubdocsPopulated = __commonJS((exports, module) => {
  var utils = require_utils4();
  module.exports = function markArraySubdocsPopulated(doc, populated) {
    if (doc._doc._id == null || populated == null || populated.length === 0) {
      return;
    }
    const id = String(doc._doc._id);
    for (const item of populated) {
      if (item.isVirtual) {
        continue;
      }
      const path = item.path;
      const pieces = path.split(".");
      for (let i = 0;i < pieces.length - 1; ++i) {
        const subpath = pieces.slice(0, i + 1).join(".");
        const rest = pieces.slice(i + 1).join(".");
        const val = doc.get(subpath);
        if (val == null) {
          continue;
        }
        if (utils.isMongooseDocumentArray(val)) {
          for (let j = 0;j < val.length; ++j) {
            if (val[j]) {
              val[j].populated(rest, item._docs[id] == null ? undefined : item._docs[id][j], item);
            }
          }
          break;
        }
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/minimize.js
var require_minimize = __commonJS((exports, module) => {
  function minimize(obj) {
    const keys = Object.keys(obj);
    let i = keys.length;
    let hasKeys;
    let key;
    let val;
    while (i--) {
      key = keys[i];
      val = obj[key];
      if (isPOJO(val)) {
        obj[key] = minimize(val);
      }
      if (obj[key] === undefined) {
        delete obj[key];
        continue;
      }
      hasKeys = true;
    }
    return hasKeys ? obj : undefined;
  }
  var { isPOJO } = require_utils4();
  module.exports = minimize;
});

// node_modules/mongoose/lib/helpers/path/parentPaths.js
var require_parentPaths = __commonJS((exports, module) => {
  var dotRE = /\./g;
  module.exports = function parentPaths(path) {
    if (path.indexOf(".") === -1) {
      return [path];
    }
    const pieces = path.split(dotRE);
    const len = pieces.length;
    const ret = new Array(len);
    let cur = "";
    for (let i = 0;i < len; ++i) {
      cur += cur.length !== 0 ? "." + pieces[i] : pieces[i];
      ret[i] = cur;
    }
    return ret;
  };
});

// node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js
var require_checkEmbeddedDiscriminatorKeyProjection = __commonJS((exports, module) => {
  module.exports = function checkEmbeddedDiscriminatorKeyProjection(userProjection, path, schema, selected, addedPaths) {
    const userProjectedInPath = Object.keys(userProjection).reduce((cur, key) => cur || key.startsWith(path + "."), false);
    const _discriminatorKey = path + "." + schema.options.discriminatorKey;
    if (!userProjectedInPath && addedPaths.length === 1 && addedPaths[0] === _discriminatorKey) {
      selected.splice(selected.indexOf(_discriminatorKey), 1);
    }
  };
});

// node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js
var require_getDiscriminatorByValue = __commonJS((exports, module) => {
  var areDiscriminatorValuesEqual = require_areDiscriminatorValuesEqual();
  module.exports = function getDiscriminatorByValue(discriminators, value) {
    if (discriminators == null) {
      return null;
    }
    for (const name of Object.keys(discriminators)) {
      const it = discriminators[name];
      if (it.schema && it.schema.discriminatorMapping && areDiscriminatorValuesEqual(it.schema.discriminatorMapping.value, value)) {
        return it;
      }
    }
    return null;
  };
});

// node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js
var require_isPathSelectedInclusive = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  module.exports = function isPathSelectedInclusive(fields, path) {
    const chunks = path.split(".");
    let cur = "";
    let j;
    let keys;
    let numKeys;
    for (let i = 0;i < chunks.length; ++i) {
      cur += cur.length ? "." : "" + chunks[i];
      if (fields[cur]) {
        keys = Object.keys(fields);
        numKeys = keys.length;
        for (j = 0;j < numKeys; ++j) {
          if (keys[i].indexOf(cur + ".") === 0 && keys[i].indexOf(path) !== 0) {
            continue;
          }
        }
        return true;
      }
    }
    return false;
  };
});

// node_modules/mongoose/lib/queryHelpers.js
var require_queryHelpers = __commonJS((exports) => {
  function makeLean(val) {
    return function(option) {
      option.options || (option.options = {});
      if (val != null && Array.isArray(val.virtuals)) {
        val = Object.assign({}, val);
        val.virtuals = val.virtuals.filter((path) => typeof path === "string" && path.startsWith(option.path + ".")).map((path) => path.slice(option.path.length + 1));
      }
      option.options.lean = val;
    };
  }
  /*!
   * Module dependencies
   */
  var PopulateOptions = require_populateOptions();
  var checkEmbeddedDiscriminatorKeyProjection = require_checkEmbeddedDiscriminatorKeyProjection();
  var get = require_get2();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var isDefiningProjection = require_isDefiningProjection();
  var clone = require_clone2();
  var isPathSelectedInclusive = require_isPathSelectedInclusive();
  exports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {
    const _populate = query._mongooseOptions.populate;
    const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);
    if (options.lean != null) {
      pop.filter((p) => (p && p.options && p.options.lean) == null).forEach(makeLean(options.lean));
    }
    const session = query && query.options && query.options.session || null;
    if (session != null) {
      pop.forEach((path) => {
        if (path.options == null) {
          path.options = { session };
          return;
        }
        if (!("session" in path.options)) {
          path.options.session = session;
        }
      });
    }
    const projection = query._fieldsForExec();
    for (let i = 0;i < pop.length; ++i) {
      if (pop[i] instanceof PopulateOptions) {
        pop[i] = new PopulateOptions({
          ...pop[i],
          _queryProjection: projection,
          _localModel: query.model
        });
      } else {
        pop[i]._queryProjection = projection;
        pop[i]._localModel = query.model;
      }
    }
    return pop;
  };
  exports.createModel = function createModel(model, doc, fields, userProvidedFields, options) {
    model.hooks.execPreSync("createModel", doc);
    const discriminatorMapping = model.schema ? model.schema.discriminatorMapping : null;
    const key = discriminatorMapping && discriminatorMapping.isRoot ? discriminatorMapping.key : null;
    const value = doc[key];
    if (key && value && model.discriminators) {
      const discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);
      if (discriminator) {
        const _fields = clone(userProvidedFields);
        exports.applyPaths(_fields, discriminator.schema);
        return new discriminator(undefined, _fields, true);
      }
    }
    const _opts = {
      skipId: true,
      isNew: false,
      willInit: true
    };
    if (options != null && "defaults" in options) {
      _opts.defaults = options.defaults;
    }
    return new model(undefined, fields, _opts);
  };
  /*!
   * ignore
   */
  exports.createModelAndInit = function createModelAndInit(model, doc, fields, userProvidedFields, options, populatedIds, callback) {
    const initOpts = populatedIds ? { populated: populatedIds } : undefined;
    const casted = exports.createModel(model, doc, fields, userProvidedFields, options);
    try {
      casted.$init(doc, initOpts, callback);
    } catch (error) {
      callback(error, casted);
    }
  };
  /*!
   * ignore
   */
  exports.applyPaths = function applyPaths(fields, schema, sanitizeProjection) {
    let exclude;
    let keys;
    const minusPathsToSkip = new Set;
    if (fields) {
      keys = Object.keys(fields);
      const minusPaths = [];
      for (let i = 0;i < keys.length; ++i) {
        const key = keys[i];
        if (keys[i][0] !== "-") {
          continue;
        }
        delete fields[key];
        if (key === "-_id") {
          fields["_id"] = 0;
        } else {
          minusPaths.push(key.slice(1));
        }
      }
      keys = Object.keys(fields);
      for (let keyIndex = 0;keyIndex < keys.length; ++keyIndex) {
        if (keys[keyIndex][0] === "+") {
          continue;
        }
        const field = fields[keys[keyIndex]];
        if (!isDefiningProjection(field)) {
          continue;
        }
        if (keys[keyIndex] === "_id" && keys.length > 1) {
          continue;
        }
        if (keys[keyIndex] === schema.options.discriminatorKey && keys.length > 1 && field != null && !field) {
          continue;
        }
        exclude = !field;
        break;
      }
      for (const path of minusPaths) {
        const type = schema.path(path);
        if (!type || !type.selected || exclude !== false) {
          fields[path] = 0;
          exclude = true;
        } else if (type && type.selected && exclude === false) {
          minusPathsToSkip.add(path);
        }
      }
    }
    const selected = [];
    const excluded = [];
    const stack = [];
    analyzeSchema(schema);
    switch (exclude) {
      case true:
        for (const fieldName of excluded) {
          fields[fieldName] = 0;
        }
        break;
      case false:
        if (schema && schema.paths["_id"] && schema.paths["_id"].options && schema.paths["_id"].options.select === false) {
          fields._id = 0;
        }
        for (const fieldName of selected) {
          if (minusPathsToSkip.has(fieldName)) {
            continue;
          }
          if (isPathSelectedInclusive(fields, fieldName)) {
            continue;
          }
          fields[fieldName] = fields[fieldName] || 1;
        }
        break;
      case undefined:
        if (fields == null) {
          break;
        }
        for (const key of Object.keys(fields || {})) {
          if (key.startsWith("+")) {
            delete fields[key];
          }
        }
        for (const fieldName of excluded) {
          if (fields[fieldName] != null) {
            continue;
          }
          fields[fieldName] = 0;
        }
        break;
    }
    function analyzeSchema(schema2, prefix) {
      prefix || (prefix = "");
      if (stack.indexOf(schema2) !== -1) {
        return [];
      }
      stack.push(schema2);
      const addedPaths = [];
      schema2.eachPath(function(path, type) {
        if (prefix)
          path = prefix + "." + path;
        if (type.$isSchemaMap || path.endsWith(".$*")) {
          const plusPath = "+" + path;
          const hasPlusPath = fields && plusPath in fields;
          if (type.options && type.options.select === false && !hasPlusPath) {
            excluded.push(path);
          }
          return;
        }
        let addedPath = analyzePath(path, type);
        if (addedPath == null && !Array.isArray(type) && type.$isMongooseArray && !type.$isMongooseDocumentArray) {
          addedPath = analyzePath(path, type.caster);
        }
        if (addedPath != null) {
          addedPaths.push(addedPath);
        }
        if (type.schema) {
          const _addedPaths = analyzeSchema(type.schema, path);
          if (exclude === false) {
            checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema, selected, _addedPaths);
          }
        }
      });
      stack.pop();
      return addedPaths;
    }
    function analyzePath(path, type) {
      if (fields == null) {
        return;
      }
      if (typeof type.selected !== "boolean") {
        return;
      }
      if (type.selected === false && fields[path]) {
        if (sanitizeProjection) {
          fields[path] = 0;
        }
        return;
      }
      if (!exclude && type.selected && path === schema.options.discriminatorKey && fields[path] != null && !fields[path]) {
        delete fields[path];
        return;
      }
      if (exclude === false && type.selected && fields[path] != null && !fields[path]) {
        delete fields[path];
        return;
      }
      const plusPath = "+" + path;
      const hasPlusPath = fields && plusPath in fields;
      if (hasPlusPath) {
        delete fields[plusPath];
        if (exclude === false && keys.length > 1 && !~keys.indexOf(path) && !sanitizeProjection) {
          fields[path] = 1;
        } else if (exclude == null && sanitizeProjection && type.selected === false) {
          fields[path] = 0;
        }
        return;
      }
      const pieces = path.split(".");
      let cur = "";
      for (let i = 0;i < pieces.length; ++i) {
        cur += cur.length ? "." + pieces[i] : pieces[i];
        if (excluded.indexOf(cur) !== -1) {
          return;
        }
      }
      if (!exclude && (type && type.options && type.options.$skipDiscriminatorCheck || false)) {
        let cur2 = "";
        for (let i = 0;i < pieces.length; ++i) {
          cur2 += (cur2.length === 0 ? "" : ".") + pieces[i];
          const projection = get(fields, cur2, false) || get(fields, cur2 + ".$", false);
          if (projection && typeof projection !== "object") {
            return;
          }
        }
      }
      (type.selected ? selected : excluded).push(path);
      return path;
    }
  };
});

// node_modules/mongoose/lib/helpers/isPromise.js
var require_isPromise = __commonJS((exports, module) => {
  function isPromise(val) {
    return !!val && (typeof val === "object" || typeof val === "function") && typeof val.then === "function";
  }
  module.exports = isPromise;
});

// node_modules/mongoose/lib/helpers/document/getDeepestSubdocumentForPath.js
var require_getDeepestSubdocumentForPath = __commonJS((exports, module) => {
  module.exports = function getDeepestSubdocumentForPath(doc, parts, schema) {
    let curPath = parts[0];
    let curSchema = schema;
    let subdoc = doc;
    for (let i = 0;i < parts.length - 1; ++i) {
      const curSchemaType = curSchema.path(curPath);
      if (curSchemaType && curSchemaType.schema) {
        let newSubdoc = subdoc.get(curPath);
        curSchema = curSchemaType.schema;
        curPath = parts[i + 1];
        if (Array.isArray(newSubdoc) && !isNaN(curPath)) {
          newSubdoc = newSubdoc[curPath];
          curPath = "";
        }
        if (newSubdoc == null) {
          break;
        }
        subdoc = newSubdoc;
      } else {
        curPath += curPath.length ? "." + parts[i + 1] : parts[i + 1];
      }
    }
    return subdoc;
  };
});

// node_modules/mongoose/lib/types/subdocument.js
var require_subdocument = __commonJS((exports, module) => {
  function Subdocument(value, fields, parent, skipId, options) {
    if (typeof skipId === "object" && skipId != null && options == null) {
      options = skipId;
      skipId = undefined;
    }
    if (parent != null) {
      const parentOptions = { isNew: parent.isNew };
      if ("defaults" in parent.$__) {
        parentOptions.defaults = parent.$__.defaults;
      }
      options = Object.assign(parentOptions, options);
    }
    if (options != null && options.path != null) {
      this.$basePath = options.path;
    }
    Document.call(this, value, fields, skipId, options);
    delete this.$__.priorDoc;
  }
  function registerRemoveListener(sub) {
    const owner = sub.ownerDocument();
    function emitRemove() {
      owner.$removeListener("save", emitRemove);
      owner.$removeListener("deleteOne", emitRemove);
      sub.emit("deleteOne", sub);
      sub.constructor.emit("deleteOne", sub);
    }
    owner.$on("save", emitRemove);
    owner.$on("deleteOne", emitRemove);
  }
  var Document = require_document2();
  var immediate = require_immediate();
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var util = import.meta.require("util");
  var utils = require_utils4();
  module.exports = Subdocument;
  Subdocument.prototype = Object.create(Document.prototype);
  Object.defineProperty(Subdocument.prototype, "$isSubdocument", {
    configurable: false,
    writable: false,
    value: true
  });
  Object.defineProperty(Subdocument.prototype, "$isSingleNested", {
    configurable: false,
    writable: false,
    value: true
  });
  /*!
   * ignore
   */
  Subdocument.prototype.toBSON = function() {
    return this.toObject(internalToObjectOptions);
  };
  Subdocument.prototype.save = async function save(options) {
    options = options || {};
    if (!options.suppressWarning) {
      utils.warn("mongoose: calling `save()` on a subdoc does **not** save " + "the document to MongoDB, it only runs save middleware. " + "Use `subdoc.save({ suppressWarning: true })` to hide this warning " + "if you\'re sure this behavior is right for your app.");
    }
    return new Promise((resolve, reject) => {
      this.$__save((err) => {
        if (err != null) {
          return reject(err);
        }
        resolve(this);
      });
    });
  };
  Subdocument.prototype.$__fullPath = function(path) {
    if (!this.$__.fullPath) {
      this.ownerDocument();
    }
    return path ? this.$__.fullPath + "." + path : this.$__.fullPath;
  };
  Subdocument.prototype.$__pathRelativeToParent = function(p) {
    if (p == null) {
      return this.$basePath;
    }
    return [this.$basePath, p].join(".");
  };
  Subdocument.prototype.$__save = function(fn) {
    return immediate(() => fn(null, this));
  };
  /*!
   * ignore
   */
  Subdocument.prototype.$isValid = function(path) {
    const parent = this.$parent();
    const fullPath = this.$__pathRelativeToParent(path);
    if (parent != null && fullPath != null) {
      return parent.$isValid(fullPath);
    }
    return Document.prototype.$isValid.call(this, path);
  };
  /*!
   * ignore
   */
  Subdocument.prototype.markModified = function(path) {
    Document.prototype.markModified.call(this, path);
    const parent = this.$parent();
    const fullPath = this.$__pathRelativeToParent(path);
    if (parent == null || fullPath == null) {
      return;
    }
    const myPath = this.$__pathRelativeToParent().replace(/\.$/, "");
    if (parent.isDirectModified(myPath) || this.isNew) {
      return;
    }
    this.$__parent.markModified(fullPath, this);
  };
  /*!
   * ignore
   */
  Subdocument.prototype.isModified = function(paths, options, modifiedPaths) {
    const parent = this.$parent();
    if (parent != null) {
      if (Array.isArray(paths) || typeof paths === "string") {
        paths = Array.isArray(paths) ? paths : paths.split(" ");
        paths = paths.map((p) => this.$__pathRelativeToParent(p)).filter((p) => p != null);
      } else if (!paths) {
        paths = this.$__pathRelativeToParent();
      }
      return parent.$isModified(paths, options, modifiedPaths);
    }
    return Document.prototype.isModified.call(this, paths, options, modifiedPaths);
  };
  Subdocument.prototype.$markValid = function(path) {
    Document.prototype.$markValid.call(this, path);
    const parent = this.$parent();
    const fullPath = this.$__pathRelativeToParent(path);
    if (parent != null && fullPath != null) {
      parent.$markValid(fullPath);
    }
  };
  /*!
   * ignore
   */
  Subdocument.prototype.invalidate = function(path, err, val) {
    Document.prototype.invalidate.call(this, path, err, val);
    const parent = this.$parent();
    const fullPath = this.$__pathRelativeToParent(path);
    if (parent != null && fullPath != null) {
      parent.invalidate(fullPath, err, val);
    } else if (err.kind === "cast" || err.name === "CastError" || fullPath == null) {
      throw err;
    }
    return this.ownerDocument().$__.validationError;
  };
  /*!
   * ignore
   */
  Subdocument.prototype.$ignore = function(path) {
    Document.prototype.$ignore.call(this, path);
    const parent = this.$parent();
    const fullPath = this.$__pathRelativeToParent(path);
    if (parent != null && fullPath != null) {
      parent.$ignore(fullPath);
    }
  };
  Subdocument.prototype.ownerDocument = function() {
    if (this.$__.ownerDocument) {
      return this.$__.ownerDocument;
    }
    let parent = this;
    const paths = [];
    const seenDocs = new Set([parent]);
    while (true) {
      if (typeof parent.$__pathRelativeToParent !== "function") {
        break;
      }
      paths.unshift(parent.$__pathRelativeToParent(undefined, true));
      const _parent = parent.$parent();
      if (_parent == null) {
        break;
      }
      parent = _parent;
      if (seenDocs.has(parent)) {
        throw new Error("Infinite subdocument loop: subdoc with _id " + parent._id + " is a parent of itself");
      }
      seenDocs.add(parent);
    }
    this.$__.fullPath = paths.join(".");
    this.$__.ownerDocument = parent;
    return this.$__.ownerDocument;
  };
  /*!
   * ignore
   */
  Subdocument.prototype.$__fullPathWithIndexes = function() {
    let parent = this;
    const paths = [];
    const seenDocs = new Set([parent]);
    while (true) {
      if (typeof parent.$__pathRelativeToParent !== "function") {
        break;
      }
      paths.unshift(parent.$__pathRelativeToParent(undefined, false));
      const _parent = parent.$parent();
      if (_parent == null) {
        break;
      }
      parent = _parent;
      if (seenDocs.has(parent)) {
        throw new Error("Infinite subdocument loop: subdoc with _id " + parent._id + " is a parent of itself");
      }
      seenDocs.add(parent);
    }
    return paths.join(".");
  };
  Subdocument.prototype.parent = function() {
    return this.$__parent;
  };
  Subdocument.prototype.$parent = Subdocument.prototype.parent;
  Subdocument.prototype.$__deleteOne = function(cb) {
    if (cb == null) {
      return;
    }
    return cb(null, this);
  };
  Subdocument.prototype.$__removeFromParent = function() {
    this.$__parent.set(this.$basePath, null);
  };
  Subdocument.prototype.deleteOne = function(options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    registerRemoveListener(this);
    if (!options || !options.noop) {
      this.$__removeFromParent();
      const owner = this.ownerDocument();
      owner.$__.removedSubdocs = owner.$__.removedSubdocs || [];
      owner.$__.removedSubdocs.push(this);
    }
    return this.$__deleteOne(callback);
  };
  /*!
   * ignore
   */
  Subdocument.prototype.populate = function() {
    throw new Error("Mongoose does not support calling populate() on nested " + 'docs. Instead of `doc.nested.populate("path")`, use ' + '`doc.populate("nested.path")`');
  };
  Subdocument.prototype.inspect = function() {
    return this.toObject();
  };
  if (util.inspect.custom) {
    Subdocument.prototype[util.inspect.custom] = Subdocument.prototype.inspect;
  }
});

// node_modules/mongoose/lib/types/arraySubdocument.js
var require_arraySubdocument = __commonJS((exports, module) => {
  function ArraySubdocument(obj, parentArr, skipId, fields, index) {
    if (utils.isMongooseDocumentArray(parentArr)) {
      this.__parentArray = parentArr;
      this[documentArrayParent] = parentArr.$parent();
    } else {
      this.__parentArray = undefined;
      this[documentArrayParent] = undefined;
    }
    this.$setIndex(index);
    this.$__parent = this[documentArrayParent];
    let options;
    if (typeof skipId === "object" && skipId != null) {
      options = { isNew: true, ...skipId };
      skipId = undefined;
    } else {
      options = { isNew: true };
    }
    Subdocument.call(this, obj, fields, this[documentArrayParent], skipId, options);
  }
  /*!
   * Module dependencies.
   */
  var EventEmitter = import.meta.require("events").EventEmitter;
  var Subdocument = require_subdocument();
  var utils = require_utils4();
  var documentArrayParent = require_symbols().documentArrayParent;
  /*!
   * Inherit from Subdocument
   */
  ArraySubdocument.prototype = Object.create(Subdocument.prototype);
  ArraySubdocument.prototype.constructor = ArraySubdocument;
  Object.defineProperty(ArraySubdocument.prototype, "$isSingleNested", {
    configurable: false,
    writable: false,
    value: false
  });
  Object.defineProperty(ArraySubdocument.prototype, "$isDocumentArrayElement", {
    configurable: false,
    writable: false,
    value: true
  });
  for (const i in EventEmitter.prototype) {
    ArraySubdocument[i] = EventEmitter.prototype[i];
  }
  /*!
   * ignore
   */
  ArraySubdocument.prototype.$setIndex = function(index) {
    this.__index = index;
    if (this.$__ != null && this.$__.validationError != null) {
      const keys = Object.keys(this.$__.validationError.errors);
      for (const key of keys) {
        this.invalidate(key, this.$__.validationError.errors[key]);
      }
    }
  };
  /*!
   * ignore
   */
  ArraySubdocument.prototype.populate = function() {
    throw new Error("Mongoose does not support calling populate() on nested " + 'docs. Instead of `doc.arr[0].populate("path")`, use ' + '`doc.populate("arr.0.path")`');
  };
  /*!
   * ignore
   */
  ArraySubdocument.prototype.$__removeFromParent = function() {
    const _id = this._doc._id;
    if (!_id) {
      throw new Error("For your own good, Mongoose does not know " + "how to remove an ArraySubdocument that has no _id");
    }
    this.__parentArray.pull({ _id });
  };
  ArraySubdocument.prototype.$__fullPath = function(path, skipIndex) {
    if (this.__index == null) {
      return null;
    }
    if (!this.$__.fullPath) {
      this.ownerDocument();
    }
    if (skipIndex) {
      return path ? this.$__.fullPath + "." + path : this.$__.fullPath;
    }
    return path ? this.$__.fullPath + "." + this.__index + "." + path : this.$__.fullPath + "." + this.__index;
  };
  ArraySubdocument.prototype.$__pathRelativeToParent = function(path, skipIndex) {
    if (this.__index == null || (!this.__parentArray || !this.__parentArray.$path)) {
      return null;
    }
    if (skipIndex) {
      return path == null ? this.__parentArray.$path() : this.__parentArray.$path() + "." + path;
    }
    if (path == null) {
      return this.__parentArray.$path() + "." + this.__index;
    }
    return this.__parentArray.$path() + "." + this.__index + "." + path;
  };
  ArraySubdocument.prototype.$parent = function() {
    return this[documentArrayParent];
  };
  ArraySubdocument.prototype.parentArray = function() {
    return this.__parentArray;
  };
  /*!
   * Module exports.
   */
  module.exports = ArraySubdocument;
});

// node_modules/mongoose/lib/types/array/methods/index.js
var require_methods = __commonJS((exports, module) => {
  function _isAllSubdocs(docs, ref) {
    if (!ref) {
      return false;
    }
    for (const arg of docs) {
      if (arg == null) {
        return false;
      }
      const model = arg.constructor;
      if (!(arg instanceof Document) || model.modelName !== ref && model.baseModelName !== ref) {
        return false;
      }
    }
    return true;
  }
  function _minimizePath(obj, parts, i) {
    if (typeof parts === "string") {
      if (parts.indexOf(".") === -1) {
        return;
      }
      parts = mpath.stringToParts(parts);
    }
    i = i || 0;
    if (i >= parts.length) {
      return;
    }
    if (obj == null || typeof obj !== "object") {
      return;
    }
    _minimizePath(obj[parts[0]], parts, i + 1);
    if (obj[parts[0]] != null && typeof obj[parts[0]] === "object" && Object.keys(obj[parts[0]]).length === 0) {
      delete obj[parts[0]];
    }
  }
  function _checkManualPopulation(arr, docs) {
    const ref = arr == null ? null : arr[arraySchemaSymbol] && arr[arraySchemaSymbol].caster && arr[arraySchemaSymbol].caster.options && arr[arraySchemaSymbol].caster.options.ref || null;
    if (arr.length === 0 && docs.length !== 0) {
      if (_isAllSubdocs(docs, ref)) {
        arr[arrayParentSymbol].$populated(arr[arrayPathSymbol], [], {
          [populateModelSymbol]: docs[0].constructor
        });
      }
    }
  }
  function _depopulateIfNecessary(arr, docs) {
    const ref = arr == null ? null : arr[arraySchemaSymbol] && arr[arraySchemaSymbol].caster && arr[arraySchemaSymbol].caster.options && arr[arraySchemaSymbol].caster.options.ref || null;
    const parentDoc = arr[arrayParentSymbol];
    const path = arr[arrayPathSymbol];
    if (!ref || !parentDoc.populated(path)) {
      return;
    }
    for (const doc of docs) {
      if (doc == null) {
        continue;
      }
      if (typeof doc !== "object" || doc instanceof String || doc instanceof Number || doc instanceof Buffer || utils.isMongooseType(doc)) {
        parentDoc.depopulate(path);
        break;
      }
    }
  }
  var Document = require_document2();
  var ArraySubdocument = require_arraySubdocument();
  var MongooseError = require_mongooseError();
  var cleanModifiedSubpaths = require_cleanModifiedSubpaths();
  var clone = require_clone2();
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var mpath = require_mpath();
  var utils = require_utils4();
  var isBsonType = require_isBsonType();
  var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
  var arrayParentSymbol = require_symbols().arrayParentSymbol;
  var arrayPathSymbol = require_symbols().arrayPathSymbol;
  var arraySchemaSymbol = require_symbols().arraySchemaSymbol;
  var populateModelSymbol = require_symbols().populateModelSymbol;
  var slicedSymbol = Symbol("mongoose#Array#sliced");
  var _basePush = Array.prototype.push;
  /*!
   * ignore
   */
  var methods = {
    $__getAtomics() {
      const ret = [];
      const keys = Object.keys(this[arrayAtomicsSymbol] || {});
      let i = keys.length;
      const opts = Object.assign({}, internalToObjectOptions, { _isNested: true });
      if (i === 0) {
        ret[0] = ["$set", this.toObject(opts)];
        return ret;
      }
      while (i--) {
        const op = keys[i];
        let val = this[arrayAtomicsSymbol][op];
        if (utils.isMongooseObject(val)) {
          val = val.toObject(opts);
        } else if (Array.isArray(val)) {
          val = this.toObject.call(val, opts);
        } else if (val != null && Array.isArray(val.$each)) {
          val.$each = this.toObject.call(val.$each, opts);
        } else if (val != null && typeof val.valueOf === "function") {
          val = val.valueOf();
        }
        if (op === "$addToSet") {
          val = { $each: val };
        }
        ret.push([op, val]);
      }
      return ret;
    },
    $atomics() {
      /*!
         * ignore
         */
      return this[arrayAtomicsSymbol];
    },
    $parent() {
      /*!
         * ignore
         */
      return this[arrayParentSymbol];
    },
    $path() {
      /*!
         * ignore
         */
      return this[arrayPathSymbol];
    },
    $shift() {
      this._registerAtomic("$pop", -1);
      this._markModified();
      const __array = this.__array;
      if (__array._shifted) {
        return;
      }
      __array._shifted = true;
      return [].shift.call(__array);
    },
    $pop() {
      this._registerAtomic("$pop", 1);
      this._markModified();
      if (this._popped) {
        return;
      }
      this._popped = true;
      return [].pop.call(this);
    },
    $schema() {
      /*!
         * ignore
         */
      return this[arraySchemaSymbol];
    },
    _cast(value) {
      let populated = false;
      let Model;
      const parent = this[arrayParentSymbol];
      if (parent) {
        populated = parent.$populated(this[arrayPathSymbol], true);
      }
      if (populated && value !== null && value !== undefined) {
        Model = populated.options[populateModelSymbol];
        if (Model == null) {
          throw new MongooseError("No populated model found for path `" + this[arrayPathSymbol] + "`. This is likely a bug in Mongoose, please report an issue on github.com/Automattic/mongoose.");
        }
        if (Buffer.isBuffer(value) || isBsonType(value, "ObjectId") || !utils.isObject(value)) {
          value = { _id: value };
        }
        const isDisc = value.schema && value.schema.discriminatorMapping && value.schema.discriminatorMapping.key !== undefined;
        if (!isDisc) {
          value = new Model(value);
        }
        return this[arraySchemaSymbol].caster.applySetters(value, parent, true);
      }
      return this[arraySchemaSymbol].caster.applySetters(value, parent, false);
    },
    _mapCast(val, index) {
      return this._cast(val, this.length + index);
    },
    _markModified(elem) {
      const parent = this[arrayParentSymbol];
      let dirtyPath;
      if (parent) {
        dirtyPath = this[arrayPathSymbol];
        if (arguments.length) {
          dirtyPath = dirtyPath + "." + elem;
        }
        if (dirtyPath != null && dirtyPath.endsWith(".$")) {
          return this;
        }
        parent.markModified(dirtyPath, arguments.length !== 0 ? elem : parent);
      }
      return this;
    },
    _registerAtomic(op, val) {
      if (this[slicedSymbol]) {
        return;
      }
      if (op === "$set") {
        this[arrayAtomicsSymbol] = { $set: val };
        cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]);
        this._markModified();
        return this;
      }
      const atomics = this[arrayAtomicsSymbol];
      if (op === "$pop" && !("$pop" in atomics)) {
        const _this = this;
        this[arrayParentSymbol].once("save", function() {
          _this._popped = _this._shifted = null;
        });
      }
      if (atomics.$set || Object.keys(atomics).length && !(op in atomics)) {
        this[arrayAtomicsSymbol] = { $set: this };
        return this;
      }
      let selector;
      if (op === "$pullAll" || op === "$addToSet") {
        atomics[op] || (atomics[op] = []);
        atomics[op] = atomics[op].concat(val);
      } else if (op === "$pullDocs") {
        const pullOp = atomics["$pull"] || (atomics["$pull"] = {});
        if (val[0] instanceof ArraySubdocument) {
          selector = pullOp["$or"] || (pullOp["$or"] = []);
          Array.prototype.push.apply(selector, val.map((v) => {
            return v.toObject({
              transform: (doc, ret) => {
                if (v == null || v.$__ == null) {
                  return ret;
                }
                Object.keys(v.$__.activePaths.getStatePaths("default")).forEach((path) => {
                  mpath.unset(path, ret);
                  _minimizePath(ret, path);
                });
                return ret;
              },
              virtuals: false
            });
          }));
        } else {
          selector = pullOp["_id"] || (pullOp["_id"] = { $in: [] });
          selector["$in"] = selector["$in"].concat(val);
        }
      } else if (op === "$push") {
        atomics.$push = atomics.$push || { $each: [] };
        if (val != null && utils.hasUserDefinedProperty(val, "$each")) {
          atomics.$push = val;
        } else {
          if (val.length === 1) {
            atomics.$push.$each.push(val[0]);
          } else if (val.length < 1e4) {
            atomics.$push.$each.push(...val);
          } else {
            for (const v of val) {
              atomics.$push.$each.push(v);
            }
          }
        }
      } else {
        atomics[op] = val;
      }
      return this;
    },
    addToSet() {
      _checkManualPopulation(this, arguments);
      _depopulateIfNecessary(this, arguments);
      const values = [].map.call(arguments, this._mapCast, this);
      const added = [];
      let type = "";
      if (values[0] instanceof ArraySubdocument) {
        type = "doc";
      } else if (values[0] instanceof Date) {
        type = "date";
      } else if (isBsonType(values[0], "ObjectId")) {
        type = "ObjectId";
      }
      const rawValues = utils.isMongooseArray(values) ? values.__array : values;
      const rawArray = utils.isMongooseArray(this) ? this.__array : this;
      rawValues.forEach(function(v) {
        let found;
        const val = +v;
        switch (type) {
          case "doc":
            found = this.some(function(doc) {
              return doc.equals(v);
            });
            break;
          case "date":
            found = this.some(function(d) {
              return +d === val;
            });
            break;
          case "ObjectId":
            found = this.find((o) => o.toString() === v.toString());
            break;
          default:
            found = ~this.indexOf(v);
            break;
        }
        if (!found) {
          this._markModified();
          rawArray.push(v);
          this._registerAtomic("$addToSet", v);
          [].push.call(added, v);
        }
      }, this);
      return added;
    },
    hasAtomics() {
      if (!utils.isPOJO(this[arrayAtomicsSymbol])) {
        return 0;
      }
      return Object.keys(this[arrayAtomicsSymbol]).length;
    },
    includes(obj, fromIndex) {
      const ret = this.indexOf(obj, fromIndex);
      return ret !== -1;
    },
    indexOf(obj, fromIndex) {
      if (isBsonType(obj, "ObjectId")) {
        obj = obj.toString();
      }
      fromIndex = fromIndex == null ? 0 : fromIndex;
      const len = this.length;
      for (let i = fromIndex;i < len; ++i) {
        if (obj == this[i]) {
          return i;
        }
      }
      return -1;
    },
    inspect() {
      return JSON.stringify(this);
    },
    nonAtomicPush() {
      const values = [].map.call(arguments, this._mapCast, this);
      this._markModified();
      const ret = [].push.apply(this, values);
      this._registerAtomic("$set", this);
      return ret;
    },
    pop() {
      this._markModified();
      const ret = [].pop.call(this);
      this._registerAtomic("$set", this);
      return ret;
    },
    pull() {
      const values = [].map.call(arguments, (v, i2) => this._cast(v, i2, { defaults: false }), this);
      let cur = this[arrayParentSymbol].get(this[arrayPathSymbol]);
      if (utils.isMongooseArray(cur)) {
        cur = cur.__array;
      }
      let i = cur.length;
      let mem;
      this._markModified();
      while (i--) {
        mem = cur[i];
        if (mem instanceof Document) {
          const some = values.some(function(v) {
            return mem.equals(v);
          });
          if (some) {
            cur.splice(i, 1);
          }
        } else if (~this.indexOf.call(values, mem)) {
          cur.splice(i, 1);
        }
      }
      if (values[0] instanceof ArraySubdocument) {
        this._registerAtomic("$pullDocs", values.map(function(v) {
          const _id = v.$__getValue("_id");
          if (_id === undefined || v.$isDefault("_id")) {
            return v;
          }
          return _id;
        }));
      } else {
        this._registerAtomic("$pullAll", values);
      }
      if (cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]) > 0) {
        this._registerAtomic("$set", this);
      }
      return this;
    },
    push() {
      let values = arguments;
      let atomic = values;
      const isOverwrite = values[0] != null && utils.hasUserDefinedProperty(values[0], "$each");
      const arr = utils.isMongooseArray(this) ? this.__array : this;
      if (isOverwrite) {
        atomic = values[0];
        values = values[0].$each;
      }
      if (this[arraySchemaSymbol] == null) {
        return _basePush.apply(this, values);
      }
      _checkManualPopulation(this, values);
      _depopulateIfNecessary(this, values);
      values = [].map.call(values, this._mapCast, this);
      let ret;
      const atomics = this[arrayAtomicsSymbol];
      this._markModified();
      if (isOverwrite) {
        atomic.$each = values;
        if ((atomics.$push && atomics.$push.$each && atomics.$push.$each.length || 0) !== 0 && atomics.$push.$position != atomic.$position) {
          if (atomic.$position != null) {
            [].splice.apply(arr, [atomic.$position, 0].concat(values));
            ret = arr.length;
          } else {
            ret = [].push.apply(arr, values);
          }
          this._registerAtomic("$set", this);
        } else if (atomic.$position != null) {
          [].splice.apply(arr, [atomic.$position, 0].concat(values));
          ret = this.length;
        } else {
          ret = [].push.apply(arr, values);
        }
      } else {
        atomic = values;
        ret = _basePush.apply(arr, values);
      }
      this._registerAtomic("$push", atomic);
      return ret;
    },
    remove() {
      return this.pull.apply(this, arguments);
    },
    set(i, val, skipModified) {
      const arr = this.__array;
      if (skipModified) {
        arr[i] = val;
        return this;
      }
      const value = methods._cast.call(this, val, i);
      methods._markModified.call(this, i);
      arr[i] = value;
      return this;
    },
    shift() {
      const arr = utils.isMongooseArray(this) ? this.__array : this;
      this._markModified();
      const ret = [].shift.call(arr);
      this._registerAtomic("$set", this);
      return ret;
    },
    sort() {
      const arr = utils.isMongooseArray(this) ? this.__array : this;
      const ret = [].sort.apply(arr, arguments);
      this._registerAtomic("$set", this);
      return ret;
    },
    splice() {
      let ret;
      const arr = utils.isMongooseArray(this) ? this.__array : this;
      this._markModified();
      _checkManualPopulation(this, Array.prototype.slice.call(arguments, 2));
      if (arguments.length) {
        let vals;
        if (this[arraySchemaSymbol] == null) {
          vals = arguments;
        } else {
          vals = [];
          for (let i = 0;i < arguments.length; ++i) {
            vals[i] = i < 2 ? arguments[i] : this._cast(arguments[i], arguments[0] + (i - 2));
          }
        }
        ret = [].splice.apply(arr, vals);
        this._registerAtomic("$set", this);
      }
      return ret;
    },
    toBSON() {
      /*!
         * ignore
         */
      return this.toObject(internalToObjectOptions);
    },
    toObject(options) {
      const arr = utils.isMongooseArray(this) ? this.__array : this;
      if (options && options.depopulate) {
        options = clone(options);
        options._isNested = true;
        return [].concat(arr).map(function(doc) {
          return doc instanceof Document ? doc.toObject(options) : doc;
        });
      }
      return [].concat(arr);
    },
    $toObject() {
      return this.constructor.prototype.toObject.apply(this, arguments);
    },
    unshift() {
      _checkManualPopulation(this, arguments);
      let values;
      if (this[arraySchemaSymbol] == null) {
        values = arguments;
      } else {
        values = [].map.call(arguments, this._cast, this);
      }
      const arr = utils.isMongooseArray(this) ? this.__array : this;
      this._markModified();
      [].unshift.apply(arr, values);
      this._registerAtomic("$set", this);
      return this.length;
    }
  };
  /*!
   * ignore
   */
  /*!
   * Minimize _just_ empty objects along the path chain specified
   * by `parts`, ignoring all other paths. Useful in cases where
   * you want to minimize after unsetting a path.
   *
   * #### Example:
   *
   *     const obj = { foo: { bar: { baz: {} } }, a: {} };
   *     _minimizePath(obj, 'foo.bar.baz');
   *     obj; // { a: {} }
   */
  /*!
   * ignore
   */
  /*!
   * If `docs` isn't all instances of the right model, depopulate `arr`
   */
  var returnVanillaArrayMethods = [
    "filter",
    "flat",
    "flatMap",
    "map",
    "slice"
  ];
  for (const method of returnVanillaArrayMethods) {
    if (Array.prototype[method] == null) {
      continue;
    }
    methods[method] = function() {
      const _arr = utils.isMongooseArray(this) ? this.__array : this;
      const arr = [].concat(_arr);
      return arr[method].apply(arr, arguments);
    };
  }
  module.exports = methods;
});

// node_modules/mongoose/lib/types/array/index.js
var require_array = __commonJS((exports, module) => {
  function MongooseArray(values, path, doc, schematype) {
    let __array;
    if (Array.isArray(values)) {
      const len = values.length;
      if (len === 0) {
        __array = new Array;
      } else if (len === 1) {
        __array = new Array(1);
        __array[0] = values[0];
      } else if (len < 1e4) {
        __array = new Array;
        _basePush.apply(__array, values);
      } else {
        __array = new Array;
        for (let i = 0;i < len; ++i) {
          _basePush.call(__array, values[i]);
        }
      }
    } else {
      __array = [];
    }
    const internals = {
      [arrayAtomicsSymbol]: {},
      [arrayAtomicsBackupSymbol]: undefined,
      [arrayPathSymbol]: path,
      [arraySchemaSymbol]: schematype,
      [arrayParentSymbol]: undefined,
      isMongooseArray: true,
      isMongooseArrayProxy: true,
      __array
    };
    if (values && values[arrayAtomicsSymbol] != null) {
      internals[arrayAtomicsSymbol] = values[arrayAtomicsSymbol];
    }
    if (doc != null && doc instanceof Document) {
      internals[arrayParentSymbol] = doc;
      internals[arraySchemaSymbol] = schematype || doc.schema.path(path);
    }
    const proxy = new Proxy(__array, {
      get: function(target, prop) {
        if (internals.hasOwnProperty(prop)) {
          return internals[prop];
        }
        if (mongooseArrayMethods.hasOwnProperty(prop)) {
          return mongooseArrayMethods[prop];
        }
        if (schematype && schematype.virtuals && schematype.virtuals.hasOwnProperty(prop)) {
          return schematype.virtuals[prop].applyGetters(undefined, target);
        }
        if (typeof prop === "string" && numberRE.test(prop) && schematype?.$embeddedSchemaType != null) {
          return schematype.$embeddedSchemaType.applyGetters(__array[prop], doc);
        }
        return __array[prop];
      },
      set: function(target, prop, value) {
        if (typeof prop === "string" && numberRE.test(prop)) {
          mongooseArrayMethods.set.call(proxy, prop, value, false);
        } else if (internals.hasOwnProperty(prop)) {
          internals[prop] = value;
        } else if (schematype && schematype.virtuals && schematype.virtuals.hasOwnProperty(prop)) {
          schematype.virtuals[prop].applySetters(value, target);
        } else {
          __array[prop] = value;
        }
        return true;
      }
    });
    return proxy;
  }
  /*!
   * Module dependencies.
   */
  var Document = require_document2();
  var mongooseArrayMethods = require_methods();
  var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
  var arrayAtomicsBackupSymbol = require_symbols().arrayAtomicsBackupSymbol;
  var arrayParentSymbol = require_symbols().arrayParentSymbol;
  var arrayPathSymbol = require_symbols().arrayPathSymbol;
  var arraySchemaSymbol = require_symbols().arraySchemaSymbol;
  var _basePush = Array.prototype.push;
  var numberRE = /^\d+$/;
  /*!
   * Module exports.
   */
  module.exports = exports = MongooseArray;
});

// node_modules/mongoose/lib/cast/objectid.js
var require_objectid2 = __commonJS((exports, module) => {
  var isBsonType = require_isBsonType();
  var ObjectId2 = require_objectid();
  module.exports = function castObjectId(value) {
    if (value == null) {
      return value;
    }
    if (isBsonType(value, "ObjectId")) {
      return value;
    }
    if (value._id) {
      if (isBsonType(value._id, "ObjectId")) {
        return value._id;
      }
      if (value._id.toString instanceof Function) {
        return new ObjectId2(value._id.toString());
      }
    }
    if (value.toString instanceof Function) {
      return new ObjectId2(value.toString());
    }
    return new ObjectId2(value);
  };
});

// node_modules/mongoose/lib/types/documentArray/methods/index.js
var require_methods2 = __commonJS((exports, module) => {
  function _updateParentPopulated(arr) {
    const parent = arr[arrayParentSymbol];
    if (!parent || parent.$__.populated == null)
      return;
    const populatedPaths = Object.keys(parent.$__.populated).filter((p) => p.startsWith(arr[arrayPathSymbol] + "."));
    for (const path of populatedPaths) {
      const remnant = path.slice((arr[arrayPathSymbol] + ".").length);
      if (!Array.isArray(parent.$__.populated[path].value)) {
        continue;
      }
      parent.$__.populated[path].value = arr.map((val) => val.$populated(remnant));
    }
  }
  var ArrayMethods = require_methods();
  var Document = require_document2();
  var castObjectId = require_objectid2();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var utils = require_utils4();
  var isBsonType = require_isBsonType();
  var arrayParentSymbol = require_symbols().arrayParentSymbol;
  var arrayPathSymbol = require_symbols().arrayPathSymbol;
  var arraySchemaSymbol = require_symbols().arraySchemaSymbol;
  var documentArrayParent = require_symbols().documentArrayParent;
  var _baseToString = Array.prototype.toString;
  var methods = {
    toBSON() {
      /*!
         * ignore
         */
      return this.toObject(internalToObjectOptions);
    },
    toString() {
      return _baseToString.call(this.__array.map((subdoc) => {
        if (subdoc != null && subdoc.$__ != null) {
          return subdoc.toString();
        }
        return subdoc;
      }));
    },
    getArrayParent() {
      /*!
         * ignore
         */
      return this[arrayParentSymbol];
    },
    _cast(value, index, options) {
      if (this[arraySchemaSymbol] == null) {
        return value;
      }
      let Constructor = this[arraySchemaSymbol].casterConstructor;
      const isInstance = Constructor.$isMongooseDocumentArray ? utils.isMongooseDocumentArray(value) : value instanceof Constructor;
      if (isInstance || value && value.constructor && value.constructor.baseCasterConstructor === Constructor) {
        if (!(value[documentArrayParent] && value.__parentArray)) {
          value[documentArrayParent] = this[arrayParentSymbol];
          value.__parentArray = this;
        }
        value.$setIndex(index);
        return value;
      }
      if (value === undefined || value === null) {
        return null;
      }
      if (Buffer.isBuffer(value) || isBsonType(value, "ObjectId") || !utils.isObject(value)) {
        value = { _id: value };
      }
      if (value && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {
        if (typeof value[Constructor.schema.options.discriminatorKey] === "string" && Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]]) {
          Constructor = Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]];
        } else {
          const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, value[Constructor.schema.options.discriminatorKey]);
          if (constructorByValue) {
            Constructor = constructorByValue;
          }
        }
      }
      if (Constructor.$isMongooseDocumentArray) {
        return Constructor.cast(value, this, undefined, undefined, index);
      }
      const ret = new Constructor(value, this, options, undefined, index);
      ret.isNew = true;
      return ret;
    },
    id(id) {
      let casted;
      let sid;
      let _id;
      try {
        casted = castObjectId(id).toString();
      } catch (e) {
        casted = null;
      }
      for (const val of this) {
        if (!val) {
          continue;
        }
        _id = val.get("_id");
        if (_id === null || typeof _id === "undefined") {
          continue;
        } else if (_id instanceof Document) {
          sid || (sid = String(id));
          if (sid == _id._id) {
            return val;
          }
        } else if (!isBsonType(id, "ObjectId") && !isBsonType(_id, "ObjectId")) {
          if (id == _id || utils.deepEqual(id, _id)) {
            return val;
          }
        } else if (casted == _id) {
          return val;
        }
      }
      return null;
    },
    toObject(options) {
      return [].concat(this.map(function(doc) {
        if (doc == null) {
          return null;
        }
        if (typeof doc.toObject !== "function") {
          return doc;
        }
        return doc.toObject(options);
      }));
    },
    $toObject() {
      return this.constructor.prototype.toObject.apply(this, arguments);
    },
    push() {
      const ret = ArrayMethods.push.apply(this, arguments);
      _updateParentPopulated(this);
      return ret;
    },
    pull() {
      const ret = ArrayMethods.pull.apply(this, arguments);
      _updateParentPopulated(this);
      return ret;
    },
    shift() {
      const ret = ArrayMethods.shift.apply(this, arguments);
      _updateParentPopulated(this);
      return ret;
    },
    splice() {
      const ret = ArrayMethods.splice.apply(this, arguments);
      _updateParentPopulated(this);
      return ret;
    },
    inspect() {
      return this.toObject();
    },
    create(obj) {
      let Constructor = this[arraySchemaSymbol].casterConstructor;
      if (obj && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {
        if (typeof obj[Constructor.schema.options.discriminatorKey] === "string" && Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]]) {
          Constructor = Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]];
        } else {
          const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, obj[Constructor.schema.options.discriminatorKey]);
          if (constructorByValue) {
            Constructor = constructorByValue;
          }
        }
      }
      return new Constructor(obj, this);
    },
    notify(event) {
      /*!
         * ignore
         */
      const _this = this;
      return function notify(val, _arr) {
        _arr = _arr || _this;
        let i = _arr.length;
        while (i--) {
          if (_arr[i] == null) {
            continue;
          }
          switch (event) {
            case "save":
              val = _this[i];
              break;
            default:
              break;
          }
          if (utils.isMongooseArray(_arr[i])) {
            notify(val, _arr[i]);
          } else if (_arr[i]) {
            _arr[i].emit(event, val);
          }
        }
      };
    },
    set(i, val, skipModified) {
      const arr = this.__array;
      if (skipModified) {
        arr[i] = val;
        return this;
      }
      const value = methods._cast.call(this, val, i);
      methods._markModified.call(this, i);
      arr[i] = value;
      return this;
    },
    _markModified(elem, embeddedPath) {
      const parent = this[arrayParentSymbol];
      let dirtyPath;
      if (parent) {
        dirtyPath = this[arrayPathSymbol];
        if (arguments.length) {
          if (embeddedPath != null) {
            const index = elem.__index;
            dirtyPath = dirtyPath + "." + index + "." + embeddedPath;
          } else {
            dirtyPath = dirtyPath + "." + elem;
          }
        }
        if (dirtyPath != null && dirtyPath.endsWith(".$")) {
          return this;
        }
        parent.markModified(dirtyPath, arguments.length !== 0 ? elem : parent);
      }
      return this;
    }
  };
  module.exports = methods;
});

// node_modules/mongoose/lib/types/documentArray/index.js
var require_documentArray = __commonJS((exports, module) => {
  function MongooseDocumentArray(values, path, doc, schematype) {
    const __array = [];
    const internals = {
      [arrayAtomicsSymbol]: {},
      [arrayAtomicsBackupSymbol]: undefined,
      [arrayPathSymbol]: path,
      [arraySchemaSymbol]: undefined,
      [arrayParentSymbol]: undefined
    };
    if (Array.isArray(values)) {
      if (values[arrayPathSymbol] === path && values[arrayParentSymbol] === doc) {
        internals[arrayAtomicsSymbol] = Object.assign({}, values[arrayAtomicsSymbol]);
      }
      values.forEach((v) => {
        _basePush.call(__array, v);
      });
    }
    internals[arrayPathSymbol] = path;
    internals.__array = __array;
    if (doc && doc instanceof Document) {
      internals[arrayParentSymbol] = doc;
      internals[arraySchemaSymbol] = doc.$__schema.path(path);
      while (internals[arraySchemaSymbol] != null && internals[arraySchemaSymbol].$isMongooseArray && !internals[arraySchemaSymbol].$isMongooseDocumentArray) {
        internals[arraySchemaSymbol] = internals[arraySchemaSymbol].casterConstructor;
      }
    }
    const proxy = new Proxy(__array, {
      get: function(target, prop) {
        if (prop === "isMongooseArray" || prop === "isMongooseArrayProxy" || prop === "isMongooseDocumentArray" || prop === "isMongooseDocumentArrayProxy") {
          return true;
        }
        if (internals.hasOwnProperty(prop)) {
          return internals[prop];
        }
        if (DocumentArrayMethods.hasOwnProperty(prop)) {
          return DocumentArrayMethods[prop];
        }
        if (schematype && schematype.virtuals && schematype.virtuals.hasOwnProperty(prop)) {
          return schematype.virtuals[prop].applyGetters(undefined, target);
        }
        if (ArrayMethods.hasOwnProperty(prop)) {
          return ArrayMethods[prop];
        }
        return __array[prop];
      },
      set: function(target, prop, value) {
        if (typeof prop === "string" && numberRE.test(prop)) {
          DocumentArrayMethods.set.call(proxy, prop, value, false);
        } else if (internals.hasOwnProperty(prop)) {
          internals[prop] = value;
        } else if (schematype && schematype.virtuals && schematype.virtuals.hasOwnProperty(prop)) {
          schematype.virtuals[prop].applySetters(value, target);
        } else {
          __array[prop] = value;
        }
        return true;
      }
    });
    return proxy;
  }
  /*!
   * Module dependencies.
   */
  var ArrayMethods = require_methods();
  var DocumentArrayMethods = require_methods2();
  var Document = require_document2();
  var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
  var arrayAtomicsBackupSymbol = require_symbols().arrayAtomicsBackupSymbol;
  var arrayParentSymbol = require_symbols().arrayParentSymbol;
  var arrayPathSymbol = require_symbols().arrayPathSymbol;
  var arraySchemaSymbol = require_symbols().arraySchemaSymbol;
  var _basePush = Array.prototype.push;
  var numberRE = /^\d+$/;
  /*!
   * Module exports.
   */
  module.exports = MongooseDocumentArray;
});

// node_modules/mongoose/lib/document.js
var require_document2 = __commonJS((exports, module) => {
  function Document(obj, fields, skipId, options) {
    if (typeof skipId === "object" && skipId != null) {
      options = skipId;
      skipId = options.skipId;
    }
    options = Object.assign({}, options);
    if (this.$__schema == null) {
      const _schema = utils.isObject(fields) && !fields.instanceOfSchema ? new Schema(fields) : fields;
      this.$__setSchema(_schema);
      fields = skipId;
      skipId = options;
      options = arguments[4] || {};
    }
    this.$__ = new InternalCache;
    if (options.isNew != null && options.isNew !== true) {
      this.$isNew = options.isNew;
    }
    if (options.priorDoc != null) {
      this.$__.priorDoc = options.priorDoc;
    }
    if (skipId) {
      this.$__.skipId = skipId;
    }
    if (obj != null && typeof obj !== "object") {
      throw new ObjectParameterError(obj, "obj", "Document");
    }
    let defaults = true;
    if (options.defaults !== undefined) {
      this.$__.defaults = options.defaults;
      defaults = options.defaults;
    }
    const schema = this.$__schema;
    if (typeof fields === "boolean" || fields === "throw") {
      if (fields !== true) {
        this.$__.strictMode = fields;
      }
      fields = undefined;
    } else if (schema.options.strict !== true) {
      this.$__.strictMode = schema.options.strict;
    }
    const requiredPaths = schema.requiredPaths(true);
    for (const path of requiredPaths) {
      this.$__.activePaths.require(path);
    }
    let exclude = null;
    if (utils.isPOJO(fields) && Object.keys(fields).length > 0) {
      exclude = isExclusive(fields);
      this.$__.selected = fields;
      this.$__.exclude = exclude;
    }
    const hasIncludedChildren = exclude === false && fields ? $__hasIncludedChildren(fields) : null;
    if (this._doc == null) {
      this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);
      if (defaults) {
        applyDefaults(this, fields, exclude, hasIncludedChildren, true, null, {
          skipParentChangeTracking: true
        });
      }
    }
    if (obj) {
      if (this.$__original_set) {
        this.$__original_set(obj, undefined, true, options);
      } else {
        this.$set(obj, undefined, true, options);
      }
      if (obj instanceof Document) {
        this.$isNew = obj.$isNew;
      }
    }
    if (options.willInit && defaults) {
      if (options.skipDefaults) {
        this.$__.skipDefaults = options.skipDefaults;
      }
    } else if (defaults) {
      applyDefaults(this, fields, exclude, hasIncludedChildren, false, options.skipDefaults);
    }
    if (!this.$__.strictMode && obj) {
      const _this = this;
      const keys = Object.keys(this._doc);
      keys.forEach(function(key) {
        if (!(key in schema.tree) && !(key in schema.methods) && !(key in schema.virtuals) && !key.startsWith("$")) {
          defineKey({ prop: key, subprops: null, prototype: _this });
        }
      });
    }
    applyQueue(this);
  }
  function $applyDefaultsToNested(val, path, doc) {
    if (val == null) {
      return;
    }
    const paths = Object.keys(doc.$__schema.paths);
    const plen = paths.length;
    const pathPieces = path.indexOf(".") === -1 ? [path] : path.split(".");
    for (let i = 0;i < plen; ++i) {
      let curPath = "";
      const p = paths[i];
      if (!p.startsWith(path + ".")) {
        continue;
      }
      const type = doc.$__schema.paths[p];
      const pieces = type.splitPath().slice(pathPieces.length);
      const len = pieces.length;
      if (type.defaultValue === undefined) {
        continue;
      }
      let cur = val;
      for (let j = 0;j < len; ++j) {
        if (cur == null) {
          break;
        }
        const piece = pieces[j];
        if (j === len - 1) {
          if (cur[piece] !== undefined) {
            break;
          }
          try {
            const def = type.getDefault(doc, false);
            if (def !== undefined) {
              cur[piece] = def;
            }
          } catch (err) {
            doc.invalidate(path + "." + curPath, err);
            break;
          }
          break;
        }
        curPath += (!curPath.length ? "" : ".") + piece;
        cur[piece] = cur[piece] || {};
        cur = cur[piece];
      }
    }
  }
  function init(self2, obj, doc, opts, prefix) {
    prefix = prefix || "";
    if (obj.$__ != null) {
      obj = obj._doc;
    }
    const keys = Object.keys(obj);
    const len = keys.length;
    let schemaType;
    let path;
    let i;
    const strict = self2.$__.strictMode;
    const docSchema = self2.$__schema;
    for (let index = 0;index < len; ++index) {
      i = keys[index];
      if (i === "__proto__" || i === "constructor") {
        return;
      }
      path = prefix ? prefix + i : i;
      schemaType = docSchema.path(path);
      if (docSchema.$isRootDiscriminator && !self2.$__isSelected(path)) {
        return;
      }
      const value = obj[i];
      if (!schemaType && utils.isPOJO(value)) {
        if (!doc[i]) {
          doc[i] = {};
          if (!strict && !(i in docSchema.tree) && !(i in docSchema.methods) && !(i in docSchema.virtuals)) {
            self2[i] = doc[i];
          }
        }
        init(self2, value, doc[i], opts, path + ".");
      } else if (!schemaType) {
        doc[i] = value;
        if (!strict && !prefix) {
          self2[i] = value;
        }
      } else {
        if (doc.hasOwnProperty(i) && value !== undefined && !opts.hydratedPopulatedDocs) {
          delete doc[i];
        }
        if (value === null) {
          doc[i] = schemaType._castNullish(null);
        } else if (value !== undefined) {
          const wasPopulated = value.$__ == null ? null : value.$__.wasPopulated;
          if (schemaType && !wasPopulated && !opts.hydratedPopulatedDocs) {
            try {
              if (opts && opts.setters) {
                const overrideInit = false;
                doc[i] = schemaType.applySetters(value, self2, overrideInit);
              } else {
                doc[i] = schemaType.cast(value, self2, true);
              }
            } catch (e) {
              self2.invalidate(e.path, new ValidatorError({
                path: e.path,
                message: e.message,
                type: "cast",
                value: e.value,
                reason: e
              }));
            }
          } else if (schemaType && opts.hydratedPopulatedDocs) {
            doc[i] = schemaType.cast(value, self2, true, undefined, { hydratedPopulatedDocs: true });
            if (doc[i] && doc[i].$__ && doc[i].$__.wasPopulated) {
              self2.$populated(path, doc[i].$__.wasPopulated.value, doc[i].$__.wasPopulated.options);
            } else if (Array.isArray(doc[i]) && doc[i].length && doc[i][0]?.$__?.wasPopulated) {
              self2.$populated(path, doc[i].map((populatedDoc) => populatedDoc?.$__?.wasPopulated?.value).filter((val) => val != null), doc[i][0].$__.wasPopulated.options);
            }
          } else {
            doc[i] = value;
          }
        }
        if (!self2.$isModified(path)) {
          self2.$__.activePaths.init(path);
        }
      }
    }
  }
  function _isManuallyPopulatedArray(val, ref) {
    if (!Array.isArray(val)) {
      return false;
    }
    if (val.length === 0) {
      return false;
    }
    for (const el of val) {
      if (!(el instanceof Document)) {
        return false;
      }
      const modelName = el.constructor.modelName;
      if (modelName == null) {
        return false;
      }
      if (el.constructor.modelName != ref && el.constructor.baseModelName != ref) {
        return false;
      }
    }
    return true;
  }
  function _isEmpty(v) {
    if (v == null) {
      return true;
    }
    if (typeof v !== "object" || Array.isArray(v)) {
      return false;
    }
    for (const key of Object.keys(v)) {
      if (!_isEmpty(v[key])) {
        return false;
      }
    }
    return true;
  }
  function _evaluateRequiredFunctions(doc) {
    const requiredFields = Object.keys(doc.$__.activePaths.getStatePaths("require"));
    let i = 0;
    const len = requiredFields.length;
    for (i = 0;i < len; ++i) {
      const path = requiredFields[i];
      const p = doc.$__schema.path(path);
      if (p != null && typeof p.originalRequiredValue === "function") {
        doc.$__.cachedRequired = doc.$__.cachedRequired || {};
        try {
          doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc, doc);
        } catch (err) {
          doc.invalidate(path, err);
        }
      }
    }
  }
  function _getPathsToValidate(doc, pathsToValidate, pathsToSkip, isNestedValidate) {
    const doValidateOptions = {};
    _evaluateRequiredFunctions(doc);
    let paths = new Set(Object.keys(doc.$__.activePaths.getStatePaths("require")).filter(function(path) {
      if (!doc.$__isSelected(path) && !doc.$isModified(path)) {
        return false;
      }
      if (doc.$__.cachedRequired != null && path in doc.$__.cachedRequired) {
        return doc.$__.cachedRequired[path];
      }
      return true;
    }));
    Object.keys(doc.$__.activePaths.getStatePaths("init")).forEach(addToPaths);
    Object.keys(doc.$__.activePaths.getStatePaths("modify")).forEach(addToPaths);
    Object.keys(doc.$__.activePaths.getStatePaths("default")).forEach(addToPaths);
    function addToPaths(p) {
      paths.add(p);
    }
    if (!isNestedValidate) {
      const subdocs = doc.$getAllSubdocs({ useCache: true });
      const modifiedPaths = doc.modifiedPaths();
      for (const subdoc of subdocs) {
        if (subdoc.$basePath) {
          const fullPathToSubdoc = subdoc.$isSingleNested ? subdoc.$__pathRelativeToParent() : subdoc.$__fullPathWithIndexes();
          for (const modifiedPath of subdoc.modifiedPaths()) {
            paths.delete(fullPathToSubdoc + "." + modifiedPath);
          }
          if (doc.$isModified(fullPathToSubdoc, null, modifiedPaths) && !doc.$__.activePaths.getStatePaths("modify").hasOwnProperty(fullPathToSubdoc) && !doc.$isDefault(fullPathToSubdoc)) {
            paths.add(fullPathToSubdoc);
            if (doc.$__.pathsToScopes == null) {
              doc.$__.pathsToScopes = {};
            }
            doc.$__.pathsToScopes[fullPathToSubdoc] = subdoc.$isDocumentArrayElement ? subdoc.__parentArray : subdoc.$parent();
            doValidateOptions[fullPathToSubdoc] = { skipSchemaValidators: true };
            if (subdoc.$isDocumentArrayElement && subdoc.__index != null) {
              doValidateOptions[fullPathToSubdoc].index = subdoc.__index;
            }
          }
        }
      }
    }
    for (const path of paths) {
      const _pathType = doc.$__schema.path(path);
      if (!_pathType) {
        continue;
      }
      if (_pathType.$isMongooseDocumentArray) {
        for (const p of paths) {
          if (p == null || p.startsWith(_pathType.path + ".")) {
            paths.delete(p);
          }
        }
      }
      if (!_pathType.caster && _pathType.validators.length === 0 && !_pathType.$parentSchemaDocArray) {
        paths.delete(path);
      } else if (_pathType.$isMongooseArray && !_pathType.$isMongooseDocumentArray && !_pathType.$embeddedSchemaType.$isMongooseArray && _pathType.validators.length === 0 && _pathType.$embeddedSchemaType.validators.length === 0) {
        paths.delete(path);
      }
    }
    if (Array.isArray(pathsToValidate)) {
      paths = _handlePathsToValidate(paths, pathsToValidate);
    } else if (Array.isArray(pathsToSkip)) {
      paths = _handlePathsToSkip(paths, pathsToSkip);
    }
    _addArrayPathsToValidate(doc, paths);
    const flattenOptions = { skipArrays: true };
    for (const pathToCheck of paths) {
      if (doc.$__schema.nested[pathToCheck]) {
        let _v = doc.$__getValue(pathToCheck);
        if (isMongooseObject(_v)) {
          _v = _v.toObject({ transform: false });
        }
        const flat = flatten(_v, pathToCheck, flattenOptions, doc.$__schema);
        Object.keys(flat).filter((path) => !doc.$__schema.singleNestedPaths.hasOwnProperty(path)).forEach(addToPaths);
      }
    }
    for (const path of paths) {
      const _pathType = doc.$__schema.path(path);
      if (!_pathType) {
        continue;
      }
      if (_pathType.$parentSchemaDocArray && typeof _pathType.$parentSchemaDocArray.path === "string") {
        paths.add(_pathType.$parentSchemaDocArray.path);
      }
      if (!_pathType.$isSchemaMap) {
        continue;
      }
      const val = doc.$__getValue(path);
      if (val == null) {
        continue;
      }
      for (const key of val.keys()) {
        paths.add(path + "." + key);
      }
    }
    paths = Array.from(paths);
    return [paths, doValidateOptions];
  }
  function _addArrayPathsToValidate(doc, paths) {
    for (const path of paths) {
      const _pathType = doc.$__schema.path(path);
      if (!_pathType) {
        continue;
      }
      if (!_pathType.$isMongooseArray || !Array.isArray(_pathType) && _pathType.$isMongooseDocumentArray && !(_pathType && _pathType.schemaOptions && _pathType.schemaOptions.required)) {
        continue;
      }
      if (_pathType.$isMongooseArray && !_pathType.$isMongooseDocumentArray && !_pathType.$embeddedSchemaType.$isMongooseArray && _pathType.$embeddedSchemaType.validators.length === 0) {
        continue;
      }
      const val = doc.$__getValue(path);
      _pushNestedArrayPaths(val, paths, path);
    }
  }
  function _pushNestedArrayPaths(val, paths, path) {
    if (val != null) {
      const numElements = val.length;
      for (let j = 0;j < numElements; ++j) {
        if (Array.isArray(val[j])) {
          _pushNestedArrayPaths(val[j], paths, path + "." + j);
        } else {
          paths.add(path + "." + j);
        }
      }
    }
  }
  function _handlePathsToValidate(paths, pathsToValidate) {
    const _pathsToValidate = new Set(pathsToValidate);
    const parentPaths2 = new Map([]);
    for (const path of pathsToValidate) {
      if (path.indexOf(".") === -1) {
        continue;
      }
      const pieces = path.split(".");
      let cur = pieces[0];
      for (let i = 1;i < pieces.length; ++i) {
        parentPaths2.set(cur, path);
        cur = cur + "." + pieces[i];
      }
    }
    const ret = new Set;
    for (const path of paths) {
      if (_pathsToValidate.has(path)) {
        ret.add(path);
      } else if (parentPaths2.has(path)) {
        ret.add(parentPaths2.get(path));
      }
    }
    return ret;
  }
  function _handlePathsToSkip(paths, pathsToSkip) {
    pathsToSkip = new Set(pathsToSkip);
    paths = Array.from(paths).filter((p) => !pathsToSkip.has(p));
    return new Set(paths);
  }
  function _markValidSubpaths(doc, path) {
    if (!doc.$__.validationError) {
      return;
    }
    const keys = Object.keys(doc.$__.validationError.errors);
    for (const key of keys) {
      if (key.startsWith(path + ".")) {
        delete doc.$__.validationError.errors[key];
      }
    }
    if (Object.keys(doc.$__.validationError.errors).length === 0) {
      doc.$__.validationError = null;
    }
  }
  function _checkImmutableSubpaths(subdoc, schematype, priorVal) {
    const schema = schematype.schema;
    if (schema == null) {
      return;
    }
    for (const key of Object.keys(schema.paths)) {
      const path = schema.paths[key];
      if (path.$immutableSetter == null) {
        continue;
      }
      const oldVal = priorVal == null ? undefined : priorVal.$__getValue(key);
      path.$immutableSetter.call(subdoc, oldVal);
    }
  }
  function applyQueue(doc) {
    const q = doc.$__schema && doc.$__schema.callQueue;
    if (!q.length) {
      return;
    }
    for (const pair of q) {
      if (pair[0] !== "pre" && pair[0] !== "post" && pair[0] !== "on") {
        doc[pair[0]].apply(doc, pair[1]);
      }
    }
  }
  function applyVirtuals(self2, json, options, toObjectOptions) {
    const schema = self2.$__schema;
    const virtuals = schema.virtuals;
    const paths = Object.keys(virtuals);
    let i = paths.length;
    const numPaths = i;
    let path;
    let assignPath;
    let cur = self2._doc;
    let v;
    const aliases = typeof (toObjectOptions && toObjectOptions.aliases) === "boolean" ? toObjectOptions.aliases : true;
    options = options || {};
    let virtualsToApply = null;
    if (Array.isArray(options.virtuals)) {
      virtualsToApply = new Set(options.virtuals);
    } else if (options.virtuals && options.virtuals.pathsToSkip) {
      virtualsToApply = new Set(paths);
      for (let i2 = 0;i2 < options.virtuals.pathsToSkip.length; i2++) {
        if (virtualsToApply.has(options.virtuals.pathsToSkip[i2])) {
          virtualsToApply.delete(options.virtuals.pathsToSkip[i2]);
        }
      }
    }
    if (!cur) {
      return json;
    }
    for (i = 0;i < numPaths; ++i) {
      path = paths[i];
      if (virtualsToApply != null && !virtualsToApply.has(path)) {
        continue;
      }
      if (!aliases && schema.aliases.hasOwnProperty(path)) {
        continue;
      }
      assignPath = path;
      if (options.path != null) {
        if (!path.startsWith(options.path + ".")) {
          continue;
        }
        assignPath = path.substring(options.path.length + 1);
      }
      if (assignPath.indexOf(".") === -1 && assignPath === path) {
        v = virtuals[path].applyGetters(undefined, self2);
        if (v === undefined) {
          continue;
        }
        v = clone(v, options);
        json[assignPath] = v;
        continue;
      }
      const parts = assignPath.split(".");
      v = clone(self2.get(path), options);
      if (v === undefined) {
        continue;
      }
      const plen = parts.length;
      cur = json;
      for (let j = 0;j < plen - 1; ++j) {
        cur[parts[j]] = cur[parts[j]] || {};
        cur = cur[parts[j]];
      }
      cur[parts[plen - 1]] = v;
    }
    return json;
  }
  function applyGetters(self2, json) {
    const schema = self2.$__schema;
    const paths = Object.keys(schema.paths);
    let i = paths.length;
    let path;
    let cur = self2._doc;
    let v;
    if (!cur) {
      return json;
    }
    while (i--) {
      path = paths[i];
      const parts = path.split(".");
      const plen = parts.length;
      const last = plen - 1;
      let branch = json;
      let part;
      cur = self2._doc;
      if (!self2.$__isSelected(path)) {
        continue;
      }
      for (let ii = 0;ii < plen; ++ii) {
        part = parts[ii];
        v = cur[part];
        if (branch != null && typeof branch !== "object") {
          break;
        } else if (ii === last) {
          branch[part] = schema.paths[path].applyGetters(branch[part], self2);
          if (Array.isArray(branch[part]) && schema.paths[path].$embeddedSchemaType) {
            for (let i2 = 0;i2 < branch[part].length; ++i2) {
              branch[part][i2] = schema.paths[path].$embeddedSchemaType.applyGetters(branch[part][i2], self2);
            }
          }
        } else if (v == null) {
          if (part in cur) {
            branch[part] = v;
          }
          break;
        } else {
          branch = branch[part] || (branch[part] = {});
        }
        cur = v;
      }
    }
    return json;
  }
  function applySchemaTypeTransforms(self2, json) {
    const schema = self2.$__schema;
    const paths = Object.keys(schema.paths || {});
    const cur = self2._doc;
    if (!cur) {
      return json;
    }
    for (const path of paths) {
      const schematype = schema.paths[path];
      const topLevelTransformFunction = schematype.options.transform ?? schematype.constructor?.defaultOptions?.transform;
      const embeddedSchemaTypeTransformFunction = schematype.$embeddedSchemaType?.options?.transform ?? schematype.$embeddedSchemaType?.constructor?.defaultOptions?.transform;
      if (typeof topLevelTransformFunction === "function") {
        const val = self2.$get(path);
        if (val === undefined) {
          continue;
        }
        const transformedValue = topLevelTransformFunction.call(self2, val);
        throwErrorIfPromise(path, transformedValue);
        utils.setValue(path, transformedValue, json);
      } else if (typeof embeddedSchemaTypeTransformFunction === "function") {
        const val = self2.$get(path);
        if (val === undefined) {
          continue;
        }
        const vals = [].concat(val);
        for (let i = 0;i < vals.length; ++i) {
          const transformedValue = embeddedSchemaTypeTransformFunction.call(self2, vals[i]);
          vals[i] = transformedValue;
          throwErrorIfPromise(path, transformedValue);
        }
        json[path] = vals;
      }
    }
    return json;
  }
  function throwErrorIfPromise(path, transformedValue) {
    if (isPromise(transformedValue)) {
      throw new Error("`transform` function must be synchronous, but the transform on path `" + path + "` returned a promise.");
    }
  }
  function omitDeselectedFields(self2, json) {
    const schema = self2.$__schema;
    const paths = Object.keys(schema.paths || {});
    const cur = self2._doc;
    if (!cur) {
      return json;
    }
    let selected = self2.$__.selected;
    if (selected === undefined) {
      selected = {};
      queryhelpers.applyPaths(selected, schema);
    }
    if (selected == null || Object.keys(selected).length === 0) {
      return json;
    }
    for (const path of paths) {
      if (selected[path] != null && !selected[path]) {
        delete json[path];
      }
    }
    return json;
  }
  function checkDivergentArray(doc, path, array) {
    const pop = doc.$populated(path, true);
    if (!pop && doc.$__.selected) {
      const top = path.split(".")[0];
      if (doc.$__.selected[top + ".$"]) {
        return top;
      }
    }
    if (!(pop && utils.isMongooseArray(array)))
      return;
    const check = pop.options.match || pop.options.options && utils.object.hasOwnProperty(pop.options.options, "limit") || pop.options.options && pop.options.options.skip || pop.options.select && (pop.options.select._id === 0 || /\s?-_id\s?/.test(pop.options.select));
    if (check) {
      const atomics = array[arrayAtomicsSymbol];
      if (Object.keys(atomics).length === 0 || atomics.$set || atomics.$pop) {
        return path;
      }
    }
  }
  function operand(self2, where, delta, data, val, op) {
    op || (op = "$set");
    if (!delta[op])
      delta[op] = {};
    delta[op][data.path] = val;
    if (self2.$__schema.options.versionKey === false)
      return;
    if (shouldSkipVersioning(self2, data.path))
      return;
    if (VERSION_ALL === (VERSION_ALL & self2.$__.version))
      return;
    if (self2.$__schema.options.optimisticConcurrency) {
      return;
    }
    switch (op) {
      case "$set":
      case "$unset":
      case "$pop":
      case "$pull":
      case "$pullAll":
      case "$push":
      case "$addToSet":
      case "$inc":
        break;
      default:
        return;
    }
    if (op === "$push" || op === "$addToSet" || op === "$pullAll" || op === "$pull") {
      if (/\.\d+\.|\.\d+$/.test(data.path)) {
        self2.$__.version = VERSION_ALL;
      } else {
        self2.$__.version = VERSION_INC;
      }
    } else if (/^\$p/.test(op)) {
      self2.$__.version = VERSION_ALL;
    } else if (Array.isArray(val)) {
      self2.$__.version = VERSION_ALL;
    } else if (/\.\d+\.|\.\d+$/.test(data.path)) {
      self2.$__.version = VERSION_WHERE;
    }
  }
  function handleAtomics(self2, where, delta, data, value) {
    if (delta.$set && delta.$set[data.path]) {
      return;
    }
    if (typeof value.$__getAtomics === "function") {
      value.$__getAtomics().forEach(function(atomic) {
        const op2 = atomic[0];
        const val2 = atomic[1];
        operand(self2, where, delta, data, val2, op2);
      });
      return;
    }
    const atomics = value[arrayAtomicsSymbol];
    const ops = Object.keys(atomics);
    let i = ops.length;
    let val;
    let op;
    if (i === 0) {
      if (utils.isMongooseObject(value)) {
        value = value.toObject({ depopulate: 1, _isNested: true });
      } else if (value.valueOf) {
        value = value.valueOf();
      }
      return operand(self2, where, delta, data, value);
    }
    function iter(mem) {
      return utils.isMongooseObject(mem) ? mem.toObject({ depopulate: 1, _isNested: true }) : mem;
    }
    while (i--) {
      op = ops[i];
      val = atomics[op];
      if (utils.isMongooseObject(val)) {
        val = val.toObject({ depopulate: true, transform: false, _isNested: true });
      } else if (Array.isArray(val)) {
        val = val.map(iter);
      } else if (val.valueOf) {
        val = val.valueOf();
      }
      if (op === "$addToSet") {
        val = { $each: val };
      }
      operand(self2, where, delta, data, val, op);
    }
  }
  function shouldSkipVersioning(self2, path) {
    const skipVersioning = self2.$__schema.options.skipVersioning;
    if (!skipVersioning)
      return false;
    path = path.replace(/\.\d+\./, ".");
    return skipVersioning[path];
  }
  /*!
   * Module dependencies.
   */
  var DivergentArrayError = require_divergentArray();
  var EventEmitter = import.meta.require("events").EventEmitter;
  var InternalCache = require_internal();
  var MongooseBuffer = require_buffer();
  var MongooseError = require_error2();
  var MixedSchema = require_mixed();
  var ModifiedPathsSnapshot = require_modifiedPathsSnapshot();
  var ObjectExpectedError = require_objectExpected();
  var ObjectParameterError = require_objectParameter();
  var ParallelValidateError = require_parallelValidate();
  var Schema = require_schema2();
  var StrictModeError = require_strict();
  var ValidationError = require_validation();
  var ValidatorError = require_validator();
  var $__hasIncludedChildren = require_hasIncludedChildren();
  var applyDefaults = require_applyDefaults();
  var cleanModifiedSubpaths = require_cleanModifiedSubpaths();
  var clone = require_clone2();
  var compile = require_compile().compile;
  var defineKey = require_compile().defineKey;
  var firstKey = require_firstKey();
  var flatten = require_common3().flatten;
  var getEmbeddedDiscriminatorPath = require_getEmbeddedDiscriminatorPath();
  var getKeysInSchemaOrder = require_getKeysInSchemaOrder();
  var getSubdocumentStrictValue = require_getSubdocumentStrictValue();
  var handleSpreadDoc = require_handleSpreadDoc();
  var immediate = require_immediate();
  var isBsonType = require_isBsonType();
  var isDefiningProjection = require_isDefiningProjection();
  var isExclusive = require_isExclusive();
  var isPathExcluded = require_isPathExcluded();
  var inspect = import.meta.require("util").inspect;
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var markArraySubdocsPopulated = require_markArraySubdocsPopulated();
  var minimize = require_minimize();
  var mpath = require_mpath();
  var parentPaths = require_parentPaths();
  var queryhelpers = require_queryHelpers();
  var utils = require_utils4();
  var isPromise = require_isPromise();
  var deepEqual = utils.deepEqual;
  var isMongooseObject = utils.isMongooseObject;
  var arrayAtomicsBackupSymbol = require_symbols().arrayAtomicsBackupSymbol;
  var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
  var documentArrayParent = require_symbols().documentArrayParent;
  var documentIsModified = require_symbols().documentIsModified;
  var documentModifiedPaths = require_symbols().documentModifiedPaths;
  var documentSchemaSymbol = require_symbols().documentSchemaSymbol;
  var getSymbol = require_symbols().getSymbol;
  var modelSymbol = require_symbols().modelSymbol;
  var populateModelSymbol = require_symbols().populateModelSymbol;
  var scopeSymbol = require_symbols().scopeSymbol;
  var schemaMixedSymbol = require_symbols2().schemaMixedSymbol;
  var getDeepestSubdocumentForPath = require_getDeepestSubdocumentForPath();
  var sessionNewDocuments = require_symbols().sessionNewDocuments;
  var DocumentArray;
  var MongooseArray;
  var Embedded;
  var specialProperties = utils.specialProperties;
  var VERSION_WHERE = 1;
  var VERSION_INC = 2;
  var VERSION_ALL = VERSION_WHERE | VERSION_INC;
  Document.prototype.$isMongooseDocumentPrototype = true;
  Object.defineProperty(Document.prototype, "isNew", {
    get: function() {
      return this.$isNew;
    },
    set: function(value) {
      this.$isNew = value;
    }
  });
  Object.defineProperty(Document.prototype, "errors", {
    get: function() {
      return this.$errors;
    },
    set: function(value) {
      this.$errors = value;
    }
  });
  /*!
   * ignore
   */
  Document.prototype.$isNew = true;
  /*!
   * Document exposes the NodeJS event emitter API, so you can use
   * `on`, `once`, etc.
   */
  utils.each([
    "on",
    "once",
    "emit",
    "listeners",
    "removeListener",
    "setMaxListeners",
    "removeAllListeners",
    "addListener"
  ], function(emitterFn) {
    Document.prototype[emitterFn] = function() {
      if (!this.$__.emitter) {
        if (emitterFn === "emit") {
          return;
        }
        this.$__.emitter = new EventEmitter;
        this.$__.emitter.setMaxListeners(0);
      }
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    };
    Document.prototype[`\$${emitterFn}`] = Document.prototype[emitterFn];
  });
  Document.prototype.constructor = Document;
  for (const i in EventEmitter.prototype) {
    Document[i] = EventEmitter.prototype[i];
  }
  Document.prototype.$__schema;
  Document.prototype.schema;
  Object.defineProperty(Document.prototype, "$locals", {
    configurable: false,
    enumerable: false,
    get: function() {
      if (this.$__.locals == null) {
        this.$__.locals = {};
      }
      return this.$__.locals;
    },
    set: function(v) {
      this.$__.locals = v;
    }
  });
  Document.prototype.isNew;
  Object.defineProperty(Document.prototype, "$where", {
    configurable: false,
    enumerable: false,
    writable: true
  });
  Document.prototype.id;
  Document.prototype.$errors;
  Object.defineProperty(Document.prototype, "$op", {
    get: function() {
      return this.$__.op || null;
    },
    set: function(value) {
      this.$__.op = value;
    }
  });
  /*!
   * ignore
   */
  Document.prototype.$__buildDoc = function(obj, fields, skipId, exclude, hasIncludedChildren) {
    const doc = {};
    const paths = Object.keys(this.$__schema.paths).filter((p) => !p.includes("$*"));
    const plen = paths.length;
    let ii = 0;
    for (;ii < plen; ++ii) {
      const p = paths[ii];
      if (p === "_id") {
        if (skipId) {
          continue;
        }
        if (obj && "_id" in obj) {
          continue;
        }
      }
      const path = this.$__schema.paths[p].splitPath();
      const len = path.length;
      const last = len - 1;
      let curPath = "";
      let doc_ = doc;
      let included = false;
      for (let i = 0;i < len; ++i) {
        const piece = path[i];
        if (!curPath.length) {
          curPath = piece;
        } else {
          curPath += "." + piece;
        }
        if (exclude === true) {
          if (curPath in fields) {
            break;
          }
        } else if (exclude === false && fields && !included) {
          if (curPath in fields) {
            included = true;
          } else if (!hasIncludedChildren[curPath]) {
            break;
          }
        }
        if (i < last) {
          doc_ = doc_[piece] || (doc_[piece] = {});
        }
      }
    }
    this._doc = doc;
  };
  /*!
   * Converts to POJO when you use the document for querying
   */
  Document.prototype.toBSON = function() {
    return this.toObject(internalToObjectOptions);
  };
  Document.prototype.init = function(doc, opts, fn) {
    if (typeof opts === "function") {
      fn = opts;
      opts = null;
    }
    this.$__init(doc, opts);
    if (fn) {
      fn(null, this);
    }
    return this;
  };
  Document.prototype.$init = function() {
    return this.constructor.prototype.init.apply(this, arguments);
  };
  Document.prototype.$__init = function(doc, opts) {
    this.$isNew = false;
    opts = opts || {};
    if (doc._id != null && opts.populated && opts.populated.length) {
      const id = String(doc._id);
      for (const item of opts.populated) {
        if (item.isVirtual) {
          this.$populated(item.path, utils.getValue(item.path, doc), item);
        } else {
          this.$populated(item.path, item._docs[id], item);
        }
        if (item._childDocs == null) {
          continue;
        }
        for (const child of item._childDocs) {
          if (child == null || child.$__ == null) {
            continue;
          }
          child.$__.parent = this;
        }
        item._childDocs = [];
      }
    }
    init(this, doc, this._doc, opts);
    markArraySubdocsPopulated(this, opts.populated);
    this.$emit("init", this);
    this.constructor.emit("init", this);
    const hasIncludedChildren = this.$__.exclude === false && this.$__.selected ? $__hasIncludedChildren(this.$__.selected) : null;
    applyDefaults(this, this.$__.selected, this.$__.exclude, hasIncludedChildren, false, this.$__.skipDefaults);
    return this;
  };
  Document.prototype.updateOne = function updateOne(doc, options, callback) {
    const query = this.constructor.updateOne({ _id: this._doc._id }, doc, options);
    const self2 = this;
    query.pre(function queryPreUpdateOne(cb) {
      self2.constructor._middleware.execPre("updateOne", self2, [self2], cb);
    });
    query.post(function queryPostUpdateOne(cb) {
      self2.constructor._middleware.execPost("updateOne", self2, [self2], {}, cb);
    });
    if (this.$session() != null) {
      if (!("session" in query.options)) {
        query.options.session = this.$session();
      }
    }
    if (callback != null) {
      return query.exec(callback);
    }
    return query;
  };
  Document.prototype.replaceOne = function replaceOne() {
    const args = [...arguments];
    args.unshift({ _id: this._doc._id });
    return this.constructor.replaceOne.apply(this.constructor, args);
  };
  Document.prototype.$session = function $session(session) {
    if (arguments.length === 0) {
      if (this.$__.session != null && this.$__.session.hasEnded) {
        this.$__.session = null;
        return null;
      }
      return this.$__.session;
    }
    if (session != null && session.hasEnded) {
      throw new MongooseError("Cannot set a document\'s session to a session that has ended. Make sure you haven\'t " + "called `endSession()` on the session you are passing to `$session()`.");
    }
    if (session == null && this.$__.session == null) {
      return;
    }
    this.$__.session = session;
    if (!this.$isSubdocument) {
      const subdocs = this.$getAllSubdocs();
      for (const child of subdocs) {
        child.$session(session);
      }
    }
    return session;
  };
  Document.prototype.$timestamps = function $timestamps(value) {
    if (arguments.length === 0) {
      if (this.$__.timestamps != null) {
        return this.$__.timestamps;
      }
      if (this.$__schema) {
        return this.$__schema.options.timestamps;
      }
      return;
    }
    const currentValue = this.$timestamps();
    if (value !== currentValue) {
      this.$__.timestamps = value;
    }
    return this;
  };
  Document.prototype.overwrite = function overwrite(obj) {
    const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));
    for (const key of keys) {
      if (key === "_id") {
        continue;
      }
      if (this.$__schema.options.versionKey && key === this.$__schema.options.versionKey) {
        continue;
      }
      if (this.$__schema.options.discriminatorKey && key === this.$__schema.options.discriminatorKey) {
        continue;
      }
      this.$set(key, obj[key]);
    }
    return this;
  };
  Document.prototype.$set = function $set(path, val, type, options) {
    if (utils.isPOJO(type)) {
      options = type;
      type = undefined;
    }
    const merge = options && options.merge;
    const adhoc = type && type !== true;
    const constructing = type === true;
    let adhocs;
    let keys;
    let i = 0;
    let pathtype;
    let key;
    let prefix;
    const userSpecifiedStrict = options && "strict" in options;
    let strict = userSpecifiedStrict ? options.strict : this.$__.strictMode;
    if (adhoc) {
      adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});
      adhocs[path] = this.$__schema.interpretAsType(path, type, this.$__schema.options);
    }
    if (path == null) {
      [path, val] = [val, path];
    } else if (typeof path !== "string") {
      if (path instanceof Document) {
        if (path.$__isNested) {
          path = path.toObject();
        } else {
          path = path.$__schema === this.$__schema ? applyVirtuals(path, { ...path._doc }) : path._doc;
        }
      }
      if (path == null) {
        [path, val] = [val, path];
      }
      prefix = val ? val + "." : "";
      keys = getKeysInSchemaOrder(this.$__schema, path);
      const len = keys.length;
      const _skipMinimizeTopLevel = options && options._skipMinimizeTopLevel || false;
      if (len === 0 && _skipMinimizeTopLevel) {
        delete options._skipMinimizeTopLevel;
        if (val) {
          this.$set(val, {});
        }
        return this;
      }
      options = Object.assign({}, options, { _skipMinimizeTopLevel: false });
      for (let i2 = 0;i2 < len; ++i2) {
        key = keys[i2];
        const pathName = prefix ? prefix + key : key;
        pathtype = this.$__schema.pathType(pathName);
        const valForKey = path[key];
        if (type === true && !prefix && valForKey != null && pathtype === "nested" && this._doc[key] != null) {
          delete this._doc[key];
        }
        if (utils.isNonBuiltinObject(valForKey) && pathtype === "nested") {
          this.$set(pathName, valForKey, constructing, Object.assign({}, options, { _skipMarkModified: true }));
          $applyDefaultsToNested(this.$get(pathName), pathName, this);
          continue;
        } else if (strict) {
          if (constructing && valForKey === undefined && this.$get(pathName) !== undefined) {
            continue;
          }
          if (pathtype === "adhocOrUndefined") {
            pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });
          }
          if (pathtype === "real" || pathtype === "virtual") {
            this.$set(pathName, valForKey, constructing, options);
          } else if (pathtype === "nested" && valForKey instanceof Document) {
            this.$set(pathName, valForKey.toObject({ transform: false }), constructing, options);
          } else if (strict === "throw") {
            if (pathtype === "nested") {
              throw new ObjectExpectedError(key, valForKey);
            } else {
              throw new StrictModeError(key);
            }
          } else if (pathtype === "nested" && valForKey == null) {
            this.$set(pathName, valForKey, constructing, options);
          }
        } else {
          this.$set(pathName, valForKey, constructing, options);
        }
      }
      const orderedDoc = {};
      const orderedKeys = Object.keys(this.$__schema.tree);
      for (let i2 = 0, len2 = orderedKeys.length;i2 < len2; ++i2) {
        (key = orderedKeys[i2]) && this._doc.hasOwnProperty(key) && (orderedDoc[key] = undefined);
      }
      this._doc = Object.assign(orderedDoc, this._doc);
      return this;
    }
    let pathType = this.$__schema.pathType(path);
    let parts = null;
    if (pathType === "adhocOrUndefined") {
      parts = path.indexOf(".") === -1 ? [path] : path.split(".");
      pathType = getEmbeddedDiscriminatorPath(this, parts, { typeOnly: true });
    }
    if (pathType === "adhocOrUndefined" && !userSpecifiedStrict) {
      if (parts == null) {
        parts = path.indexOf(".") === -1 ? [path] : path.split(".");
      }
      const subdocStrict = getSubdocumentStrictValue(this.$__schema, parts);
      if (subdocStrict !== undefined) {
        strict = subdocStrict;
      }
    }
    val = handleSpreadDoc(val, true);
    const priorVal = (() => {
      if (this.$__.priorDoc != null) {
        return this.$__.priorDoc.$__getValue(path);
      }
      if (constructing) {
        return;
      }
      return this.$__getValue(path);
    })();
    if (pathType === "nested" && val) {
      if (typeof val === "object" && val != null) {
        if (val.$__ != null) {
          val = val.toObject(internalToObjectOptions);
        }
        if (val == null) {
          this.invalidate(path, new MongooseError.CastError("Object", val, path));
          return this;
        }
        const wasModified = this.$isModified(path);
        const hasInitialVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);
        if (this.$__.savedState != null && !this.$isNew && !this.$__.savedState.hasOwnProperty(path)) {
          const initialVal = this.$__getValue(path);
          this.$__.savedState[path] = initialVal;
          const keys3 = Object.keys(initialVal || {});
          for (const key2 of keys3) {
            this.$__.savedState[path + "." + key2] = initialVal[key2];
          }
        }
        if (!merge) {
          this.$__setValue(path, null);
          cleanModifiedSubpaths(this, path);
        } else {
          return this.$set(val, path, constructing, options);
        }
        const keys2 = getKeysInSchemaOrder(this.$__schema, val, path);
        this.$__setValue(path, {});
        for (const key2 of keys2) {
          this.$set(path + "." + key2, val[key2], constructing, { ...options, _skipMarkModified: true });
        }
        if (priorVal != null && (!wasModified || hasInitialVal) && utils.deepEqual(hasInitialVal ? this.$__.savedState[path] : priorVal, val)) {
          this.unmarkModified(path);
        } else {
          this.markModified(path);
        }
        return this;
      }
      this.invalidate(path, new MongooseError.CastError("Object", val, path));
      return this;
    }
    let schema;
    if (parts == null) {
      parts = path.indexOf(".") === -1 ? [path] : path.split(".");
    }
    if (typeof this.$__schema.aliases[parts[0]] === "string") {
      parts[0] = this.$__schema.aliases[parts[0]];
    }
    if (pathType === "adhocOrUndefined" && strict) {
      let mixed;
      for (i = 0;i < parts.length; ++i) {
        const subpath = parts.slice(0, i + 1).join(".");
        if (i + 1 < parts.length && this.$__schema.pathType(subpath) === "virtual") {
          mpath.set(path, val, this);
          return this;
        }
        schema = this.$__schema.path(subpath);
        if (schema == null) {
          continue;
        }
        if (schema instanceof MixedSchema) {
          mixed = true;
          break;
        } else if (schema.$isSchemaMap && schema.$__schemaType instanceof MixedSchema && i < parts.length - 1) {
          mixed = true;
          schema = schema.$__schemaType;
          break;
        }
      }
      if (schema == null) {
        schema = getEmbeddedDiscriminatorPath(this, path);
      }
      if (!mixed && !schema) {
        if (strict === "throw") {
          throw new StrictModeError(path);
        }
        return this;
      }
    } else if (pathType === "virtual") {
      schema = this.$__schema.virtualpath(path);
      schema.applySetters(val, this);
      return this;
    } else {
      schema = this.$__path(path);
    }
    let cur = this._doc;
    let curPath = "";
    for (i = 0;i < parts.length - 1; ++i) {
      cur = cur[parts[i]];
      curPath += (curPath.length !== 0 ? "." : "") + parts[i];
      if (!cur) {
        this.$set(curPath, {});
        if (!this.$__isSelected(curPath)) {
          this.unmarkModified(curPath);
        }
        cur = this.$__getValue(curPath);
      }
    }
    let pathToMark;
    if (parts.length <= 1) {
      pathToMark = path;
    } else {
      const len = parts.length;
      for (i = 0;i < len; ++i) {
        const subpath = parts.slice(0, i + 1).join(".");
        if (this.$get(subpath, null, { getters: false }) === null) {
          pathToMark = subpath;
          break;
        }
      }
      if (!pathToMark) {
        pathToMark = path;
      }
    }
    if (!schema) {
      this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);
      if (pathType === "nested" && val == null) {
        cleanModifiedSubpaths(this, path);
      }
      return this;
    }
    if (schema.$isSingleNested || schema.$isMongooseArray) {
      _markValidSubpaths(this, path);
    }
    if (val != null && merge && schema.$isSingleNested) {
      if (val instanceof Document) {
        val = val.toObject({ virtuals: false, transform: false });
      }
      const keys2 = Object.keys(val);
      for (const key2 of keys2) {
        this.$set(path + "." + key2, val[key2], constructing, options);
      }
      return this;
    }
    let shouldSet = true;
    try {
      const refMatches = (() => {
        if (schema.options == null) {
          return false;
        }
        if (!(val instanceof Document)) {
          return false;
        }
        const model = val.constructor;
        const refOpt = typeof schema.options.ref === "function" && !schema.options.ref[modelSymbol] ? schema.options.ref.call(this, this) : schema.options.ref;
        const ref = refOpt?.modelName || refOpt;
        if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {
          return true;
        }
        const refPath = schema.options.refPath;
        if (refPath == null) {
          return false;
        }
        const modelName = val.get(refPath);
        return modelName === model.modelName || modelName === model.baseModelName;
      })();
      let didPopulate = false;
      if (refMatches && val instanceof Document && (!val.$__.wasPopulated || utils.deepEqual(val.$__.wasPopulated.value, val._doc._id))) {
        const unpopulatedValue = schema && schema.$isSingleNested ? schema.cast(val, this) : val._doc._id;
        this.$populated(path, unpopulatedValue, { [populateModelSymbol]: val.constructor });
        val.$__.wasPopulated = { value: unpopulatedValue };
        didPopulate = true;
      }
      let popOpts;
      const typeKey = this.$__schema.options.typeKey;
      if (schema.options && Array.isArray(schema.options[typeKey]) && schema.options[typeKey].length && schema.options[typeKey][0] && schema.options[typeKey][0].ref && _isManuallyPopulatedArray(val, schema.options[typeKey][0].ref)) {
        popOpts = { [populateModelSymbol]: val[0].constructor };
        this.$populated(path, val.map(function(v) {
          return v._doc._id;
        }), popOpts);
        for (const doc of val) {
          doc.$__.wasPopulated = { value: doc._doc._id };
        }
        didPopulate = true;
      }
      if (!refMatches || !schema.$isSingleNested || !val.$__) {
        let setterContext = this;
        if (this.$__schema.singleNestedPaths[path] != null && parts.length > 1) {
          setterContext = getDeepestSubdocumentForPath(this, parts, this.schema);
        }
        if (options != null && options.overwriteImmutable) {
          val = schema.applySetters(val, setterContext, false, priorVal, { overwriteImmutable: true });
        } else {
          val = schema.applySetters(val, setterContext, false, priorVal);
        }
      }
      if (Array.isArray(val) && !Array.isArray(schema) && schema.$isMongooseDocumentArray && val.length !== 0 && val[0] != null && val[0].$__ != null && val[0].$__.populated != null) {
        const populatedPaths = Object.keys(val[0].$__.populated);
        for (const populatedPath of populatedPaths) {
          this.$populated(path + "." + populatedPath, val.map((v) => v.$populated(populatedPath)), val[0].$__.populated[populatedPath].options);
        }
        didPopulate = true;
      }
      if (!didPopulate && this.$__.populated) {
        if (Array.isArray(val) && this.$__.populated[path]) {
          for (let i2 = 0;i2 < val.length; ++i2) {
            if (val[i2] instanceof Document) {
              val.set(i2, val[i2]._doc._id, true);
            }
          }
        }
        delete this.$__.populated[path];
      }
      if (val != null && schema.$isSingleNested) {
        _checkImmutableSubpaths(val, schema, priorVal);
      }
      this.$markValid(path);
    } catch (e) {
      if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {
        this.invalidate(path, e);
      } else if (e instanceof MongooseError.CastError) {
        this.invalidate(e.path, e);
        if (e.$originalErrorPath) {
          this.invalidate(path, new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));
        }
      } else {
        this.invalidate(path, new MongooseError.CastError(schema.instance, val, path, e));
      }
      shouldSet = false;
    }
    if (shouldSet) {
      let savedState = null;
      let savedStatePath = null;
      if (!constructing) {
        const doc = this.$isSubdocument ? this.ownerDocument() : this;
        savedState = doc.$__.savedState;
        savedStatePath = this.$isSubdocument ? this.$__.fullPath + "." + path : path;
        doc.$__saveInitialState(savedStatePath);
      }
      this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);
      const isInTransaction = !!this.$__.session?.transaction;
      const isModifiedWithinTransaction = this.$__.session && this.$__.session[sessionNewDocuments] && this.$__.session[sessionNewDocuments].has(this) && this.$__.session[sessionNewDocuments].get(this).modifiedPaths && !this.$__.session[sessionNewDocuments].get(this).modifiedPaths.has(savedStatePath);
      if (savedState != null && savedState.hasOwnProperty(savedStatePath) && (!isInTransaction || isModifiedWithinTransaction) && utils.deepEqual(val, savedState[savedStatePath])) {
        this.unmarkModified(path);
      }
    }
    if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {
      cleanModifiedSubpaths(this, path);
    }
    return this;
  };
  /*!
   * ignore
   */
  Document.prototype.set = Document.prototype.$set;
  Document.prototype.$__shouldModify = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {
    if (options && options._skipMarkModified) {
      return false;
    }
    if (this.$isNew) {
      return true;
    }
    if (path in this.$__.activePaths.getStatePaths("modify")) {
      return true;
    }
    if (val === undefined && !this.$__isSelected(path)) {
      return true;
    }
    if (val === undefined && path in this.$__.activePaths.getStatePaths("default")) {
      return false;
    }
    if (this.$populated(path) && val instanceof Document && deepEqual(val._doc._id, priorVal)) {
      return false;
    }
    if (!deepEqual(val, priorVal !== undefined ? priorVal : utils.getValue(path, this))) {
      return true;
    }
    if (!constructing && val !== null && val !== undefined && path in this.$__.activePaths.getStatePaths("default") && deepEqual(val, schema.getDefault(this, constructing))) {
      return true;
    }
    return false;
  };
  Document.prototype.$__set = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {
    Embedded = Embedded || require_arraySubdocument();
    const shouldModify = this.$__shouldModify(pathToMark, path, options, constructing, parts, schema, val, priorVal);
    if (shouldModify) {
      if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[path]) {
        delete this.$__.primitiveAtomics[path];
        if (Object.keys(this.$__.primitiveAtomics).length === 0) {
          delete this.$__.primitiveAtomics;
        }
      }
      this.markModified(pathToMark);
      MongooseArray || (MongooseArray = require_array());
      if (val && utils.isMongooseArray(val)) {
        val._registerAtomic("$set", val);
        if (utils.isMongooseDocumentArray(val)) {
          val.forEach(function(item) {
            item && item.__parentArray && (item.__parentArray = val);
          });
        }
      }
    } else if (Array.isArray(val) && Array.isArray(priorVal) && utils.isMongooseArray(val) && utils.isMongooseArray(priorVal)) {
      val[arrayAtomicsSymbol] = priorVal[arrayAtomicsSymbol];
      val[arrayAtomicsBackupSymbol] = priorVal[arrayAtomicsBackupSymbol];
      if (utils.isMongooseDocumentArray(val)) {
        val.forEach((doc) => {
          if (doc != null) {
            doc.$isNew = false;
          }
        });
      }
    }
    let obj = this._doc;
    let i = 0;
    const l = parts.length;
    let cur = "";
    for (;i < l; i++) {
      const next = i + 1;
      const last = next === l;
      cur += cur ? "." + parts[i] : parts[i];
      if (specialProperties.has(parts[i])) {
        return;
      }
      if (last) {
        if (obj instanceof Map) {
          obj.set(parts[i], val);
        } else if (obj.$isSingleNested) {
          if (!(parts[i] in obj)) {
            obj[parts[i]] = val;
            obj._doc[parts[i]] = val;
          } else {
            obj._doc[parts[i]] = val;
          }
          if (shouldModify) {
            obj.markModified(parts[i]);
          }
        } else {
          obj[parts[i]] = val;
        }
      } else {
        const isMap = obj instanceof Map;
        let value = isMap ? obj.get(parts[i]) : obj[parts[i]];
        if (utils.isPOJO(value)) {
          obj = value;
        } else if (value && value instanceof Embedded) {
          obj = value;
        } else if (value && !Array.isArray(value) && value.$isSingleNested) {
          obj = value;
        } else if (value && Array.isArray(value)) {
          obj = value;
        } else if (value == null) {
          value = {};
          if (isMap) {
            obj.set(parts[i], value);
          } else {
            obj[parts[i]] = value;
          }
          obj = value;
        } else {
          obj = value;
        }
      }
    }
  };
  Document.prototype.$__getValue = function(path) {
    if (typeof path !== "string" && !Array.isArray(path)) {
      throw new TypeError(`Invalid \`path\`. Must be either string or array. Got "${path}" (type ${typeof path})`);
    }
    return utils.getValue(path, this._doc);
  };
  Document.prototype.$inc = function $inc(path, val) {
    if (val == null) {
      val = 1;
    }
    if (Array.isArray(path)) {
      path.forEach((p) => this.$inc(p, val));
      return this;
    }
    const schemaType = this.$__path(path);
    if (schemaType == null) {
      if (this.$__.strictMode === "throw") {
        throw new StrictModeError(path);
      } else if (this.$__.strictMode === true) {
        return this;
      }
    } else if (schemaType.instance !== "Number") {
      this.invalidate(path, new MongooseError.CastError(schemaType.instance, val, path));
      return this;
    }
    const currentValue = this.$__getValue(path) || 0;
    let shouldSet = false;
    let valToSet = null;
    let valToInc = val;
    try {
      val = schemaType.cast(val);
      valToSet = schemaType.applySetters(currentValue + val, this);
      valToInc = valToSet - currentValue;
      shouldSet = true;
    } catch (err) {
      this.invalidate(path, new MongooseError.CastError("number", val, path, err));
    }
    if (shouldSet) {
      this.$__.primitiveAtomics = this.$__.primitiveAtomics || {};
      if (this.$__.primitiveAtomics[path] == null) {
        this.$__.primitiveAtomics[path] = { $inc: valToInc };
      } else {
        this.$__.primitiveAtomics[path].$inc += valToInc;
      }
      this.markModified(path);
      this.$__setValue(path, valToSet);
    }
    return this;
  };
  Document.prototype.$__setValue = function(path, val) {
    utils.setValue(path, val, this._doc);
    return this;
  };
  Document.prototype.get = function(path, type, options) {
    let adhoc;
    if (options == null) {
      options = {};
    }
    if (type) {
      adhoc = this.$__schema.interpretAsType(path, type, this.$__schema.options);
    }
    const noDottedPath = options.noDottedPath;
    let schema = noDottedPath ? this.$__schema.paths[path] : this.$__path(path);
    if (schema == null) {
      schema = this.$__schema.virtualpath(path);
      if (schema != null) {
        return schema.applyGetters(undefined, this);
      }
    }
    if (noDottedPath) {
      let obj2 = this._doc[path];
      if (adhoc) {
        obj2 = adhoc.cast(obj2);
      }
      if (schema != null && options.getters !== false) {
        return schema.applyGetters(obj2, this);
      }
      return obj2;
    }
    if (schema != null && schema.instance === "Mixed") {
      const virtual = this.$__schema.virtualpath(path);
      if (virtual != null) {
        schema = virtual;
      }
    }
    const hasDot = path.indexOf(".") !== -1;
    let obj = this._doc;
    const pieces = hasDot ? path.split(".") : [path];
    if (typeof this.$__schema.aliases[pieces[0]] === "string") {
      pieces[0] = this.$__schema.aliases[pieces[0]];
    }
    for (let i = 0, l = pieces.length;i < l; i++) {
      if (obj && obj._doc) {
        obj = obj._doc;
      }
      if (obj == null) {
        obj = undefined;
      } else if (obj instanceof Map) {
        obj = obj.get(pieces[i], { getters: false });
      } else if (i === l - 1) {
        obj = utils.getValue(pieces[i], obj);
      } else {
        obj = obj[pieces[i]];
      }
    }
    if (adhoc) {
      obj = adhoc.cast(obj);
    }
    if (schema != null && options.getters !== false) {
      obj = schema.applyGetters(obj, this);
    } else if (this.$__schema.nested[path] && options.virtuals) {
      return applyVirtuals(this, clone(obj) || {}, { path });
    }
    return obj;
  };
  /*!
   * ignore
   */
  Document.prototype[getSymbol] = Document.prototype.get;
  Document.prototype.$get = Document.prototype.get;
  Document.prototype.$__path = function(path) {
    const adhocs = this.$__.adhocPaths;
    const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;
    if (adhocType) {
      return adhocType;
    }
    return this.$__schema.path(path);
  };
  Document.prototype.markModified = function(path, scope) {
    this.$__saveInitialState(path);
    this.$__.activePaths.modify(path);
    if (scope != null && !this.$isSubdocument) {
      this.$__.pathsToScopes = this.$__pathsToScopes || {};
      this.$__.pathsToScopes[path] = scope;
    }
  };
  /*!
   * ignore
   */
  Document.prototype.$__saveInitialState = function $__saveInitialState(path) {
    const savedState = this.$__.savedState;
    const savedStatePath = path;
    if (savedState != null) {
      const firstDot = savedStatePath.indexOf(".");
      const topLevelPath = firstDot === -1 ? savedStatePath : savedStatePath.slice(0, firstDot);
      if (!savedState.hasOwnProperty(topLevelPath)) {
        savedState[topLevelPath] = clone(this.$__getValue(topLevelPath));
      }
    }
  };
  Document.prototype.unmarkModified = function(path) {
    this.$__.activePaths.init(path);
    if (this.$__.pathsToScopes != null) {
      delete this.$__.pathsToScopes[path];
    }
  };
  Document.prototype.$ignore = function(path) {
    this.$__.activePaths.ignore(path);
  };
  Document.prototype.directModifiedPaths = function() {
    return Object.keys(this.$__.activePaths.getStatePaths("modify"));
  };
  Document.prototype.$isEmpty = function(path) {
    const isEmptyOptions = {
      minimize: true,
      virtuals: false,
      getters: false,
      transform: false
    };
    if (arguments.length !== 0) {
      const v = this.$get(path);
      if (v == null) {
        return true;
      }
      if (typeof v !== "object") {
        return false;
      }
      if (utils.isPOJO(v)) {
        return _isEmpty(v);
      }
      return Object.keys(v.toObject(isEmptyOptions)).length === 0;
    }
    return Object.keys(this.toObject(isEmptyOptions)).length === 0;
  };
  /*!
   * ignore
   */
  Document.prototype.modifiedPaths = function(options) {
    options = options || {};
    const directModifiedPaths = Object.keys(this.$__.activePaths.getStatePaths("modify"));
    const result = new Set;
    let i = 0;
    let j = 0;
    const len = directModifiedPaths.length;
    for (i = 0;i < len; ++i) {
      const path = directModifiedPaths[i];
      const parts = parentPaths(path);
      const pLen = parts.length;
      for (j = 0;j < pLen; ++j) {
        result.add(parts[j]);
      }
      if (!options.includeChildren) {
        continue;
      }
      let ii = 0;
      let cur = this.$get(path);
      if (typeof cur === "object" && cur !== null) {
        if (cur._doc) {
          cur = cur._doc;
        }
        const len2 = cur.length;
        if (Array.isArray(cur)) {
          for (ii = 0;ii < len2; ++ii) {
            const subPath = path + "." + ii;
            if (!result.has(subPath)) {
              result.add(subPath);
              if (cur[ii] != null && cur[ii].$__) {
                const modified = cur[ii].modifiedPaths();
                let iii = 0;
                const iiiLen = modified.length;
                for (iii = 0;iii < iiiLen; ++iii) {
                  result.add(subPath + "." + modified[iii]);
                }
              }
            }
          }
        } else {
          const keys = Object.keys(cur);
          let ii2 = 0;
          const len3 = keys.length;
          for (ii2 = 0;ii2 < len3; ++ii2) {
            result.add(path + "." + keys[ii2]);
          }
        }
      }
    }
    return Array.from(result);
  };
  Document.prototype[documentModifiedPaths] = Document.prototype.modifiedPaths;
  Document.prototype.isModified = function(paths, options, modifiedPaths) {
    if (paths) {
      const ignoreAtomics = options && options.ignoreAtomics;
      const directModifiedPathsObj = this.$__.activePaths.states.modify;
      if (directModifiedPathsObj == null) {
        return false;
      }
      if (typeof paths === "string") {
        paths = paths.indexOf(" ") === -1 ? [paths] : paths.split(" ");
      }
      for (const path of paths) {
        if (directModifiedPathsObj[path] != null) {
          return true;
        }
      }
      const modified = modifiedPaths || this[documentModifiedPaths]();
      const isModifiedChild = paths.some(function(path) {
        return !!~modified.indexOf(path);
      });
      let directModifiedPaths = Object.keys(directModifiedPathsObj);
      if (ignoreAtomics) {
        directModifiedPaths = directModifiedPaths.filter((path) => {
          const value = this.$__getValue(path);
          if (value != null && value[arrayAtomicsSymbol] != null && value[arrayAtomicsSymbol].$set === undefined) {
            return false;
          }
          return true;
        });
      }
      return isModifiedChild || paths.some(function(path) {
        return directModifiedPaths.some(function(mod) {
          return mod === path || path.startsWith(mod + ".");
        });
      });
    }
    return this.$__.activePaths.some("modify");
  };
  Document.prototype.$isModified = Document.prototype.isModified;
  Document.prototype[documentIsModified] = Document.prototype.isModified;
  Document.prototype.$isDefault = function(path) {
    if (path == null) {
      return this.$__.activePaths.some("default");
    }
    if (typeof path === "string" && path.indexOf(" ") === -1) {
      return this.$__.activePaths.getStatePaths("default").hasOwnProperty(path);
    }
    let paths = path;
    if (!Array.isArray(paths)) {
      paths = paths.split(" ");
    }
    return paths.some((path2) => this.$__.activePaths.getStatePaths("default").hasOwnProperty(path2));
  };
  Document.prototype.$isDeleted = function(val) {
    if (arguments.length === 0) {
      return !!this.$__.isDeleted;
    }
    this.$__.isDeleted = !!val;
    return this;
  };
  Document.prototype.isDirectModified = function(path) {
    if (path == null) {
      return this.$__.activePaths.some("modify");
    }
    if (typeof path === "string" && path.indexOf(" ") === -1) {
      const res = this.$__.activePaths.getStatePaths("modify").hasOwnProperty(path);
      if (res || path.indexOf(".") === -1) {
        return res;
      }
      const pieces = path.split(".");
      for (let i = 0;i < pieces.length - 1; ++i) {
        const subpath = pieces.slice(0, i + 1).join(".");
        const subdoc = this.$get(subpath);
        if (subdoc != null && subdoc.$__ != null && subdoc.isDirectModified(pieces.slice(i + 1).join("."))) {
          return true;
        }
      }
      return false;
    }
    let paths = path;
    if (typeof paths === "string") {
      paths = paths.split(" ");
    }
    return paths.some((path2) => this.isDirectModified(path2));
  };
  Document.prototype.isInit = function(path) {
    if (path == null) {
      return this.$__.activePaths.some("init");
    }
    if (typeof path === "string" && path.indexOf(" ") === -1) {
      return this.$__.activePaths.getStatePaths("init").hasOwnProperty(path);
    }
    let paths = path;
    if (!Array.isArray(paths)) {
      paths = paths.split(" ");
    }
    return paths.some((path2) => this.$__.activePaths.getStatePaths("init").hasOwnProperty(path2));
  };
  Document.prototype.isSelected = function isSelected(path) {
    if (this.$__.selected == null) {
      return true;
    }
    if (!path) {
      return false;
    }
    if (path === "_id") {
      return this.$__.selected._id !== 0;
    }
    if (path.indexOf(" ") !== -1) {
      path = path.split(" ");
    }
    if (Array.isArray(path)) {
      return path.some((p) => this.$__isSelected(p));
    }
    const paths = Object.keys(this.$__.selected);
    let inclusive = null;
    if (paths.length === 1 && paths[0] === "_id") {
      return this.$__.selected._id === 0;
    }
    for (const cur of paths) {
      if (cur === "_id") {
        continue;
      }
      if (!isDefiningProjection(this.$__.selected[cur])) {
        continue;
      }
      inclusive = !!this.$__.selected[cur];
      break;
    }
    if (inclusive === null) {
      return true;
    }
    if (path in this.$__.selected) {
      return inclusive;
    }
    const pathDot = path + ".";
    for (const cur of paths) {
      if (cur === "_id") {
        continue;
      }
      if (cur.startsWith(pathDot)) {
        return inclusive || cur !== pathDot;
      }
      if (pathDot.startsWith(cur + ".")) {
        return inclusive;
      }
    }
    return !inclusive;
  };
  Document.prototype.$__isSelected = Document.prototype.isSelected;
  Document.prototype.isDirectSelected = function isDirectSelected(path) {
    if (this.$__.selected == null) {
      return true;
    }
    if (path === "_id") {
      return this.$__.selected._id !== 0;
    }
    if (path.indexOf(" ") !== -1) {
      path = path.split(" ");
    }
    if (Array.isArray(path)) {
      return path.some((p) => this.isDirectSelected(p));
    }
    const paths = Object.keys(this.$__.selected);
    let inclusive = null;
    if (paths.length === 1 && paths[0] === "_id") {
      return this.$__.selected._id === 0;
    }
    for (const cur of paths) {
      if (cur === "_id") {
        continue;
      }
      if (!isDefiningProjection(this.$__.selected[cur])) {
        continue;
      }
      inclusive = !!this.$__.selected[cur];
      break;
    }
    if (inclusive === null) {
      return true;
    }
    if (this.$__.selected.hasOwnProperty(path)) {
      return inclusive;
    }
    return !inclusive;
  };
  Document.prototype.validate = async function validate(pathsToValidate, options) {
    if (typeof pathsToValidate === "function" || typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Document.prototype.validate() no longer accepts a callback");
    }
    let parallelValidate;
    this.$op = "validate";
    if (arguments.length === 1) {
      if (typeof arguments[0] === "object" && !Array.isArray(arguments[0])) {
        options = arguments[0];
        pathsToValidate = null;
      }
    }
    if (options && typeof options.pathsToSkip === "string") {
      const isOnePathOnly = options.pathsToSkip.indexOf(" ") === -1;
      options.pathsToSkip = isOnePathOnly ? [options.pathsToSkip] : options.pathsToSkip.split(" ");
    }
    const _skipParallelValidateCheck = options && options._skipParallelValidateCheck;
    if (this.$isSubdocument != null) {
    } else if (this.$__.validating && !_skipParallelValidateCheck) {
      parallelValidate = new ParallelValidateError(this, {
        parentStack: options && options.parentStack,
        conflictStack: this.$__.validating.stack
      });
    } else if (!_skipParallelValidateCheck) {
      this.$__.validating = new ParallelValidateError(this, { parentStack: options && options.parentStack });
    }
    if (parallelValidate != null) {
      throw parallelValidate;
    }
    return new Promise((resolve, reject) => {
      this.$__validate(pathsToValidate, options, (error) => {
        this.$op = null;
        this.$__.validating = null;
        if (error != null) {
          return reject(error);
        }
        resolve();
      });
    });
  };
  Document.prototype.$validate = Document.prototype.validate;
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  Document.prototype.$__validate = function(pathsToValidate, options, callback) {
    if (this.$__.saveOptions && this.$__.saveOptions.pathsToSave && !pathsToValidate) {
      pathsToValidate = [...this.$__.saveOptions.pathsToSave];
    } else if (typeof pathsToValidate === "function") {
      callback = pathsToValidate;
      options = null;
      pathsToValidate = null;
    } else if (typeof options === "function") {
      callback = options;
      options = null;
    }
    const hasValidateModifiedOnlyOption = options && typeof options === "object" && "validateModifiedOnly" in options;
    const pathsToSkip = options && options.pathsToSkip || null;
    let shouldValidateModifiedOnly;
    if (hasValidateModifiedOnlyOption) {
      shouldValidateModifiedOnly = !!options.validateModifiedOnly;
    } else {
      shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;
    }
    const validateAllPaths = options && options.validateAllPaths;
    if (validateAllPaths) {
      if (pathsToSkip) {
        throw new TypeError("Cannot set both `validateAllPaths` and `pathsToSkip`");
      }
      if (pathsToValidate) {
        throw new TypeError("Cannot set both `validateAllPaths` and `pathsToValidate`");
      }
      if (hasValidateModifiedOnlyOption && shouldValidateModifiedOnly) {
        throw new TypeError("Cannot set both `validateAllPaths` and `validateModifiedOnly`");
      }
    }
    const _this = this;
    const _complete = () => {
      let validationError = this.$__.validationError;
      this.$__.validationError = null;
      this.$__.validating = null;
      if (shouldValidateModifiedOnly && validationError != null) {
        const errors = Object.keys(validationError.errors);
        for (const errPath of errors) {
          if (!this.$isModified(errPath)) {
            delete validationError.errors[errPath];
          }
        }
        if (Object.keys(validationError.errors).length === 0) {
          validationError = undefined;
        }
      }
      this.$__.cachedRequired = {};
      this.$emit("validate", _this);
      this.constructor.emit("validate", _this);
      if (validationError) {
        for (const key in validationError.errors) {
          if (!this[documentArrayParent] && validationError.errors[key] instanceof MongooseError.CastError) {
            this.invalidate(key, validationError.errors[key]);
          }
        }
        return validationError;
      }
    };
    let paths;
    let doValidateOptionsByPath;
    if (validateAllPaths) {
      paths = new Set(Object.keys(this.$__schema.paths));
      for (const path of paths) {
        const schemaType = this.$__schema.path(path);
        if (!schemaType || !schemaType.$isMongooseArray) {
          continue;
        }
        const val = this.$__getValue(path);
        if (!val) {
          continue;
        }
        _pushNestedArrayPaths(val, paths, path);
      }
      paths = [...paths];
      doValidateOptionsByPath = {};
    } else {
      const pathDetails = _getPathsToValidate(this, pathsToValidate, pathsToSkip, options && options._nestedValidate);
      paths = shouldValidateModifiedOnly ? pathDetails[0].filter((path) => this.$isModified(path)) : pathDetails[0];
      doValidateOptionsByPath = pathDetails[1];
    }
    if (typeof pathsToValidate === "string") {
      pathsToValidate = pathsToValidate.split(" ");
    }
    if (paths.length === 0) {
      return immediate(function() {
        const error = _complete();
        if (error) {
          return _this.$__schema.s.hooks.execPost("validate:error", _this, [_this], { error }, function(error2) {
            callback(error2);
          });
        }
        callback(null, _this);
      });
    }
    const validated = {};
    let total = 0;
    let pathsToSave = this.$__.saveOptions?.pathsToSave;
    if (Array.isArray(pathsToSave)) {
      pathsToSave = new Set(pathsToSave);
      for (const path of paths) {
        if (!pathsToSave.has(path)) {
          continue;
        }
        validatePath(path);
      }
    } else {
      for (const path of paths) {
        validatePath(path);
      }
    }
    function validatePath(path) {
      if (path == null || validated[path]) {
        return;
      }
      validated[path] = true;
      total++;
      immediate(function() {
        const schemaType = _this.$__schema.path(path);
        if (!schemaType) {
          return --total || complete();
        }
        if (!_this.$isValid(path)) {
          --total || complete();
          return;
        }
        if (schemaType[schemaMixedSymbol] != null && path !== schemaType.path) {
          return --total || complete();
        }
        let val = _this.$__getValue(path);
        let pop;
        if (pop = _this.$populated(path)) {
          val = pop;
        } else if (val != null && val.$__ != null && val.$__.wasPopulated) {
          val = val._doc._id;
        }
        const scope = _this.$__.pathsToScopes != null && path in _this.$__.pathsToScopes ? _this.$__.pathsToScopes[path] : _this;
        const doValidateOptions = {
          ...doValidateOptionsByPath[path],
          path,
          validateAllPaths,
          _nestedValidate: true
        };
        schemaType.doValidate(val, function(err) {
          if (err) {
            const isSubdoc = schemaType.$isSingleNested || schemaType.$isArraySubdocument || schemaType.$isMongooseDocumentArray;
            if (isSubdoc && err instanceof ValidationError) {
              return --total || complete();
            }
            _this.invalidate(path, err, undefined, true);
          }
          --total || complete();
        }, scope, doValidateOptions);
      });
    }
    function complete() {
      const error = _complete();
      if (error) {
        return _this.$__schema.s.hooks.execPost("validate:error", _this, [_this], { error }, function(error2) {
          callback(error2);
        });
      }
      callback(null, _this);
    }
  };
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  Document.prototype.validateSync = function(pathsToValidate, options) {
    const _this = this;
    if (arguments.length === 1 && typeof arguments[0] === "object" && !Array.isArray(arguments[0])) {
      options = arguments[0];
      pathsToValidate = null;
    }
    const hasValidateModifiedOnlyOption = options && typeof options === "object" && "validateModifiedOnly" in options;
    let shouldValidateModifiedOnly;
    if (hasValidateModifiedOnlyOption) {
      shouldValidateModifiedOnly = !!options.validateModifiedOnly;
    } else {
      shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;
    }
    let pathsToSkip = options && options.pathsToSkip;
    const validateAllPaths = options && options.validateAllPaths;
    if (validateAllPaths) {
      if (pathsToSkip) {
        throw new TypeError("Cannot set both `validateAllPaths` and `pathsToSkip`");
      }
      if (pathsToValidate) {
        throw new TypeError("Cannot set both `validateAllPaths` and `pathsToValidate`");
      }
    }
    if (typeof pathsToValidate === "string") {
      const isOnePathOnly = pathsToValidate.indexOf(" ") === -1;
      pathsToValidate = isOnePathOnly ? [pathsToValidate] : pathsToValidate.split(" ");
    } else if (typeof pathsToSkip === "string" && pathsToSkip.indexOf(" ") !== -1) {
      pathsToSkip = pathsToSkip.split(" ");
    }
    let paths;
    let skipSchemaValidators;
    if (validateAllPaths) {
      paths = new Set(Object.keys(this.$__schema.paths));
      for (const path of paths) {
        const schemaType = this.$__schema.path(path);
        if (!schemaType || !schemaType.$isMongooseArray) {
          continue;
        }
        const val = this.$__getValue(path);
        if (!val) {
          continue;
        }
        _pushNestedArrayPaths(val, paths, path);
      }
      paths = [...paths];
      skipSchemaValidators = {};
    } else {
      const pathDetails = _getPathsToValidate(this, pathsToValidate, pathsToSkip);
      paths = shouldValidateModifiedOnly ? pathDetails[0].filter((path) => this.$isModified(path)) : pathDetails[0];
      skipSchemaValidators = pathDetails[1];
    }
    const validating = {};
    for (let i = 0, len = paths.length;i < len; ++i) {
      const path = paths[i];
      if (validating[path]) {
        continue;
      }
      validating[path] = true;
      const p = _this.$__schema.path(path);
      if (!p) {
        continue;
      }
      if (!_this.$isValid(path)) {
        continue;
      }
      const val = _this.$__getValue(path);
      const err2 = p.doValidateSync(val, _this, {
        skipSchemaValidators: skipSchemaValidators[path],
        path,
        validateModifiedOnly: shouldValidateModifiedOnly,
        validateAllPaths
      });
      if (err2) {
        const isSubdoc = p.$isSingleNested || p.$isArraySubdocument || p.$isMongooseDocumentArray;
        if (isSubdoc && err2 instanceof ValidationError) {
          continue;
        }
        _this.invalidate(path, err2, undefined, true);
      }
    }
    const err = _this.$__.validationError;
    _this.$__.validationError = undefined;
    _this.$emit("validate", _this);
    _this.constructor.emit("validate", _this);
    if (err) {
      for (const key in err.errors) {
        if (err.errors[key] instanceof MongooseError.CastError) {
          _this.invalidate(key, err.errors[key]);
        }
      }
    }
    return err;
  };
  Document.prototype.invalidate = function(path, err, val, kind) {
    if (!this.$__.validationError) {
      this.$__.validationError = new ValidationError(this);
    }
    if (this.$__.validationError.errors[path]) {
      return;
    }
    if (!err || typeof err === "string") {
      err = new ValidatorError({
        path,
        message: err,
        type: kind || "user defined",
        value: val
      });
    }
    if (this.$__.validationError === err) {
      return this.$__.validationError;
    }
    this.$__.validationError.addError(path, err);
    return this.$__.validationError;
  };
  Document.prototype.$markValid = function(path) {
    if (!this.$__.validationError || !this.$__.validationError.errors[path]) {
      return;
    }
    delete this.$__.validationError.errors[path];
    if (Object.keys(this.$__.validationError.errors).length === 0) {
      this.$__.validationError = null;
    }
  };
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  Document.prototype.$isValid = function(path) {
    if (this.$__.validationError == null || Object.keys(this.$__.validationError.errors).length === 0) {
      return true;
    }
    if (path == null) {
      return false;
    }
    if (path.indexOf(" ") !== -1) {
      path = path.split(" ");
    }
    if (Array.isArray(path)) {
      return path.some((p) => this.$__.validationError.errors[p] == null);
    }
    return this.$__.validationError.errors[path] == null;
  };
  Document.prototype.$__reset = function reset() {
    let _this = this;
    const subdocs = !this.$isSubdocument ? this.$getAllSubdocs({ useCache: true }) : null;
    if (subdocs && subdocs.length > 0) {
      for (const subdoc of subdocs) {
        subdoc.$__reset();
      }
    }
    this.$__dirty().forEach(function(dirt) {
      const type = dirt.value;
      if (type && type[arrayAtomicsSymbol]) {
        type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];
        type[arrayAtomicsSymbol] = {};
      }
    });
    this.$__.backup = {};
    this.$__.backup.activePaths = {
      modify: Object.assign({}, this.$__.activePaths.getStatePaths("modify")),
      default: Object.assign({}, this.$__.activePaths.getStatePaths("default"))
    };
    this.$__.backup.validationError = this.$__.validationError;
    this.$__.backup.errors = this.$errors;
    this.$__.activePaths.clear("modify");
    this.$__.activePaths.clear("default");
    this.$__.validationError = undefined;
    this.$errors = undefined;
    _this = this;
    this.$__schema.requiredPaths().forEach(function(path) {
      _this.$__.activePaths.require(path);
    });
    return this;
  };
  /*!
   * ignore
   */
  Document.prototype.$__undoReset = function $__undoReset() {
    if (this.$__.backup == null || this.$__.backup.activePaths == null) {
      return;
    }
    this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;
    this.$__.activePaths.states.default = this.$__.backup.activePaths.default;
    this.$__.validationError = this.$__.backup.validationError;
    this.$errors = this.$__.backup.errors;
    for (const dirt of this.$__dirty()) {
      const type = dirt.value;
      if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {
        type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];
      }
    }
    if (!this.$isSubdocument) {
      for (const subdoc of this.$getAllSubdocs()) {
        subdoc.$__undoReset();
      }
    }
  };
  Document.prototype.$__dirty = function() {
    const _this = this;
    let all = this.$__.activePaths.map("modify", function(path) {
      return {
        path,
        value: _this.$__getValue(path),
        schema: _this.$__path(path)
      };
    });
    all = all.concat(this.$__.activePaths.map("default", function(path) {
      if (path === "_id" || _this.$__getValue(path) == null) {
        return;
      }
      return {
        path,
        value: _this.$__getValue(path),
        schema: _this.$__path(path)
      };
    }));
    const allPaths = new Map(all.filter((el) => el != null).map((el) => [el.path, el.value]));
    const minimal = [];
    all.forEach(function(item) {
      if (!item) {
        return;
      }
      let top = null;
      const array = parentPaths(item.path);
      for (let i = 0;i < array.length - 1; i++) {
        if (allPaths.has(array[i])) {
          top = allPaths.get(array[i]);
          break;
        }
      }
      if (top == null) {
        minimal.push(item);
      } else if (top != null && top[arrayAtomicsSymbol] != null && top.hasAtomics()) {
        top[arrayAtomicsSymbol] = {};
        top[arrayAtomicsSymbol].$set = top;
      }
    });
    return minimal;
  };
  Document.prototype.$__setSchema = function(schema) {
    compile(schema.tree, this, undefined, schema.options);
    for (const key of Object.keys(schema.virtuals)) {
      schema.virtuals[key]._applyDefaultGetters();
    }
    if (schema.path("schema") == null) {
      this.schema = schema;
    }
    this.$__schema = schema;
    this[documentSchemaSymbol] = schema;
  };
  Document.prototype.$__getArrayPathsToValidate = function() {
    DocumentArray || (DocumentArray = require_documentArray());
    return this.$__.activePaths.map("init", "modify", function(i) {
      return this.$__getValue(i);
    }.bind(this)).filter(function(val) {
      return val && Array.isArray(val) && utils.isMongooseDocumentArray(val) && val.length;
    }).reduce(function(seed, array) {
      return seed.concat(array);
    }, []).filter(function(doc) {
      return doc;
    });
  };
  Document.prototype.$getAllSubdocs = function(options) {
    if (options?.useCache && this.$__.saveOptions?.__subdocs) {
      return this.$__.saveOptions.__subdocs;
    }
    DocumentArray || (DocumentArray = require_documentArray());
    Embedded = Embedded || require_arraySubdocument();
    const subDocs = [];
    function getSubdocs(doc) {
      const newSubdocs = [];
      for (const { model } of doc.$__schema.childSchemas) {
        const val = doc.$__getValue(model.path);
        if (val == null) {
          continue;
        }
        if (val.$__) {
          newSubdocs.push(val);
        }
        if (Array.isArray(val)) {
          for (const el of val) {
            if (el != null && el.$__) {
              newSubdocs.push(el);
            }
          }
        }
        if (val instanceof Map) {
          for (const el of val.values()) {
            if (el != null && el.$__) {
              newSubdocs.push(el);
            }
          }
        }
      }
      for (const subdoc of newSubdocs) {
        getSubdocs(subdoc);
      }
      subDocs.push(...newSubdocs);
    }
    getSubdocs(this);
    if (this.$__.saveOptions) {
      this.$__.saveOptions.__subdocs = subDocs;
    }
    return subDocs;
  };
  /*!
   * Runs queued functions
   */
  /*!
   * ignore
   */
  Document.prototype.$__handleReject = function handleReject(err) {
    if (this.$listeners("error").length) {
      this.$emit("error", err);
    } else if (this.constructor.listeners && this.constructor.listeners("error").length) {
      this.constructor.emit("error", err);
    }
  };
  Document.prototype.$toObject = function(options, json) {
    const defaultOptions = this.$__schema._defaultToObjectOptions(json);
    const hasOnlyPrimitiveValues = this.$__hasOnlyPrimitiveValues();
    options = utils.isPOJO(options) ? { ...options } : {};
    options._calledWithOptions = options._calledWithOptions || { ...options };
    let _minimize;
    if (options._calledWithOptions.minimize != null) {
      _minimize = options.minimize;
    } else if (defaultOptions != null && defaultOptions.minimize != null) {
      _minimize = defaultOptions.minimize;
    } else {
      _minimize = this.$__schema.options.minimize;
    }
    options.minimize = _minimize;
    if (!hasOnlyPrimitiveValues) {
      options._seen = options._seen || new Map;
    }
    const depopulate = options._calledWithOptions.depopulate ?? defaultOptions?.depopulate ?? options.depopulate ?? false;
    if (depopulate && options._isNested && this.$__.wasPopulated) {
      return clone(this.$__.wasPopulated.value || this._doc._id, options);
    }
    if (depopulate) {
      options.depopulate = true;
    }
    if (defaultOptions != null) {
      for (const key of Object.keys(defaultOptions)) {
        if (options[key] == null) {
          options[key] = defaultOptions[key];
        }
      }
    }
    options._isNested = true;
    options.json = json;
    options.minimize = _minimize;
    const parentOptions = options._parentOptions;
    options._parentOptions = this.$isSubdocument ? options : null;
    let ret;
    if (hasOnlyPrimitiveValues && !options.flattenObjectIds) {
      ret = this.$__toObjectShallow();
    } else {
      ret = clone(this._doc, options) || {};
    }
    const getters = options._calledWithOptions.getters ?? options.getters ?? defaultOptions.getters ?? false;
    if (getters) {
      applyGetters(this, ret);
      if (options.minimize) {
        ret = minimize(ret) || {};
      }
    }
    const virtuals = options._calledWithOptions.virtuals ?? defaultOptions.virtuals ?? parentOptions?.virtuals ?? undefined;
    if (virtuals || getters && virtuals !== false) {
      applyVirtuals(this, ret, options, options);
    }
    if (options.versionKey === false && this.$__schema.options.versionKey) {
      delete ret[this.$__schema.options.versionKey];
    }
    const transform = options._calledWithOptions.transform ?? true;
    let transformFunction = undefined;
    if (transform === true) {
      transformFunction = defaultOptions.transform;
    } else if (typeof transform === "function") {
      transformFunction = transform;
    }
    if (transform) {
      applySchemaTypeTransforms(this, ret);
    }
    if (options.useProjection) {
      omitDeselectedFields(this, ret);
    }
    if (typeof transformFunction === "function") {
      const xformed = transformFunction(this, ret, options);
      if (typeof xformed !== "undefined") {
        ret = xformed;
      }
    }
    return ret;
  };
  /*!
   * Internal shallow clone alternative to `$toObject()`: much faster, no options processing
   */
  Document.prototype.$__toObjectShallow = function $__toObjectShallow() {
    const ret = {};
    if (this._doc != null) {
      for (const key of Object.keys(this._doc)) {
        const value = this._doc[key];
        if (value instanceof Date) {
          ret[key] = new Date(value);
        } else if (value !== undefined) {
          ret[key] = value;
        }
      }
    }
    return ret;
  };
  Document.prototype.toObject = function(options) {
    return this.$toObject(options);
  };
  /*!
   * Applies virtuals properties to `json`.
   */
  /*!
   * ignore
   */
  Document.prototype.toJSON = function(options) {
    return this.$toObject(options, true);
  };
  /*!
   * ignore
   */
  Document.prototype.ownerDocument = function() {
    return this;
  };
  Document.prototype.parent = function() {
    if (this.$isSubdocument || this.$__.wasPopulated) {
      return this.$__.parent;
    }
    return this;
  };
  Document.prototype.$parent = Document.prototype.parent;
  Document.prototype.inspect = function(options) {
    const isPOJO = utils.isPOJO(options);
    let opts;
    if (isPOJO) {
      opts = options;
      opts.minimize = false;
    }
    const ret = arguments.length > 0 ? this.toObject(opts) : this.toObject();
    if (ret == null) {
      return "MongooseDocument { " + ret + " }";
    }
    return ret;
  };
  if (inspect.custom) {
    Document.prototype[inspect.custom] = Document.prototype.inspect;
  }
  Document.prototype.toString = function() {
    const ret = this.inspect();
    if (typeof ret === "string") {
      return ret;
    }
    return inspect(ret);
  };
  Document.prototype.equals = function(doc) {
    if (!doc) {
      return false;
    }
    const tid = this.$__getValue("_id");
    const docid = doc.$__ != null ? doc.$__getValue("_id") : doc;
    if (!tid && !docid) {
      return deepEqual(this, doc);
    }
    return tid && tid.equals ? tid.equals(docid) : tid === docid;
  };
  Document.prototype.populate = async function populate() {
    const pop = {};
    const args = [...arguments];
    if (typeof args[args.length - 1] === "function") {
      throw new MongooseError("Document.prototype.populate() no longer accepts a callback");
    }
    if (args.length !== 0) {
      const res = utils.populate.apply(null, args);
      for (const populateOptions of res) {
        pop[populateOptions.path] = populateOptions;
      }
    }
    const paths = utils.object.vals(pop);
    let topLevelModel = this.constructor;
    if (this.$__isNested) {
      topLevelModel = this.$__[scopeSymbol].constructor;
      const nestedPath = this.$__.nestedPath;
      paths.forEach(function(populateOptions) {
        populateOptions.path = nestedPath + "." + populateOptions.path;
      });
    }
    if (this.$session() != null) {
      const session = this.$session();
      paths.forEach((path) => {
        if (path.options == null) {
          path.options = { session };
          return;
        }
        if (!("session" in path.options)) {
          path.options.session = session;
        }
      });
    }
    paths.forEach((p) => {
      p._localModel = topLevelModel;
    });
    return topLevelModel.populate(this, paths);
  };
  Document.prototype.$getPopulatedDocs = function $getPopulatedDocs() {
    let keys = [];
    if (this.$__.populated != null) {
      keys = keys.concat(Object.keys(this.$__.populated));
    }
    let result = [];
    for (const key of keys) {
      const value = this.$get(key);
      if (Array.isArray(value)) {
        result = result.concat(value);
      } else if (value instanceof Document) {
        result.push(value);
      }
    }
    return result;
  };
  Document.prototype.populated = function(path, val, options) {
    if (val == null || val === true) {
      if (!this.$__.populated) {
        return;
      }
      if (typeof path !== "string") {
        return;
      }
      const _path = path.endsWith(".$*") ? path.replace(/\.\$\*$/, "") : path;
      const v = this.$__.populated[_path];
      if (v) {
        return val === true ? v : v.value;
      }
      return;
    }
    this.$__.populated || (this.$__.populated = {});
    this.$__.populated[path] = { value: val, options };
    const pieces = path.split(".");
    for (let i = 0;i < pieces.length - 1; ++i) {
      const subpath = pieces.slice(0, i + 1).join(".");
      const subdoc = this.$get(subpath);
      if (subdoc != null && subdoc.$__ != null && this.$populated(subpath)) {
        const rest = pieces.slice(i + 1).join(".");
        subdoc.$populated(rest, val, options);
        break;
      }
    }
    return val;
  };
  Document.prototype.$populated = Document.prototype.populated;
  Document.prototype.$assertPopulated = function $assertPopulated(path, values) {
    if (Array.isArray(path)) {
      path.forEach((p) => this.$assertPopulated(p, values));
      return this;
    }
    if (arguments.length > 1) {
      this.$set(values);
    }
    if (!this.$populated(path)) {
      throw new MongooseError(`Expected path "${path}" to be populated`);
    }
    return this;
  };
  Document.prototype.depopulate = function(path) {
    if (typeof path === "string") {
      path = path.indexOf(" ") === -1 ? [path] : path.split(" ");
    }
    let populatedIds;
    const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];
    const populated = this.$__ && this.$__.populated || {};
    if (arguments.length === 0) {
      for (const virtualKey of virtualKeys) {
        delete this.$$populatedVirtuals[virtualKey];
        delete this._doc[virtualKey];
        delete populated[virtualKey];
      }
      const keys = Object.keys(populated);
      for (const key of keys) {
        populatedIds = this.$populated(key);
        if (!populatedIds) {
          continue;
        }
        delete populated[key];
        if (Array.isArray(populatedIds)) {
          const arr = utils.getValue(key, this._doc);
          if (arr.isMongooseArray) {
            const rawArray = arr.__array;
            for (let i = 0;i < rawArray.length; ++i) {
              const subdoc = rawArray[i];
              if (subdoc == null) {
                continue;
              }
              rawArray[i] = subdoc instanceof Document ? subdoc._doc._id : subdoc._id;
            }
          } else {
            utils.setValue(key, populatedIds, this._doc);
          }
        } else {
          utils.setValue(key, populatedIds, this._doc);
        }
      }
      return this;
    }
    for (const singlePath of path) {
      populatedIds = this.$populated(singlePath);
      delete populated[singlePath];
      if (virtualKeys.indexOf(singlePath) !== -1) {
        delete this.$$populatedVirtuals[singlePath];
        delete this._doc[singlePath];
      } else if (populatedIds) {
        if (Array.isArray(populatedIds)) {
          const arr = utils.getValue(singlePath, this._doc);
          if (arr.isMongooseArray) {
            const rawArray = arr.__array;
            for (let i = 0;i < rawArray.length; ++i) {
              const subdoc = rawArray[i];
              if (subdoc == null) {
                continue;
              }
              rawArray[i] = subdoc instanceof Document ? subdoc._doc._id : subdoc._id;
            }
          } else {
            utils.setValue(singlePath, populatedIds, this._doc);
          }
        } else {
          utils.setValue(singlePath, populatedIds, this._doc);
        }
      }
    }
    return this;
  };
  Document.prototype.$__fullPath = function(path) {
    return path || "";
  };
  Document.prototype.getChanges = function() {
    const delta = this.$__delta();
    const changes = delta ? delta[1] : {};
    return changes;
  };
  Document.prototype.$__delta = function $__delta() {
    const dirty = this.$__dirty();
    const optimisticConcurrency = this.$__schema.options.optimisticConcurrency;
    if (optimisticConcurrency) {
      if (Array.isArray(optimisticConcurrency)) {
        const optCon = new Set(optimisticConcurrency);
        const modPaths = this.modifiedPaths();
        if (modPaths.find((path) => optCon.has(path))) {
          this.$__.version = dirty.length ? VERSION_ALL : VERSION_WHERE;
        }
      } else {
        this.$__.version = dirty.length ? VERSION_ALL : VERSION_WHERE;
      }
    }
    if (!dirty.length && VERSION_ALL !== this.$__.version) {
      return;
    }
    const where = {};
    const delta = {};
    const len = dirty.length;
    const divergent = [];
    let d = 0;
    where._id = this._doc._id;
    if ((where && where._id && where._id.$__ || null) != null) {
      where._id = where._id.toObject({ transform: false, depopulate: true });
    }
    for (;d < len; ++d) {
      const data = dirty[d];
      let value = data.value;
      const match = checkDivergentArray(this, data.path, value);
      if (match) {
        divergent.push(match);
        continue;
      }
      const pop = this.$populated(data.path, true);
      if (!pop && this.$__.selected) {
        const pathSplit = data.path.split(".");
        const top = pathSplit[0];
        if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {
          if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === "undefined") {
            where[top] = this.$__.selected[top];
            pathSplit[1] = "$";
            data.path = pathSplit.join(".");
          } else {
            divergent.push(data.path);
            continue;
          }
        }
      }
      if (this.$isDefault(data.path) && this.$__.selected) {
        if (data.path.indexOf(".") === -1 && isPathExcluded(this.$__.selected, data.path)) {
          continue;
        }
        const pathsToCheck = parentPaths(data.path);
        if (pathsToCheck.find((path) => isPathExcluded(this.$__.isSelected, path))) {
          continue;
        }
      }
      if (divergent.length)
        continue;
      if (value === undefined) {
        operand(this, where, delta, data, 1, "$unset");
      } else if (value === null) {
        operand(this, where, delta, data, null);
      } else if (utils.isMongooseArray(value) && value.$path() && value[arrayAtomicsSymbol]) {
        handleAtomics(this, where, delta, data, value);
      } else if (value[MongooseBuffer.pathSymbol] && Buffer.isBuffer(value)) {
        value = value.toObject();
        operand(this, where, delta, data, value);
      } else {
        if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[data.path] != null) {
          const val = this.$__.primitiveAtomics[data.path];
          const op = firstKey(val);
          operand(this, where, delta, data, val[op], op);
        } else {
          value = clone(value, {
            depopulate: true,
            transform: false,
            virtuals: false,
            getters: false,
            omitUndefined: true,
            _isNested: true
          });
          operand(this, where, delta, data, value);
        }
      }
    }
    if (divergent.length) {
      return new DivergentArrayError(divergent);
    }
    if (this.$__.version) {
      this.$__version(where, delta);
    }
    if (Object.keys(delta).length === 0) {
      return [where, null];
    }
    return [where, delta];
  };
  Document.prototype.$clone = function() {
    const Model = this.constructor;
    const clonedDoc = new Model;
    clonedDoc.$isNew = this.$isNew;
    if (this._doc) {
      clonedDoc._doc = clone(this._doc, { retainDocuments: true });
    }
    if (this.$__) {
      const Cache = this.$__.constructor;
      const clonedCache = new Cache;
      for (const key of Object.getOwnPropertyNames(this.$__)) {
        if (key === "activePaths") {
          continue;
        }
        clonedCache[key] = clone(this.$__[key]);
      }
      Object.assign(clonedCache.activePaths, clone({ ...this.$__.activePaths }));
      clonedDoc.$__ = clonedCache;
    }
    return clonedDoc;
  };
  Document.prototype.$createModifiedPathsSnapshot = function $createModifiedPathsSnapshot() {
    const subdocSnapshot = new WeakMap;
    if (!this.$isSubdocument) {
      const subdocs = this.$getAllSubdocs();
      for (const child of subdocs) {
        subdocSnapshot.set(child, child.$__.activePaths.clone());
      }
    }
    return new ModifiedPathsSnapshot(subdocSnapshot, this.$__.activePaths.clone(), this.$__.version);
  };
  Document.prototype.$restoreModifiedPathsSnapshot = function $restoreModifiedPathsSnapshot(snapshot) {
    this.$__.activePaths = snapshot.activePaths.clone();
    this.$__.version = snapshot.version;
    if (!this.$isSubdocument) {
      const subdocs = this.$getAllSubdocs();
      for (const child of subdocs) {
        if (snapshot.subdocSnapshot.has(child)) {
          child.$__.activePaths = snapshot.subdocSnapshot.get(child);
        }
      }
    }
    return this;
  };
  Document.prototype.$clearModifiedPaths = function $clearModifiedPaths() {
    this.$__.activePaths.clear("modify");
    this.$__.activePaths.clear("init");
    this.$__.version = 0;
    if (!this.$isSubdocument) {
      const subdocs = this.$getAllSubdocs();
      for (const child of subdocs) {
        child.$clearModifiedPaths();
      }
    }
    return this;
  };
  /*!
   * Check if the given document only has primitive values
   */
  Document.prototype.$__hasOnlyPrimitiveValues = function $__hasOnlyPrimitiveValues() {
    return !this.$__.populated && !this.$__.wasPopulated && (this._doc == null || Object.values(this._doc).every((v) => {
      return v == null || typeof v !== "object" || utils.isNativeObject(v) && !Array.isArray(v) || isBsonType(v, "ObjectId") || isBsonType(v, "Decimal128");
    }));
  };
  /*!
   * Module exports.
   */
  Document.VERSION_WHERE = VERSION_WHERE;
  Document.VERSION_INC = VERSION_INC;
  Document.VERSION_ALL = VERSION_ALL;
  Document.ValidationError = ValidationError;
  module.exports = exports = Document;
});

// node_modules/mongoose/lib/utils.js
var require_utils4 = __commonJS((exports) => {
  function _populateObj(obj) {
    if (Array.isArray(obj.populate)) {
      const ret2 = [];
      obj.populate.forEach(function(obj2) {
        if (oneSpaceRE.test(obj2.path)) {
          const copy = Object.assign({}, obj2);
          const paths2 = copy.path.split(manySpaceRE);
          paths2.forEach(function(p) {
            copy.path = p;
            ret2.push(exports.populate(copy)[0]);
          });
        } else {
          ret2.push(exports.populate(obj2)[0]);
        }
      });
      obj.populate = exports.populate(ret2);
    } else if (obj.populate != null && typeof obj.populate === "object") {
      obj.populate = exports.populate(obj.populate);
    }
    const ret = [];
    const paths = oneSpaceRE.test(obj.path) ? obj.path.split(manySpaceRE) : [obj.path];
    if (obj.options != null) {
      obj.options = clone(obj.options);
    }
    for (const path of paths) {
      ret.push(new PopulateOptions(Object.assign({}, obj, { path })));
    }
    return ret;
  }
  function getValueLookup(obj, part) {
    if (part === "$*" && obj instanceof Map) {
      return obj;
    }
    let _from = obj?._doc || obj;
    if (_from != null && _from.isMongooseArrayProxy) {
      _from = _from.__array;
    }
    return _from instanceof Map ? _from.get(part, mapGetterOptions) : _from[part];
  }
  /*!
   * Module dependencies.
   */
  var UUID = require_bson().UUID;
  var ms = require_ms();
  var mpath = require_mpath();
  var ObjectId2 = require_objectid();
  var PopulateOptions = require_populateOptions();
  var clone = require_clone2();
  var immediate = require_immediate();
  var isObject = require_isObject2();
  var isMongooseArray = require_isMongooseArray();
  var isMongooseDocumentArray = require_isMongooseDocumentArray();
  var isBsonType = require_isBsonType();
  var isPOJO = require_isPOJO();
  var getFunctionName = require_getFunctionName();
  var isMongooseObject = require_isMongooseObject();
  var promiseOrCallback = require_promiseOrCallback();
  var schemaMerge = require_merge();
  var specialProperties = require_specialProperties();
  var { trustedSymbol } = require_trusted();
  var Document;
  exports.specialProperties = specialProperties;
  exports.isMongooseArray = isMongooseArray.isMongooseArray;
  exports.isMongooseDocumentArray = isMongooseDocumentArray.isMongooseDocumentArray;
  exports.registerMongooseArray = isMongooseArray.registerMongooseArray;
  exports.registerMongooseDocumentArray = isMongooseDocumentArray.registerMongooseDocumentArray;
  var oneSpaceRE = /\s/;
  var manySpaceRE = /\s+/;
  exports.toCollectionName = function(name, pluralize) {
    if (name === "system.profile") {
      return name;
    }
    if (name === "system.indexes") {
      return name;
    }
    if (typeof pluralize === "function") {
      if (typeof name !== "string") {
        throw new TypeError("Collection name must be a string");
      }
      if (name.length === 0) {
        throw new TypeError("Collection name cannot be empty");
      }
      return pluralize(name);
    }
    return name;
  };
  exports.deepEqual = function deepEqual(a, b) {
    if (a === b) {
      return true;
    }
    if (typeof a !== "object" || typeof b !== "object") {
      return a === b;
    }
    if (a instanceof Date && b instanceof Date) {
      return a.getTime() === b.getTime();
    }
    if (isBsonType(a, "ObjectId") && isBsonType(b, "ObjectId") || isBsonType(a, "Decimal128") && isBsonType(b, "Decimal128")) {
      return a.toString() === b.toString();
    }
    if (a instanceof RegExp && b instanceof RegExp) {
      return a.source === b.source && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.global === b.global && a.dotAll === b.dotAll && a.unicode === b.unicode && a.sticky === b.sticky && a.hasIndices === b.hasIndices;
    }
    if (a == null || b == null) {
      return false;
    }
    if (a.prototype !== b.prototype) {
      return false;
    }
    if (a instanceof Map || b instanceof Map) {
      if (!(a instanceof Map) || !(b instanceof Map)) {
        return false;
      }
      return deepEqual(Array.from(a.keys()), Array.from(b.keys())) && deepEqual(Array.from(a.values()), Array.from(b.values()));
    }
    if (a instanceof Number && b instanceof Number) {
      return a.valueOf() === b.valueOf();
    }
    if (Buffer.isBuffer(a)) {
      return exports.buffer.areEqual(a, b);
    }
    if (Array.isArray(a) || Array.isArray(b)) {
      if (!Array.isArray(a) || !Array.isArray(b)) {
        return false;
      }
      const len = a.length;
      if (len !== b.length) {
        return false;
      }
      for (let i = 0;i < len; ++i) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    if (a.$__ != null) {
      a = a._doc;
    } else if (isMongooseObject(a)) {
      a = a.toObject();
    }
    if (b.$__ != null) {
      b = b._doc;
    } else if (isMongooseObject(b)) {
      b = b.toObject();
    }
    const ka = Object.keys(a);
    const kb = Object.keys(b);
    const kaLength = ka.length;
    if (kaLength !== kb.length) {
      return false;
    }
    for (let i = kaLength - 1;i >= 0; i--) {
      if (ka[i] !== kb[i]) {
        return false;
      }
    }
    for (const key of ka) {
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  };
  exports.last = function(arr) {
    if (arr.length > 0) {
      return arr[arr.length - 1];
    }
    return;
  };
  /*!
   * ignore
   */
  exports.promiseOrCallback = promiseOrCallback;
  /*!
   * ignore
   */
  exports.cloneArrays = function cloneArrays(arr) {
    if (!Array.isArray(arr)) {
      return arr;
    }
    return arr.map((el) => exports.cloneArrays(el));
  };
  /*!
   * ignore
   */
  exports.omit = function omit(obj, keys) {
    if (keys == null) {
      return Object.assign({}, obj);
    }
    if (!Array.isArray(keys)) {
      keys = [keys];
    }
    const ret = Object.assign({}, obj);
    for (const key of keys) {
      delete ret[key];
    }
    return ret;
  };
  exports.merge = function merge(to, from, options, path) {
    options = options || {};
    const keys = Object.keys(from);
    let i = 0;
    const len = keys.length;
    let key;
    if (from[trustedSymbol]) {
      to[trustedSymbol] = from[trustedSymbol];
    }
    path = path || "";
    const omitNested = options.omitNested || {};
    while (i < len) {
      key = keys[i++];
      if (options.omit && options.omit[key]) {
        continue;
      }
      if (omitNested[path]) {
        continue;
      }
      if (specialProperties.has(key)) {
        continue;
      }
      if (to[key] == null) {
        if (isPOJO(from[key])) {
          to[key] = { ...from[key] };
        } else if (Array.isArray(from[key])) {
          to[key] = [...from[key]];
        } else {
          to[key] = from[key];
        }
      } else if (exports.isObject(from[key])) {
        if (!exports.isObject(to[key])) {
          to[key] = {};
        }
        if (from[key] != null) {
          if (options.isDiscriminatorSchemaMerge && (from[key].$isSingleNested && to[key].$isMongooseDocumentArray) || from[key].$isMongooseDocumentArray && to[key].$isSingleNested) {
            continue;
          } else if (from[key].instanceOfSchema) {
            if (to[key].instanceOfSchema) {
              schemaMerge(to[key], from[key].clone(), options.isDiscriminatorSchemaMerge);
            } else {
              to[key] = from[key].clone();
            }
            continue;
          } else if (isBsonType(from[key], "ObjectId")) {
            to[key] = new ObjectId2(from[key]);
            continue;
          }
        }
        merge(to[key], from[key], options, path ? path + "." + key : key);
      } else if (options.overwrite) {
        to[key] = from[key];
      }
    }
    return to;
  };
  exports.toObject = function toObject(obj) {
    Document || (Document = require_document2());
    let ret;
    if (obj == null) {
      return obj;
    }
    if (obj instanceof Document) {
      return obj.toObject();
    }
    if (Array.isArray(obj)) {
      ret = [];
      for (const doc of obj) {
        ret.push(toObject(doc));
      }
      return ret;
    }
    if (exports.isPOJO(obj)) {
      ret = {};
      if (obj[trustedSymbol]) {
        ret[trustedSymbol] = obj[trustedSymbol];
      }
      for (const k of Object.keys(obj)) {
        if (specialProperties.has(k)) {
          continue;
        }
        ret[k] = toObject(obj[k]);
      }
      return ret;
    }
    return obj;
  };
  exports.isObject = isObject;
  exports.isPOJO = require_isPOJO();
  exports.isNonBuiltinObject = function isNonBuiltinObject(val) {
    return typeof val === "object" && !exports.isNativeObject(val) && !exports.isMongooseType(val) && !(val instanceof UUID) && val != null;
  };
  exports.isNativeObject = function(arg) {
    return Array.isArray(arg) || arg instanceof Date || arg instanceof Boolean || arg instanceof Number || arg instanceof String;
  };
  exports.isEmptyObject = function(val) {
    return val != null && typeof val === "object" && Object.keys(val).length === 0;
  };
  exports.hasKey = function hasKey(obj, key) {
    const props = Object.keys(obj);
    for (const prop of props) {
      if (prop === key) {
        return true;
      }
      if (exports.isPOJO(obj[prop]) && exports.hasKey(obj[prop], key)) {
        return true;
      }
    }
    return false;
  };
  exports.tick = function tick(callback) {
    if (typeof callback !== "function") {
      return;
    }
    return function() {
      try {
        callback.apply(this, arguments);
      } catch (err) {
        immediate(function() {
          throw err;
        });
      }
    };
  };
  exports.isMongooseType = function(v) {
    return isBsonType(v, "ObjectId") || isBsonType(v, "Decimal128") || v instanceof Buffer;
  };
  exports.isMongooseObject = isMongooseObject;
  exports.expires = function expires(object) {
    if (!(object && object.constructor.name === "Object")) {
      return;
    }
    if (!("expires" in object)) {
      return;
    }
    object.expireAfterSeconds = typeof object.expires !== "string" ? object.expires : Math.round(ms(object.expires) / 1000);
    delete object.expires;
  };
  exports.populate = function populate(path, select, model, match, options, subPopulate, justOne, count) {
    let obj = null;
    if (arguments.length === 1) {
      if (path instanceof PopulateOptions) {
        path._docs = {};
        path._childDocs = [];
        return [path];
      }
      if (Array.isArray(path)) {
        const singles = makeSingles(path);
        return singles.map((o) => exports.populate(o)[0]);
      }
      if (exports.isObject(path)) {
        obj = Object.assign({}, path);
      } else {
        obj = { path };
      }
    } else if (typeof model === "object") {
      obj = {
        path,
        select,
        match: model,
        options: match
      };
    } else {
      obj = {
        path,
        select,
        model,
        match,
        options,
        populate: subPopulate,
        justOne,
        count
      };
    }
    if (typeof obj.path !== "string") {
      throw new TypeError("utils.populate: invalid path. Expected string. Got typeof `" + typeof path + "`");
    }
    return _populateObj(obj);
    function makeSingles(arr) {
      const ret = [];
      arr.forEach(function(obj2) {
        if (oneSpaceRE.test(obj2.path)) {
          const paths = obj2.path.split(manySpaceRE);
          paths.forEach(function(p) {
            const copy = Object.assign({}, obj2);
            copy.path = p;
            ret.push(copy);
          });
        } else {
          ret.push(obj2);
        }
      });
      return ret;
    }
  };
  exports.getValue = function(path, obj, map) {
    return mpath.get(path, obj, getValueLookup, map);
  };
  /*!
   * ignore
   */
  var mapGetterOptions = Object.freeze({ getters: false });
  exports.setValue = function(path, val, obj, map, _copying) {
    mpath.set(path, val, obj, "_doc", map, _copying);
  };
  exports.object = {};
  exports.object.vals = function vals(o) {
    const keys = Object.keys(o);
    let i = keys.length;
    const ret = [];
    while (i--) {
      ret.push(o[keys[i]]);
    }
    return ret;
  };
  var hop = Object.prototype.hasOwnProperty;
  exports.object.hasOwnProperty = function(obj, prop) {
    return hop.call(obj, prop);
  };
  exports.isNullOrUndefined = function(val) {
    return val === null || val === undefined;
  };
  /*!
   * ignore
   */
  exports.array = {};
  exports.array.flatten = function flatten(arr, filter, ret) {
    ret || (ret = []);
    arr.forEach(function(item) {
      if (Array.isArray(item)) {
        flatten(item, filter, ret);
      } else {
        if (!filter || filter(item)) {
          ret.push(item);
        }
      }
    });
    return ret;
  };
  /*!
   * ignore
   */
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  exports.hasUserDefinedProperty = function(obj, key) {
    if (obj == null) {
      return false;
    }
    if (Array.isArray(key)) {
      for (const k of key) {
        if (exports.hasUserDefinedProperty(obj, k)) {
          return true;
        }
      }
      return false;
    }
    if (_hasOwnProperty.call(obj, key)) {
      return true;
    }
    if (typeof obj === "object" && key in obj) {
      const v = obj[key];
      return v !== Object.prototype[key] && v !== Array.prototype[key];
    }
    return false;
  };
  /*!
   * ignore
   */
  var MAX_ARRAY_INDEX = Math.pow(2, 32) - 1;
  exports.isArrayIndex = function(val) {
    if (typeof val === "number") {
      return val >= 0 && val <= MAX_ARRAY_INDEX;
    }
    if (typeof val === "string") {
      if (!/^\d+$/.test(val)) {
        return false;
      }
      val = +val;
      return val >= 0 && val <= MAX_ARRAY_INDEX;
    }
    return false;
  };
  exports.array.unique = function(arr) {
    const primitives = new Set;
    const ids = new Set;
    const ret = [];
    for (const item of arr) {
      if (typeof item === "number" || typeof item === "string" || item == null) {
        if (primitives.has(item)) {
          continue;
        }
        ret.push(item);
        primitives.add(item);
      } else if (isBsonType(item, "ObjectId")) {
        if (ids.has(item.toString())) {
          continue;
        }
        ret.push(item);
        ids.add(item.toString());
      } else {
        ret.push(item);
      }
    }
    return ret;
  };
  exports.buffer = {};
  exports.buffer.areEqual = function(a, b) {
    if (!Buffer.isBuffer(a)) {
      return false;
    }
    if (!Buffer.isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0, len = a.length;i < len; ++i) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  };
  exports.getFunctionName = getFunctionName;
  exports.decorate = function(destination, source) {
    for (const key in source) {
      if (specialProperties.has(key)) {
        continue;
      }
      destination[key] = source[key];
    }
  };
  exports.mergeClone = function(to, fromObj) {
    if (isMongooseObject(fromObj)) {
      fromObj = fromObj.toObject({
        transform: false,
        virtuals: false,
        depopulate: true,
        getters: false,
        flattenDecimals: false
      });
    }
    const keys = Object.keys(fromObj);
    const len = keys.length;
    let i = 0;
    let key;
    while (i < len) {
      key = keys[i++];
      if (specialProperties.has(key)) {
        continue;
      }
      if (typeof to[key] === "undefined") {
        to[key] = clone(fromObj[key], {
          transform: false,
          virtuals: false,
          depopulate: true,
          getters: false,
          flattenDecimals: false
        });
      } else {
        let val = fromObj[key];
        if (val != null && val.valueOf && !(val instanceof Date)) {
          val = val.valueOf();
        }
        if (exports.isObject(val)) {
          let obj = val;
          if (isMongooseObject(val) && !val.isMongooseBuffer) {
            obj = obj.toObject({
              transform: false,
              virtuals: false,
              depopulate: true,
              getters: false,
              flattenDecimals: false
            });
          }
          if (val.isMongooseBuffer) {
            obj = Buffer.from(obj);
          }
          exports.mergeClone(to[key], obj);
        } else {
          to[key] = clone(val, {
            flattenDecimals: false
          });
        }
      }
    }
  };
  exports.each = function(arr, fn) {
    for (const item of arr) {
      fn(item);
    }
  };
  exports.renameObjKey = function(oldObj, oldKey, newKey) {
    const keys = Object.keys(oldObj);
    return keys.reduce((acc, val) => {
      if (val === oldKey) {
        acc[newKey] = oldObj[oldKey];
      } else {
        acc[val] = oldObj[val];
      }
      return acc;
    }, {});
  };
  /*!
   * ignore
   */
  exports.getOption = function(name) {
    const sources = Array.prototype.slice.call(arguments, 1);
    for (const source of sources) {
      if (source == null) {
        continue;
      }
      if (source[name] != null) {
        return source[name];
      }
    }
    return null;
  };
  /*!
   * ignore
   */
  exports.noop = function() {
  };
  exports.errorToPOJO = function errorToPOJO(error) {
    const isError = error instanceof Error;
    if (!isError) {
      throw new Error("`error` must be `instanceof Error`.");
    }
    const ret = {};
    for (const properyName of Object.getOwnPropertyNames(error)) {
      ret[properyName] = error[properyName];
    }
    return ret;
  };
  /*!
   * ignore
   */
  exports.warn = function warn(message) {
    return process.emitWarning(message, { code: "MONGOOSE" });
  };
  exports.injectTimestampsOption = function injectTimestampsOption(writeOperation, timestampsOption) {
    if (timestampsOption == null) {
      return;
    }
    writeOperation.timestamps = timestampsOption;
  };
});

// node_modules/mongoose/lib/schemaType.js
var require_schemaType = __commonJS((exports, module) => {
  function SchemaType(path, options, instance) {
    this[schemaTypeSymbol] = true;
    this.path = path;
    this.instance = instance;
    this.validators = [];
    this.getters = this.constructor.hasOwnProperty("getters") ? this.constructor.getters.slice() : [];
    this.setters = this.constructor.hasOwnProperty("setters") ? this.constructor.setters.slice() : [];
    this.splitPath();
    options = options || {};
    const defaultOptions = this.constructor.defaultOptions || {};
    const defaultOptionsKeys = Object.keys(defaultOptions);
    for (const option of defaultOptionsKeys) {
      if (option === "validate") {
        this.validate(defaultOptions.validate);
      } else if (defaultOptions.hasOwnProperty(option) && !Object.prototype.hasOwnProperty.call(options, option)) {
        options[option] = defaultOptions[option];
      }
    }
    if (options.select == null) {
      delete options.select;
    }
    const Options = this.OptionsConstructor || SchemaTypeOptions;
    this.options = new Options(options);
    this._index = null;
    if (utils.hasUserDefinedProperty(this.options, "immutable")) {
      this.$immutable = this.options.immutable;
      handleImmutable(this);
    }
    const keys = Object.keys(this.options);
    for (const prop of keys) {
      if (prop === "cast") {
        if (Array.isArray(this.options[prop])) {
          this.castFunction.apply(this, this.options[prop]);
        } else {
          this.castFunction(this.options[prop]);
        }
        continue;
      }
      if (utils.hasUserDefinedProperty(this.options, prop) && typeof this[prop] === "function") {
        if (prop === "index" && this._index) {
          if (options.index === false) {
            const index = this._index;
            if (typeof index === "object" && index != null) {
              if (index.unique) {
                throw new Error('Path "' + this.path + '" may not have `index` ' + "set to false and `unique` set to true");
              }
              if (index.sparse) {
                throw new Error('Path "' + this.path + '" may not have `index` ' + "set to false and `sparse` set to true");
              }
            }
            this._index = false;
          }
          continue;
        }
        const val = options[prop];
        if (prop === "default") {
          this.default(val);
          continue;
        }
        const opts = Array.isArray(val) ? val : [val];
        this[prop].apply(this, opts);
      }
    }
    Object.defineProperty(this, "$$context", {
      enumerable: false,
      configurable: false,
      writable: true,
      value: null
    });
  }
  function _validate(ok, validatorProperties) {
    if (ok !== undefined && !ok) {
      const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;
      const err = new ErrorConstructor(validatorProperties);
      err[validatorErrorSymbol] = true;
      return err;
    }
  }
  function handleSingle(val, context) {
    return this.castForQuery(null, val, context);
  }
  function handleArray(val, context) {
    const _this = this;
    if (!Array.isArray(val)) {
      return [this.castForQuery(null, val, context)];
    }
    return val.map(function(m) {
      return _this.castForQuery(null, m, context);
    });
  }
  function handle$in(val, context) {
    const _this = this;
    if (!Array.isArray(val)) {
      return [this.castForQuery(null, val, context)];
    }
    return val.map(function(m) {
      if (Array.isArray(m) && m.length === 0) {
        return m;
      }
      return _this.castForQuery(null, m, context);
    });
  }
  /*!
   * Module dependencies.
   */
  var MongooseError = require_error2();
  var SchemaTypeOptions = require_schemaTypeOptions();
  var $exists = require_exists();
  var $type = require_type();
  var clone = require_clone2();
  var handleImmutable = require_handleImmutable();
  var isAsyncFunction = require_isAsyncFunction();
  var isSimpleValidator = require_isSimpleValidator();
  var immediate = require_immediate();
  var schemaTypeSymbol = require_symbols().schemaTypeSymbol;
  var utils = require_utils4();
  var validatorErrorSymbol = require_symbols().validatorErrorSymbol;
  var documentIsModified = require_symbols().documentIsModified;
  var populateModelSymbol = require_symbols().populateModelSymbol;
  var CastError = MongooseError.CastError;
  var ValidatorError = MongooseError.ValidatorError;
  var setOptionsForDefaults = { _skipMarkModified: true };
  SchemaType.prototype.OptionsConstructor = SchemaTypeOptions;
  SchemaType.prototype.path;
  SchemaType.prototype.validators;
  SchemaType.prototype.isRequired;
  SchemaType.prototype.splitPath = function() {
    if (this._presplitPath != null) {
      return this._presplitPath;
    }
    if (this.path == null) {
      return;
    }
    this._presplitPath = this.path.indexOf(".") === -1 ? [this.path] : this.path.split(".");
    return this._presplitPath;
  };
  SchemaType.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = (v) => v;
    }
    this._cast = caster;
    return this._cast;
  };
  SchemaType.prototype.castFunction = function castFunction(caster, message) {
    if (arguments.length === 0) {
      return this._castFunction;
    }
    if (caster === false) {
      caster = this.constructor._defaultCaster || ((v) => v);
    }
    if (typeof caster === "string") {
      this._castErrorMessage = caster;
      return this._castFunction;
    }
    if (caster != null) {
      this._castFunction = caster;
    }
    if (message != null) {
      this._castErrorMessage = message;
    }
    return this._castFunction;
  };
  SchemaType.prototype.cast = function cast() {
    throw new Error("Base SchemaType class does not implement a `cast()` function");
  };
  SchemaType.set = function set(option, value) {
    if (!this.hasOwnProperty("defaultOptions")) {
      this.defaultOptions = Object.assign({}, this.defaultOptions);
    }
    this.defaultOptions[option] = value;
  };
  SchemaType.get = function(getter) {
    this.getters = this.hasOwnProperty("getters") ? this.getters : [];
    this.getters.push(getter);
  };
  SchemaType.prototype.default = function(val) {
    if (arguments.length === 1) {
      if (val === undefined) {
        this.defaultValue = undefined;
        return;
      }
      if (val != null && val.instanceOfSchema) {
        throw new MongooseError("Cannot set default value of path `" + this.path + "` to a mongoose Schema instance.");
      }
      this.defaultValue = val;
      return this.defaultValue;
    } else if (arguments.length > 1) {
      this.defaultValue = [...arguments];
    }
    return this.defaultValue;
  };
  SchemaType.prototype.index = function(options) {
    this._index = options;
    utils.expires(this._index);
    return this;
  };
  SchemaType.prototype.unique = function unique(value, message) {
    if (this._index === false) {
      if (!value) {
        return;
      }
      throw new Error('Path "' + this.path + '" may not have `index` set to ' + "false and `unique` set to true");
    }
    if (!this.options.hasOwnProperty("index") && value === false) {
      return this;
    }
    if (this._index == null || this._index === true) {
      this._index = {};
    } else if (typeof this._index === "string") {
      this._index = { type: this._index };
    }
    this._index.unique = !!value;
    if (typeof message === "string") {
      this._duplicateKeyErrorMessage = message;
    }
    return this;
  };
  SchemaType.prototype.text = function(bool) {
    if (this._index === false) {
      if (!bool) {
        return this;
      }
      throw new Error('Path "' + this.path + '" may not have `index` set to ' + "false and `text` set to true");
    }
    if (!this.options.hasOwnProperty("index") && bool === false) {
      return this;
    }
    if (this._index === null || this._index === undefined || typeof this._index === "boolean") {
      this._index = {};
    } else if (typeof this._index === "string") {
      this._index = { type: this._index };
    }
    this._index.text = bool;
    return this;
  };
  SchemaType.prototype.sparse = function(bool) {
    if (this._index === false) {
      if (!bool) {
        return this;
      }
      throw new Error('Path "' + this.path + '" may not have `index` set to ' + "false and `sparse` set to true");
    }
    if (!this.options.hasOwnProperty("index") && bool === false) {
      return this;
    }
    if (this._index == null || typeof this._index === "boolean") {
      this._index = {};
    } else if (typeof this._index === "string") {
      this._index = { type: this._index };
    }
    this._index.sparse = bool;
    return this;
  };
  SchemaType.prototype.immutable = function(bool) {
    this.$immutable = bool;
    handleImmutable(this);
    return this;
  };
  SchemaType.prototype.transform = function(fn) {
    this.options.transform = fn;
    return this;
  };
  SchemaType.prototype.set = function(fn) {
    if (typeof fn !== "function") {
      throw new TypeError("A setter must be a function.");
    }
    this.setters.push(fn);
    return this;
  };
  SchemaType.prototype.get = function(fn) {
    if (typeof fn !== "function") {
      throw new TypeError("A getter must be a function.");
    }
    this.getters.push(fn);
    return this;
  };
  SchemaType.prototype.validateAll = function(validators) {
    for (let i = 0;i < validators.length; i++) {
      this.validate(validators[i]);
    }
    return this;
  };
  SchemaType.prototype.validate = function(obj, message, type) {
    if (typeof obj === "function" || obj && utils.getFunctionName(obj.constructor) === "RegExp") {
      let properties;
      if (typeof message === "function") {
        properties = { validator: obj, message };
        properties.type = type || "user defined";
      } else if (message instanceof Object && !type) {
        properties = isSimpleValidator(message) ? Object.assign({}, message) : clone(message);
        if (!properties.message) {
          properties.message = properties.msg;
        }
        properties.validator = obj;
        properties.type = properties.type || "user defined";
      } else {
        if (message == null) {
          message = MongooseError.messages.general.default;
        }
        if (!type) {
          type = "user defined";
        }
        properties = { message, type, validator: obj };
      }
      this.validators.push(properties);
      return this;
    }
    let i;
    let length;
    let arg;
    for (i = 0, length = arguments.length;i < length; i++) {
      arg = arguments[i];
      if (!utils.isPOJO(arg)) {
        const msg = "Invalid validator. Received (" + typeof arg + ") " + arg + ". See https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.validate()";
        throw new Error(msg);
      }
      this.validate(arg.validator, arg);
    }
    return this;
  };
  SchemaType.prototype.required = function(required, message) {
    let customOptions = {};
    if (arguments.length > 0 && required == null) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.requiredValidator;
      }, this);
      this.isRequired = false;
      delete this.originalRequiredValue;
      return this;
    }
    if (typeof required === "object") {
      customOptions = required;
      message = customOptions.message || message;
      required = required.isRequired;
    }
    if (required === false) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.requiredValidator;
      }, this);
      this.isRequired = false;
      delete this.originalRequiredValue;
      return this;
    }
    const _this = this;
    this.isRequired = true;
    this.requiredValidator = function(v) {
      const cachedRequired = this && this.$__ && this.$__.cachedRequired;
      if (cachedRequired != null && !this.$__isSelected(_this.path) && !this[documentIsModified](_this.path)) {
        return true;
      }
      if (cachedRequired != null && _this.path in cachedRequired) {
        const res = cachedRequired[_this.path] ? _this.checkRequired(v, this) : true;
        delete cachedRequired[_this.path];
        return res;
      } else if (typeof required === "function") {
        return required.apply(this) ? _this.checkRequired(v, this) : true;
      }
      return _this.checkRequired(v, this);
    };
    this.originalRequiredValue = required;
    if (typeof required === "string") {
      message = required;
      required = undefined;
    }
    const msg = message || MongooseError.messages.general.required;
    this.validators.unshift(Object.assign({}, customOptions, {
      validator: this.requiredValidator,
      message: msg,
      type: "required"
    }));
    return this;
  };
  SchemaType.prototype.ref = function(ref) {
    this.options.ref = ref;
    return this;
  };
  SchemaType.prototype.getDefault = function(scope, init, options) {
    let ret;
    if (typeof this.defaultValue === "function") {
      if (this.defaultValue === Date.now || this.defaultValue === Array || this.defaultValue.name.toLowerCase() === "objectid") {
        ret = this.defaultValue.call(scope);
      } else {
        ret = this.defaultValue.call(scope, scope);
      }
    } else {
      ret = this.defaultValue;
    }
    if (ret !== null && ret !== undefined) {
      if (typeof ret === "object" && (!this.options || !this.options.shared)) {
        ret = clone(ret);
      }
      if (options && options.skipCast) {
        return this._applySetters(ret, scope);
      }
      const casted = this.applySetters(ret, scope, init, undefined, setOptionsForDefaults);
      if (casted && !Array.isArray(casted) && casted.$isSingleNested) {
        casted.$__parent = scope;
      }
      return casted;
    }
    return ret;
  };
  SchemaType.prototype._applySetters = function(value, scope, init, priorVal, options) {
    let v = value;
    if (init) {
      return v;
    }
    const setters = this.setters;
    for (let i = setters.length - 1;i >= 0; i--) {
      v = setters[i].call(scope, v, priorVal, this, options);
    }
    return v;
  };
  /*!
   * ignore
   */
  SchemaType.prototype._castNullish = function _castNullish(v) {
    return v;
  };
  SchemaType.prototype.applySetters = function(value, scope, init, priorVal, options) {
    let v = this._applySetters(value, scope, init, priorVal, options);
    if (v == null) {
      return this._castNullish(v);
    }
    v = this.cast(v, scope, init, priorVal, options);
    return v;
  };
  SchemaType.prototype.applyGetters = function(value, scope) {
    let v = value;
    const getters = this.getters;
    const len = getters.length;
    if (len === 0) {
      return v;
    }
    for (let i = 0;i < len; ++i) {
      v = getters[i].call(scope, v, this);
    }
    return v;
  };
  SchemaType.prototype.select = function select(val) {
    this.selected = !!val;
    return this;
  };
  SchemaType.prototype.doValidate = function(value, fn, scope, options) {
    let err = false;
    const path = this.path;
    if (typeof fn !== "function") {
      throw new TypeError(`Must pass callback function to doValidate(), got ${typeof fn}`);
    }
    const validators = this.validators.filter((v) => typeof v === "object" && v !== null);
    let count = validators.length;
    if (!count) {
      return fn(null);
    }
    for (let i = 0, len = validators.length;i < len; ++i) {
      if (err) {
        break;
      }
      const v = validators[i];
      const validator = v.validator;
      let ok;
      const validatorProperties = isSimpleValidator(v) ? Object.assign({}, v) : clone(v);
      validatorProperties.path = options && options.path ? options.path : path;
      validatorProperties.fullPath = this.$fullPath;
      validatorProperties.value = value;
      if (validator instanceof RegExp) {
        validate(validator.test(value), validatorProperties, scope);
        continue;
      }
      if (typeof validator !== "function") {
        continue;
      }
      if (value === undefined && validator !== this.requiredValidator) {
        validate(true, validatorProperties, scope);
        continue;
      }
      try {
        if (validatorProperties.propsParameter) {
          ok = validator.call(scope, value, validatorProperties);
        } else {
          ok = validator.call(scope, value);
        }
      } catch (error) {
        ok = false;
        validatorProperties.reason = error;
        if (error.message) {
          validatorProperties.message = error.message;
        }
      }
      if (ok != null && typeof ok.then === "function") {
        ok.then(function(ok2) {
          validate(ok2, validatorProperties, scope);
        }, function(error) {
          validatorProperties.reason = error;
          validatorProperties.message = error.message;
          ok = false;
          validate(ok, validatorProperties, scope);
        });
      } else {
        validate(ok, validatorProperties, scope);
      }
    }
    function validate(ok, validatorProperties, scope2) {
      if (err) {
        return;
      }
      if (ok === undefined || ok) {
        if (--count <= 0) {
          immediate(function() {
            fn(null);
          });
        }
      } else {
        const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;
        err = new ErrorConstructor(validatorProperties, scope2);
        err[validatorErrorSymbol] = true;
        immediate(function() {
          fn(err);
        });
      }
    }
  };
  SchemaType.prototype.doValidateSync = function(value, scope, options) {
    const path = this.path;
    const count = this.validators.length;
    if (!count) {
      return null;
    }
    let validators = this.validators;
    if (value === undefined) {
      if (this.validators.length !== 0 && this.validators[0].type === "required") {
        validators = [this.validators[0]];
      } else {
        return null;
      }
    }
    let err = null;
    let i = 0;
    const len = validators.length;
    for (i = 0;i < len; ++i) {
      const v = validators[i];
      if (v === null || typeof v !== "object") {
        continue;
      }
      const validator = v.validator;
      const validatorProperties = isSimpleValidator(v) ? Object.assign({}, v) : clone(v);
      validatorProperties.path = options && options.path ? options.path : path;
      validatorProperties.fullPath = this.$fullPath;
      validatorProperties.value = value;
      let ok = false;
      if (isAsyncFunction(validator)) {
        continue;
      }
      if (validator instanceof RegExp) {
        err = _validate(validator.test(value), validatorProperties);
        continue;
      }
      if (typeof validator !== "function") {
        continue;
      }
      try {
        if (validatorProperties.propsParameter) {
          ok = validator.call(scope, value, validatorProperties);
        } else {
          ok = validator.call(scope, value);
        }
      } catch (error) {
        ok = false;
        validatorProperties.reason = error;
      }
      if (ok != null && typeof ok.then === "function") {
        continue;
      }
      err = _validate(ok, validatorProperties);
      if (err) {
        break;
      }
    }
    return err;
  };
  SchemaType._isRef = function(self2, value, doc, init) {
    let ref = init && self2.options && (self2.options.ref || self2.options.refPath);
    if (!ref && doc && doc.$__ != null) {
      const path = doc.$__fullPath(self2.path, true);
      const owner = doc.ownerDocument();
      ref = path != null && owner.$populated(path) || doc.$populated(self2.path);
    }
    if (ref) {
      if (value == null) {
        return true;
      }
      if (!Buffer.isBuffer(value) && value._bsontype !== "Binary" && utils.isObject(value)) {
        return true;
      }
      return init;
    }
    return false;
  };
  /*!
   * ignore
   */
  SchemaType.prototype._castRef = function _castRef(value, doc, init, options) {
    if (value == null) {
      return value;
    }
    if (value.$__ != null) {
      value.$__.wasPopulated = value.$__.wasPopulated || { value: value._doc._id };
      return value;
    }
    if (Buffer.isBuffer(value) || !utils.isObject(value)) {
      if (init) {
        return value;
      }
      throw new CastError(this.instance, value, this.path, null, this);
    }
    const path = doc.$__fullPath(this.path, true);
    const owner = doc.ownerDocument();
    const pop = owner.$populated(path, true);
    let ret = value;
    if (!doc.$__.populated || !doc.$__.populated[path] || !doc.$__.populated[path].options || !doc.$__.populated[path].options.options || !doc.$__.populated[path].options.options.lean) {
      const PopulatedModel = pop ? pop.options[populateModelSymbol] : doc.constructor.db.model(this.options.ref);
      ret = PopulatedModel.hydrate(value, null, options);
      ret.$__.wasPopulated = { value: ret._doc._id, options: { [populateModelSymbol]: PopulatedModel } };
    }
    return ret;
  };
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  SchemaType.prototype.$conditionalHandlers = {
    $all: handleArray,
    $eq: handleSingle,
    $in: handle$in,
    $ne: handleSingle,
    $nin: handle$in,
    $exists,
    $type
  };
  SchemaType.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = this.$conditionalHandlers[$conditional];
      if (!handler) {
        throw new Error("Can\'t use " + $conditional);
      }
      return handler.call(this, val, context);
    }
    try {
      return this.applySetters(val, context);
    } catch (err) {
      if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {
        err.path = this.$fullPath;
      }
      throw err;
    }
  };
  SchemaType.checkRequired = function(fn) {
    if (arguments.length !== 0) {
      this._checkRequired = fn;
    }
    return this._checkRequired;
  };
  SchemaType.prototype.checkRequired = function(val) {
    return val != null;
  };
  SchemaType.prototype.clone = function() {
    const options = Object.assign({}, this.options);
    const schematype = new this.constructor(this.path, options, this.instance);
    schematype.validators = this.validators.slice();
    if (this.requiredValidator !== undefined)
      schematype.requiredValidator = this.requiredValidator;
    if (this.defaultValue !== undefined)
      schematype.defaultValue = this.defaultValue;
    if (this.$immutable !== undefined && this.options.immutable === undefined) {
      schematype.$immutable = this.$immutable;
      handleImmutable(schematype);
    }
    if (this._index !== undefined)
      schematype._index = this._index;
    if (this.selected !== undefined)
      schematype.selected = this.selected;
    if (this.isRequired !== undefined)
      schematype.isRequired = this.isRequired;
    if (this.originalRequiredValue !== undefined)
      schematype.originalRequiredValue = this.originalRequiredValue;
    schematype.getters = this.getters.slice();
    schematype.setters = this.setters.slice();
    return schematype;
  };
  SchemaType.prototype.getEmbeddedSchemaType = function getEmbeddedSchemaType() {
    return this.$embeddedSchemaType;
  };
  /*!
   * If _duplicateKeyErrorMessage is a string, replace unique index errors "E11000 duplicate key error" with this string.
   *
   * @api private
   */
  SchemaType.prototype._duplicateKeyErrorMessage = null;
  SchemaType.prototype.toJSONSchema = function toJSONSchema() {
    throw new Error("Converting unsupported SchemaType to JSON Schema: " + this.instance);
  };
  /*!
   * Module exports.
   */
  module.exports = exports = SchemaType;
  exports.CastError = CastError;
  exports.ValidatorError = ValidatorError;
});

// node_modules/mongoose/lib/options/virtualOptions.js
var require_virtualOptions = __commonJS((exports, module) => {
  var opts = require_propertyOptions();

  class VirtualOptions {
    constructor(obj) {
      Object.assign(this, obj);
      if (obj != null && obj.options != null) {
        this.options = Object.assign({}, obj.options);
      }
    }
  }
  Object.defineProperty(VirtualOptions.prototype, "ref", opts);
  Object.defineProperty(VirtualOptions.prototype, "refPath", opts);
  Object.defineProperty(VirtualOptions.prototype, "localField", opts);
  Object.defineProperty(VirtualOptions.prototype, "foreignField", opts);
  Object.defineProperty(VirtualOptions.prototype, "justOne", opts);
  Object.defineProperty(VirtualOptions.prototype, "count", opts);
  Object.defineProperty(VirtualOptions.prototype, "match", opts);
  Object.defineProperty(VirtualOptions.prototype, "options", opts);
  Object.defineProperty(VirtualOptions.prototype, "skip", opts);
  Object.defineProperty(VirtualOptions.prototype, "limit", opts);
  Object.defineProperty(VirtualOptions.prototype, "perDocumentLimit", opts);
  module.exports = VirtualOptions;
});

// node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js
var require_lookupLocalFields = __commonJS((exports, module) => {
  module.exports = function lookupLocalFields(cur, path, val) {
    if (cur == null) {
      return cur;
    }
    if (cur._doc != null) {
      cur = cur._doc;
    }
    if (arguments.length >= 3) {
      if (typeof cur !== "object") {
        return;
      }
      if (val === undefined) {
        return;
      }
      if (cur instanceof Map) {
        cur.set(path, val);
      } else {
        cur[path] = val;
      }
      return val;
    }
    if (path === "$*") {
      return cur instanceof Map ? Array.from(cur.values()) : Object.keys(cur).map((key) => cur[key]);
    }
    if (cur instanceof Map) {
      return cur.get(path);
    }
    return cur[path];
  };
});

// node_modules/mongoose/lib/helpers/populate/modelNamesFromRefPath.js
var require_modelNamesFromRefPath = __commonJS((exports, module) => {
  var MongooseError = require_mongooseError();
  var isPathExcluded = require_isPathExcluded();
  var lookupLocalFields = require_lookupLocalFields();
  var mpath = require_mpath();
  var util = import.meta.require("util");
  var utils = require_utils4();
  var hasNumericPropRE = /(\.\d+$|\.\d+\.)/g;
  module.exports = function modelNamesFromRefPath(refPath, doc, populatedPath, modelSchema, queryProjection) {
    if (refPath == null) {
      return [];
    }
    if (typeof refPath === "string" && queryProjection != null && isPathExcluded(queryProjection, refPath)) {
      throw new MongooseError("refPath `" + refPath + "` must not be excluded in projection, got " + util.inspect(queryProjection));
    }
    if (hasNumericPropRE.test(populatedPath)) {
      const chunks = populatedPath.split(hasNumericPropRE);
      if (chunks[chunks.length - 1] === "") {
        throw new Error("Can\'t populate individual element in an array");
      }
      let _refPath = "";
      let _remaining = refPath;
      for (let i = 0;i < chunks.length; i += 2) {
        const chunk = chunks[i];
        if (_remaining.startsWith(chunk + ".")) {
          _refPath += _remaining.substring(0, chunk.length) + chunks[i + 1];
          _remaining = _remaining.substring(chunk.length + 1);
        } else if (i === chunks.length - 1) {
          _refPath += _remaining;
          _remaining = "";
          break;
        } else {
          throw new Error("Could not normalize ref path, chunk " + chunk + " not in populated path");
        }
      }
      const refValue2 = mpath.get(_refPath, doc, lookupLocalFields);
      let modelNames2 = Array.isArray(refValue2) ? refValue2 : [refValue2];
      modelNames2 = utils.array.flatten(modelNames2);
      return modelNames2;
    }
    const refValue = mpath.get(refPath, doc, lookupLocalFields);
    let modelNames;
    if (modelSchema != null && modelSchema.virtuals.hasOwnProperty(refPath)) {
      modelNames = [modelSchema.virtuals[refPath].applyGetters(undefined, doc)];
    } else {
      modelNames = Array.isArray(refValue) ? refValue : [refValue];
    }
    return modelNames;
  };
});

// node_modules/mongoose/lib/virtualType.js
var require_virtualType = __commonJS((exports, module) => {
  function VirtualType(options, name) {
    this.path = name;
    this.getters = [];
    this.setters = [];
    this.options = Object.assign({}, options);
  }
  var modelNamesFromRefPath = require_modelNamesFromRefPath();
  var utils = require_utils4();
  var modelSymbol = require_symbols().modelSymbol;
  VirtualType.prototype._applyDefaultGetters = function() {
    if (this.getters.length > 0 || this.setters.length > 0) {
      return;
    }
    const path = this.path;
    const internalProperty = "$" + path;
    this.getters.push(function() {
      return this.$locals[internalProperty];
    });
    this.setters.push(function(v) {
      this.$locals[internalProperty] = v;
    });
  };
  /*!
   * ignore
   */
  VirtualType.prototype.clone = function() {
    const clone = new VirtualType(this.options, this.path);
    clone.getters = [].concat(this.getters);
    clone.setters = [].concat(this.setters);
    return clone;
  };
  VirtualType.prototype.get = function(fn) {
    this.getters.push(fn);
    return this;
  };
  VirtualType.prototype.set = function(fn) {
    this.setters.push(fn);
    return this;
  };
  VirtualType.prototype.applyGetters = function(value, doc) {
    if (utils.hasUserDefinedProperty(this.options, ["ref", "refPath"]) && doc.$$populatedVirtuals && doc.$$populatedVirtuals.hasOwnProperty(this.path)) {
      value = doc.$$populatedVirtuals[this.path];
    }
    let v = value;
    for (const getter of this.getters) {
      v = getter.call(doc, v, this, doc);
    }
    return v;
  };
  VirtualType.prototype.applySetters = function(value, doc) {
    let v = value;
    for (const setter of this.setters) {
      v = setter.call(doc, v, this, doc);
    }
    return v;
  };
  VirtualType.prototype._getModelNamesForPopulate = function _getModelNamesForPopulate(doc) {
    if (this.options.refPath) {
      return modelNamesFromRefPath(this.options.refPath, doc, this.path);
    }
    let normalizedRef = null;
    if (typeof this.options.ref === "function" && !this.options.ref[modelSymbol]) {
      normalizedRef = this.options.ref.call(doc, doc);
    } else {
      normalizedRef = this.options.ref;
    }
    if (normalizedRef != null && !Array.isArray(normalizedRef)) {
      return [normalizedRef];
    }
    return normalizedRef;
  };
  /*!
   * exports
   */
  module.exports = VirtualType;
});

// node_modules/mongoose/lib/helpers/schema/addAutoId.js
var require_addAutoId = __commonJS((exports, module) => {
  module.exports = function addAutoId(schema) {
    const _obj = { _id: { auto: true } };
    _obj._id[schema.options.typeKey] = "ObjectId";
    schema.add(_obj);
  };
});

// node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js
var require_decorateDiscriminatorIndexOptions = __commonJS((exports, module) => {
  module.exports = function decorateDiscriminatorIndexOptions(schema, indexOptions) {
    const discriminatorName = schema.discriminatorMapping && schema.discriminatorMapping.value;
    if (discriminatorName && !("sparse" in indexOptions)) {
      const discriminatorKey = schema.options.discriminatorKey;
      indexOptions.partialFilterExpression = indexOptions.partialFilterExpression || {};
      indexOptions.partialFilterExpression[discriminatorKey] = discriminatorName;
    }
    return indexOptions;
  };
});

// node_modules/mongoose/lib/helpers/schema/getIndexes.js
var require_getIndexes = __commonJS((exports, module) => {
  var get = require_get2();
  var helperIsObject = require_isObject2();
  var decorateDiscriminatorIndexOptions = require_decorateDiscriminatorIndexOptions();
  module.exports = function getIndexes(schema) {
    let indexes = [];
    const schemaStack = new WeakMap;
    const indexTypes = schema.constructor.indexTypes;
    const indexByName = new Map;
    collectIndexes(schema);
    return indexes;
    function collectIndexes(schema2, prefix, baseSchema) {
      if (schemaStack.has(schema2)) {
        return;
      }
      schemaStack.set(schema2, true);
      prefix = prefix || "";
      const keys = Object.keys(schema2.paths);
      for (const key of keys) {
        const path = schema2.paths[key];
        if (baseSchema != null && baseSchema.paths[key]) {
          continue;
        }
        if (path._duplicateKeyErrorMessage != null) {
          schema2._duplicateKeyErrorMessagesByPath = schema2._duplicateKeyErrorMessagesByPath || {};
          schema2._duplicateKeyErrorMessagesByPath[key] = path._duplicateKeyErrorMessage;
        }
        if (path.$isMongooseDocumentArray || path.$isSingleNested) {
          if (get(path, "options.excludeIndexes") !== true && get(path, "schemaOptions.excludeIndexes") !== true && get(path, "schema.options.excludeIndexes") !== true) {
            collectIndexes(path.schema, prefix + key + ".");
          }
          if (path.schema.discriminators != null) {
            const discriminators = path.schema.discriminators;
            const discriminatorKeys = Object.keys(discriminators);
            for (const discriminatorKey of discriminatorKeys) {
              collectIndexes(discriminators[discriminatorKey], prefix + key + ".", path.schema);
            }
          }
          if (path.$isMongooseDocumentArray) {
            continue;
          }
        }
        const index = path._index || path.caster && path.caster._index;
        if (index !== false && index !== null && index !== undefined) {
          const field = {};
          const isObject = helperIsObject(index);
          const options = isObject ? index : {};
          const type = typeof index === "string" ? index : isObject ? index.type : false;
          if (type && indexTypes.indexOf(type) !== -1) {
            field[prefix + key] = type;
          } else if (options.text) {
            field[prefix + key] = "text";
            delete options.text;
          } else {
            let isDescendingIndex = false;
            if (index === "descending" || index === "desc") {
              isDescendingIndex = true;
            } else if (index === "ascending" || index === "asc") {
              isDescendingIndex = false;
            } else {
              isDescendingIndex = Number(index) === -1;
            }
            field[prefix + key] = isDescendingIndex ? -1 : 1;
          }
          delete options.type;
          if (!("background" in options)) {
            options.background = true;
          }
          if (schema2.options.autoIndex != null) {
            options._autoIndex = schema2.options.autoIndex;
          }
          const indexName = options && options.name;
          if (typeof indexName === "string") {
            if (indexByName.has(indexName)) {
              Object.assign(indexByName.get(indexName), field);
            } else {
              indexes.push([field, options]);
              indexByName.set(indexName, field);
            }
          } else {
            indexes.push([field, options]);
            indexByName.set(indexName, field);
          }
        }
      }
      schemaStack.delete(schema2);
      if (prefix) {
        fixSubIndexPaths(schema2, prefix);
      } else {
        schema2._indexes.forEach(function(index) {
          const options = index[1];
          if (!("background" in options)) {
            options.background = true;
          }
          decorateDiscriminatorIndexOptions(schema2, options);
        });
        indexes = indexes.concat(schema2._indexes);
      }
    }
    function fixSubIndexPaths(schema2, prefix) {
      const subindexes = schema2._indexes;
      const len = subindexes.length;
      for (let i = 0;i < len; ++i) {
        const indexObj = subindexes[i][0];
        const indexOptions = subindexes[i][1];
        const keys = Object.keys(indexObj);
        const klen = keys.length;
        const newindex = {};
        for (let j = 0;j < klen; ++j) {
          const key = keys[j];
          newindex[prefix + key] = indexObj[key];
        }
        const newIndexOptions = Object.assign({}, indexOptions);
        if (indexOptions != null && indexOptions.partialFilterExpression != null) {
          newIndexOptions.partialFilterExpression = {};
          const partialFilterExpression = indexOptions.partialFilterExpression;
          for (const key of Object.keys(partialFilterExpression)) {
            newIndexOptions.partialFilterExpression[prefix + key] = partialFilterExpression[key];
          }
        }
        indexes.push([newindex, newIndexOptions]);
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/query/handleReadPreferenceAliases.js
var require_handleReadPreferenceAliases = __commonJS((exports, module) => {
  module.exports = function handleReadPreferenceAliases(pref) {
    switch (pref) {
      case "p":
        pref = "primary";
        break;
      case "pp":
        pref = "primaryPreferred";
        break;
      case "s":
        pref = "secondary";
        break;
      case "sp":
        pref = "secondaryPreferred";
        break;
      case "n":
        pref = "nearest";
        break;
    }
    return pref;
  };
});

// node_modules/mongoose/lib/helpers/schema/idGetter.js
var require_idGetter = __commonJS((exports, module) => {
  function idGetter() {
    if (this._id != null) {
      return this._id.toString();
    }
    return null;
  }
  /*!
   * ignore
   */
  module.exports = function addIdGetter(schema) {
    const autoIdGetter = !schema.paths["id"] && schema.paths["_id"] && schema.options.id;
    if (!autoIdGetter) {
      return schema;
    }
    if (schema.aliases && schema.aliases.id) {
      return schema;
    }
    schema.virtual("id").get(idGetter);
    return schema;
  };
});

// node_modules/mongoose/lib/helpers/indexes/isIndexSpecEqual.js
var require_isIndexSpecEqual = __commonJS((exports, module) => {
  module.exports = function isIndexSpecEqual(spec1, spec2) {
    const spec1Keys = Object.keys(spec1);
    const spec2Keys = Object.keys(spec2);
    if (spec1Keys.length !== spec2Keys.length) {
      return false;
    }
    for (let i = 0;i < spec1Keys.length; i++) {
      const key = spec1Keys[i];
      if (key !== spec2Keys[i] || spec1[key] !== spec2[key]) {
        return false;
      }
    }
    return true;
  };
});

// node_modules/mongoose/lib/helpers/populate/setPopulatedVirtualValue.js
var require_setPopulatedVirtualValue = __commonJS((exports, module) => {
  module.exports = function setPopulatedVirtualValue(populatedVirtuals, name, v, options) {
    if (options.justOne || options.count) {
      populatedVirtuals[name] = Array.isArray(v) ? v[0] : v;
      if (typeof populatedVirtuals[name] !== "object") {
        populatedVirtuals[name] = options.count ? v : null;
      }
    } else {
      populatedVirtuals[name] = Array.isArray(v) ? v : v == null ? [] : [v];
      populatedVirtuals[name] = populatedVirtuals[name].filter(function(doc) {
        return doc && typeof doc === "object";
      });
    }
    return populatedVirtuals[name];
  };
});

// node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js
var require_cleanPositionalOperators = __commonJS((exports, module) => {
  module.exports = function cleanPositionalOperators(path) {
    return path.replace(/\.\$(\[[^\]]*\])?(?=\.)/g, ".0").replace(/\.\$(\[[^\]]*\])?$/g, ".0");
  };
});

// node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js
var require_handleTimestampOption = __commonJS((exports, module) => {
  function handleTimestampOption(arg, prop) {
    if (arg == null) {
      return null;
    }
    if (typeof arg === "boolean") {
      return prop;
    }
    if (typeof arg[prop] === "boolean") {
      return arg[prop] ? prop : null;
    }
    if (!(prop in arg)) {
      return prop;
    }
    return arg[prop];
  }
  module.exports = handleTimestampOption;
  /*!
   * ignore
   */
});

// node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js
var require_applyTimestampsToChildren = __commonJS((exports, module) => {
  function applyTimestampsToChildren(now, update, schema) {
    if (update == null) {
      return;
    }
    const keys = Object.keys(update);
    const hasDollarKey = keys.some((key) => key[0] === "$");
    if (hasDollarKey) {
      if (update.$push) {
        _applyTimestampToUpdateOperator(update.$push);
      }
      if (update.$addToSet) {
        _applyTimestampToUpdateOperator(update.$addToSet);
      }
      if (update.$set != null) {
        const keys2 = Object.keys(update.$set);
        for (const key of keys2) {
          applyTimestampsToUpdateKey(schema, key, update.$set, now);
        }
      }
      if (update.$setOnInsert != null) {
        const keys2 = Object.keys(update.$setOnInsert);
        for (const key of keys2) {
          applyTimestampsToUpdateKey(schema, key, update.$setOnInsert, now);
        }
      }
    }
    const updateKeys = Object.keys(update).filter((key) => key[0] !== "$");
    for (const key of updateKeys) {
      applyTimestampsToUpdateKey(schema, key, update, now);
    }
    function _applyTimestampToUpdateOperator(op) {
      for (const key of Object.keys(op)) {
        const $path = schema.path(key.replace(/\.\$\./i, ".").replace(/.\$$/, ""));
        if (op[key] && $path && $path.$isMongooseDocumentArray && $path.schema.options.timestamps) {
          const timestamps = $path.schema.options.timestamps;
          const createdAt = handleTimestampOption(timestamps, "createdAt");
          const updatedAt = handleTimestampOption(timestamps, "updatedAt");
          if (op[key].$each) {
            op[key].$each.forEach(function(subdoc) {
              if (updatedAt != null) {
                subdoc[updatedAt] = now;
              }
              if (createdAt != null) {
                subdoc[createdAt] = now;
              }
              applyTimestampsToChildren(now, subdoc, $path.schema);
            });
          } else {
            if (updatedAt != null) {
              op[key][updatedAt] = now;
            }
            if (createdAt != null) {
              op[key][createdAt] = now;
            }
            applyTimestampsToChildren(now, op[key], $path.schema);
          }
        }
      }
    }
  }
  function applyTimestampsToDocumentArray(arr, schematype, now) {
    const timestamps = schematype.schema.options.timestamps;
    const len = arr.length;
    if (!timestamps) {
      for (let i = 0;i < len; ++i) {
        applyTimestampsToChildren(now, arr[i], schematype.schema);
      }
      return;
    }
    const createdAt = handleTimestampOption(timestamps, "createdAt");
    const updatedAt = handleTimestampOption(timestamps, "updatedAt");
    for (let i = 0;i < len; ++i) {
      if (updatedAt != null) {
        arr[i][updatedAt] = now;
      }
      if (createdAt != null) {
        arr[i][createdAt] = now;
      }
      applyTimestampsToChildren(now, arr[i], schematype.schema);
    }
  }
  function applyTimestampsToSingleNested(subdoc, schematype, now) {
    const timestamps = schematype.schema.options.timestamps;
    if (!timestamps) {
      applyTimestampsToChildren(now, subdoc, schematype.schema);
      return;
    }
    const createdAt = handleTimestampOption(timestamps, "createdAt");
    const updatedAt = handleTimestampOption(timestamps, "updatedAt");
    if (updatedAt != null) {
      subdoc[updatedAt] = now;
    }
    if (createdAt != null) {
      subdoc[createdAt] = now;
    }
    applyTimestampsToChildren(now, subdoc, schematype.schema);
  }
  function applyTimestampsToUpdateKey(schema, key, update, now) {
    const keyToSearch = cleanPositionalOperators(key);
    const path = schema.path(keyToSearch);
    if (!path) {
      return;
    }
    const parentSchemaTypes = [];
    const pieces = keyToSearch.split(".");
    for (let i = pieces.length - 1;i > 0; --i) {
      const s = schema.path(pieces.slice(0, i).join("."));
      if (s != null && (s.$isMongooseDocumentArray || s.$isSingleNested)) {
        parentSchemaTypes.push({ parentPath: key.split(".").slice(0, i).join("."), parentSchemaType: s });
      }
    }
    if (Array.isArray(update[key]) && path.$isMongooseDocumentArray) {
      applyTimestampsToDocumentArray(update[key], path, now);
    } else if (update[key] && path.$isSingleNested) {
      applyTimestampsToSingleNested(update[key], path, now);
    } else if (parentSchemaTypes.length > 0) {
      for (const item of parentSchemaTypes) {
        const parentPath = item.parentPath;
        const parentSchemaType = item.parentSchemaType;
        const timestamps = parentSchemaType.schema.options.timestamps;
        const updatedAt = handleTimestampOption(timestamps, "updatedAt");
        if (!timestamps || updatedAt == null) {
          continue;
        }
        if (parentSchemaType.$isSingleNested) {
          update[parentPath + "." + updatedAt] = now;
        } else if (parentSchemaType.$isMongooseDocumentArray) {
          let childPath = key.substring(parentPath.length + 1);
          if (/^\d+$/.test(childPath)) {
            update[parentPath + "." + childPath][updatedAt] = now;
            continue;
          }
          const firstDot = childPath.indexOf(".");
          childPath = firstDot !== -1 ? childPath.substring(0, firstDot) : childPath;
          update[parentPath + "." + childPath + "." + updatedAt] = now;
        }
      }
    } else if (path.schema != null && path.schema != schema && update[key]) {
      const timestamps = path.schema.options.timestamps;
      const createdAt = handleTimestampOption(timestamps, "createdAt");
      const updatedAt = handleTimestampOption(timestamps, "updatedAt");
      if (!timestamps) {
        return;
      }
      if (updatedAt != null) {
        update[key][updatedAt] = now;
      }
      if (createdAt != null) {
        update[key][createdAt] = now;
      }
    }
  }
  var cleanPositionalOperators = require_cleanPositionalOperators();
  var handleTimestampOption = require_handleTimestampOption();
  module.exports = applyTimestampsToChildren;
  /*!
   * ignore
   */
});

// node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js
var require_applyTimestampsToUpdate = __commonJS((exports, module) => {
  function applyTimestampsToUpdate(now, createdAt, updatedAt, currentUpdate, options, isReplace) {
    const updates = currentUpdate;
    let _updates = updates;
    const timestamps = get(options, "timestamps", true);
    if (!timestamps || updates == null) {
      return currentUpdate;
    }
    const skipCreatedAt = timestamps != null && timestamps.createdAt === false;
    const skipUpdatedAt = timestamps != null && timestamps.updatedAt === false;
    if (isReplace) {
      if (currentUpdate && currentUpdate.$set) {
        currentUpdate = currentUpdate.$set;
        updates.$set = {};
        _updates = updates.$set;
      }
      if (!skipUpdatedAt && updatedAt && !currentUpdate[updatedAt]) {
        _updates[updatedAt] = now;
      }
      if (!skipCreatedAt && createdAt && !currentUpdate[createdAt]) {
        _updates[createdAt] = now;
      }
      return updates;
    }
    currentUpdate = currentUpdate || {};
    if (Array.isArray(updates)) {
      if (updatedAt == null) {
        return updates;
      }
      updates.push({ $set: { [updatedAt]: now } });
      return updates;
    }
    updates.$set = updates.$set || {};
    if (!skipUpdatedAt && updatedAt && (!currentUpdate.$currentDate || !currentUpdate.$currentDate[updatedAt])) {
      let timestampSet = false;
      if (updatedAt.indexOf(".") !== -1) {
        const pieces = updatedAt.split(".");
        for (let i = 1;i < pieces.length; ++i) {
          const remnant = pieces.slice(-i).join(".");
          const start = pieces.slice(0, -i).join(".");
          if (currentUpdate[start] != null) {
            currentUpdate[start][remnant] = now;
            timestampSet = true;
            break;
          } else if (currentUpdate.$set && currentUpdate.$set[start]) {
            currentUpdate.$set[start][remnant] = now;
            timestampSet = true;
            break;
          }
        }
      }
      if (!timestampSet) {
        updates.$set[updatedAt] = now;
      }
      if (updates.hasOwnProperty(updatedAt)) {
        delete updates[updatedAt];
      }
    }
    if (!skipCreatedAt && createdAt) {
      if (currentUpdate[createdAt]) {
        delete currentUpdate[createdAt];
      }
      if (currentUpdate.$set && currentUpdate.$set[createdAt]) {
        delete currentUpdate.$set[createdAt];
      }
      let timestampSet = false;
      if (createdAt.indexOf(".") !== -1) {
        const pieces = createdAt.split(".");
        for (let i = 1;i < pieces.length; ++i) {
          const remnant = pieces.slice(-i).join(".");
          const start = pieces.slice(0, -i).join(".");
          if (currentUpdate[start] != null) {
            currentUpdate[start][remnant] = now;
            timestampSet = true;
            break;
          } else if (currentUpdate.$set && currentUpdate.$set[start]) {
            currentUpdate.$set[start][remnant] = now;
            timestampSet = true;
            break;
          }
        }
      }
      if (!timestampSet) {
        updates.$setOnInsert = updates.$setOnInsert || {};
        updates.$setOnInsert[createdAt] = now;
      }
    }
    if (Object.keys(updates.$set).length === 0) {
      delete updates.$set;
    }
    return updates;
  }
  /*!
   * ignore
   */
  var get = require_get2();
  module.exports = applyTimestampsToUpdate;
  /*!
   * ignore
   */
});

// node_modules/mongoose/lib/helpers/timestamps/setDocumentTimestamps.js
var require_setDocumentTimestamps = __commonJS((exports, module) => {
  module.exports = function setDocumentTimestamps(doc, timestampOption, currentTime, createdAt, updatedAt) {
    const skipUpdatedAt = timestampOption != null && timestampOption.updatedAt === false;
    const skipCreatedAt = timestampOption != null && timestampOption.createdAt === false;
    const defaultTimestamp = currentTime != null ? currentTime() : doc.ownerDocument().constructor.base.now();
    if (!skipCreatedAt && (doc.isNew || doc.$isSubdocument) && createdAt && !doc.$__getValue(createdAt) && doc.$__isSelected(createdAt)) {
      doc.$set(createdAt, defaultTimestamp, undefined, { overwriteImmutable: true });
    }
    if (!skipUpdatedAt && updatedAt && (doc.isNew || doc.$isModified())) {
      let ts = defaultTimestamp;
      if (doc.isNew && createdAt != null) {
        ts = doc.$__getValue(createdAt);
      }
      doc.$set(updatedAt, ts);
    }
  };
});

// node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js
var require_setupTimestamps = __commonJS((exports, module) => {
  var applyTimestampsToChildren = require_applyTimestampsToChildren();
  var applyTimestampsToUpdate = require_applyTimestampsToUpdate();
  var get = require_get2();
  var handleTimestampOption = require_handleTimestampOption();
  var setDocumentTimestamps = require_setDocumentTimestamps();
  var symbols = require_symbols2();
  var replaceOps = new Set([
    "replaceOne",
    "findOneAndReplace"
  ]);
  module.exports = function setupTimestamps(schema, timestamps) {
    const childHasTimestamp = schema.childSchemas.find(withTimestamp);
    function withTimestamp(s) {
      const ts = s.schema.options.timestamps;
      return !!ts;
    }
    if (!timestamps && !childHasTimestamp) {
      return;
    }
    const createdAt = handleTimestampOption(timestamps, "createdAt");
    const updatedAt = handleTimestampOption(timestamps, "updatedAt");
    const currentTime = timestamps != null && timestamps.hasOwnProperty("currentTime") ? timestamps.currentTime : null;
    const schemaAdditions = {};
    schema.$timestamps = { createdAt, updatedAt };
    if (createdAt && !schema.paths[createdAt]) {
      const baseImmutableCreatedAt = schema.base != null ? schema.base.get("timestamps.createdAt.immutable") : null;
      const immutable = baseImmutableCreatedAt != null ? baseImmutableCreatedAt : true;
      schemaAdditions[createdAt] = { [schema.options.typeKey || "type"]: Date, immutable };
    }
    if (updatedAt && !schema.paths[updatedAt]) {
      schemaAdditions[updatedAt] = Date;
    }
    schema.add(schemaAdditions);
    schema.pre("save", function timestampsPreSave(next) {
      const timestampOption = get(this, "$__.saveOptions.timestamps");
      if (timestampOption === false) {
        return next();
      }
      setDocumentTimestamps(this, timestampOption, currentTime, createdAt, updatedAt);
      next();
    });
    schema.methods.initializeTimestamps = function() {
      const ts = currentTime != null ? currentTime() : this.constructor.base.now();
      if (createdAt && !this.get(createdAt)) {
        this.$set(createdAt, ts);
      }
      if (updatedAt && !this.get(updatedAt)) {
        this.$set(updatedAt, ts);
      }
      if (this.$isSubdocument) {
        return this;
      }
      const subdocs = this.$getAllSubdocs();
      for (const subdoc of subdocs) {
        if (subdoc.initializeTimestamps) {
          subdoc.initializeTimestamps();
        }
      }
      return this;
    };
    _setTimestampsOnUpdate[symbols.builtInMiddleware] = true;
    const opts = { query: true, model: false };
    schema.pre("findOneAndReplace", opts, _setTimestampsOnUpdate);
    schema.pre("findOneAndUpdate", opts, _setTimestampsOnUpdate);
    schema.pre("replaceOne", opts, _setTimestampsOnUpdate);
    schema.pre("update", opts, _setTimestampsOnUpdate);
    schema.pre("updateOne", opts, _setTimestampsOnUpdate);
    schema.pre("updateMany", opts, _setTimestampsOnUpdate);
    function _setTimestampsOnUpdate(next) {
      const now = currentTime != null ? currentTime() : this.model.base.now();
      if (replaceOps.has(this.op) && this.getUpdate() == null) {
        this.setUpdate({});
      }
      applyTimestampsToUpdate(now, createdAt, updatedAt, this.getUpdate(), this._mongooseOptions, replaceOps.has(this.op));
      applyTimestampsToChildren(now, this.getUpdate(), this.model.schema);
      next();
    }
  };
});

// node_modules/mongoose/lib/helpers/populate/validateRef.js
var require_validateRef = __commonJS((exports, module) => {
  function validateRef(ref, path) {
    if (typeof ref === "string") {
      return;
    }
    if (typeof ref === "function") {
      return;
    }
    throw new MongooseError('Invalid ref at path "' + path + '". Got ' + util.inspect(ref, { depth: 0 }));
  }
  var MongooseError = require_mongooseError();
  var util = import.meta.require("util");
  module.exports = validateRef;
});

// node_modules/mongoose/lib/constants.js
var require_constants3 = __commonJS((exports) => {
  /*!
   * ignore
   */
  var queryOperations = Object.freeze([
    "countDocuments",
    "distinct",
    "estimatedDocumentCount",
    "find",
    "findOne",
    "findOneAndReplace",
    "findOneAndUpdate",
    "replaceOne",
    "updateMany",
    "updateOne",
    "deleteMany",
    "deleteOne",
    "findOneAndDelete"
  ]);
  exports.queryOperations = queryOperations;
  /*!
   * ignore
   */
  var queryMiddlewareFunctions = queryOperations.concat([
    "validate"
  ]);
  exports.queryMiddlewareFunctions = queryMiddlewareFunctions;
  /*!
   * ignore
   */
  var aggregateMiddlewareFunctions = [
    "aggregate"
  ];
  exports.aggregateMiddlewareFunctions = aggregateMiddlewareFunctions;
  /*!
   * ignore
   */
  var modelMiddlewareFunctions = [
    "bulkWrite",
    "createCollection",
    "insertMany"
  ];
  exports.modelMiddlewareFunctions = modelMiddlewareFunctions;
  /*!
   * ignore
   */
  var documentMiddlewareFunctions = [
    "validate",
    "save",
    "remove",
    "updateOne",
    "deleteOne",
    "init"
  ];
  exports.documentMiddlewareFunctions = documentMiddlewareFunctions;
});

// node_modules/mongoose/lib/helpers/model/applyHooks.js
var require_applyHooks = __commonJS((exports, module) => {
  function applyHooks(model, schema, options) {
    options = options || {};
    const kareemOptions = {
      useErrorHandlers: true,
      numCallbackParams: 1,
      nullResultByDefault: true,
      contextParameter: true
    };
    const objToDecorate = options.decorateDoc ? model : model.prototype;
    model.$appliedHooks = true;
    for (const key of Object.keys(schema.paths)) {
      const type = schema.paths[key];
      let childModel = null;
      if (type.$isSingleNested) {
        childModel = type.caster;
      } else if (type.$isMongooseDocumentArray) {
        childModel = type.Constructor;
      } else {
        continue;
      }
      if (childModel.$appliedHooks) {
        continue;
      }
      applyHooks(childModel, type.schema, { ...options, isChildSchema: true });
      if (childModel.discriminators != null) {
        const keys = Object.keys(childModel.discriminators);
        for (const key2 of keys) {
          applyHooks(childModel.discriminators[key2], childModel.discriminators[key2].schema, options);
        }
      }
    }
    const middleware = schema.s.hooks.filter((hook) => {
      if (hook.name === "updateOne" || hook.name === "deleteOne") {
        return !!hook["document"];
      }
      if (hook.name === "remove" || hook.name === "init") {
        return hook["document"] == null || !!hook["document"];
      }
      if (hook.query != null || hook.document != null) {
        return hook.document !== false;
      }
      return true;
    }).filter((hook) => {
      if (schema.methods[hook.name]) {
        return !hook.fn[symbols.builtInMiddleware];
      }
      return true;
    });
    model._middleware = middleware;
    objToDecorate.$__originalValidate = objToDecorate.$__originalValidate || objToDecorate.$__validate;
    const internalMethodsToWrap = options && options.isChildSchema ? ["save", "validate", "deleteOne"] : ["save", "validate"];
    for (const method of internalMethodsToWrap) {
      const toWrap = method === "validate" ? "$__originalValidate" : `\$__${method}`;
      const wrapped = middleware.createWrapper(method, objToDecorate[toWrap], null, kareemOptions);
      objToDecorate[`\$__${method}`] = wrapped;
    }
    objToDecorate.$__init = middleware.createWrapperSync("init", objToDecorate.$__init, null, kareemOptions);
    const customMethods = Object.keys(schema.methods);
    const customMethodOptions = Object.assign({}, kareemOptions, {
      checkForPromise: true
    });
    for (const method of customMethods) {
      if (alreadyHookedFunctions.has(method)) {
        continue;
      }
      if (!middleware.hasHooks(method)) {
        continue;
      }
      const originalMethod = objToDecorate[method];
      objToDecorate[method] = function() {
        const args = Array.prototype.slice.call(arguments);
        const cb = args.slice(-1).pop();
        const argsWithoutCallback = typeof cb === "function" ? args.slice(0, args.length - 1) : args;
        return promiseOrCallback(cb, (callback) => {
          return this[`\$__${method}`].apply(this, argsWithoutCallback.concat([callback]));
        }, model.events);
      };
      objToDecorate[`\$__${method}`] = middleware.createWrapper(method, originalMethod, null, customMethodOptions);
    }
  }
  var symbols = require_symbols2();
  var promiseOrCallback = require_promiseOrCallback();
  /*!
   * ignore
   */
  module.exports = applyHooks;
  /*!
   * ignore
   */
  applyHooks.middlewareFunctions = [
    "deleteOne",
    "save",
    "validate",
    "remove",
    "updateOne",
    "init"
  ];
  /*!
   * ignore
   */
  var alreadyHookedFunctions = new Set(applyHooks.middlewareFunctions.flatMap((fn) => [fn, `\$__${fn}`]));
});

// node_modules/mongoose/lib/types/map.js
var require_map2 = __commonJS((exports, module) => {
  function checkValidKey(key) {
    const keyType = typeof key;
    if (keyType !== "string") {
      throw new TypeError(`Mongoose maps only support string keys, got ${keyType}`);
    }
    if (key.startsWith("$")) {
      throw new Error(`Mongoose maps do not support keys that start with "\$", got "${key}"`);
    }
    if (key.includes(".")) {
      throw new Error(`Mongoose maps do not support keys that contain ".", got "${key}"`);
    }
    if (specialProperties.has(key)) {
      throw new Error(`Mongoose maps do not support reserved key name "${key}"`);
    }
  }
  var Mixed = require_mixed();
  var MongooseError = require_mongooseError();
  var clone = require_clone2();
  var deepEqual = require_utils4().deepEqual;
  var getConstructorName = require_getConstructorName();
  var handleSpreadDoc = require_handleSpreadDoc();
  var util = import.meta.require("util");
  var specialProperties = require_specialProperties();
  var isBsonType = require_isBsonType();
  var cleanModifiedSubpaths = require_cleanModifiedSubpaths();
  var populateModelSymbol = require_symbols().populateModelSymbol;
  /*!
   * ignore
   */

  class MongooseMap extends Map {
    constructor(v, path, doc, schemaType) {
      if (getConstructorName(v) === "Object") {
        v = Object.keys(v).reduce((arr, key) => arr.concat([[key, v[key]]]), []);
      }
      super(v);
      this.$__parent = doc != null && doc.$__ != null ? doc : null;
      this.$__path = path;
      this.$__schemaType = schemaType == null ? new Mixed(path) : schemaType;
      this.$__runDeferred();
    }
    $init(key, value) {
      checkValidKey(key);
      super.set(key, value);
      if (value != null && value.$isSingleNested) {
        value.$basePath = this.$__path + "." + key;
      }
    }
    $__set(key, value) {
      super.set(key, value);
    }
    get(key, options) {
      if (isBsonType(key, "ObjectId")) {
        key = key.toString();
      }
      options = options || {};
      if (options.getters === false) {
        return super.get(key);
      }
      return this.$__schemaType.applyGetters(super.get(key), this.$__parent);
    }
    set(key, value) {
      if (isBsonType(key, "ObjectId")) {
        key = key.toString();
      }
      checkValidKey(key);
      value = handleSpreadDoc(value);
      if (this.$__schemaType == null) {
        this.$__deferred = this.$__deferred || [];
        this.$__deferred.push({ key, value });
        return;
      }
      let _fullPath;
      const parent = this.$__parent;
      const populated = parent != null && parent.$__ && parent.$__.populated ? parent.$populated(fullPath.call(this), true) || parent.$populated(this.$__path, true) : null;
      const priorVal = this.get(key);
      if (populated != null) {
        if (this.$__schemaType.$isSingleNested) {
          throw new MongooseError("Cannot manually populate single nested subdoc underneath Map " + `at path "${this.$__path}". Try using an array instead of a Map.`);
        }
        if (Array.isArray(value) && this.$__schemaType.$isMongooseArray) {
          value = value.map((v) => {
            if (v.$__ == null) {
              v = new populated.options[populateModelSymbol](v);
            }
            v.$__.wasPopulated = { value: v._doc._id };
            return v;
          });
        } else if (value != null) {
          if (value.$__ == null) {
            value = new populated.options[populateModelSymbol](value);
          }
          value.$__.wasPopulated = { value: value._doc._id };
        }
      } else {
        try {
          const options = this.$__schemaType.$isMongooseDocumentArray || this.$__schemaType.$isSingleNested ? { path: fullPath.call(this) } : null;
          value = this.$__schemaType.applySetters(value, this.$__parent, false, this.get(key), options);
        } catch (error) {
          if (this.$__parent != null && this.$__parent.$__ != null) {
            this.$__parent.invalidate(fullPath.call(this), error);
            return;
          }
          throw error;
        }
      }
      super.set(key, value);
      if (parent != null && parent.$__ != null && !deepEqual(value, priorVal)) {
        const path = fullPath.call(this);
        parent.markModified(path);
        if (this.$__schemaType.$isMongooseDocumentArray || this.$__schemaType.$isSingleNested) {
          cleanModifiedSubpaths(parent, path);
        }
      }
      function fullPath() {
        if (_fullPath) {
          return _fullPath;
        }
        _fullPath = this.$__path + "." + key;
        return _fullPath;
      }
    }
    clear() {
      super.clear();
      const parent = this.$__parent;
      if (parent != null) {
        parent.markModified(this.$__path);
      }
    }
    delete(key) {
      if (isBsonType(key, "ObjectId")) {
        key = key.toString();
      }
      this.set(key, undefined);
      return super.delete(key);
    }
    toBSON() {
      return new Map(this);
    }
    toObject(options) {
      if (options && options.flattenMaps) {
        const ret = {};
        const keys = this.keys();
        for (const key of keys) {
          ret[key] = clone(this.get(key), options);
        }
        return ret;
      }
      return new Map(this);
    }
    $toObject() {
      return this.constructor.prototype.toObject.apply(this, arguments);
    }
    toJSON(options) {
      if (typeof (options && options.flattenMaps) === "boolean" ? options.flattenMaps : true) {
        const ret = {};
        const keys = this.keys();
        for (const key of keys) {
          ret[key] = clone(this.get(key), options);
        }
        return ret;
      }
      return new Map(this);
    }
    inspect() {
      return new Map(this);
    }
    $__runDeferred() {
      if (!this.$__deferred) {
        return;
      }
      for (const keyValueObject of this.$__deferred) {
        this.set(keyValueObject.key, keyValueObject.value);
      }
      this.$__deferred = null;
    }
  }
  if (util.inspect.custom) {
    Object.defineProperty(MongooseMap.prototype, util.inspect.custom, {
      enumerable: false,
      writable: false,
      configurable: false,
      value: MongooseMap.prototype.inspect
    });
  }
  Object.defineProperty(MongooseMap.prototype, "$__set", {
    enumerable: false,
    writable: true,
    configurable: false
  });
  Object.defineProperty(MongooseMap.prototype, "$__parent", {
    enumerable: false,
    writable: true,
    configurable: false
  });
  Object.defineProperty(MongooseMap.prototype, "$__path", {
    enumerable: false,
    writable: true,
    configurable: false
  });
  Object.defineProperty(MongooseMap.prototype, "$__schemaType", {
    enumerable: false,
    writable: true,
    configurable: false
  });
  Object.defineProperty(MongooseMap.prototype, "$isMongooseMap", {
    enumerable: false,
    writable: false,
    configurable: false,
    value: true
  });
  Object.defineProperty(MongooseMap.prototype, "$__deferredCalls", {
    enumerable: false,
    writable: false,
    configurable: false,
    value: true
  });
  module.exports = MongooseMap;
});

// node_modules/mongoose/lib/types/uuid.js
var require_uuid = __commonJS((exports, module) => {
  module.exports = require_bson().UUID;
});

// node_modules/mongoose/lib/types/index.js
var require_types = __commonJS((exports) => {
  /*!
   * Module exports.
   */
  exports.Array = require_array();
  exports.Buffer = require_buffer();
  exports.Document = exports.Embedded = require_arraySubdocument();
  exports.DocumentArray = require_documentArray();
  exports.Decimal128 = require_decimal128();
  exports.ObjectId = require_objectid();
  exports.Map = require_map2();
  exports.Subdocument = require_subdocument();
  exports.UUID = require_uuid();
});

// node_modules/mongoose/lib/options/schemaArrayOptions.js
var require_schemaArrayOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_schemaTypeOptions();

  class SchemaArrayOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaArrayOptions.prototype, "enum", opts);
  Object.defineProperty(SchemaArrayOptions.prototype, "of", opts);
  Object.defineProperty(SchemaArrayOptions.prototype, "castNonArrays", opts);
  /*!
   * ignore
   */
  module.exports = SchemaArrayOptions;
});

// node_modules/mongoose/lib/helpers/arrayDepth.js
var require_arrayDepth = __commonJS((exports, module) => {
  function arrayDepth(arr) {
    if (!Array.isArray(arr)) {
      return { min: 0, max: 0, containsNonArrayItem: true };
    }
    if (arr.length === 0) {
      return { min: 1, max: 1, containsNonArrayItem: false };
    }
    if (arr.length === 1 && !Array.isArray(arr[0])) {
      return { min: 1, max: 1, containsNonArrayItem: false };
    }
    const res = arrayDepth(arr[0]);
    for (let i = 1;i < arr.length; ++i) {
      const _res = arrayDepth(arr[i]);
      if (_res.min < res.min) {
        res.min = _res.min;
      }
      if (_res.max > res.max) {
        res.max = _res.max;
      }
      res.containsNonArrayItem = res.containsNonArrayItem || _res.containsNonArrayItem;
    }
    res.min = res.min + 1;
    res.max = res.max + 1;
    return res;
  }
  module.exports = arrayDepth;
});

// node_modules/mongoose/lib/cast/number.js
var require_number = __commonJS((exports, module) => {
  var assert = import.meta.require("assert");
  module.exports = function castNumber(val) {
    if (val == null) {
      return val;
    }
    if (val === "") {
      return null;
    }
    if (typeof val === "string" || typeof val === "boolean") {
      val = Number(val);
    }
    assert.ok(!isNaN(val));
    if (val instanceof Number) {
      return val.valueOf();
    }
    if (typeof val === "number") {
      return val;
    }
    if (!Array.isArray(val) && typeof val.valueOf === "function") {
      return Number(val.valueOf());
    }
    if (val.toString && !Array.isArray(val) && val.toString() == Number(val)) {
      return Number(val);
    }
    assert.ok(false);
  };
});

// node_modules/mongoose/lib/helpers/omitUndefined.js
var require_omitUndefined = __commonJS((exports, module) => {
  module.exports = function omitUndefined(val) {
    if (val == null || typeof val !== "object") {
      return val;
    }
    if (Array.isArray(val)) {
      for (let i = val.length - 1;i >= 0; --i) {
        if (val[i] === undefined) {
          val.splice(i, 1);
        }
      }
    }
    for (const key of Object.keys(val)) {
      if (val[key] === undefined) {
        delete val[key];
      }
    }
    return val;
  };
});

// node_modules/mongoose/lib/helpers/query/cast$expr.js
var require_cast$expr = __commonJS((exports, module) => {
  function _castExpression(val, schema, strictQuery) {
    if (isPath(val) || val === null) {
      return val;
    }
    if (val.$cond != null) {
      if (Array.isArray(val.$cond)) {
        val.$cond = val.$cond.map((expr) => _castExpression(expr, schema, strictQuery));
      } else {
        val.$cond.if = _castExpression(val.$cond.if, schema, strictQuery);
        val.$cond.then = _castExpression(val.$cond.then, schema, strictQuery);
        val.$cond.else = _castExpression(val.$cond.else, schema, strictQuery);
      }
    } else if (val.$ifNull != null) {
      val.$ifNull.map((v) => _castExpression(v, schema, strictQuery));
    } else if (val.$switch != null) {
      if (Array.isArray(val.$switch.branches)) {
        val.$switch.branches = val.$switch.branches.map((v) => _castExpression(v, schema, strictQuery));
      }
      if ("default" in val.$switch) {
        val.$switch.default = _castExpression(val.$switch.default, schema, strictQuery);
      }
    }
    const keys = Object.keys(val);
    for (const key of keys) {
      if (booleanComparison.has(key)) {
        val[key] = val[key].map((v) => _castExpression(v, schema, strictQuery));
      } else if (comparisonOperator.has(key)) {
        val[key] = castComparison(val[key], schema, strictQuery);
      } else if (arithmeticOperatorArray.has(key)) {
        val[key] = castArithmetic(val[key], schema, strictQuery);
      } else if (arithmeticOperatorNumber.has(key)) {
        val[key] = castNumberOperator(val[key], schema, strictQuery);
      } else if (expressionOperator.has(key)) {
        val[key] = _castExpression(val[key], schema, strictQuery);
      }
    }
    if (val.$in) {
      val.$in = castIn(val.$in, schema, strictQuery);
    }
    if (val.$size) {
      val.$size = castNumberOperator(val.$size, schema, strictQuery);
    }
    if (val.$round) {
      const $round = val.$round;
      if (!Array.isArray($round) || $round.length < 1 || $round.length > 2) {
        throw new CastError("Array", $round, "$round");
      }
      val.$round = $round.map((v) => castNumberOperator(v, schema, strictQuery));
    }
    omitUndefined(val);
    return val;
  }
  function castNumberOperator(val) {
    if (!isLiteral(val)) {
      return val;
    }
    try {
      return castNumber(val);
    } catch (err) {
      throw new CastError("Number", val);
    }
  }
  function castIn(val, schema, strictQuery) {
    const path = val[1];
    if (!isPath(path)) {
      return val;
    }
    const search = val[0];
    const schematype = schema.path(path.slice(1));
    if (schematype === null) {
      if (strictQuery === false) {
        return val;
      } else if (strictQuery === "throw") {
        throw new StrictModeError("$in");
      }
      return;
    }
    if (!schematype.$isMongooseArray) {
      throw new Error("Path must be an array for $in");
    }
    return [
      schematype.$isMongooseDocumentArray ? schematype.$embeddedSchemaType.cast(search) : schematype.caster.cast(search),
      path
    ];
  }
  function castArithmetic(val) {
    if (!Array.isArray(val)) {
      if (!isLiteral(val)) {
        return val;
      }
      try {
        return castNumber(val);
      } catch (err) {
        throw new CastError("Number", val);
      }
    }
    return val.map((v) => {
      if (!isLiteral(v)) {
        return v;
      }
      try {
        return castNumber(v);
      } catch (err) {
        throw new CastError("Number", v);
      }
    });
  }
  function castComparison(val, schema, strictQuery) {
    if (!Array.isArray(val) || val.length !== 2) {
      throw new Error("Comparison operator must be an array of length 2");
    }
    val[0] = _castExpression(val[0], schema, strictQuery);
    const lhs = val[0];
    if (isLiteral(val[1])) {
      let path = null;
      let schematype = null;
      let caster = null;
      if (isPath(lhs)) {
        path = lhs.slice(1);
        schematype = schema.path(path);
      } else if (typeof lhs === "object" && lhs != null) {
        for (const key of Object.keys(lhs)) {
          if (dateOperators.has(key) && isPath(lhs[key])) {
            path = lhs[key].slice(1) + "." + key;
            caster = castNumber;
          } else if (arrayElementOperators.has(key) && isPath(lhs[key])) {
            path = lhs[key].slice(1) + "." + key;
            schematype = schema.path(lhs[key].slice(1));
            if (schematype != null) {
              if (schematype.$isMongooseDocumentArray) {
                schematype = schematype.$embeddedSchemaType;
              } else if (schematype.$isMongooseArray) {
                schematype = schematype.caster;
              }
            }
          }
        }
      }
      const is$literal = typeof val[1] === "object" && val[1] != null && val[1].$literal != null;
      if (schematype != null) {
        if (is$literal) {
          val[1] = { $literal: schematype.cast(val[1].$literal) };
        } else {
          val[1] = schematype.cast(val[1]);
        }
      } else if (caster != null) {
        if (is$literal) {
          try {
            val[1] = { $literal: caster(val[1].$literal) };
          } catch (err) {
            throw new CastError(caster.name.replace(/^cast/, ""), val[1], path + ".$literal");
          }
        } else {
          try {
            val[1] = caster(val[1]);
          } catch (err) {
            throw new CastError(caster.name.replace(/^cast/, ""), val[1], path);
          }
        }
      } else if (path != null && strictQuery === true) {
        return;
      } else if (path != null && strictQuery === "throw") {
        throw new StrictModeError(path);
      }
    } else {
      val[1] = _castExpression(val[1]);
    }
    return val;
  }
  function isPath(val) {
    return typeof val === "string" && val[0] === "$";
  }
  function isLiteral(val) {
    if (typeof val === "string" && val[0] === "$") {
      return false;
    }
    if (typeof val === "object" && val !== null && Object.keys(val).find((key) => key[0] === "$")) {
      return val.$literal != null;
    }
    return true;
  }
  var CastError = require_cast();
  var StrictModeError = require_strict();
  var castNumber = require_number();
  var omitUndefined = require_omitUndefined();
  var booleanComparison = new Set(["$and", "$or"]);
  var comparisonOperator = new Set(["$cmp", "$eq", "$lt", "$lte", "$gt", "$gte"]);
  var arithmeticOperatorArray = new Set([
    "$multiply",
    "$divide",
    "$log",
    "$mod",
    "$trunc",
    "$avg",
    "$max",
    "$min",
    "$stdDevPop",
    "$stdDevSamp",
    "$sum"
  ]);
  var arithmeticOperatorNumber = new Set([
    "$abs",
    "$exp",
    "$ceil",
    "$floor",
    "$ln",
    "$log10",
    "$sqrt",
    "$sin",
    "$cos",
    "$tan",
    "$asin",
    "$acos",
    "$atan",
    "$atan2",
    "$asinh",
    "$acosh",
    "$atanh",
    "$sinh",
    "$cosh",
    "$tanh",
    "$degreesToRadians",
    "$radiansToDegrees"
  ]);
  var arrayElementOperators = new Set([
    "$arrayElemAt",
    "$first",
    "$last"
  ]);
  var dateOperators = new Set([
    "$year",
    "$month",
    "$week",
    "$dayOfMonth",
    "$dayOfYear",
    "$hour",
    "$minute",
    "$second",
    "$isoDayOfWeek",
    "$isoWeekYear",
    "$isoWeek",
    "$millisecond"
  ]);
  var expressionOperator = new Set(["$not"]);
  module.exports = function cast$expr(val, schema, strictQuery) {
    if (typeof val !== "object" || val === null) {
      throw new Error("`$expr` must be an object");
    }
    return _castExpression(val, schema, strictQuery);
  };
});

// node_modules/mongoose/lib/cast/string.js
var require_string = __commonJS((exports, module) => {
  var CastError = require_cast();
  module.exports = function castString(value, path) {
    if (value == null) {
      return value;
    }
    if (value._id && typeof value._id === "string") {
      return value._id;
    }
    if (value.toString && value.toString !== Object.prototype.toString && !Array.isArray(value)) {
      return value.toString();
    }
    throw new CastError("string", value, path);
  };
});

// node_modules/mongoose/lib/schema/operators/text.js
var require_text = __commonJS((exports, module) => {
  var CastError = require_cast();
  var castBoolean = require_boolean();
  var castString = require_string();
  module.exports = function castTextSearch(val, path) {
    if (val == null || typeof val !== "object") {
      throw new CastError("$text", val, path);
    }
    if (val.$search != null) {
      val.$search = castString(val.$search, path + ".$search");
    }
    if (val.$language != null) {
      val.$language = castString(val.$language, path + ".$language");
    }
    if (val.$caseSensitive != null) {
      val.$caseSensitive = castBoolean(val.$caseSensitive, path + ".$castSensitive");
    }
    if (val.$diacriticSensitive != null) {
      val.$diacriticSensitive = castBoolean(val.$diacriticSensitive, path + ".$diacriticSensitive");
    }
    return val;
  };
});

// node_modules/mongoose/lib/helpers/query/isOperator.js
var require_isOperator = __commonJS((exports, module) => {
  var specialKeys = new Set([
    "$ref",
    "$id",
    "$db"
  ]);
  module.exports = function isOperator(path) {
    return path[0] === "$" && !specialKeys.has(path);
  };
});

// node_modules/mongoose/lib/cast.js
var require_cast2 = __commonJS((exports, module) => {
  function _cast(val, numbertype, context) {
    if (Array.isArray(val)) {
      val.forEach(function(item, i) {
        if (Array.isArray(item) || isObject(item)) {
          return _cast(item, numbertype, context);
        }
        val[i] = numbertype.castForQuery(null, item, context);
      });
    } else {
      const nearKeys = Object.keys(val);
      let nearLen = nearKeys.length;
      while (nearLen--) {
        const nkey = nearKeys[nearLen];
        const item = val[nkey];
        if (Array.isArray(item) || isObject(item)) {
          _cast(item, numbertype, context);
          val[nkey] = item;
        } else {
          val[nkey] = numbertype.castForQuery({ val: item, context });
        }
      }
    }
  }
  function getStrictQuery(queryOptions, schemaUserProvidedOptions, schemaOptions, context) {
    if ("strictQuery" in queryOptions) {
      return queryOptions.strictQuery;
    }
    if ("strictQuery" in schemaUserProvidedOptions) {
      return schemaUserProvidedOptions.strictQuery;
    }
    const mongooseOptions = context && context.mongooseCollection && context.mongooseCollection.conn && context.mongooseCollection.conn.base && context.mongooseCollection.conn.base.options;
    if (mongooseOptions) {
      if ("strictQuery" in mongooseOptions) {
        return mongooseOptions.strictQuery;
      }
    }
    return schemaOptions.strictQuery;
  }
  /*!
   * Module dependencies.
   */
  var CastError = require_cast();
  var StrictModeError = require_strict();
  var Types = require_schema();
  var cast$expr = require_cast$expr();
  var castString = require_string();
  var castTextSearch = require_text();
  var get = require_get2();
  var getSchemaDiscriminatorByValue = require_getSchemaDiscriminatorByValue();
  var isOperator = require_isOperator();
  var util = import.meta.require("util");
  var isObject = require_isObject2();
  var isMongooseObject = require_isMongooseObject();
  var utils = require_utils4();
  var ALLOWED_GEOWITHIN_GEOJSON_TYPES = ["Polygon", "MultiPolygon"];
  module.exports = function cast(schema, obj, options, context) {
    if (Array.isArray(obj)) {
      throw new Error("Query filter must be an object, got an array ", util.inspect(obj));
    }
    if (obj == null) {
      return obj;
    }
    if (schema != null && schema.discriminators != null && obj[schema.options.discriminatorKey] != null) {
      schema = getSchemaDiscriminatorByValue(schema, obj[schema.options.discriminatorKey]) || schema;
    }
    const paths = Object.keys(obj);
    let i = paths.length;
    let _keys;
    let any$conditionals;
    let schematype;
    let nested;
    let path;
    let type;
    let val;
    options = options || {};
    while (i--) {
      path = paths[i];
      val = obj[path];
      if (path === "$or" || path === "$nor" || path === "$and") {
        if (!Array.isArray(val)) {
          throw new CastError("Array", val, path);
        }
        for (let k = val.length - 1;k >= 0; k--) {
          if (val[k] == null || typeof val[k] !== "object") {
            throw new CastError("Object", val[k], path + "." + k);
          }
          const beforeCastKeysLength = Object.keys(val[k]).length;
          const discriminatorValue = val[k][schema.options.discriminatorKey];
          if (discriminatorValue == null) {
            val[k] = cast(schema, val[k], options, context);
          } else {
            const discriminatorSchema = getSchemaDiscriminatorByValue(context.schema, discriminatorValue);
            val[k] = cast(discriminatorSchema ? discriminatorSchema : schema, val[k], options, context);
          }
          if (Object.keys(val[k]).length === 0 && beforeCastKeysLength !== 0) {
            val.splice(k, 1);
          }
        }
        if (val.length === 0) {
          delete obj[path];
        }
      } else if (path === "$where") {
        type = typeof val;
        if (type !== "string" && type !== "function") {
          throw new Error("Must have a string or function for $where");
        }
        if (type === "function") {
          obj[path] = val.toString();
        }
        continue;
      } else if (path === "$expr") {
        val = cast$expr(val, schema);
        continue;
      } else if (path === "$elemMatch") {
        val = cast(schema, val, options, context);
      } else if (path === "$text") {
        val = castTextSearch(val, path);
      } else if (path === "$comment" && !schema.paths.hasOwnProperty("$comment")) {
        val = castString(val, path);
        obj[path] = val;
      } else {
        if (!schema) {
          continue;
        }
        schematype = schema.path(path);
        if (!schematype) {
          const split = path.split(".");
          let j = split.length;
          while (j--) {
            const pathFirstHalf = split.slice(0, j).join(".");
            const pathLastHalf = split.slice(j).join(".");
            const _schematype = schema.path(pathFirstHalf);
            const discriminatorKey = _schematype && _schematype.schema && _schematype.schema.options && _schematype.schema.options.discriminatorKey;
            if (_schematype != null && (_schematype.schema && _schematype.schema.discriminators) != null && discriminatorKey != null && pathLastHalf !== discriminatorKey) {
              const discriminatorVal = get(obj, pathFirstHalf + "." + discriminatorKey);
              const discriminators = _schematype.schema.discriminators;
              if (typeof discriminatorVal === "string" && discriminators[discriminatorVal] != null) {
                schematype = discriminators[discriminatorVal].path(pathLastHalf);
              } else if (discriminatorVal != null && Object.keys(discriminatorVal).length === 1 && Array.isArray(discriminatorVal.$in) && discriminatorVal.$in.length === 1 && typeof discriminatorVal.$in[0] === "string" && discriminators[discriminatorVal.$in[0]] != null) {
                schematype = discriminators[discriminatorVal.$in[0]].path(pathLastHalf);
              }
            }
          }
        }
        if (!schematype) {
          const split = path.split(".");
          let j = split.length;
          let pathFirstHalf;
          let pathLastHalf;
          let remainingConds;
          while (j--) {
            pathFirstHalf = split.slice(0, j).join(".");
            schematype = schema.path(pathFirstHalf);
            if (schematype) {
              break;
            }
          }
          if (schematype) {
            if (schematype.caster && schematype.caster.schema) {
              remainingConds = {};
              pathLastHalf = split.slice(j).join(".");
              remainingConds[pathLastHalf] = val;
              const ret = cast(schematype.caster.schema, remainingConds, options, context)[pathLastHalf];
              if (ret === undefined) {
                delete obj[path];
              } else {
                obj[path] = ret;
              }
            } else {
              obj[path] = val;
            }
            continue;
          }
          if (isObject(val)) {
            let geo = "";
            if (val.$near) {
              geo = "$near";
            } else if (val.$nearSphere) {
              geo = "$nearSphere";
            } else if (val.$within) {
              geo = "$within";
            } else if (val.$geoIntersects) {
              geo = "$geoIntersects";
            } else if (val.$geoWithin) {
              geo = "$geoWithin";
            }
            if (geo) {
              const numbertype = new Types.Number("__QueryCasting__");
              let value = val[geo];
              if (val.$maxDistance != null) {
                val.$maxDistance = numbertype.castForQuery(null, val.$maxDistance, context);
              }
              if (val.$minDistance != null) {
                val.$minDistance = numbertype.castForQuery(null, val.$minDistance, context);
              }
              if (geo === "$within") {
                const withinType = value.$center || value.$centerSphere || value.$box || value.$polygon;
                if (!withinType) {
                  throw new Error("Bad $within parameter: " + JSON.stringify(val));
                }
                value = withinType;
              } else if (geo === "$near" && typeof value.type === "string" && Array.isArray(value.coordinates)) {
                value = value.coordinates;
              } else if ((geo === "$near" || geo === "$nearSphere" || geo === "$geoIntersects") && value.$geometry && typeof value.$geometry.type === "string" && Array.isArray(value.$geometry.coordinates)) {
                if (value.$maxDistance != null) {
                  value.$maxDistance = numbertype.castForQuery(null, value.$maxDistance, context);
                }
                if (value.$minDistance != null) {
                  value.$minDistance = numbertype.castForQuery(null, value.$minDistance, context);
                }
                if (isMongooseObject(value.$geometry)) {
                  value.$geometry = value.$geometry.toObject({
                    transform: false,
                    virtuals: false
                  });
                }
                value = value.$geometry.coordinates;
              } else if (geo === "$geoWithin") {
                if (value.$geometry) {
                  if (isMongooseObject(value.$geometry)) {
                    value.$geometry = value.$geometry.toObject({ virtuals: false });
                  }
                  const geoWithinType = value.$geometry.type;
                  if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {
                    throw new Error('Invalid geoJSON type for $geoWithin "' + geoWithinType + '", must be "Polygon" or "MultiPolygon"');
                  }
                  value = value.$geometry.coordinates;
                } else {
                  value = value.$box || value.$polygon || value.$center || value.$centerSphere;
                  if (isMongooseObject(value)) {
                    value = value.toObject({ virtuals: false });
                  }
                }
              }
              _cast(value, numbertype, context);
              continue;
            }
          }
          if (schema.nested[path]) {
            continue;
          }
          const strict = "strict" in options ? options.strict : schema.options.strict;
          const strictQuery = getStrictQuery(options, schema._userProvidedOptions, schema.options, context);
          if (options.upsert && strict) {
            if (strict === "throw") {
              throw new StrictModeError(path);
            }
            throw new StrictModeError(path, 'Path "' + path + '" is not in ' + "schema, strict mode is `true`, and upsert is `true`.");
          }
          if (strictQuery === "throw") {
            throw new StrictModeError(path, 'Path "' + path + '" is not in ' + "schema and strictQuery is \'throw\'.");
          } else if (strictQuery) {
            delete obj[path];
          }
        } else if (val == null) {
          continue;
        } else if (utils.isPOJO(val)) {
          any$conditionals = Object.keys(val).some(isOperator);
          if (!any$conditionals) {
            obj[path] = schematype.castForQuery(null, val, context);
          } else {
            const ks = Object.keys(val);
            let $cond;
            let k = ks.length;
            while (k--) {
              $cond = ks[k];
              nested = val[$cond];
              if ($cond === "$elemMatch") {
                if (nested && schematype != null && schematype.schema != null) {
                  cast(schematype.schema, nested, options, context);
                } else if (nested && schematype != null && schematype.$isMongooseArray) {
                  if (utils.isPOJO(nested) && nested.$not != null) {
                    cast(schema, nested, options, context);
                  } else {
                    val[$cond] = schematype.castForQuery($cond, nested, context);
                  }
                }
              } else if ($cond === "$not") {
                if (nested && schematype) {
                  _keys = Object.keys(nested);
                  if (_keys.length && isOperator(_keys[0])) {
                    for (const key in nested) {
                      nested[key] = schematype.castForQuery(key, nested[key], context);
                    }
                  } else {
                    val[$cond] = schematype.castForQuery($cond, nested, context);
                  }
                  continue;
                }
              } else {
                val[$cond] = schematype.castForQuery($cond, nested, context);
              }
            }
          }
        } else if (Array.isArray(val) && ["Buffer", "Array"].indexOf(schematype.instance) === -1 && !options.sanitizeFilter) {
          const casted = [];
          const valuesArray = val;
          for (const _val of valuesArray) {
            casted.push(schematype.castForQuery(null, _val, context));
          }
          obj[path] = { $in: casted };
        } else {
          obj[path] = schematype.castForQuery(null, val, context);
        }
      }
    }
    return obj;
  };
});

// node_modules/mongoose/lib/options/schemaNumberOptions.js
var require_schemaNumberOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_schemaTypeOptions();

  class SchemaNumberOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaNumberOptions.prototype, "min", opts);
  Object.defineProperty(SchemaNumberOptions.prototype, "max", opts);
  Object.defineProperty(SchemaNumberOptions.prototype, "enum", opts);
  Object.defineProperty(SchemaNumberOptions.prototype, "populate", opts);
  /*!
   * ignore
   */
  module.exports = SchemaNumberOptions;
});

// node_modules/mongoose/lib/helpers/createJSONSchemaTypeDefinition.js
var require_createJSONSchemaTypeDefinition = __commonJS((exports, module) => {
  module.exports = function createJSONSchemaTypeArray(type, bsonType, useBsonType, isRequired) {
    if (useBsonType) {
      if (isRequired) {
        return { bsonType };
      }
      return { bsonType: [bsonType, "null"] };
    } else {
      if (isRequired) {
        return { type };
      }
      return { type: [type, "null"] };
    }
  };
});

// node_modules/mongoose/lib/schema/operators/bitwise.js
var require_bitwise = __commonJS((exports, module) => {
  function handleBitwiseOperator(val) {
    const _this = this;
    if (Array.isArray(val)) {
      return val.map(function(v) {
        return _castNumber(_this.path, v);
      });
    } else if (Buffer.isBuffer(val)) {
      return val;
    }
    return _castNumber(_this.path, val);
  }
  function _castNumber(path, num) {
    const v = Number(num);
    if (isNaN(v)) {
      throw new CastError("number", num, path);
    }
    return v;
  }
  /*!
   * Module requirements.
   */
  var CastError = require_cast();
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  module.exports = handleBitwiseOperator;
});

// node_modules/mongoose/lib/schema/number.js
var require_number2 = __commonJS((exports, module) => {
  function SchemaNumber(key, options) {
    SchemaType.call(this, key, options, "Number");
  }
  function handleSingle(val) {
    return this.cast(val);
  }
  function handleArray(val) {
    const _this = this;
    if (!Array.isArray(val)) {
      return [this.cast(val)];
    }
    return val.map(function(m) {
      return _this.cast(m);
    });
  }
  /*!
   * Module requirements.
   */
  var MongooseError = require_error2();
  var SchemaNumberOptions = require_schemaNumberOptions();
  var SchemaType = require_schemaType();
  var castNumber = require_number();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  var handleBitwiseOperator = require_bitwise();
  var utils = require_utils4();
  var CastError = SchemaType.CastError;
  SchemaNumber.get = SchemaType.get;
  SchemaNumber.set = SchemaType.set;
  SchemaNumber.setters = [];
  /*!
   * ignore
   */
  SchemaNumber._cast = castNumber;
  SchemaNumber.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaNumber._defaultCaster = (v) => {
    if (typeof v !== "number") {
      throw new Error;
    }
    return v;
  };
  SchemaNumber.schemaName = "Number";
  SchemaNumber.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaNumber.prototype = Object.create(SchemaType.prototype);
  SchemaNumber.prototype.constructor = SchemaNumber;
  SchemaNumber.prototype.OptionsConstructor = SchemaNumberOptions;
  /*!
   * ignore
   */
  SchemaNumber._checkRequired = (v) => typeof v === "number" || v instanceof Number;
  SchemaNumber.checkRequired = SchemaType.checkRequired;
  SchemaNumber.prototype.checkRequired = function checkRequired(value, doc) {
    if (typeof value === "object" && SchemaType._isRef(this, value, doc, true)) {
      return value != null;
    }
    const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : SchemaNumber.checkRequired();
    return _checkRequired(value);
  };
  SchemaNumber.prototype.min = function(value, message) {
    if (this.minValidator) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.minValidator;
      }, this);
    }
    if (value !== null && value !== undefined) {
      let msg = message || MongooseError.messages.Number.min;
      msg = msg.replace(/{MIN}/, value);
      this.validators.push({
        validator: this.minValidator = function(v) {
          return v == null || v >= value;
        },
        message: msg,
        type: "min",
        min: value
      });
    }
    return this;
  };
  SchemaNumber.prototype.max = function(value, message) {
    if (this.maxValidator) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.maxValidator;
      }, this);
    }
    if (value !== null && value !== undefined) {
      let msg = message || MongooseError.messages.Number.max;
      msg = msg.replace(/{MAX}/, value);
      this.validators.push({
        validator: this.maxValidator = function(v) {
          return v == null || v <= value;
        },
        message: msg,
        type: "max",
        max: value
      });
    }
    return this;
  };
  SchemaNumber.prototype.enum = function(values, message) {
    if (this.enumValidator) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.enumValidator;
      }, this);
    }
    if (!Array.isArray(values)) {
      const isObjectSyntax = utils.isPOJO(values) && values.values != null;
      if (isObjectSyntax) {
        message = values.message;
        values = values.values;
      } else if (typeof values === "number") {
        values = Array.prototype.slice.call(arguments);
        message = null;
      }
      if (utils.isPOJO(values)) {
        values = Object.values(values);
      }
      message = message || MongooseError.messages.Number.enum;
    }
    message = message == null ? MongooseError.messages.Number.enum : message;
    this.enumValidator = (v) => v == null || values.indexOf(v) !== -1;
    this.validators.push({
      validator: this.enumValidator,
      message,
      type: "enum",
      enumValues: values
    });
    return this;
  };
  SchemaNumber.prototype.cast = function(value, doc, init, prev, options) {
    if (typeof value !== "number" && SchemaType._isRef(this, value, doc, init)) {
      if (value == null || utils.isNonBuiltinObject(value)) {
        return this._castRef(value, doc, init, options);
      }
    }
    const val = value && typeof value._id !== "undefined" ? value._id : value;
    let castNumber2;
    if (typeof this._castFunction === "function") {
      castNumber2 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castNumber2 = this.constructor.cast();
    } else {
      castNumber2 = SchemaNumber.cast();
    }
    try {
      return castNumber2(val);
    } catch (err) {
      throw new CastError("Number", val, this.path, err, this);
    }
  };
  /*!
   * ignore
   */
  SchemaNumber.prototype.$conditionalHandlers = {
    ...SchemaType.prototype.$conditionalHandlers,
    $bitsAllClear: handleBitwiseOperator,
    $bitsAnyClear: handleBitwiseOperator,
    $bitsAllSet: handleBitwiseOperator,
    $bitsAnySet: handleBitwiseOperator,
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle,
    $mod: handleArray
  };
  SchemaNumber.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = this.$conditionalHandlers[$conditional];
      if (!handler) {
        throw new CastError("number", val, this.path, null, this);
      }
      return handler.call(this, val, context);
    }
    try {
      val = this.applySetters(val, context);
    } catch (err) {
      if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {
        err.path = this.$fullPath;
      }
      throw err;
    }
    return val;
  };
  SchemaNumber.prototype.toJSONSchema = function toJSONSchema(options) {
    const isRequired = this.options.required && typeof this.options.required !== "function" || this.path === "_id";
    return createJSONSchemaTypeDefinition("number", "number", options?.useBsonType, isRequired);
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaNumber;
});

// node_modules/mongoose/lib/schema/operators/helpers.js
var require_helpers = __commonJS((exports) => {
  function castToNumber(val) {
    return SchemaNumber.cast()(val);
  }
  function castArraysOfNumbers(arr, self2) {
    arr.forEach(function(v, i) {
      if (Array.isArray(v)) {
        castArraysOfNumbers(v, self2);
      } else {
        arr[i] = castToNumber.call(self2, v);
      }
    });
  }
  /*!
   * Module requirements.
   */
  var SchemaNumber = require_number2();
  /*!
   * ignore
   */
  exports.castToNumber = castToNumber;
  exports.castArraysOfNumbers = castArraysOfNumbers;
  /*!
   * ignore
   */
});

// node_modules/mongoose/lib/schema/operators/geospatial.js
var require_geospatial = __commonJS((exports) => {
  function cast$near(val) {
    const SchemaArray = require_array2();
    if (Array.isArray(val)) {
      castArraysOfNumbers(val, this);
      return val;
    }
    _castMinMaxDistance(this, val);
    if (val && val.$geometry) {
      return cast$geometry(val, this);
    }
    if (!Array.isArray(val)) {
      throw new TypeError("$near must be either an array or an object " + "with a $geometry property");
    }
    return SchemaArray.prototype.castForQuery.call(this, null, val);
  }
  function cast$geometry(val, self2) {
    switch (val.$geometry.type) {
      case "Polygon":
      case "LineString":
      case "Point":
        castArraysOfNumbers(val.$geometry.coordinates, self2);
        break;
      default:
        break;
    }
    _castMinMaxDistance(self2, val);
    return val;
  }
  function cast$within(val) {
    _castMinMaxDistance(this, val);
    if (val.$box || val.$polygon) {
      const type = val.$box ? "$box" : "$polygon";
      val[type].forEach((arr) => {
        if (!Array.isArray(arr)) {
          const msg = "Invalid $within $box argument. " + "Expected an array, received " + arr;
          throw new TypeError(msg);
        }
        arr.forEach((v, i) => {
          arr[i] = castToNumber.call(this, v);
        });
      });
    } else if (val.$center || val.$centerSphere) {
      const type = val.$center ? "$center" : "$centerSphere";
      val[type].forEach((item, i) => {
        if (Array.isArray(item)) {
          item.forEach((v, j) => {
            item[j] = castToNumber.call(this, v);
          });
        } else {
          val[type][i] = castToNumber.call(this, item);
        }
      });
    } else if (val.$geometry) {
      cast$geometry(val, this);
    }
    return val;
  }
  function cast$geoIntersects(val) {
    const geo = val.$geometry;
    if (!geo) {
      return;
    }
    cast$geometry(val, this);
    return val;
  }
  function _castMinMaxDistance(self2, val) {
    if (val.$maxDistance) {
      val.$maxDistance = castToNumber.call(self2, val.$maxDistance);
    }
    if (val.$minDistance) {
      val.$minDistance = castToNumber.call(self2, val.$minDistance);
    }
  }
  /*!
   * Module requirements.
   */
  var castArraysOfNumbers = require_helpers().castArraysOfNumbers;
  var castToNumber = require_helpers().castToNumber;
  /*!
   * ignore
   */
  exports.cast$geoIntersects = cast$geoIntersects;
  exports.cast$near = cast$near;
  exports.cast$within = cast$within;
});

// node_modules/mongoose/lib/schema/array.js
var require_array2 = __commonJS((exports, module) => {
  function SchemaArray(key, cast2, options, schemaOptions) {
    EmbeddedDoc || (EmbeddedDoc = require_types().Embedded);
    let typeKey = "type";
    if (schemaOptions && schemaOptions.typeKey) {
      typeKey = schemaOptions.typeKey;
    }
    this.schemaOptions = schemaOptions;
    if (cast2) {
      let castOptions = {};
      if (utils.isPOJO(cast2)) {
        if (cast2[typeKey]) {
          castOptions = clone(cast2);
          delete castOptions[typeKey];
          cast2 = cast2[typeKey];
        } else {
          cast2 = Mixed;
        }
      }
      if (options != null && options.ref != null && castOptions.ref == null) {
        castOptions.ref = options.ref;
      }
      if (cast2 === Object) {
        cast2 = Mixed;
      }
      const name = typeof cast2 === "string" ? cast2 : utils.getFunctionName(cast2);
      const Types = require_schema();
      const caster = Types.hasOwnProperty(name) ? Types[name] : cast2;
      this.casterConstructor = caster;
      if (this.casterConstructor instanceof SchemaArray) {
        this.casterConstructor[isNestedArraySymbol] = true;
      }
      if (typeof caster === "function" && !caster.$isArraySubdocument && !caster.$isSchemaMap) {
        const path = this.caster instanceof EmbeddedDoc ? null : key;
        this.caster = new caster(path, castOptions);
      } else {
        this.caster = caster;
        if (!(this.caster instanceof EmbeddedDoc)) {
          this.caster.path = key;
        }
      }
      this.$embeddedSchemaType = this.caster;
    }
    this.$isMongooseArray = true;
    SchemaType.call(this, key, options, "Array");
    let defaultArr;
    let fn;
    if (this.defaultValue != null) {
      defaultArr = this.defaultValue;
      fn = typeof defaultArr === "function";
    }
    if (!("defaultValue" in this) || this.defaultValue != null) {
      const defaultFn = function() {
        return fn ? defaultArr.call(this) : defaultArr != null ? [].concat(defaultArr) : [];
      };
      defaultFn.$runBeforeSetters = !fn;
      this.default(defaultFn);
    }
  }
  function cast$all(val, context) {
    if (!Array.isArray(val)) {
      val = [val];
    }
    val = val.map((v) => {
      if (!utils.isObject(v)) {
        return v;
      }
      if (v.$elemMatch != null) {
        return { $elemMatch: cast(this.casterConstructor.schema, v.$elemMatch, null, this && this.$$context) };
      }
      const o = {};
      o[this.path] = v;
      return cast(this.casterConstructor.schema, o, null, this && this.$$context)[this.path];
    }, this);
    return this.castForQuery(null, val, context);
  }
  function cast$elemMatch(val, context) {
    const keys = Object.keys(val);
    const numKeys = keys.length;
    for (let i = 0;i < numKeys; ++i) {
      const key = keys[i];
      const value = val[key];
      if (isOperator(key) && value != null) {
        val[key] = this.castForQuery(key, value, context);
      }
    }
    return val;
  }
  function createLogicalQueryOperatorHandler(op) {
    return function logicalQueryOperatorHandler(val, context) {
      if (!Array.isArray(val)) {
        throw new TypeError("conditional " + op + " requires an array");
      }
      const ret = [];
      for (const obj of val) {
        ret.push(cast(this.casterConstructor.schema ?? context.schema, obj, null, this && this.$$context));
      }
      return ret;
    };
  }
  /*!
   * Module dependencies.
   */
  var $exists = require_exists();
  var $type = require_type();
  var MongooseError = require_mongooseError();
  var SchemaArrayOptions = require_schemaArrayOptions();
  var SchemaType = require_schemaType();
  var CastError = SchemaType.CastError;
  var Mixed = require_mixed();
  var VirtualOptions = require_virtualOptions();
  var VirtualType = require_virtualType();
  var arrayDepth = require_arrayDepth();
  var cast = require_cast2();
  var clone = require_clone2();
  var getConstructorName = require_getConstructorName();
  var isOperator = require_isOperator();
  var util = import.meta.require("util");
  var utils = require_utils4();
  var castToNumber = require_helpers().castToNumber;
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  var geospatial = require_geospatial();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var MongooseArray;
  var EmbeddedDoc;
  var isNestedArraySymbol = Symbol("mongoose#isNestedArray");
  var emptyOpts = Object.freeze({});
  SchemaArray.schemaName = "Array";
  SchemaArray.options = { castNonArrays: true };
  /*!
   * ignore
   */
  SchemaArray.defaultOptions = {};
  SchemaArray.set = SchemaType.set;
  SchemaArray.setters = [];
  SchemaArray.get = SchemaType.get;
  /*!
   * Inherits from SchemaType.
   */
  SchemaArray.prototype = Object.create(SchemaType.prototype);
  SchemaArray.prototype.constructor = SchemaArray;
  SchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;
  /*!
   * ignore
   */
  SchemaArray._checkRequired = SchemaType.prototype.checkRequired;
  SchemaArray.checkRequired = SchemaType.checkRequired;
  /*!
   * Virtuals defined on this array itself.
   */
  SchemaArray.prototype.virtuals = null;
  SchemaArray.prototype.checkRequired = function checkRequired(value, doc) {
    if (typeof value === "object" && SchemaType._isRef(this, value, doc, true)) {
      return !!value;
    }
    const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : SchemaArray.checkRequired();
    return _checkRequired(value);
  };
  SchemaArray.prototype.enum = function() {
    let arr = this;
    while (true) {
      const instance = arr && arr.caster && arr.caster.instance;
      if (instance === "Array") {
        arr = arr.caster;
        continue;
      }
      if (instance !== "String" && instance !== "Number") {
        throw new Error("`enum` can only be set on an array of strings or numbers " + ", not " + instance);
      }
      break;
    }
    let enumArray = arguments;
    if (!Array.isArray(arguments) && utils.isObject(arguments)) {
      enumArray = utils.object.vals(enumArray);
    }
    arr.caster.enum.apply(arr.caster, enumArray);
    return this;
  };
  SchemaArray.prototype.applyGetters = function(value, scope) {
    if (scope != null && scope.$__ != null && scope.$populated(this.path)) {
      return value;
    }
    const ret = SchemaType.prototype.applyGetters.call(this, value, scope);
    return ret;
  };
  SchemaArray.prototype._applySetters = function(value, scope, init, priorVal) {
    if (this.casterConstructor.$isMongooseArray && SchemaArray.options.castNonArrays && !this[isNestedArraySymbol]) {
      let depth = 0;
      let arr = this;
      while (arr != null && arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {
        ++depth;
        arr = arr.casterConstructor;
      }
      if (value != null && value.length !== 0) {
        const valueDepth = arrayDepth(value);
        if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {
          for (let i = valueDepth.max;i < depth; ++i) {
            value = [value];
          }
        }
      }
    }
    return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);
  };
  SchemaArray.prototype.cast = function(value, doc, init, prev, options) {
    MongooseArray || (MongooseArray = require_types().Array);
    let i;
    let l;
    if (Array.isArray(value)) {
      const len = value.length;
      if (!len && doc) {
        const indexes = doc.schema.indexedPaths();
        const arrayPath = this.path;
        for (i = 0, l = indexes.length;i < l; ++i) {
          const pathIndex = indexes[i][0][arrayPath];
          if (pathIndex === "2dsphere" || pathIndex === "2d") {
            return;
          }
        }
        const arrayGeojsonPath = this.path.endsWith(".coordinates") ? this.path.substring(0, this.path.lastIndexOf(".")) : null;
        if (arrayGeojsonPath != null) {
          for (i = 0, l = indexes.length;i < l; ++i) {
            const pathIndex = indexes[i][0][arrayGeojsonPath];
            if (pathIndex === "2dsphere") {
              return;
            }
          }
        }
      }
      options = options || emptyOpts;
      let rawValue = utils.isMongooseArray(value) ? value.__array : value;
      let path = options.path || this.path;
      if (options.arrayPathIndex != null) {
        path += "." + options.arrayPathIndex;
      }
      value = MongooseArray(rawValue, path, doc, this);
      rawValue = value.__array;
      if (init && doc != null && doc.$__ != null && doc.$populated(this.path)) {
        return value;
      }
      const caster = this.caster;
      const isMongooseArray = caster.$isMongooseArray;
      if (caster && this.casterConstructor !== Mixed) {
        try {
          const len2 = rawValue.length;
          for (i = 0;i < len2; i++) {
            const opts = {};
            if (isMongooseArray) {
              if (options.arrayPath != null) {
                opts.arrayPathIndex = i;
              } else if (caster._arrayParentPath != null) {
                opts.arrayPathIndex = i;
              }
            }
            if (options.hydratedPopulatedDocs) {
              opts.hydratedPopulatedDocs = options.hydratedPopulatedDocs;
            }
            rawValue[i] = caster.applySetters(rawValue[i], doc, init, undefined, opts);
          }
        } catch (e) {
          throw new CastError("[" + e.kind + "]", util.inspect(value), this.path + "." + i, e, this);
        }
      }
      return value;
    }
    const castNonArraysOption = this.options.castNonArrays != null ? this.options.castNonArrays : SchemaArray.options.castNonArrays;
    if (init || castNonArraysOption) {
      if (!!doc && !!init) {
        doc.markModified(this.path);
      }
      return this.cast([value], doc, init);
    }
    throw new CastError("Array", util.inspect(value), this.path, null, this);
  };
  /*!
   * ignore
   */
  SchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {
    MongooseArray || (MongooseArray = require_types().Array);
    if (Array.isArray(value)) {
      let i;
      const rawValue = value.__array ? value.__array : value;
      const len = rawValue.length;
      const caster = this.caster;
      if (caster && this.casterConstructor !== Mixed) {
        try {
          for (i = 0;i < len; i++) {
            const opts = {};
            if (caster.$isMongooseArray && caster._arrayParentPath != null) {
              opts.arrayPathIndex = i;
            }
            rawValue[i] = caster.cast(rawValue[i], doc, false, undefined, opts);
          }
        } catch (e) {
          throw new CastError("[" + e.kind + "]", util.inspect(value), this.path + "." + i, e, this);
        }
      }
      return value;
    }
    throw new CastError("Array", util.inspect(value), this.path, null, this);
  };
  SchemaArray.prototype.$toObject = SchemaArray.prototype.toObject;
  /*!
   * ignore
   */
  SchemaArray.prototype.discriminator = function(...args) {
    let arr = this;
    while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {
      arr = arr.casterConstructor;
      if (arr == null || typeof arr === "function") {
        throw new MongooseError("You can only add an embedded discriminator on " + "a document array, " + this.path + " is a plain array");
      }
    }
    return arr.discriminator(...args);
  };
  /*!
   * ignore
   */
  SchemaArray.prototype.clone = function() {
    const options = Object.assign({}, this.options);
    const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);
    schematype.validators = this.validators.slice();
    if (this.requiredValidator !== undefined) {
      schematype.requiredValidator = this.requiredValidator;
    }
    return schematype;
  };
  SchemaArray.prototype._castForQuery = function(val, context) {
    let Constructor = this.casterConstructor;
    if (val && Constructor.discriminators && Constructor.schema && Constructor.schema.options && Constructor.schema.options.discriminatorKey) {
      if (typeof val[Constructor.schema.options.discriminatorKey] === "string" && Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {
        Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];
      } else {
        const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, val[Constructor.schema.options.discriminatorKey]);
        if (constructorByValue) {
          Constructor = constructorByValue;
        }
      }
    }
    const proto = this.casterConstructor.prototype;
    const protoCastForQuery = proto && proto.castForQuery;
    const protoCast = proto && proto.cast;
    const constructorCastForQuery = Constructor.castForQuery;
    const caster = this.caster;
    if (Array.isArray(val)) {
      this.setters.reverse().forEach((setter) => {
        val = setter.call(this, val, this);
      });
      val = val.map(function(v) {
        if (utils.isObject(v) && v.$elemMatch) {
          return v;
        }
        if (protoCastForQuery) {
          v = protoCastForQuery.call(caster, null, v, context);
          return v;
        } else if (protoCast) {
          v = protoCast.call(caster, v);
          return v;
        } else if (constructorCastForQuery) {
          v = constructorCastForQuery.call(caster, null, v, context);
          return v;
        }
        if (v != null) {
          v = new Constructor(v);
          return v;
        }
        return v;
      });
    } else if (protoCastForQuery) {
      val = protoCastForQuery.call(caster, null, val, context);
    } else if (protoCast) {
      val = protoCast.call(caster, val);
    } else if (constructorCastForQuery) {
      val = constructorCastForQuery.call(caster, null, val, context);
    } else if (val != null) {
      val = new Constructor(val);
    }
    return val;
  };
  SchemaArray.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = this.$conditionalHandlers[$conditional];
      if (!handler) {
        throw new Error("Can\'t use " + $conditional + " with Array.");
      }
      return handler.call(this, val, context);
    } else {
      return this._castForQuery(val, context);
    }
  };
  SchemaArray.prototype.virtual = function virtual(name, options) {
    if (name instanceof VirtualType || getConstructorName(name) === "VirtualType") {
      return this.virtual(name.path, name.options);
    }
    options = new VirtualOptions(options);
    if (utils.hasUserDefinedProperty(options, ["ref", "refPath"])) {
      throw new MongooseError("Cannot set populate virtual as a property of an array");
    }
    const virtual = new VirtualType(options, name);
    if (this.virtuals === null) {
      this.virtuals = {};
    }
    this.virtuals[name] = virtual;
    return virtual;
  };
  var handle = SchemaArray.prototype.$conditionalHandlers = {};
  handle.$all = cast$all;
  handle.$options = String;
  handle.$elemMatch = cast$elemMatch;
  handle.$geoIntersects = geospatial.cast$geoIntersects;
  handle.$or = createLogicalQueryOperatorHandler("$or");
  handle.$and = createLogicalQueryOperatorHandler("$and");
  handle.$nor = createLogicalQueryOperatorHandler("$nor");
  handle.$near = handle.$nearSphere = geospatial.cast$near;
  handle.$within = handle.$geoWithin = geospatial.cast$within;
  handle.$size = handle.$minDistance = handle.$maxDistance = castToNumber;
  handle.$exists = $exists;
  handle.$type = $type;
  handle.$eq = handle.$gt = handle.$gte = handle.$lt = handle.$lte = handle.$not = handle.$regex = handle.$ne = SchemaArray.prototype._castForQuery;
  handle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;
  handle.$in = SchemaType.prototype.$conditionalHandlers.$in;
  SchemaArray.prototype.toJSONSchema = function toJSONSchema(options) {
    const embeddedSchemaType = this.getEmbeddedSchemaType();
    const isRequired = this.options.required && typeof this.options.required !== "function";
    return {
      ...createJSONSchemaTypeDefinition("array", "array", options?.useBsonType, isRequired),
      items: embeddedSchemaType.toJSONSchema(options)
    };
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaArray;
});

// node_modules/mongoose/lib/cast/bigint.js
var require_bigint = __commonJS((exports, module) => {
  var assert = import.meta.require("assert");
  var { Long } = require_bson();
  module.exports = function castBigInt(val) {
    if (val == null) {
      return val;
    }
    if (val === "") {
      return null;
    }
    if (typeof val === "bigint") {
      return val;
    }
    if (val instanceof Long) {
      return val.toBigInt();
    }
    if (typeof val === "string" || typeof val === "number") {
      return BigInt(val);
    }
    assert.ok(false);
  };
});

// node_modules/mongoose/lib/schema/bigint.js
var require_bigint2 = __commonJS((exports, module) => {
  function SchemaBigInt(path, options) {
    SchemaType.call(this, path, options, "BigInt");
  }
  function handleSingle(val, context) {
    return this.castForQuery(null, val, context);
  }
  /*!
   * Module dependencies.
   */
  var CastError = require_cast();
  var SchemaType = require_schemaType();
  var castBigInt = require_bigint();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  SchemaBigInt.schemaName = "BigInt";
  SchemaBigInt.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaBigInt.prototype = Object.create(SchemaType.prototype);
  SchemaBigInt.prototype.constructor = SchemaBigInt;
  /*!
   * ignore
   */
  SchemaBigInt._cast = castBigInt;
  SchemaBigInt.set = SchemaType.set;
  SchemaBigInt.setters = [];
  SchemaBigInt.get = SchemaType.get;
  SchemaBigInt.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaBigInt._checkRequired = (v) => v != null;
  SchemaBigInt.checkRequired = SchemaType.checkRequired;
  SchemaBigInt.prototype.checkRequired = function(value) {
    return this.constructor._checkRequired(value);
  };
  SchemaBigInt.prototype.cast = function(value) {
    let castBigInt2;
    if (typeof this._castFunction === "function") {
      castBigInt2 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castBigInt2 = this.constructor.cast();
    } else {
      castBigInt2 = SchemaBigInt.cast();
    }
    try {
      return castBigInt2(value);
    } catch (error) {
      throw new CastError("BigInt", value, this.path, error, this);
    }
  };
  /*!
   * ignore
   */
  SchemaBigInt.$conditionalHandlers = {
    ...SchemaType.prototype.$conditionalHandlers,
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle
  };
  /*!
   * ignore
   */
  SchemaBigInt.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = SchemaBigInt.$conditionalHandlers[$conditional];
      if (handler) {
        return handler.call(this, val);
      }
      return this.applySetters(val, context);
    }
    try {
      return this.applySetters(val, context);
    } catch (err) {
      if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {
        err.path = this.$fullPath;
      }
      throw err;
    }
  };
  SchemaBigInt.prototype._castNullish = function _castNullish(v) {
    if (typeof v === "undefined") {
      return v;
    }
    const castBigInt2 = typeof this.constructor.cast === "function" ? this.constructor.cast() : SchemaBigInt.cast();
    if (castBigInt2 == null) {
      return v;
    }
    return v;
  };
  SchemaBigInt.prototype.toJSONSchema = function toJSONSchema(options) {
    const isRequired = this.options.required && typeof this.options.required !== "function";
    return createJSONSchemaTypeDefinition("string", "long", options?.useBsonType, isRequired);
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaBigInt;
});

// node_modules/mongoose/lib/schema/boolean.js
var require_boolean2 = __commonJS((exports, module) => {
  function SchemaBoolean(path, options) {
    SchemaType.call(this, path, options, "Boolean");
  }
  /*!
   * Module dependencies.
   */
  var CastError = require_cast();
  var SchemaType = require_schemaType();
  var castBoolean = require_boolean();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  SchemaBoolean.schemaName = "Boolean";
  SchemaBoolean.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaBoolean.prototype = Object.create(SchemaType.prototype);
  SchemaBoolean.prototype.constructor = SchemaBoolean;
  /*!
   * ignore
   */
  SchemaBoolean._cast = castBoolean;
  SchemaBoolean.set = SchemaType.set;
  SchemaBoolean.setters = [];
  SchemaBoolean.get = SchemaType.get;
  SchemaBoolean.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaBoolean._defaultCaster = (v) => {
    if (v != null && typeof v !== "boolean") {
      throw new Error;
    }
    return v;
  };
  /*!
   * ignore
   */
  SchemaBoolean._checkRequired = (v) => v === true || v === false;
  SchemaBoolean.checkRequired = SchemaType.checkRequired;
  SchemaBoolean.prototype.checkRequired = function(value) {
    return this.constructor._checkRequired(value);
  };
  Object.defineProperty(SchemaBoolean, "convertToTrue", {
    get: () => castBoolean.convertToTrue,
    set: (v) => {
      castBoolean.convertToTrue = v;
    }
  });
  Object.defineProperty(SchemaBoolean, "convertToFalse", {
    get: () => castBoolean.convertToFalse,
    set: (v) => {
      castBoolean.convertToFalse = v;
    }
  });
  SchemaBoolean.prototype.cast = function(value) {
    let castBoolean2;
    if (typeof this._castFunction === "function") {
      castBoolean2 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castBoolean2 = this.constructor.cast();
    } else {
      castBoolean2 = SchemaBoolean.cast();
    }
    try {
      return castBoolean2(value);
    } catch (error) {
      throw new CastError("Boolean", value, this.path, error, this);
    }
  };
  SchemaBoolean.$conditionalHandlers = { ...SchemaType.prototype.$conditionalHandlers };
  SchemaBoolean.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = SchemaBoolean.$conditionalHandlers[$conditional];
      if (handler) {
        return handler.call(this, val);
      }
      return this.applySetters(val, context);
    }
    try {
      return this.applySetters(val, context);
    } catch (err) {
      if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {
        err.path = this.$fullPath;
      }
      throw err;
    }
  };
  SchemaBoolean.prototype._castNullish = function _castNullish(v) {
    if (typeof v === "undefined") {
      return v;
    }
    const castBoolean2 = typeof this.constructor.cast === "function" ? this.constructor.cast() : SchemaBoolean.cast();
    if (castBoolean2 == null) {
      return v;
    }
    if (castBoolean2.convertToFalse instanceof Set && castBoolean2.convertToFalse.has(v)) {
      return false;
    }
    if (castBoolean2.convertToTrue instanceof Set && castBoolean2.convertToTrue.has(v)) {
      return true;
    }
    return v;
  };
  SchemaBoolean.prototype.toJSONSchema = function toJSONSchema(options) {
    const isRequired = this.options.required && typeof this.options.required !== "function";
    return createJSONSchemaTypeDefinition("boolean", "bool", options?.useBsonType, isRequired);
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaBoolean;
});

// node_modules/mongoose/lib/options/schemaBufferOptions.js
var require_schemaBufferOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_schemaTypeOptions();

  class SchemaBufferOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaBufferOptions.prototype, "subtype", opts);
  /*!
   * ignore
   */
  module.exports = SchemaBufferOptions;
});

// node_modules/mongoose/lib/schema/buffer.js
var require_buffer2 = __commonJS((exports, module) => {
  function SchemaBuffer(key, options) {
    SchemaType.call(this, key, options, "Buffer");
  }
  function handleSingle(val, context) {
    return this.castForQuery(null, val, context);
  }
  /*!
   * Module dependencies.
   */
  var MongooseBuffer = require_buffer();
  var SchemaBufferOptions = require_schemaBufferOptions();
  var SchemaType = require_schemaType();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  var handleBitwiseOperator = require_bitwise();
  var utils = require_utils4();
  var Binary = MongooseBuffer.Binary;
  var CastError = SchemaType.CastError;
  SchemaBuffer.schemaName = "Buffer";
  SchemaBuffer.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaBuffer.prototype = Object.create(SchemaType.prototype);
  SchemaBuffer.prototype.constructor = SchemaBuffer;
  SchemaBuffer.prototype.OptionsConstructor = SchemaBufferOptions;
  /*!
   * ignore
   */
  SchemaBuffer._checkRequired = (v) => !!(v && v.length);
  SchemaBuffer.set = SchemaType.set;
  SchemaBuffer.setters = [];
  SchemaBuffer.get = SchemaType.get;
  SchemaBuffer.checkRequired = SchemaType.checkRequired;
  SchemaBuffer.prototype.checkRequired = function(value, doc) {
    if (SchemaType._isRef(this, value, doc, true)) {
      return !!value;
    }
    return this.constructor._checkRequired(value);
  };
  SchemaBuffer.prototype.cast = function(value, doc, init, prev, options) {
    let ret;
    if (SchemaType._isRef(this, value, doc, init)) {
      if (value && value.isMongooseBuffer) {
        return value;
      }
      if (Buffer.isBuffer(value)) {
        if (!value || !value.isMongooseBuffer) {
          value = new MongooseBuffer(value, [this.path, doc]);
          if (this.options.subtype != null) {
            value._subtype = this.options.subtype;
          }
        }
        return value;
      }
      if (value instanceof Binary) {
        ret = new MongooseBuffer(value.value(true), [this.path, doc]);
        if (typeof value.sub_type !== "number") {
          throw new CastError("Buffer", value, this.path, null, this);
        }
        ret._subtype = value.sub_type;
        return ret;
      }
      if (value == null || utils.isNonBuiltinObject(value)) {
        return this._castRef(value, doc, init, options);
      }
    }
    if (value && value._id) {
      value = value._id;
    }
    if (value && value.isMongooseBuffer) {
      return value;
    }
    if (Buffer.isBuffer(value)) {
      if (!value || !value.isMongooseBuffer) {
        value = new MongooseBuffer(value, [this.path, doc]);
        if (this.options.subtype != null) {
          value._subtype = this.options.subtype;
        }
      }
      return value;
    }
    if (value instanceof Binary) {
      ret = new MongooseBuffer(value.value(true), [this.path, doc]);
      if (typeof value.sub_type !== "number") {
        throw new CastError("Buffer", value, this.path, null, this);
      }
      ret._subtype = value.sub_type;
      return ret;
    }
    if (value === null) {
      return value;
    }
    const type = typeof value;
    if (type === "string" || type === "number" || Array.isArray(value) || type === "object" && value.type === "Buffer" && Array.isArray(value.data)) {
      if (type === "number") {
        value = [value];
      }
      ret = new MongooseBuffer(value, [this.path, doc]);
      if (this.options.subtype != null) {
        ret._subtype = this.options.subtype;
      }
      return ret;
    }
    if (utils.isPOJO(value) && (value.$binary instanceof Binary || typeof value.$binary === "string")) {
      const buf = this.cast(Buffer.from(value.$binary, "base64"));
      if (value.$type != null) {
        buf._subtype = value.$type;
        return buf;
      }
    }
    throw new CastError("Buffer", value, this.path, null, this);
  };
  SchemaBuffer.prototype.subtype = function(subtype) {
    this.options.subtype = subtype;
    return this;
  };
  /*!
   * ignore
   */
  SchemaBuffer.prototype.$conditionalHandlers = {
    ...SchemaType.prototype.$conditionalHandlers,
    $bitsAllClear: handleBitwiseOperator,
    $bitsAnyClear: handleBitwiseOperator,
    $bitsAllSet: handleBitwiseOperator,
    $bitsAnySet: handleBitwiseOperator,
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle
  };
  SchemaBuffer.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = this.$conditionalHandlers[$conditional];
      if (!handler) {
        throw new Error("Can\'t use " + $conditional + " with Buffer.");
      }
      return handler.call(this, val);
    }
    let casted;
    try {
      casted = this.applySetters(val, context);
    } catch (err) {
      if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {
        err.path = this.$fullPath;
      }
      throw err;
    }
    return casted ? casted.toObject({ transform: false, virtuals: false }) : casted;
  };
  SchemaBuffer.prototype.toJSONSchema = function toJSONSchema(options) {
    const isRequired = this.options.required && typeof this.options.required !== "function";
    return createJSONSchemaTypeDefinition("string", "binData", options?.useBsonType, isRequired);
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaBuffer;
});

// node_modules/mongoose/lib/options/schemaDateOptions.js
var require_schemaDateOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_schemaTypeOptions();

  class SchemaDateOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaDateOptions.prototype, "min", opts);
  Object.defineProperty(SchemaDateOptions.prototype, "max", opts);
  Object.defineProperty(SchemaDateOptions.prototype, "expires", opts);
  /*!
   * ignore
   */
  module.exports = SchemaDateOptions;
});

// node_modules/mongoose/lib/cast/date.js
var require_date = __commonJS((exports, module) => {
  var assert = import.meta.require("assert");
  module.exports = function castDate(value) {
    if (value == null || value === "") {
      return null;
    }
    if (value instanceof Date) {
      assert.ok(!isNaN(value.valueOf()));
      return value;
    }
    let date;
    assert.ok(typeof value !== "boolean");
    if (value instanceof Number || typeof value === "number") {
      date = new Date(value);
    } else if (typeof value === "string" && !isNaN(Number(value)) && (Number(value) >= 275761 || Number(value) < -271820)) {
      date = new Date(Number(value));
    } else if (typeof value.valueOf === "function") {
      date = new Date(value.valueOf());
    } else {
      date = new Date(value);
    }
    if (!isNaN(date.valueOf())) {
      return date;
    }
    assert.ok(false);
  };
});

// node_modules/mongoose/lib/schema/date.js
var require_date2 = __commonJS((exports, module) => {
  function SchemaDate(key, options) {
    SchemaType.call(this, key, options, "Date");
  }
  function handleSingle(val) {
    return this.cast(val);
  }
  /*!
   * Module requirements.
   */
  var MongooseError = require_error2();
  var SchemaDateOptions = require_schemaDateOptions();
  var SchemaType = require_schemaType();
  var castDate = require_date();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  var getConstructorName = require_getConstructorName();
  var utils = require_utils4();
  var CastError = SchemaType.CastError;
  SchemaDate.schemaName = "Date";
  SchemaDate.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaDate.prototype = Object.create(SchemaType.prototype);
  SchemaDate.prototype.constructor = SchemaDate;
  SchemaDate.prototype.OptionsConstructor = SchemaDateOptions;
  /*!
   * ignore
   */
  SchemaDate._cast = castDate;
  SchemaDate.set = SchemaType.set;
  SchemaDate.setters = [];
  SchemaDate.get = SchemaType.get;
  SchemaDate.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaDate._defaultCaster = (v) => {
    if (v != null && !(v instanceof Date)) {
      throw new Error;
    }
    return v;
  };
  SchemaDate.prototype.expires = function(when) {
    if (getConstructorName(this._index) !== "Object") {
      this._index = {};
    }
    this._index.expires = when;
    utils.expires(this._index);
    return this;
  };
  /*!
   * ignore
   */
  SchemaDate._checkRequired = (v) => v instanceof Date;
  SchemaDate.checkRequired = SchemaType.checkRequired;
  SchemaDate.prototype.checkRequired = function(value, doc) {
    if (typeof value === "object" && SchemaType._isRef(this, value, doc, true)) {
      return value != null;
    }
    const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : SchemaDate.checkRequired();
    return _checkRequired(value);
  };
  SchemaDate.prototype.min = function(value, message) {
    if (this.minValidator) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.minValidator;
      }, this);
    }
    if (value) {
      let msg = message || MongooseError.messages.Date.min;
      if (typeof msg === "string") {
        msg = msg.replace(/{MIN}/, value === Date.now ? "Date.now()" : value.toString());
      }
      const _this = this;
      this.validators.push({
        validator: this.minValidator = function(val) {
          let _value = value;
          if (typeof value === "function" && value !== Date.now) {
            _value = _value.call(this);
          }
          const min = _value === Date.now ? _value() : _this.cast(_value);
          return val === null || val.valueOf() >= min.valueOf();
        },
        message: msg,
        type: "min",
        min: value
      });
    }
    return this;
  };
  SchemaDate.prototype.max = function(value, message) {
    if (this.maxValidator) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.maxValidator;
      }, this);
    }
    if (value) {
      let msg = message || MongooseError.messages.Date.max;
      if (typeof msg === "string") {
        msg = msg.replace(/{MAX}/, value === Date.now ? "Date.now()" : value.toString());
      }
      const _this = this;
      this.validators.push({
        validator: this.maxValidator = function(val) {
          let _value = value;
          if (typeof _value === "function" && _value !== Date.now) {
            _value = _value.call(this);
          }
          const max = _value === Date.now ? _value() : _this.cast(_value);
          return val === null || val.valueOf() <= max.valueOf();
        },
        message: msg,
        type: "max",
        max: value
      });
    }
    return this;
  };
  SchemaDate.prototype.cast = function(value) {
    let castDate2;
    if (typeof this._castFunction === "function") {
      castDate2 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castDate2 = this.constructor.cast();
    } else {
      castDate2 = SchemaDate.cast();
    }
    try {
      return castDate2(value);
    } catch (error) {
      throw new CastError("date", value, this.path, error, this);
    }
  };
  SchemaDate.prototype.$conditionalHandlers = {
    ...SchemaType.prototype.$conditionalHandlers,
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle
  };
  SchemaDate.prototype.castForQuery = function($conditional, val, context) {
    if ($conditional == null) {
      try {
        return this.applySetters(val, context);
      } catch (err) {
        if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {
          err.path = this.$fullPath;
        }
        throw err;
      }
    }
    const handler = this.$conditionalHandlers[$conditional];
    if (!handler) {
      throw new Error("Can\'t use " + $conditional + " with Date.");
    }
    return handler.call(this, val);
  };
  SchemaDate.prototype.toJSONSchema = function toJSONSchema(options) {
    const isRequired = this.options.required && typeof this.options.required !== "function";
    return createJSONSchemaTypeDefinition("string", "date", options?.useBsonType, isRequired);
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaDate;
});

// node_modules/mongoose/lib/cast/decimal128.js
var require_decimal1282 = __commonJS((exports, module) => {
  var Decimal128Type = require_decimal128();
  var assert = import.meta.require("assert");
  module.exports = function castDecimal128(value) {
    if (value == null) {
      return value;
    }
    if (typeof value === "object" && typeof value.$numberDecimal === "string") {
      return Decimal128Type.fromString(value.$numberDecimal);
    }
    if (value instanceof Decimal128Type) {
      return value;
    }
    if (typeof value === "string") {
      return Decimal128Type.fromString(value);
    }
    if (typeof Buffer === "function" && Buffer.isBuffer(value)) {
      return new Decimal128Type(value);
    }
    if (typeof Uint8Array === "function" && value instanceof Uint8Array) {
      return new Decimal128Type(value);
    }
    if (typeof value === "number") {
      return Decimal128Type.fromString(String(value));
    }
    if (typeof value.valueOf === "function" && typeof value.valueOf() === "string") {
      return Decimal128Type.fromString(value.valueOf());
    }
    assert.ok(false);
  };
});

// node_modules/mongoose/lib/schema/decimal128.js
var require_decimal1283 = __commonJS((exports, module) => {
  function SchemaDecimal128(key, options) {
    SchemaType.call(this, key, options, "Decimal128");
  }
  function handleSingle(val) {
    return this.cast(val);
  }
  /*!
   * Module dependencies.
   */
  var SchemaType = require_schemaType();
  var CastError = SchemaType.CastError;
  var castDecimal128 = require_decimal1282();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  var isBsonType = require_isBsonType();
  SchemaDecimal128.schemaName = "Decimal128";
  SchemaDecimal128.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaDecimal128.prototype = Object.create(SchemaType.prototype);
  SchemaDecimal128.prototype.constructor = SchemaDecimal128;
  /*!
   * ignore
   */
  SchemaDecimal128._cast = castDecimal128;
  SchemaDecimal128.set = SchemaType.set;
  SchemaDecimal128.setters = [];
  SchemaDecimal128.get = SchemaType.get;
  SchemaDecimal128.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaDecimal128._defaultCaster = (v) => {
    if (v != null && !isBsonType(v, "Decimal128")) {
      throw new Error;
    }
    return v;
  };
  /*!
   * ignore
   */
  SchemaDecimal128._checkRequired = (v) => isBsonType(v, "Decimal128");
  SchemaDecimal128.checkRequired = SchemaType.checkRequired;
  SchemaDecimal128.prototype.checkRequired = function checkRequired(value, doc) {
    if (SchemaType._isRef(this, value, doc, true)) {
      return !!value;
    }
    const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : SchemaDecimal128.checkRequired();
    return _checkRequired(value);
  };
  SchemaDecimal128.prototype.cast = function(value, doc, init, prev, options) {
    if (SchemaType._isRef(this, value, doc, init)) {
      if (isBsonType(value, "Decimal128")) {
        return value;
      }
      return this._castRef(value, doc, init, options);
    }
    let castDecimal1282;
    if (typeof this._castFunction === "function") {
      castDecimal1282 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castDecimal1282 = this.constructor.cast();
    } else {
      castDecimal1282 = SchemaDecimal128.cast();
    }
    try {
      return castDecimal1282(value);
    } catch (error) {
      throw new CastError("Decimal128", value, this.path, error, this);
    }
  };
  /*!
   * ignore
   */
  SchemaDecimal128.prototype.$conditionalHandlers = {
    ...SchemaType.prototype.$conditionalHandlers,
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle
  };
  SchemaDecimal128.prototype.toJSONSchema = function toJSONSchema(options) {
    const isRequired = this.options.required && typeof this.options.required !== "function";
    return createJSONSchemaTypeDefinition("string", "decimal", options?.useBsonType, isRequired);
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaDecimal128;
});

// node_modules/mongoose/lib/options/schemaSubdocumentOptions.js
var require_schemaSubdocumentOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_schemaTypeOptions();

  class SchemaSubdocumentOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaSubdocumentOptions.prototype, "_id", opts);
  module.exports = SchemaSubdocumentOptions;
});

// node_modules/mongoose/lib/helpers/each.js
var require_each = __commonJS((exports, module) => {
  module.exports = function each(arr, cb, done) {
    if (arr.length === 0) {
      return done();
    }
    let remaining = arr.length;
    let err = null;
    for (const v of arr) {
      cb(v, function(_err) {
        if (err != null) {
          return;
        }
        if (_err != null) {
          err = _err;
          return done(err);
        }
        if (--remaining <= 0) {
          return done();
        }
      });
    }
  };
});

// node_modules/mongoose/lib/plugins/saveSubdocs.js
var require_saveSubdocs = __commonJS((exports, module) => {
  var each = require_each();
  /*!
   * ignore
   */
  module.exports = function saveSubdocs(schema) {
    const unshift = true;
    schema.s.hooks.pre("save", false, function saveSubdocsPreSave(next) {
      if (this.$isSubdocument) {
        next();
        return;
      }
      const _this = this;
      const subdocs = this.$getAllSubdocs({ useCache: true });
      if (!subdocs.length) {
        next();
        return;
      }
      each(subdocs, function(subdoc, cb) {
        subdoc.$__schema.s.hooks.execPre("save", subdoc, function(err) {
          cb(err);
        });
      }, function(error) {
        if (_this.$__.saveOptions) {
          _this.$__.saveOptions.__subdocs = null;
        }
        if (error) {
          return _this.$__schema.s.hooks.execPost("save:error", _this, [_this], { error }, function(error2) {
            next(error2);
          });
        }
        next();
      });
    }, null, unshift);
    schema.s.hooks.post("save", async function saveSubdocsPostDeleteOne() {
      const removedSubdocs = this.$__.removedSubdocs;
      if (!removedSubdocs || !removedSubdocs.length) {
        return;
      }
      const promises = [];
      for (const subdoc of removedSubdocs) {
        promises.push(new Promise((resolve, reject) => {
          subdoc.$__schema.s.hooks.execPost("deleteOne", subdoc, [subdoc], function(err) {
            if (err) {
              return reject(err);
            }
            resolve();
          });
        }));
      }
      this.$__.removedSubdocs = null;
      await Promise.all(promises);
    });
    schema.s.hooks.post("save", async function saveSubdocsPostSave() {
      if (this.$isSubdocument) {
        return;
      }
      const _this = this;
      const subdocs = this.$getAllSubdocs({ useCache: true });
      if (!subdocs.length) {
        return;
      }
      const promises = [];
      for (const subdoc of subdocs) {
        promises.push(new Promise((resolve, reject) => {
          subdoc.$__schema.s.hooks.execPost("save", subdoc, [subdoc], function(err) {
            if (err) {
              return reject(err);
            }
            resolve();
          });
        }));
      }
      try {
        await Promise.all(promises);
      } catch (error) {
        await new Promise((resolve, reject) => {
          this.$__schema.s.hooks.execPost("save:error", _this, [_this], { error }, function(error2) {
            if (error2) {
              return reject(error2);
            }
            resolve();
          });
        });
      }
    }, null, unshift);
  };
});

// node_modules/mongoose/lib/plugins/sharding.js
var require_sharding = __commonJS((exports, module) => {
  function applyWhere() {
    let paths;
    let len;
    if (this.$__.shardval) {
      paths = Object.keys(this.$__.shardval);
      len = paths.length;
      this.$where = this.$where || {};
      for (let i = 0;i < len; ++i) {
        this.$where[paths[i]] = this.$__.shardval[paths[i]];
      }
    }
  }
  function storeShard() {
    const key = this.$__schema.options.shardKey || this.$__schema.options.shardkey;
    if (!utils.isPOJO(key)) {
      return;
    }
    const orig = this.$__.shardval = {};
    const paths = Object.keys(key);
    const len = paths.length;
    let val;
    for (let i = 0;i < len; ++i) {
      val = this.$__getValue(paths[i]);
      if (val == null) {
        orig[paths[i]] = val;
      } else if (utils.isMongooseObject(val)) {
        orig[paths[i]] = val.toObject({ depopulate: true, _isNested: true });
      } else if (val instanceof Date || val[objectIdSymbol]) {
        orig[paths[i]] = val;
      } else if (typeof val.valueOf === "function") {
        orig[paths[i]] = val.valueOf();
      } else {
        orig[paths[i]] = val;
      }
    }
  }
  var objectIdSymbol = require_symbols().objectIdSymbol;
  var utils = require_utils4();
  /*!
   * ignore
   */
  module.exports = function shardingPlugin(schema) {
    schema.post("init", function shardingPluginPostInit() {
      storeShard.call(this);
      return this;
    });
    schema.pre("save", function shardingPluginPreSave(next) {
      applyWhere.call(this);
      next();
    });
    schema.pre("remove", function shardingPluginPreRemove(next) {
      applyWhere.call(this);
      next();
    });
    schema.post("save", function shardingPluginPostSave() {
      storeShard.call(this);
    });
  };
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  module.exports.storeShard = storeShard;
  /*!
   * ignore
   */
});

// node_modules/mongoose/lib/plugins/trackTransaction.js
var require_trackTransaction = __commonJS((exports, module) => {
  function _getAtomics(doc, previous) {
    const pathToAtomics = new Map;
    previous = previous || new Map;
    const pathsToCheck = Object.keys(doc.$__.activePaths.init).concat(Object.keys(doc.$__.activePaths.modify));
    for (const path of pathsToCheck) {
      const val = doc.$__getValue(path);
      if (val != null && Array.isArray(val) && utils.isMongooseDocumentArray(val) && val.length && val[arrayAtomicsSymbol] != null && Object.keys(val[arrayAtomicsSymbol]).length !== 0) {
        const existing = previous.get(path) || {};
        pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));
      }
    }
    const dirty = doc.$__dirty();
    for (const dirt of dirty) {
      const path = dirt.path;
      const val = dirt.value;
      if (val != null && val[arrayAtomicsSymbol] != null && Object.keys(val[arrayAtomicsSymbol]).length !== 0) {
        const existing = previous.get(path) || {};
        pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));
      }
    }
    return pathToAtomics;
  }
  function mergeAtomics(destination, source) {
    destination = destination || {};
    if (source.$pullAll != null) {
      destination.$pullAll = (destination.$pullAll || []).concat(source.$pullAll);
    }
    if (source.$push != null) {
      destination.$push = destination.$push || {};
      destination.$push.$each = (destination.$push.$each || []).concat(source.$push.$each);
    }
    if (source.$addToSet != null) {
      destination.$addToSet = (destination.$addToSet || []).concat(source.$addToSet);
    }
    if (source.$set != null) {
      destination.$set = Array.isArray(source.$set) ? [...source.$set] : Object.assign({}, source.$set);
    }
    return destination;
  }
  var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
  var sessionNewDocuments = require_symbols().sessionNewDocuments;
  var utils = require_utils4();
  module.exports = function trackTransaction(schema) {
    schema.pre("save", function trackTransactionPreSave() {
      const session = this.$session();
      if (session == null) {
        return;
      }
      if (session.transaction == null || session[sessionNewDocuments] == null) {
        return;
      }
      if (!session[sessionNewDocuments].has(this)) {
        const initialState = {};
        if (this.isNew) {
          initialState.isNew = true;
        }
        if (this.$__schema.options.versionKey) {
          initialState.versionKey = this.get(this.$__schema.options.versionKey);
        }
        initialState.modifiedPaths = new Set(Object.keys(this.$__.activePaths.getStatePaths("modify")));
        initialState.atomics = _getAtomics(this);
        session[sessionNewDocuments].set(this, initialState);
      }
    });
  };
});

// node_modules/mongoose/lib/plugins/validateBeforeSave.js
var require_validateBeforeSave = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  module.exports = function validateBeforeSave(schema) {
    const unshift = true;
    schema.pre("save", false, function validateBeforeSave(next, options) {
      const _this = this;
      if (this.$isSubdocument) {
        return next();
      }
      const hasValidateBeforeSaveOption = options && typeof options === "object" && "validateBeforeSave" in options;
      let shouldValidate;
      if (hasValidateBeforeSaveOption) {
        shouldValidate = !!options.validateBeforeSave;
      } else {
        shouldValidate = this.$__schema.options.validateBeforeSave;
      }
      if (shouldValidate) {
        const hasValidateModifiedOnlyOption = options && typeof options === "object" && "validateModifiedOnly" in options;
        const validateOptions = hasValidateModifiedOnlyOption ? { validateModifiedOnly: options.validateModifiedOnly } : null;
        this.$validate(validateOptions).then(() => {
          this.$op = "save";
          next();
        }, (error) => {
          _this.$__schema.s.hooks.execPost("save:error", _this, [_this], { error }, function(error2) {
            _this.$op = "save";
            next(error2);
          });
        });
      } else {
        next();
      }
    }, null, unshift);
  };
});

// node_modules/mongoose/lib/plugins/index.js
var require_plugins = __commonJS((exports) => {
  exports.saveSubdocs = require_saveSubdocs();
  exports.sharding = require_sharding();
  exports.trackTransaction = require_trackTransaction();
  exports.validateBeforeSave = require_validateBeforeSave();
});

// node_modules/mongoose/lib/helpers/schema/applyBuiltinPlugins.js
var require_applyBuiltinPlugins = __commonJS((exports, module) => {
  var builtinPlugins = require_plugins();
  module.exports = function applyBuiltinPlugins(schema) {
    for (const plugin of Object.values(builtinPlugins)) {
      plugin(schema, { deduplicate: true });
    }
    schema.plugins = Object.values(builtinPlugins).map((fn) => ({ fn, opts: { deduplicate: true } })).concat(schema.plugins);
  };
});

// node_modules/mongoose/lib/helpers/discriminator/mergeDiscriminatorSchema.js
var require_mergeDiscriminatorSchema = __commonJS((exports, module) => {
  var schemaMerge = require_merge();
  var specialProperties = require_specialProperties();
  var isBsonType = require_isBsonType();
  var ObjectId2 = require_objectid();
  var isObject = require_isObject2();
  module.exports = function mergeDiscriminatorSchema(to, from, path, seen) {
    const keys = Object.keys(from);
    let i = 0;
    const len = keys.length;
    let key;
    path = path || "";
    seen = seen || new WeakSet;
    if (seen.has(from)) {
      return;
    }
    seen.add(from);
    while (i < len) {
      key = keys[i++];
      if (!path) {
        if (key === "discriminators" || key === "base" || key === "_applyDiscriminators" || key === "_userProvidedOptions" || key === "options" || key === "tree") {
          continue;
        }
      }
      if (path === "tree" && from != null && from.instanceOfSchema) {
        continue;
      }
      if (specialProperties.has(key)) {
        continue;
      }
      if (to[key] == null) {
        to[key] = from[key];
      } else if (isObject(from[key])) {
        if (!isObject(to[key])) {
          to[key] = {};
        }
        if (from[key] != null) {
          if (from[key].$isSingleNested && to[key].$isMongooseDocumentArray || from[key].$isMongooseDocumentArray && to[key].$isSingleNested || from[key].$isMongooseDocumentArrayElement && to[key].$isMongooseDocumentArrayElement) {
            continue;
          } else if (from[key].instanceOfSchema) {
            if (to[key].instanceOfSchema) {
              schemaMerge(to[key], from[key].clone(), true);
            } else {
              to[key] = from[key].clone();
            }
            continue;
          } else if (isBsonType(from[key], "ObjectId")) {
            to[key] = new ObjectId2(from[key]);
            continue;
          }
        }
        mergeDiscriminatorSchema(to[key], from[key], path ? path + "." + key : key, seen);
      }
    }
    if (from != null && from.instanceOfSchema) {
      to.tree = Object.assign({}, from.tree, to.tree);
    }
  };
});

// node_modules/mongoose/lib/helpers/model/discriminator.js
var require_discriminator = __commonJS((exports, module) => {
  var Mixed = require_mixed();
  var applyBuiltinPlugins = require_applyBuiltinPlugins();
  var clone = require_clone2();
  var defineKey = require_compile().defineKey;
  var get = require_get2();
  var utils = require_utils4();
  var mergeDiscriminatorSchema = require_mergeDiscriminatorSchema();
  var CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {
    toJSON: true,
    toObject: true,
    _id: true,
    id: true,
    virtuals: true,
    methods: true
  };
  /*!
   * ignore
   */
  module.exports = function discriminator(model, name, schema, tiedValue, applyPlugins, mergeHooks, overwriteExisting) {
    if (!(schema && schema.instanceOfSchema)) {
      throw new Error("You must pass a valid discriminator Schema");
    }
    mergeHooks = mergeHooks == null ? true : mergeHooks;
    if (model.schema.discriminatorMapping && !model.schema.discriminatorMapping.isRoot) {
      throw new Error('Discriminator "' + name + '" can only be a discriminator of the root model');
    }
    if (applyPlugins) {
      const applyPluginsToDiscriminators = get(model.base, "options.applyPluginsToDiscriminators", false) || !mergeHooks;
      model.base._applyPlugins(schema, {
        skipTopLevel: !applyPluginsToDiscriminators
      });
    } else if (!mergeHooks) {
      applyBuiltinPlugins(schema);
    }
    const key = model.schema.options.discriminatorKey;
    const existingPath = model.schema.path(key);
    if (existingPath != null) {
      if (!utils.hasUserDefinedProperty(existingPath.options, "select")) {
        existingPath.options.select = true;
      }
      existingPath.options.$skipDiscriminatorCheck = true;
    } else {
      const baseSchemaAddition = {};
      baseSchemaAddition[key] = {
        default: undefined,
        select: true,
        $skipDiscriminatorCheck: true
      };
      baseSchemaAddition[key][model.schema.options.typeKey] = String;
      model.schema.add(baseSchemaAddition);
      defineKey({
        prop: key,
        prototype: model.prototype,
        options: model.schema.options
      });
    }
    if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) {
      throw new Error('Discriminator "' + name + '" cannot have field with name "' + key + '"');
    }
    let value = name;
    if (typeof tiedValue === "string" && tiedValue.length || tiedValue != null) {
      value = tiedValue;
    }
    function merge(schema2, baseSchema) {
      schema2._baseSchema = baseSchema;
      if (baseSchema.paths._id && baseSchema.paths._id.options && !baseSchema.paths._id.options.auto) {
        schema2.remove("_id");
      }
      const baseSchemaPaths = Object.keys(baseSchema.paths);
      const conflictingPaths = [];
      for (const path of baseSchemaPaths) {
        if (schema2.nested[path]) {
          conflictingPaths.push(path);
          continue;
        }
        if (path.indexOf(".") === -1) {
          continue;
        }
        const sp = path.split(".").slice(0, -1);
        let cur = "";
        for (const piece of sp) {
          cur += (cur.length ? "." : "") + piece;
          if (schema2.paths[cur] instanceof Mixed || schema2.singleNestedPaths[cur] instanceof Mixed) {
            conflictingPaths.push(path);
          }
        }
      }
      schema2.obj = { ...schema2.obj };
      mergeDiscriminatorSchema(schema2, baseSchema);
      schema2._gatherChildSchemas();
      for (const conflictingPath of conflictingPaths) {
        delete schema2.paths[conflictingPath];
      }
      schema2.childSchemas.forEach((obj2) => {
        obj2.model.prototype.$__setSchema(obj2.schema);
      });
      const obj = {};
      obj[key] = {
        default: value,
        select: true,
        set: function(newName) {
          if (newName === value || Array.isArray(value) && utils.deepEqual(newName, value)) {
            return value;
          }
          throw new Error('Can\'t set discriminator key "' + key + '"');
        },
        $skipDiscriminatorCheck: true
      };
      obj[key][schema2.options.typeKey] = existingPath ? existingPath.options[schema2.options.typeKey] : String;
      schema2.add(obj);
      schema2.discriminatorMapping = { key, value, isRoot: false };
      if (baseSchema.options.collection) {
        schema2.options.collection = baseSchema.options.collection;
      }
      const toJSON = schema2.options.toJSON;
      const toObject = schema2.options.toObject;
      const _id = schema2.options._id;
      const id = schema2.options.id;
      const keys = Object.keys(schema2.options);
      schema2.options.discriminatorKey = baseSchema.options.discriminatorKey;
      const userProvidedOptions = schema2._userProvidedOptions;
      for (const _key of keys) {
        if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {
          if (_key in userProvidedOptions && !utils.deepEqual(schema2.options[_key], baseSchema.options[_key])) {
            throw new Error("Can\'t customize discriminator option " + _key + " (can only modify " + Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(", ") + ")");
          }
        }
      }
      schema2.options = clone(baseSchema.options);
      for (const _key of Object.keys(userProvidedOptions)) {
        schema2.options[_key] = userProvidedOptions[_key];
      }
      if (toJSON)
        schema2.options.toJSON = toJSON;
      if (toObject)
        schema2.options.toObject = toObject;
      if (typeof _id !== "undefined") {
        schema2.options._id = _id;
      }
      schema2.options.id = id;
      if (mergeHooks) {
        schema2.s.hooks = model.schema.s.hooks.merge(schema2.s.hooks);
      }
      if (applyPlugins) {
        schema2.plugins = Array.prototype.slice.call(baseSchema.plugins);
      }
      schema2.callQueue = baseSchema.callQueue.concat(schema2.callQueue);
      delete schema2._requiredpaths;
    }
    merge(schema, model.schema);
    if (!model.discriminators) {
      model.discriminators = {};
    }
    if (!model.schema.discriminatorMapping) {
      model.schema.discriminatorMapping = { key, value: null, isRoot: true };
    }
    if (!model.schema.discriminators) {
      model.schema.discriminators = {};
    }
    model.schema.discriminators[name] = schema;
    if (model.discriminators[name] && !schema.options.overwriteModels && !overwriteExisting) {
      throw new Error('Discriminator with name "' + name + '" already exists');
    }
    return schema;
  };
});

// node_modules/mongoose/lib/helpers/discriminator/getConstructor.js
var require_getConstructor = __commonJS((exports, module) => {
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  module.exports = function getConstructor(Constructor, value, defaultDiscriminatorValue) {
    const discriminatorKey = Constructor.schema.options.discriminatorKey;
    let discriminatorValue = value != null && value[discriminatorKey];
    if (discriminatorValue == null) {
      discriminatorValue = defaultDiscriminatorValue;
    }
    if (Constructor.discriminators && discriminatorValue != null) {
      if (Constructor.discriminators[discriminatorValue]) {
        Constructor = Constructor.discriminators[discriminatorValue];
      } else {
        const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, discriminatorValue);
        if (constructorByValue) {
          Constructor = constructorByValue;
        }
      }
    }
    return Constructor;
  };
});

// node_modules/mongoose/lib/helpers/schema/handleIdOption.js
var require_handleIdOption = __commonJS((exports, module) => {
  var addAutoId = require_addAutoId();
  module.exports = function handleIdOption(schema, options) {
    if (options == null || options._id == null) {
      return schema;
    }
    schema = schema.clone();
    if (!options._id) {
      schema.remove("_id");
      schema.options._id = false;
    } else if (!schema.paths["_id"]) {
      addAutoId(schema);
      schema.options._id = true;
    }
    return schema;
  };
});

// node_modules/mongoose/lib/error/invalidSchemaOption.js
var require_invalidSchemaOption = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class InvalidSchemaOptionError extends MongooseError {
    constructor(name, option) {
      const msg = `Cannot create use schema for property "${name}" because the schema has the ${option} option enabled.`;
      super(msg);
    }
  }
  Object.defineProperty(InvalidSchemaOptionError.prototype, "name", {
    value: "InvalidSchemaOptionError"
  });
  /*!
   * exports
   */
  module.exports = InvalidSchemaOptionError;
});

// node_modules/mongoose/lib/schema/subdocument.js
var require_subdocument2 = __commonJS((exports, module) => {
  function SchemaSubdocument(schema, path, options) {
    if (schema.options.timeseries) {
      throw new InvalidSchemaOptionError(path, "timeseries");
    }
    const schemaTypeIdOption = SchemaSubdocument.defaultOptions && SchemaSubdocument.defaultOptions._id;
    if (schemaTypeIdOption != null) {
      options = options || {};
      options._id = schemaTypeIdOption;
    }
    schema = handleIdOption(schema, options);
    this.caster = _createConstructor(schema, null, options);
    this.caster.path = path;
    this.caster.prototype.$basePath = path;
    this.schema = schema;
    this.$isSingleNested = true;
    this.base = schema.base;
    SchemaType.call(this, path, options, "Embedded");
  }
  function _createConstructor(schema, baseClass, options) {
    SubdocumentType || (SubdocumentType = require_subdocument());
    const _embedded = function SingleNested(value, path, parent) {
      this.$__parent = parent;
      SubdocumentType.apply(this, arguments);
      if (parent == null) {
        return;
      }
      this.$session(parent.$session());
    };
    schema._preCompile();
    const proto = baseClass != null ? baseClass.prototype : SubdocumentType.prototype;
    _embedded.prototype = Object.create(proto);
    _embedded.prototype.$__setSchema(schema);
    _embedded.prototype.constructor = _embedded;
    _embedded.$__required = options?.required;
    _embedded.base = schema.base;
    _embedded.schema = schema;
    _embedded.$isSingleNested = true;
    _embedded.events = new EventEmitter;
    _embedded.prototype.toBSON = function() {
      return this.toObject(internalToObjectOptions);
    };
    for (const i in schema.methods) {
      _embedded.prototype[i] = schema.methods[i];
    }
    for (const i in schema.statics) {
      _embedded[i] = schema.statics[i];
    }
    for (const i in EventEmitter.prototype) {
      _embedded[i] = EventEmitter.prototype[i];
    }
    return _embedded;
  }
  /*!
   * Module dependencies.
   */
  var CastError = require_cast();
  var EventEmitter = import.meta.require("events").EventEmitter;
  var ObjectExpectedError = require_objectExpected();
  var SchemaSubdocumentOptions = require_schemaSubdocumentOptions();
  var SchemaType = require_schemaType();
  var applyDefaults = require_applyDefaults();
  var $exists = require_exists();
  var castToNumber = require_helpers().castToNumber;
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  var discriminator = require_discriminator();
  var geospatial = require_geospatial();
  var getConstructor = require_getConstructor();
  var handleIdOption = require_handleIdOption();
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var isExclusive = require_isExclusive();
  var utils = require_utils4();
  var InvalidSchemaOptionError = require_invalidSchemaOption();
  var SubdocumentType;
  module.exports = SchemaSubdocument;
  /*!
   * ignore
   */
  SchemaSubdocument.prototype = Object.create(SchemaType.prototype);
  SchemaSubdocument.prototype.constructor = SchemaSubdocument;
  SchemaSubdocument.prototype.OptionsConstructor = SchemaSubdocumentOptions;
  /*!
   * ignore
   */
  SchemaSubdocument.prototype.$conditionalHandlers.$geoWithin = function handle$geoWithin(val, context) {
    return { $geometry: this.castForQuery(null, val.$geometry, context) };
  };
  /*!
   * ignore
   */
  SchemaSubdocument.prototype.$conditionalHandlers.$near = SchemaSubdocument.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;
  SchemaSubdocument.prototype.$conditionalHandlers.$within = SchemaSubdocument.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;
  SchemaSubdocument.prototype.$conditionalHandlers.$geoIntersects = geospatial.cast$geoIntersects;
  SchemaSubdocument.prototype.$conditionalHandlers.$minDistance = castToNumber;
  SchemaSubdocument.prototype.$conditionalHandlers.$maxDistance = castToNumber;
  SchemaSubdocument.prototype.$conditionalHandlers.$exists = $exists;
  SchemaSubdocument.prototype.cast = function(val, doc, init, priorVal, options) {
    if (val && val.$isSingleNested && val.parent === doc) {
      return val;
    }
    if (val != null && (typeof val !== "object" || Array.isArray(val))) {
      throw new ObjectExpectedError(this.path, val);
    }
    const discriminatorKeyPath = this.schema.path(this.schema.options.discriminatorKey);
    const defaultDiscriminatorValue = discriminatorKeyPath == null ? null : discriminatorKeyPath.getDefault(doc);
    const Constructor = getConstructor(this.caster, val, defaultDiscriminatorValue);
    let subdoc;
    const parentSelected = doc && doc.$__ && doc.$__.selected;
    const path = this.path;
    const selected = parentSelected == null ? null : Object.keys(parentSelected).reduce((obj, key) => {
      if (key.startsWith(path + ".")) {
        obj = obj || {};
        obj[key.substring(path.length + 1)] = parentSelected[key];
      }
      return obj;
    }, null);
    if (init) {
      subdoc = new Constructor(undefined, selected, doc, false, { defaults: false });
      delete subdoc.$__.defaults;
      subdoc.$init(val);
      const exclude = isExclusive(selected);
      applyDefaults(subdoc, selected, exclude);
    } else {
      options = Object.assign({}, options, { priorDoc: priorVal });
      if (Object.keys(val).length === 0) {
        return new Constructor({}, selected, doc, undefined, options);
      }
      return new Constructor(val, selected, doc, undefined, options);
    }
    return subdoc;
  };
  SchemaSubdocument.prototype.castForQuery = function($conditional, val, context, options) {
    let handler;
    if ($conditional != null) {
      handler = this.$conditionalHandlers[$conditional];
      if (!handler) {
        throw new Error("Can\'t use " + $conditional);
      }
      return handler.call(this, val);
    }
    if (val == null) {
      return val;
    }
    const Constructor = getConstructor(this.caster, val);
    if (val instanceof Constructor) {
      return val;
    }
    if (this.options.runSetters) {
      val = this._applySetters(val, context);
    }
    const overrideStrict = options != null && options.strict != null ? options.strict : undefined;
    try {
      val = new Constructor(val, overrideStrict);
    } catch (error) {
      if (!(error instanceof CastError)) {
        throw new CastError("Embedded", val, this.path, error, this);
      }
      throw error;
    }
    return val;
  };
  SchemaSubdocument.prototype.doValidate = function(value, fn, scope, options) {
    const Constructor = getConstructor(this.caster, value);
    if (value && !(value instanceof Constructor)) {
      value = new Constructor(value, null, scope != null && scope.$__ != null ? scope : null);
    }
    if (options && options.skipSchemaValidators) {
      if (!value) {
        return fn(null);
      }
      return value.validate().then(() => fn(null), (err) => fn(err));
    }
    SchemaType.prototype.doValidate.call(this, value, function(error) {
      if (error) {
        return fn(error);
      }
      if (!value) {
        return fn(null);
      }
      value.validate().then(() => fn(null), (err) => fn(err));
    }, scope, options);
  };
  SchemaSubdocument.prototype.doValidateSync = function(value, scope, options) {
    if (!options || !options.skipSchemaValidators) {
      const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);
      if (schemaTypeError) {
        return schemaTypeError;
      }
    }
    if (!value) {
      return;
    }
    return value.validateSync();
  };
  SchemaSubdocument.prototype.discriminator = function(name, schema, options) {
    options = options || {};
    const value = utils.isPOJO(options) ? options.value : options;
    const clone = typeof options.clone === "boolean" ? options.clone : true;
    if (schema.instanceOfSchema && clone) {
      schema = schema.clone();
    }
    schema = discriminator(this.caster, name, schema, value, null, null, options.overwriteExisting);
    this.caster.discriminators[name] = _createConstructor(schema, this.caster);
    return this.caster.discriminators[name];
  };
  /*!
   * ignore
   */
  SchemaSubdocument.defaultOptions = {};
  SchemaSubdocument.set = SchemaType.set;
  SchemaSubdocument.setters = [];
  SchemaSubdocument.get = SchemaType.get;
  /*!
   * ignore
   */
  SchemaSubdocument.prototype.toJSON = function toJSON() {
    return { path: this.path, options: this.options };
  };
  /*!
   * ignore
   */
  SchemaSubdocument.prototype.clone = function() {
    const schematype = new this.constructor(this.schema, this.path, { ...this.options, _skipApplyDiscriminators: true });
    schematype.validators = this.validators.slice();
    if (this.requiredValidator !== undefined) {
      schematype.requiredValidator = this.requiredValidator;
    }
    schematype.caster.discriminators = Object.assign({}, this.caster.discriminators);
    schematype._appliedDiscriminators = this._appliedDiscriminators;
    return schematype;
  };
  SchemaSubdocument.prototype.toJSONSchema = function toJSONSchema(options) {
    const isRequired = this.options.required && typeof this.options.required !== "function";
    return {
      ...this.schema.toJSONSchema(options),
      ...createJSONSchemaTypeDefinition("object", "object", options?.useBsonType, isRequired)
    };
  };
});

// node_modules/mongoose/lib/schema/documentArrayElement.js
var require_documentArrayElement = __commonJS((exports, module) => {
  function SchemaDocumentArrayElement(path, options) {
    this.$parentSchemaType = options && options.$parentSchemaType;
    if (!this.$parentSchemaType) {
      throw new MongooseError("Cannot create DocumentArrayElement schematype without a parent");
    }
    delete options.$parentSchemaType;
    SchemaType.call(this, path, options, "DocumentArrayElement");
    this.$isMongooseDocumentArrayElement = true;
  }
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();
  var SchemaType = require_schemaType();
  var SchemaSubdocument = require_subdocument2();
  var getConstructor = require_getConstructor();
  SchemaDocumentArrayElement.schemaName = "DocumentArrayElement";
  SchemaDocumentArrayElement.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaDocumentArrayElement.prototype = Object.create(SchemaType.prototype);
  SchemaDocumentArrayElement.prototype.constructor = SchemaDocumentArrayElement;
  SchemaDocumentArrayElement.prototype.cast = function(...args) {
    return this.$parentSchemaType.cast(...args)[0];
  };
  SchemaDocumentArrayElement.prototype.doValidate = function(value, fn, scope, options) {
    const Constructor = getConstructor(this.caster, value);
    if (value && !(value instanceof Constructor)) {
      value = new Constructor(value, scope, null, null, options && options.index != null ? options.index : null);
    }
    return SchemaSubdocument.prototype.doValidate.call(this, value, fn, scope, options);
  };
  SchemaDocumentArrayElement.prototype.clone = function() {
    this.options.$parentSchemaType = this.$parentSchemaType;
    const ret = SchemaType.prototype.clone.apply(this, arguments);
    delete this.options.$parentSchemaType;
    ret.caster = this.caster;
    ret.schema = this.schema;
    return ret;
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaDocumentArrayElement;
});

// node_modules/mongoose/lib/options/schemaDocumentArrayOptions.js
var require_schemaDocumentArrayOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_schemaTypeOptions();

  class SchemaDocumentArrayOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaDocumentArrayOptions.prototype, "excludeIndexes", opts);
  Object.defineProperty(SchemaDocumentArrayOptions.prototype, "_id", opts);
  /*!
   * ignore
   */
  module.exports = SchemaDocumentArrayOptions;
});

// node_modules/mongoose/lib/schema/documentArray.js
var require_documentArray2 = __commonJS((exports, module) => {
  function SchemaDocumentArray(key, schema, options, schemaOptions) {
    if (schema.options && schema.options.timeseries) {
      throw new InvalidSchemaOptionError(key, "timeseries");
    }
    const schemaTypeIdOption = SchemaDocumentArray.defaultOptions && SchemaDocumentArray.defaultOptions._id;
    if (schemaTypeIdOption != null) {
      schemaOptions = schemaOptions || {};
      schemaOptions._id = schemaTypeIdOption;
    }
    if (schemaOptions != null && schemaOptions._id != null) {
      schema = handleIdOption(schema, schemaOptions);
    } else if (options != null && options._id != null) {
      schema = handleIdOption(schema, options);
    }
    const EmbeddedDocument = _createConstructor(schema, options);
    EmbeddedDocument.prototype.$basePath = key;
    SchemaArray.call(this, key, EmbeddedDocument, options);
    this.schema = schema;
    this.schemaOptions = schemaOptions || {};
    this.$isMongooseDocumentArray = true;
    this.Constructor = EmbeddedDocument;
    EmbeddedDocument.base = schema.base;
    const fn = this.defaultValue;
    if (!("defaultValue" in this) || fn != null) {
      this.default(function() {
        let arr = fn.call(this);
        if (arr != null && !Array.isArray(arr)) {
          arr = [arr];
        }
        return arr;
      });
    }
    const $parentSchemaType = this;
    this.$embeddedSchemaType = new DocumentArrayElement(key + ".$", {
      required: this && this.schemaOptions && this.schemaOptions.required || false,
      $parentSchemaType
    });
    this.$embeddedSchemaType.caster = this.Constructor;
    this.$embeddedSchemaType.schema = this.schema;
  }
  function _createConstructor(schema, options, baseClass) {
    Subdocument || (Subdocument = require_arraySubdocument());
    function EmbeddedDocument() {
      Subdocument.apply(this, arguments);
      if (this.__parentArray == null || this.__parentArray.getArrayParent() == null) {
        return;
      }
      this.$session(this.__parentArray.getArrayParent().$session());
    }
    schema._preCompile();
    const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;
    EmbeddedDocument.prototype = Object.create(proto);
    EmbeddedDocument.prototype.$__setSchema(schema);
    EmbeddedDocument.schema = schema;
    EmbeddedDocument.prototype.constructor = EmbeddedDocument;
    EmbeddedDocument.$isArraySubdocument = true;
    EmbeddedDocument.events = new EventEmitter;
    EmbeddedDocument.base = schema.base;
    for (const i in schema.methods) {
      EmbeddedDocument.prototype[i] = schema.methods[i];
    }
    for (const i in schema.statics) {
      EmbeddedDocument[i] = schema.statics[i];
    }
    for (const i in EventEmitter.prototype) {
      EmbeddedDocument[i] = EventEmitter.prototype[i];
    }
    EmbeddedDocument.options = options;
    return EmbeddedDocument;
  }
  function scopePaths(array, fields, init) {
    if (!(init && fields)) {
      return;
    }
    const path = array.path + ".";
    const keys = Object.keys(fields);
    let i = keys.length;
    const selected = {};
    let hasKeys;
    let key;
    let sub;
    while (i--) {
      key = keys[i];
      if (key.startsWith(path)) {
        sub = key.substring(path.length);
        if (sub === "$") {
          continue;
        }
        if (sub.startsWith("$.")) {
          sub = sub.substring(2);
        }
        hasKeys || (hasKeys = true);
        selected[sub] = fields[key];
      }
    }
    return hasKeys && selected || undefined;
  }
  function cast$elemMatch(val, context) {
    const keys = Object.keys(val);
    const numKeys = keys.length;
    for (let i = 0;i < numKeys; ++i) {
      const key = keys[i];
      const value = val[key];
      if (isOperator(key) && value != null) {
        val[key] = this.castForQuery(key, value, context);
      }
    }
    const discriminatorKey = this && this.casterConstructor && this.casterConstructor.schema && this.casterConstructor.schema.options && this.casterConstructor.schema.options.discriminatorKey;
    const discriminators = this && this.casterConstructor && this.casterConstructor.schema && this.casterConstructor.schema.discriminators || {};
    if (discriminatorKey != null && val[discriminatorKey] != null && discriminators[val[discriminatorKey]] != null) {
      return cast(discriminators[val[discriminatorKey]], val, null, this && this.$$context);
    }
    const schema = this.casterConstructor.schema ?? context.schema;
    return cast(schema, val, null, this && this.$$context);
  }
  /*!
   * Module dependencies.
   */
  var CastError = require_cast();
  var DocumentArrayElement = require_documentArrayElement();
  var EventEmitter = import.meta.require("events").EventEmitter;
  var SchemaArray = require_array2();
  var SchemaDocumentArrayOptions = require_schemaDocumentArrayOptions();
  var SchemaType = require_schemaType();
  var cast = require_cast2();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  var discriminator = require_discriminator();
  var handleIdOption = require_handleIdOption();
  var handleSpreadDoc = require_handleSpreadDoc();
  var isOperator = require_isOperator();
  var utils = require_utils4();
  var getConstructor = require_getConstructor();
  var InvalidSchemaOptionError = require_invalidSchemaOption();
  var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
  var arrayPathSymbol = require_symbols().arrayPathSymbol;
  var documentArrayParent = require_symbols().documentArrayParent;
  var MongooseDocumentArray;
  var Subdocument;
  SchemaDocumentArray.schemaName = "DocumentArray";
  SchemaDocumentArray.options = { castNonArrays: true };
  /*!
   * Inherits from SchemaArray.
   */
  SchemaDocumentArray.prototype = Object.create(SchemaArray.prototype);
  SchemaDocumentArray.prototype.constructor = SchemaDocumentArray;
  SchemaDocumentArray.prototype.OptionsConstructor = SchemaDocumentArrayOptions;
  SchemaDocumentArray.prototype.$conditionalHandlers = { ...SchemaArray.prototype.$conditionalHandlers };
  /*!
   * ignore
   */
  SchemaDocumentArray.prototype.discriminator = function(name, schema, options) {
    if (typeof name === "function") {
      name = utils.getFunctionName(name);
    }
    options = options || {};
    const tiedValue = utils.isPOJO(options) ? options.value : options;
    const clone = typeof options.clone === "boolean" ? options.clone : true;
    if (schema.instanceOfSchema && clone) {
      schema = schema.clone();
    }
    schema = discriminator(this.casterConstructor, name, schema, tiedValue, null, null, options?.overwriteExisting);
    const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);
    EmbeddedDocument.baseCasterConstructor = this.casterConstructor;
    try {
      Object.defineProperty(EmbeddedDocument, "name", {
        value: name
      });
    } catch (error) {
    }
    this.casterConstructor.discriminators[name] = EmbeddedDocument;
    return this.casterConstructor.discriminators[name];
  };
  SchemaDocumentArray.prototype.doValidate = function(array, fn, scope, options) {
    MongooseDocumentArray || (MongooseDocumentArray = require_documentArray());
    const _this = this;
    try {
      SchemaType.prototype.doValidate.call(this, array, cb, scope);
    } catch (err) {
      return fn(err);
    }
    function cb(err) {
      if (err) {
        return fn(err);
      }
      let count = array && array.length;
      let error;
      if (!count) {
        return fn();
      }
      if (options && options.updateValidator) {
        return fn();
      }
      if (!utils.isMongooseDocumentArray(array)) {
        array = new MongooseDocumentArray(array, _this.path, scope);
      }
      function callback(err2) {
        if (err2 != null) {
          error = err2;
        }
        --count || fn(error);
      }
      for (let i = 0, len = count;i < len; ++i) {
        let doc = array[i];
        if (doc == null) {
          --count || fn(error);
          continue;
        }
        if (!(doc instanceof Subdocument)) {
          const Constructor = getConstructor(_this.casterConstructor, array[i]);
          doc = array[i] = new Constructor(doc, array, undefined, undefined, i);
        }
        if (options != null && options.validateModifiedOnly && !doc.$isModified()) {
          --count || fn(error);
          continue;
        }
        doc.$__validate(null, options, callback);
      }
    }
  };
  SchemaDocumentArray.prototype.doValidateSync = function(array, scope, options) {
    const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);
    if (schemaTypeError != null) {
      return schemaTypeError;
    }
    const count = array && array.length;
    let resultError = null;
    if (!count) {
      return;
    }
    for (let i = 0, len = count;i < len; ++i) {
      let doc = array[i];
      if (!doc) {
        continue;
      }
      if (!(doc instanceof Subdocument)) {
        const Constructor = getConstructor(this.casterConstructor, array[i]);
        doc = array[i] = new Constructor(doc, array, undefined, undefined, i);
      }
      if (options != null && options.validateModifiedOnly && !doc.$isModified()) {
        continue;
      }
      const subdocValidateError = doc.validateSync(options);
      if (subdocValidateError && resultError == null) {
        resultError = subdocValidateError;
      }
    }
    return resultError;
  };
  /*!
   * ignore
   */
  SchemaDocumentArray.prototype.getDefault = function(scope, init, options) {
    let ret = typeof this.defaultValue === "function" ? this.defaultValue.call(scope) : this.defaultValue;
    if (ret == null) {
      return ret;
    }
    if (options && options.skipCast) {
      return ret;
    }
    MongooseDocumentArray || (MongooseDocumentArray = require_documentArray());
    if (!Array.isArray(ret)) {
      ret = [ret];
    }
    ret = new MongooseDocumentArray(ret, this.path, scope);
    for (let i = 0;i < ret.length; ++i) {
      const Constructor = getConstructor(this.casterConstructor, ret[i]);
      const _subdoc = new Constructor({}, ret, undefined, undefined, i);
      _subdoc.$init(ret[i]);
      _subdoc.isNew = true;
      Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);
      _subdoc.$__.activePaths.init = {};
      ret[i] = _subdoc;
    }
    return ret;
  };
  var _toObjectOptions = Object.freeze({ transform: false, virtuals: false });
  var initDocumentOptions = Object.freeze({ skipId: false, willInit: true });
  SchemaDocumentArray.prototype.cast = function(value, doc, init, prev, options) {
    MongooseDocumentArray || (MongooseDocumentArray = require_documentArray());
    if (value != null && value[arrayPathSymbol] != null && value === prev) {
      return value;
    }
    let selected;
    let subdoc;
    options = options || {};
    const path = options.path || this.path;
    if (!Array.isArray(value)) {
      if (!init && !SchemaDocumentArray.options.castNonArrays) {
        throw new CastError("DocumentArray", value, this.path, null, this);
      }
      if (!!doc && init) {
        doc.markModified(path);
      }
      return this.cast([value], doc, init, prev, options);
    }
    if (!options.skipDocumentArrayCast || utils.isMongooseDocumentArray(value)) {
      value = new MongooseDocumentArray(value, path, doc, this);
    }
    if (prev != null) {
      value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};
    }
    if (options.arrayPathIndex != null) {
      value[arrayPathSymbol] = path + "." + options.arrayPathIndex;
    }
    const rawArray = utils.isMongooseDocumentArray(value) ? value.__array : value;
    const len = rawArray.length;
    for (let i = 0;i < len; ++i) {
      if (!rawArray[i]) {
        continue;
      }
      const Constructor = getConstructor(this.casterConstructor, rawArray[i]);
      const spreadDoc = handleSpreadDoc(rawArray[i], true);
      if (rawArray[i] !== spreadDoc) {
        rawArray[i] = spreadDoc;
      }
      if (rawArray[i] instanceof Subdocument) {
        if (rawArray[i][documentArrayParent] !== doc) {
          if (init) {
            const subdoc2 = new Constructor(null, value, initDocumentOptions, selected, i);
            rawArray[i] = subdoc2.$init(rawArray[i]);
          } else {
            const subdoc2 = new Constructor(rawArray[i], value, undefined, undefined, i);
            rawArray[i] = subdoc2;
          }
        }
        if (rawArray[i].__index == null) {
          rawArray[i].$setIndex(i);
        }
      } else if (rawArray[i] != null) {
        if (init) {
          if (doc) {
            selected || (selected = scopePaths(this, doc.$__.selected, init));
          } else {
            selected = true;
          }
          subdoc = new Constructor(null, value, initDocumentOptions, selected, i);
          rawArray[i] = subdoc.$init(rawArray[i]);
        } else {
          if (prev && typeof prev.id === "function") {
            subdoc = prev.id(rawArray[i]._id);
          }
          if (prev && subdoc && utils.deepEqual(subdoc.toObject(_toObjectOptions), rawArray[i])) {
            subdoc.set(rawArray[i]);
            rawArray[i] = subdoc;
          } else {
            try {
              subdoc = new Constructor(rawArray[i], value, undefined, undefined, i);
              rawArray[i] = subdoc;
            } catch (error) {
              throw new CastError("embedded", rawArray[i], value[arrayPathSymbol], error, this);
            }
          }
        }
      }
    }
    return value;
  };
  /*!
   * ignore
   */
  SchemaDocumentArray.prototype.clone = function() {
    const options = Object.assign({}, this.options);
    const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);
    schematype.validators = this.validators.slice();
    if (this.requiredValidator !== undefined) {
      schematype.requiredValidator = this.requiredValidator;
    }
    schematype.Constructor.discriminators = Object.assign({}, this.Constructor.discriminators);
    schematype._appliedDiscriminators = this._appliedDiscriminators;
    return schematype;
  };
  /*!
   * ignore
   */
  SchemaDocumentArray.prototype.applyGetters = function(value, scope) {
    return SchemaType.prototype.applyGetters.call(this, value, scope);
  };
  /*!
   * ignore
   */
  SchemaDocumentArray.defaultOptions = {};
  SchemaDocumentArray.set = SchemaType.set;
  SchemaDocumentArray.setters = [];
  SchemaDocumentArray.get = SchemaType.get;
  /*!
   * Handle casting $elemMatch operators
   */
  SchemaDocumentArray.prototype.$conditionalHandlers.$elemMatch = cast$elemMatch;
  SchemaDocumentArray.prototype.toJSONSchema = function toJSONSchema(options) {
    const itemsTypeDefinition = createJSONSchemaTypeDefinition("object", "object", options?.useBsonType, false);
    const isRequired = this.options.required && typeof this.options.required !== "function";
    return {
      ...createJSONSchemaTypeDefinition("array", "array", options?.useBsonType, isRequired),
      items: { ...itemsTypeDefinition, ...this.schema.toJSONSchema(options) }
    };
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaDocumentArray;
});

// node_modules/mongoose/lib/options/schemaMapOptions.js
var require_schemaMapOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_schemaTypeOptions();

  class SchemaMapOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaMapOptions.prototype, "of", opts);
  module.exports = SchemaMapOptions;
});

// node_modules/mongoose/lib/schema/map.js
var require_map3 = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  var MongooseMap = require_map2();
  var SchemaMapOptions = require_schemaMapOptions();
  var SchemaType = require_schemaType();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  /*!
   * ignore
   */

  class SchemaMap extends SchemaType {
    constructor(key, options) {
      super(key, options, "Map");
      this.$isSchemaMap = true;
    }
    set(option, value) {
      return SchemaType.set(option, value);
    }
    cast(val, doc, init) {
      if (val instanceof MongooseMap) {
        return val;
      }
      const path = this.path;
      if (init) {
        const map = new MongooseMap({}, path, doc, this.$__schemaType);
        if (val instanceof global.Map) {
          for (const key of val.keys()) {
            let _val = val.get(key);
            if (_val == null) {
              _val = map.$__schemaType._castNullish(_val);
            } else {
              _val = map.$__schemaType.cast(_val, doc, true, null, { path: path + "." + key });
            }
            map.$init(key, _val);
          }
        } else {
          for (const key of Object.keys(val)) {
            let _val = val[key];
            if (_val == null) {
              _val = map.$__schemaType._castNullish(_val);
            } else {
              _val = map.$__schemaType.cast(_val, doc, true, null, { path: path + "." + key });
            }
            map.$init(key, _val);
          }
        }
        return map;
      }
      return new MongooseMap(val, path, doc, this.$__schemaType);
    }
    clone() {
      const schematype = super.clone();
      if (this.$__schemaType != null) {
        schematype.$__schemaType = this.$__schemaType.clone();
      }
      return schematype;
    }
    getEmbeddedSchemaType() {
      return this.$__schemaType;
    }
    toJSONSchema(options) {
      const useBsonType = options?.useBsonType;
      const embeddedSchemaType = this.getEmbeddedSchemaType();
      const isRequired = this.options.required && typeof this.options.required !== "function";
      const result = createJSONSchemaTypeDefinition("object", "object", useBsonType, isRequired);
      result.additionalProperties = embeddedSchemaType.toJSONSchema(options);
      return result;
    }
  }
  SchemaMap.schemaName = "Map";
  SchemaMap.prototype.OptionsConstructor = SchemaMapOptions;
  SchemaMap.defaultOptions = {};
  module.exports = SchemaMap;
});

// node_modules/mongoose/lib/options/schemaObjectIdOptions.js
var require_schemaObjectIdOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_schemaTypeOptions();

  class SchemaObjectIdOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaObjectIdOptions.prototype, "auto", opts);
  Object.defineProperty(SchemaObjectIdOptions.prototype, "populate", opts);
  /*!
   * ignore
   */
  module.exports = SchemaObjectIdOptions;
});

// node_modules/mongoose/lib/schema/objectId.js
var require_objectId = __commonJS((exports, module) => {
  function SchemaObjectId(key, options) {
    const isKeyHexStr = typeof key === "string" && key.length === 24 && /^[a-f0-9]+$/i.test(key);
    const suppressWarning = options && options.suppressWarning;
    if ((isKeyHexStr || typeof key === "undefined") && !suppressWarning) {
      utils.warn("mongoose: To create a new ObjectId please try " + "`Mongoose.Types.ObjectId` instead of using " + "`Mongoose.Schema.ObjectId`. Set the `suppressWarning` option if " + "you\'re trying to create a hex char path in your schema.");
    }
    SchemaType.call(this, key, options, "ObjectId");
  }
  function handleSingle(val) {
    return this.cast(val);
  }
  function defaultId() {
    return new oid;
  }
  function resetId(v) {
    Document || (Document = require_document2());
    if (this instanceof Document) {
      if (v === undefined) {
        const _v = new oid;
        return _v;
      }
    }
    return v;
  }
  /*!
   * Module dependencies.
   */
  var SchemaObjectIdOptions = require_schemaObjectIdOptions();
  var SchemaType = require_schemaType();
  var castObjectId = require_objectid2();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  var getConstructorName = require_getConstructorName();
  var oid = require_objectid();
  var isBsonType = require_isBsonType();
  var utils = require_utils4();
  var CastError = SchemaType.CastError;
  var Document;
  SchemaObjectId.schemaName = "ObjectId";
  SchemaObjectId.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaObjectId.prototype = Object.create(SchemaType.prototype);
  SchemaObjectId.prototype.constructor = SchemaObjectId;
  SchemaObjectId.prototype.OptionsConstructor = SchemaObjectIdOptions;
  SchemaObjectId.get = SchemaType.get;
  SchemaObjectId.set = SchemaType.set;
  SchemaObjectId.setters = [];
  SchemaObjectId.prototype.auto = function(turnOn) {
    if (turnOn) {
      this.default(defaultId);
      this.set(resetId);
    }
    return this;
  };
  /*!
   * ignore
   */
  SchemaObjectId._checkRequired = (v) => isBsonType(v, "ObjectId");
  /*!
   * ignore
   */
  SchemaObjectId._cast = castObjectId;
  SchemaObjectId.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaObjectId._defaultCaster = (v) => {
    if (!isBsonType(v, "ObjectId")) {
      throw new Error(v + " is not an instance of ObjectId");
    }
    return v;
  };
  SchemaObjectId.checkRequired = SchemaType.checkRequired;
  SchemaObjectId.prototype.checkRequired = function checkRequired(value, doc) {
    if (SchemaType._isRef(this, value, doc, true)) {
      return !!value;
    }
    const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : SchemaObjectId.checkRequired();
    return _checkRequired(value);
  };
  SchemaObjectId.prototype.cast = function(value, doc, init, prev, options) {
    if (!isBsonType(value, "ObjectId") && SchemaType._isRef(this, value, doc, init)) {
      if ((getConstructorName(value) || "").toLowerCase() === "objectid") {
        return new oid(value.toHexString());
      }
      if (value == null || utils.isNonBuiltinObject(value)) {
        return this._castRef(value, doc, init, options);
      }
    }
    let castObjectId2;
    if (typeof this._castFunction === "function") {
      castObjectId2 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castObjectId2 = this.constructor.cast();
    } else {
      castObjectId2 = SchemaObjectId.cast();
    }
    try {
      return castObjectId2(value);
    } catch (error) {
      throw new CastError("ObjectId", value, this.path, error, this);
    }
  };
  /*!
   * ignore
   */
  SchemaObjectId.prototype.$conditionalHandlers = {
    ...SchemaType.prototype.$conditionalHandlers,
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle
  };
  /*!
   * ignore
   */
  defaultId.$runBeforeSetters = true;
  SchemaObjectId.prototype.toJSONSchema = function toJSONSchema(options) {
    const isRequired = this.options.required && typeof this.options.required !== "function" || this.path === "_id";
    return createJSONSchemaTypeDefinition("string", "objectId", options?.useBsonType, isRequired);
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaObjectId;
});

// node_modules/mongoose/lib/options/schemaStringOptions.js
var require_schemaStringOptions = __commonJS((exports, module) => {
  var SchemaTypeOptions = require_schemaTypeOptions();

  class SchemaStringOptions extends SchemaTypeOptions {
  }
  var opts = require_propertyOptions();
  Object.defineProperty(SchemaStringOptions.prototype, "enum", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "match", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "lowercase", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "trim", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "uppercase", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "minLength", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "minlength", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "maxLength", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "maxlength", opts);
  Object.defineProperty(SchemaStringOptions.prototype, "populate", opts);
  /*!
   * ignore
   */
  module.exports = SchemaStringOptions;
});

// node_modules/mongoose/lib/schema/string.js
var require_string2 = __commonJS((exports, module) => {
  function SchemaString(key, options) {
    this.enumValues = [];
    this.regExp = null;
    SchemaType.call(this, key, options, "String");
  }
  function handleSingle(val, context) {
    return this.castForQuery(null, val, context);
  }
  function handleArray(val, context) {
    const _this = this;
    if (!Array.isArray(val)) {
      return [this.castForQuery(null, val, context)];
    }
    return val.map(function(m) {
      return _this.castForQuery(null, m, context);
    });
  }
  function handleSingleNoSetters(val) {
    if (val == null) {
      return this._castNullish(val);
    }
    return this.cast(val, this);
  }
  /*!
   * Module dependencies.
   */
  var SchemaType = require_schemaType();
  var MongooseError = require_error2();
  var SchemaStringOptions = require_schemaStringOptions();
  var castString = require_string();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  var utils = require_utils4();
  var isBsonType = require_isBsonType();
  var CastError = SchemaType.CastError;
  SchemaString.schemaName = "String";
  SchemaString.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaString.prototype = Object.create(SchemaType.prototype);
  SchemaString.prototype.constructor = SchemaString;
  Object.defineProperty(SchemaString.prototype, "OptionsConstructor", {
    configurable: false,
    enumerable: false,
    writable: false,
    value: SchemaStringOptions
  });
  /*!
   * ignore
   */
  SchemaString._cast = castString;
  SchemaString.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaString._defaultCaster = (v) => {
    if (v != null && typeof v !== "string") {
      throw new Error;
    }
    return v;
  };
  SchemaString.get = SchemaType.get;
  SchemaString.set = SchemaType.set;
  SchemaString.setters = [];
  /*!
   * ignore
   */
  SchemaString._checkRequired = (v) => (v instanceof String || typeof v === "string") && v.length;
  SchemaString.checkRequired = SchemaType.checkRequired;
  SchemaString.prototype.enum = function() {
    if (this.enumValidator) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.enumValidator;
      }, this);
      this.enumValidator = false;
    }
    if (arguments[0] === undefined || arguments[0] === false) {
      return this;
    }
    let values;
    let errorMessage;
    if (utils.isObject(arguments[0])) {
      if (Array.isArray(arguments[0].values)) {
        values = arguments[0].values;
        errorMessage = arguments[0].message;
      } else {
        values = utils.object.vals(arguments[0]);
        errorMessage = MongooseError.messages.String.enum;
      }
    } else {
      values = arguments;
      errorMessage = MongooseError.messages.String.enum;
    }
    for (const value of values) {
      if (value !== undefined) {
        this.enumValues.push(this.cast(value));
      }
    }
    const vals = this.enumValues;
    this.enumValidator = function(v) {
      return v == null || ~vals.indexOf(v);
    };
    this.validators.push({
      validator: this.enumValidator,
      message: errorMessage,
      type: "enum",
      enumValues: vals
    });
    return this;
  };
  SchemaString.prototype.lowercase = function(shouldApply) {
    if (arguments.length > 0 && !shouldApply) {
      return this;
    }
    return this.set((v) => {
      if (typeof v !== "string") {
        v = this.cast(v);
      }
      if (v) {
        return v.toLowerCase();
      }
      return v;
    });
  };
  SchemaString.prototype.uppercase = function(shouldApply) {
    if (arguments.length > 0 && !shouldApply) {
      return this;
    }
    return this.set((v) => {
      if (typeof v !== "string") {
        v = this.cast(v);
      }
      if (v) {
        return v.toUpperCase();
      }
      return v;
    });
  };
  SchemaString.prototype.trim = function(shouldTrim) {
    if (arguments.length > 0 && !shouldTrim) {
      return this;
    }
    return this.set((v) => {
      if (typeof v !== "string") {
        v = this.cast(v);
      }
      if (v) {
        return v.trim();
      }
      return v;
    });
  };
  SchemaString.prototype.minlength = function(value, message) {
    if (this.minlengthValidator) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.minlengthValidator;
      }, this);
    }
    if (value !== null && value !== undefined) {
      let msg = message || MongooseError.messages.String.minlength;
      msg = msg.replace(/{MINLENGTH}/, value);
      this.validators.push({
        validator: this.minlengthValidator = function(v) {
          return v === null || v.length >= value;
        },
        message: msg,
        type: "minlength",
        minlength: value
      });
    }
    return this;
  };
  SchemaString.prototype.minLength = SchemaString.prototype.minlength;
  SchemaString.prototype.maxlength = function(value, message) {
    if (this.maxlengthValidator) {
      this.validators = this.validators.filter(function(v) {
        return v.validator !== this.maxlengthValidator;
      }, this);
    }
    if (value !== null && value !== undefined) {
      let msg = message || MongooseError.messages.String.maxlength;
      msg = msg.replace(/{MAXLENGTH}/, value);
      this.validators.push({
        validator: this.maxlengthValidator = function(v) {
          return v === null || v.length <= value;
        },
        message: msg,
        type: "maxlength",
        maxlength: value
      });
    }
    return this;
  };
  SchemaString.prototype.maxLength = SchemaString.prototype.maxlength;
  SchemaString.prototype.match = function match(regExp, message) {
    const msg = message || MongooseError.messages.String.match;
    const matchValidator = function(v) {
      if (!regExp) {
        return false;
      }
      regExp.lastIndex = 0;
      const ret = v != null && v !== "" ? regExp.test(v) : true;
      return ret;
    };
    this.validators.push({
      validator: matchValidator,
      message: msg,
      type: "regexp",
      regexp: regExp
    });
    return this;
  };
  SchemaString.prototype.checkRequired = function checkRequired(value, doc) {
    if (typeof value === "object" && SchemaType._isRef(this, value, doc, true)) {
      return value != null;
    }
    const _checkRequired = typeof this.constructor.checkRequired === "function" ? this.constructor.checkRequired() : SchemaString.checkRequired();
    return _checkRequired(value);
  };
  SchemaString.prototype.cast = function(value, doc, init, prev, options) {
    if (typeof value !== "string" && SchemaType._isRef(this, value, doc, init)) {
      return this._castRef(value, doc, init, options);
    }
    let castString2;
    if (typeof this._castFunction === "function") {
      castString2 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castString2 = this.constructor.cast();
    } else {
      castString2 = SchemaString.cast();
    }
    try {
      return castString2(value);
    } catch (error) {
      throw new CastError("string", value, this.path, null, this);
    }
  };
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  var $conditionalHandlers = {
    ...SchemaType.prototype.$conditionalHandlers,
    $all: handleArray,
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle,
    $options: handleSingleNoSetters,
    $regex: function handle$regex(val) {
      if (Object.prototype.toString.call(val) === "[object RegExp]") {
        return val;
      }
      return handleSingleNoSetters.call(this, val);
    },
    $not: handleSingle
  };
  Object.defineProperty(SchemaString.prototype, "$conditionalHandlers", {
    configurable: false,
    enumerable: false,
    writable: false,
    value: Object.freeze($conditionalHandlers)
  });
  SchemaString.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = this.$conditionalHandlers[$conditional];
      if (!handler) {
        throw new Error("Can\'t use " + $conditional + " with String.");
      }
      return handler.call(this, val, context);
    }
    if (Object.prototype.toString.call(val) === "[object RegExp]" || isBsonType(val, "BSONRegExp")) {
      return val;
    }
    try {
      return this.applySetters(val, context);
    } catch (err) {
      if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {
        err.path = this.$fullPath;
      }
      throw err;
    }
  };
  SchemaString.prototype.toJSONSchema = function toJSONSchema(options) {
    const isRequired = this.options.required && typeof this.options.required !== "function";
    return createJSONSchemaTypeDefinition("string", "string", options?.useBsonType, isRequired);
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaString;
});

// node_modules/mongoose/lib/cast/uuid.js
var require_uuid2 = __commonJS((exports, module) => {
  function hex2buffer(hex) {
    const buff = hex != null && Buffer.from(hex, "hex");
    return buff;
  }
  function stringToBinary(uuidStr) {
    if (typeof uuidStr !== "string")
      uuidStr = "";
    const hex = uuidStr.replace(/[{}-]/g, "");
    const bytes = hex2buffer(hex);
    const buff = new MongooseBuffer(bytes);
    buff._subtype = 4;
    return buff;
  }
  var MongooseBuffer = require_buffer();
  var UUID_FORMAT = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i;
  var Binary = MongooseBuffer.Binary;
  module.exports = function castUUID(value) {
    if (value == null) {
      return value;
    }
    function newBuffer(initbuff) {
      const buff = new MongooseBuffer(initbuff);
      buff._subtype = 4;
      return buff;
    }
    if (typeof value === "string") {
      if (UUID_FORMAT.test(value)) {
        return stringToBinary(value);
      } else {
        throw new Error(`"${value}" is not a valid UUID string`);
      }
    }
    if (Buffer.isBuffer(value)) {
      return newBuffer(value);
    }
    if (value instanceof Binary) {
      return newBuffer(value.value(true));
    }
    if (value.toString && value.toString !== Object.prototype.toString) {
      if (UUID_FORMAT.test(value.toString())) {
        return stringToBinary(value.toString());
      }
    }
    throw new Error(`"${value}" cannot be casted to a UUID`);
  };
  module.exports.UUID_FORMAT = UUID_FORMAT;
});

// node_modules/mongoose/lib/schema/uuid.js
var require_uuid3 = __commonJS((exports, module) => {
  function binaryToString(uuidBin) {
    let hex;
    if (typeof uuidBin !== "string" && uuidBin != null) {
      hex = uuidBin.toString("hex");
      const uuidStr = hex.substring(0, 8) + "-" + hex.substring(8, 8 + 4) + "-" + hex.substring(12, 12 + 4) + "-" + hex.substring(16, 16 + 4) + "-" + hex.substring(20, 20 + 12);
      return uuidStr;
    }
    return uuidBin;
  }
  function SchemaUUID(key, options) {
    SchemaType.call(this, key, options, "UUID");
    this.getters.push(function(value) {
      if (value != null && value.$__ != null) {
        return value;
      }
      if (Buffer.isBuffer(value)) {
        return binaryToString(value);
      } else if (value instanceof Binary) {
        return binaryToString(value.buffer);
      } else if (utils.isPOJO(value) && value.type === "Buffer" && Array.isArray(value.data)) {
        return binaryToString(Buffer.from(value.data));
      }
      return value;
    });
  }
  function handleSingle(val) {
    return this.cast(val);
  }
  function handleArray(val) {
    return val.map((m) => {
      return this.cast(m);
    });
  }
  /*!
   * Module dependencies.
   */
  var MongooseBuffer = require_buffer();
  var SchemaType = require_schemaType();
  var CastError = SchemaType.CastError;
  var castUUID = require_uuid2();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  var utils = require_utils4();
  var handleBitwiseOperator = require_bitwise();
  var UUID_FORMAT = castUUID.UUID_FORMAT;
  var Binary = MongooseBuffer.Binary;
  SchemaUUID.schemaName = "UUID";
  SchemaUUID.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaUUID.prototype = Object.create(SchemaType.prototype);
  SchemaUUID.prototype.constructor = SchemaUUID;
  /*!
   * ignore
   */
  SchemaUUID._cast = castUUID;
  SchemaUUID.get = SchemaType.get;
  SchemaUUID.set = SchemaType.set;
  SchemaUUID.setters = [];
  SchemaUUID.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaUUID._checkRequired = (v) => v != null;
  SchemaUUID.checkRequired = SchemaType.checkRequired;
  SchemaUUID.prototype.checkRequired = function checkRequired(value) {
    if (Buffer.isBuffer(value)) {
      value = binaryToString(value);
    }
    return value != null && UUID_FORMAT.test(value);
  };
  SchemaUUID.prototype.cast = function(value, doc, init, prev, options) {
    if (utils.isNonBuiltinObject(value) && SchemaType._isRef(this, value, doc, init)) {
      return this._castRef(value, doc, init, options);
    }
    let castFn;
    if (typeof this._castFunction === "function") {
      castFn = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castFn = this.constructor.cast();
    } else {
      castFn = SchemaUUID.cast();
    }
    try {
      return castFn(value);
    } catch (error) {
      throw new CastError(SchemaUUID.schemaName, value, this.path, error, this);
    }
  };
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  SchemaUUID.prototype.$conditionalHandlers = {
    ...SchemaType.prototype.$conditionalHandlers,
    $bitsAllClear: handleBitwiseOperator,
    $bitsAnyClear: handleBitwiseOperator,
    $bitsAllSet: handleBitwiseOperator,
    $bitsAnySet: handleBitwiseOperator,
    $all: handleArray,
    $gt: handleSingle,
    $gte: handleSingle,
    $in: handleArray,
    $lt: handleSingle,
    $lte: handleSingle,
    $ne: handleSingle,
    $nin: handleArray
  };
  SchemaUUID.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = this.$conditionalHandlers[$conditional];
      if (!handler)
        throw new Error("Can\'t use " + $conditional + " with UUID.");
      return handler.call(this, val, context);
    }
    try {
      return this.applySetters(val, context);
    } catch (err) {
      if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {
        err.path = this.$fullPath;
      }
      throw err;
    }
  };
  SchemaUUID.prototype.toJSONSchema = function toJSONSchema(options) {
    const isRequired = this.options.required && typeof this.options.required !== "function";
    return createJSONSchemaTypeDefinition("string", "binData", options?.useBsonType, isRequired);
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaUUID;
});

// node_modules/mongoose/lib/cast/double.js
var require_double = __commonJS((exports, module) => {
  var assert = import.meta.require("assert");
  var BSON = require_bson();
  var isBsonType = require_isBsonType();
  module.exports = function castDouble(val) {
    if (val == null || val === "") {
      return null;
    }
    let coercedVal;
    if (isBsonType(val, "Long")) {
      coercedVal = val.toNumber();
    } else if (typeof val === "string") {
      try {
        coercedVal = BSON.Double.fromString(val);
        return coercedVal;
      } catch {
        assert.ok(false);
      }
    } else if (typeof val === "object") {
      const tempVal = val.valueOf() ?? val.toString();
      if (typeof tempVal === "string") {
        try {
          coercedVal = BSON.Double.fromString(val);
          return coercedVal;
        } catch {
          assert.ok(false);
        }
      } else {
        coercedVal = Number(tempVal);
      }
    } else {
      coercedVal = Number(val);
    }
    return new BSON.Double(coercedVal);
  };
});

// node_modules/mongoose/lib/schema/double.js
var require_double2 = __commonJS((exports, module) => {
  function SchemaDouble(path, options) {
    SchemaType.call(this, path, options, "Double");
  }
  function handleSingle(val) {
    return this.cast(val);
  }
  /*!
   * Module dependencies.
   */
  var CastError = require_cast();
  var SchemaType = require_schemaType();
  var castDouble = require_double();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  SchemaDouble.schemaName = "Double";
  SchemaDouble.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaDouble.prototype = Object.create(SchemaType.prototype);
  SchemaDouble.prototype.constructor = SchemaDouble;
  /*!
   * ignore
   */
  SchemaDouble._cast = castDouble;
  SchemaDouble.set = SchemaType.set;
  SchemaDouble.setters = [];
  SchemaDouble.get = SchemaType.get;
  /*!
   * ignore
   */
  SchemaDouble._defaultCaster = (v) => {
    if (v != null) {
      if (v._bsontype !== "Double") {
        throw new Error;
      }
    }
    return v;
  };
  SchemaDouble.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaDouble._checkRequired = (v) => v != null;
  SchemaDouble.checkRequired = SchemaType.checkRequired;
  SchemaDouble.prototype.checkRequired = function(value) {
    return this.constructor._checkRequired(value);
  };
  SchemaDouble.prototype.cast = function(value) {
    let castDouble2;
    if (typeof this._castFunction === "function") {
      castDouble2 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castDouble2 = this.constructor.cast();
    } else {
      castDouble2 = SchemaDouble.cast();
    }
    try {
      return castDouble2(value);
    } catch (error) {
      throw new CastError("Double", value, this.path, error, this);
    }
  };
  /*!
   * ignore
   */
  SchemaDouble.prototype.$conditionalHandlers = {
    ...SchemaType.prototype.$conditionalHandlers,
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle
  };
  SchemaDouble.prototype.toJSONSchema = function toJSONSchema(options) {
    const isRequired = this.options.required && typeof this.options.required !== "function";
    return createJSONSchemaTypeDefinition("number", "double", options?.useBsonType, isRequired);
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaDouble;
});

// node_modules/mongoose/lib/cast/int32.js
var require_int32 = __commonJS((exports, module) => {
  var isBsonType = require_isBsonType();
  var assert = import.meta.require("assert");
  module.exports = function castInt32(val) {
    if (val == null) {
      return val;
    }
    if (val === "") {
      return null;
    }
    const coercedVal = isBsonType(val, "Long") ? val.toNumber() : Number(val);
    const INT32_MAX = 2147483647;
    const INT32_MIN = -2147483648;
    if (coercedVal === (coercedVal | 0) && coercedVal >= INT32_MIN && coercedVal <= INT32_MAX) {
      return coercedVal;
    }
    assert.ok(false);
  };
});

// node_modules/mongoose/lib/schema/int32.js
var require_int322 = __commonJS((exports, module) => {
  function SchemaInt32(path, options) {
    SchemaType.call(this, path, options, "Int32");
  }
  function handleSingle(val, context) {
    return this.castForQuery(null, val, context);
  }
  /*!
   * Module dependencies.
   */
  var CastError = require_cast();
  var SchemaType = require_schemaType();
  var castInt32 = require_int32();
  var createJSONSchemaTypeDefinition = require_createJSONSchemaTypeDefinition();
  var handleBitwiseOperator = require_bitwise();
  SchemaInt32.schemaName = "Int32";
  SchemaInt32.defaultOptions = {};
  /*!
   * Inherits from SchemaType.
   */
  SchemaInt32.prototype = Object.create(SchemaType.prototype);
  SchemaInt32.prototype.constructor = SchemaInt32;
  /*!
   * ignore
   */
  SchemaInt32._cast = castInt32;
  SchemaInt32.set = SchemaType.set;
  SchemaInt32.setters = [];
  SchemaInt32.get = SchemaType.get;
  /*!
   * ignore
   */
  SchemaInt32._defaultCaster = (v) => {
    const INT32_MAX = 2147483647;
    const INT32_MIN = -2147483648;
    if (v != null) {
      if (typeof v !== "number" || v !== (v | 0) || v < INT32_MIN || v > INT32_MAX) {
        throw new Error;
      }
    }
    return v;
  };
  SchemaInt32.cast = function cast(caster) {
    if (arguments.length === 0) {
      return this._cast;
    }
    if (caster === false) {
      caster = this._defaultCaster;
    }
    this._cast = caster;
    return this._cast;
  };
  /*!
   * ignore
   */
  SchemaInt32._checkRequired = (v) => v != null;
  SchemaInt32.checkRequired = SchemaType.checkRequired;
  SchemaInt32.prototype.checkRequired = function(value) {
    return this.constructor._checkRequired(value);
  };
  SchemaInt32.prototype.cast = function(value) {
    let castInt322;
    if (typeof this._castFunction === "function") {
      castInt322 = this._castFunction;
    } else if (typeof this.constructor.cast === "function") {
      castInt322 = this.constructor.cast();
    } else {
      castInt322 = SchemaInt32.cast();
    }
    try {
      return castInt322(value);
    } catch (error) {
      throw new CastError("Int32", value, this.path, error, this);
    }
  };
  /*!
   * ignore
   */
  SchemaInt32.$conditionalHandlers = {
    ...SchemaType.prototype.$conditionalHandlers,
    $gt: handleSingle,
    $gte: handleSingle,
    $lt: handleSingle,
    $lte: handleSingle,
    $bitsAllClear: handleBitwiseOperator,
    $bitsAnyClear: handleBitwiseOperator,
    $bitsAllSet: handleBitwiseOperator,
    $bitsAnySet: handleBitwiseOperator
  };
  /*!
   * ignore
   */
  SchemaInt32.prototype.castForQuery = function($conditional, val, context) {
    let handler;
    if ($conditional != null) {
      handler = SchemaInt32.$conditionalHandlers[$conditional];
      if (handler) {
        return handler.call(this, val);
      }
      return this.applySetters(val, context);
    }
    try {
      return this.applySetters(val, context);
    } catch (err) {
      if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {
        err.path = this.$fullPath;
      }
      throw err;
    }
  };
  SchemaInt32.prototype.toJSONSchema = function toJSONSchema(options) {
    const isRequired = this.options.required && typeof this.options.required !== "function";
    return createJSONSchemaTypeDefinition("number", "int", options?.useBsonType, isRequired);
  };
  /*!
   * Module exports.
   */
  module.exports = SchemaInt32;
});

// node_modules/mongoose/lib/schema/index.js
var require_schema = __commonJS((exports) => {
  /*!
   * Module exports.
   */
  exports.Array = require_array2();
  exports.BigInt = require_bigint2();
  exports.Boolean = require_boolean2();
  exports.Buffer = require_buffer2();
  exports.Date = require_date2();
  exports.Decimal128 = exports.Decimal = require_decimal1283();
  exports.DocumentArray = require_documentArray2();
  exports.Map = require_map3();
  exports.Mixed = require_mixed();
  exports.Number = require_number2();
  exports.ObjectId = require_objectId();
  exports.String = require_string2();
  exports.Subdocument = require_subdocument2();
  exports.UUID = require_uuid3();
  exports.Double = require_double2();
  exports.Int32 = require_int322();
  exports.Oid = exports.ObjectId;
  exports.Object = exports.Mixed;
  exports.Bool = exports.Boolean;
  exports.ObjectID = exports.ObjectId;
});

// node_modules/mongoose/lib/schema.js
var require_schema2 = __commonJS((exports, module) => {
  function Schema(obj, options) {
    if (!(this instanceof Schema)) {
      return new Schema(obj, options);
    }
    this.obj = obj;
    this.paths = {};
    this.aliases = {};
    this.subpaths = {};
    this.virtuals = {};
    this.singleNestedPaths = {};
    this.nested = {};
    this.inherits = {};
    this.callQueue = [];
    this._indexes = [];
    this._searchIndexes = [];
    this.methods = options && options.methods || {};
    this.methodOptions = {};
    this.statics = options && options.statics || {};
    this.tree = {};
    this.query = options && options.query || {};
    this.childSchemas = [];
    this.plugins = [];
    this.$id = ++id;
    this.mapPaths = [];
    this.s = {
      hooks: new Kareem
    };
    this.options = this.defaultOptions(options);
    if (Array.isArray(obj)) {
      for (const definition of obj) {
        this.add(definition);
      }
    } else if (obj) {
      this.add(obj);
    }
    if (options && options.virtuals) {
      const virtuals = options.virtuals;
      const pathNames = Object.keys(virtuals);
      for (const pathName of pathNames) {
        const pathOptions = virtuals[pathName].options ? virtuals[pathName].options : undefined;
        const virtual = this.virtual(pathName, pathOptions);
        if (virtuals[pathName].get) {
          virtual.get(virtuals[pathName].get);
        }
        if (virtuals[pathName].set) {
          virtual.set(virtuals[pathName].set);
        }
      }
    }
    const _idSubDoc = obj && obj._id && utils.isObject(obj._id);
    const auto_id = !this.paths["_id"] && this.options._id && !_idSubDoc;
    if (auto_id) {
      addAutoId(this);
    }
    this.setupTimestamp(this.options.timestamps);
  }
  function aliasFields(schema, paths) {
    for (const path of Object.keys(paths)) {
      let alias = null;
      if (paths[path] != null) {
        alias = paths[path];
      } else {
        const options = get(schema.paths[path], "options");
        if (options == null) {
          continue;
        }
        alias = options.alias;
      }
      if (!alias) {
        continue;
      }
      const prop = schema.paths[path].path;
      if (Array.isArray(alias)) {
        for (const a of alias) {
          if (typeof a !== "string") {
            throw new Error("Invalid value for alias option on " + prop + ", got " + a);
          }
          schema.aliases[a] = prop;
          schema.virtual(a).get(function(p) {
            return function() {
              if (typeof this.get === "function") {
                return this.get(p);
              }
              return this[p];
            };
          }(prop)).set(function(p) {
            return function(v) {
              return this.$set(p, v);
            };
          }(prop));
        }
        continue;
      }
      if (typeof alias !== "string") {
        throw new Error("Invalid value for alias option on " + prop + ", got " + alias);
      }
      schema.aliases[alias] = prop;
      schema.virtual(alias).get(function(p) {
        return function() {
          if (typeof this.get === "function") {
            return this.get(p);
          }
          return this[p];
        };
      }(prop)).set(function(p) {
        return function(v) {
          return this.$set(p, v);
        };
      }(prop));
    }
  }
  function _getPath(schema, path, cleanPath) {
    if (schema.paths.hasOwnProperty(path)) {
      return schema.paths[path];
    }
    if (schema.subpaths.hasOwnProperty(cleanPath)) {
      const subpath = schema.subpaths[cleanPath];
      if (subpath === "nested") {
        return;
      }
      return subpath;
    }
    if (schema.singleNestedPaths.hasOwnProperty(cleanPath) && typeof schema.singleNestedPaths[cleanPath] === "object") {
      const singleNestedPath = schema.singleNestedPaths[cleanPath];
      if (singleNestedPath === "nested") {
        return;
      }
      return singleNestedPath;
    }
    return null;
  }
  function _pathToPositionalSyntax(path) {
    if (!/\.\d+/.test(path)) {
      return path;
    }
    return path.replace(/\.\d+\./g, ".$.").replace(/\.\d+$/, ".$");
  }
  function getMapPath(schema, path) {
    if (schema.mapPaths.length === 0) {
      return null;
    }
    for (const val of schema.mapPaths) {
      const _path = val.path;
      const re = new RegExp("^" + _path.replace(/\.\$\*/g, "\\.[^.]+") + "$");
      if (re.test(path)) {
        return schema.paths[_path];
      }
    }
    return null;
  }
  function createMapNestedSchemaType(schema, schemaType, path, obj, options) {
    const mapPath = path + ".$*";
    let _mapType = { type: {} };
    if (utils.hasUserDefinedProperty(obj, "of")) {
      const isInlineSchema = utils.isPOJO(obj.of) && Object.keys(obj.of).length > 0 && !utils.hasUserDefinedProperty(obj.of, schema.options.typeKey);
      if (isInlineSchema) {
        _mapType = { [schema.options.typeKey]: new Schema(obj.of) };
      } else if (utils.isPOJO(obj.of)) {
        _mapType = Object.assign({}, obj.of);
      } else {
        _mapType = { [schema.options.typeKey]: obj.of };
      }
      if (_mapType[schema.options.typeKey] && _mapType[schema.options.typeKey].instanceOfSchema) {
        const subdocumentSchema = _mapType[schema.options.typeKey];
        subdocumentSchema.eachPath((subpath, type) => {
          if (type.options.select === true || type.options.select === false) {
            throw new MongooseError('Cannot use schema-level projections (`select: true` or `select: false`) within maps at path "' + path + "." + subpath + '"');
          }
        });
      }
      if (utils.hasUserDefinedProperty(obj, "ref")) {
        _mapType.ref = obj.ref;
      }
    }
    schemaType.$__schemaType = schema.interpretAsType(mapPath, _mapType, options);
  }
  function getPositionalPathType(self2, path, cleanPath) {
    const subpaths = path.split(/\.(\d+)\.|\.(\d+)$/).filter(Boolean);
    if (subpaths.length < 2) {
      return self2.paths.hasOwnProperty(subpaths[0]) ? self2.paths[subpaths[0]] : "adhocOrUndefined";
    }
    let val = self2.path(subpaths[0]);
    let isNested = false;
    if (!val) {
      return "adhocOrUndefined";
    }
    const last = subpaths.length - 1;
    for (let i = 1;i < subpaths.length; ++i) {
      isNested = false;
      const subpath = subpaths[i];
      if (i === last && val && !/\D/.test(subpath)) {
        if (val.$isMongooseDocumentArray) {
          val = val.$embeddedSchemaType;
        } else if (val instanceof MongooseTypes.Array) {
          val = val.caster;
        } else {
          val = undefined;
        }
        break;
      }
      if (!/\D/.test(subpath)) {
        if (val instanceof MongooseTypes.Array && i !== last) {
          val = val.caster;
        }
        continue;
      }
      if (!(val && val.schema)) {
        val = undefined;
        break;
      }
      const type = val.schema.pathType(subpath);
      isNested = type === "nested";
      val = val.schema.path(subpath);
    }
    self2.subpaths[cleanPath] = val;
    if (val) {
      return "real";
    }
    if (isNested) {
      return "nested";
    }
    return "adhocOrUndefined";
  }
  function getPositionalPath(self2, path, cleanPath) {
    getPositionalPathType(self2, path, cleanPath);
    return self2.subpaths[cleanPath];
  }
  function _propagateOptionsToImplicitlyCreatedSchemas(baseSchema, options) {
    for (const { schema } of baseSchema.childSchemas) {
      if (!schema.$implicitlyCreated) {
        continue;
      }
      Object.assign(schema.options, options);
      _propagateOptionsToImplicitlyCreatedSchemas(schema, options);
    }
  }
  function _deletePath(schema, name) {
    const pieces = name.split(".");
    const last = pieces.pop();
    let branch = schema.tree;
    for (const piece of pieces) {
      branch = branch[piece];
    }
    delete branch[last];
  }
  function isArrayFilter(piece) {
    return piece.startsWith("$[") && piece.endsWith("]");
  }
  /*!
   * Module dependencies.
   */
  var EventEmitter = import.meta.require("events").EventEmitter;
  var Kareem = require_kareem();
  var MongooseError = require_mongooseError();
  var SchemaType = require_schemaType();
  var SchemaTypeOptions = require_schemaTypeOptions();
  var VirtualOptions = require_virtualOptions();
  var VirtualType = require_virtualType();
  var addAutoId = require_addAutoId();
  var clone = require_clone2();
  var get = require_get2();
  var getConstructorName = require_getConstructorName();
  var getIndexes = require_getIndexes();
  var handleReadPreferenceAliases = require_handleReadPreferenceAliases();
  var idGetter = require_idGetter();
  var isIndexSpecEqual = require_isIndexSpecEqual();
  var merge = require_merge();
  var mpath = require_mpath();
  var setPopulatedVirtualValue = require_setPopulatedVirtualValue();
  var setupTimestamps = require_setupTimestamps();
  var utils = require_utils4();
  var validateRef = require_validateRef();
  var hasNumericSubpathRegex = /\.\d+(\.|$)/;
  var MongooseTypes;
  var queryHooks = require_constants3().queryMiddlewareFunctions;
  var documentHooks = require_applyHooks().middlewareFunctions;
  var hookNames = queryHooks.concat(documentHooks).reduce((s, hook) => s.add(hook), new Set);
  var isPOJO = utils.isPOJO;
  var id = 0;
  var numberRE = /^\d+$/;
  /*!
   * Inherit from EventEmitter.
   */
  Schema.prototype = Object.create(EventEmitter.prototype);
  Schema.prototype.constructor = Schema;
  Schema.prototype.instanceOfSchema = true;
  /*!
   * ignore
   */
  Object.defineProperty(Schema.prototype, "$schemaType", {
    configurable: false,
    enumerable: false,
    writable: true
  });
  Object.defineProperty(Schema.prototype, "childSchemas", {
    configurable: false,
    enumerable: true,
    writable: true
  });
  Object.defineProperty(Schema.prototype, "virtuals", {
    configurable: false,
    enumerable: true,
    writable: true
  });
  Schema.prototype.obj;
  Schema.prototype.paths;
  Schema.prototype.tree;
  Schema.prototype.clone = function() {
    const s = this._clone();
    s.on("init", (v) => this.emit("init", v));
    return s;
  };
  /*!
   * ignore
   */
  Schema.prototype._clone = function _clone(Constructor) {
    Constructor = Constructor || (this.base == null ? Schema : this.base.Schema);
    const s = new Constructor({}, this._userProvidedOptions);
    s.base = this.base;
    s.obj = this.obj;
    s.options = clone(this.options);
    s.callQueue = this.callQueue.map(function(f) {
      return f;
    });
    s.methods = clone(this.methods);
    s.methodOptions = clone(this.methodOptions);
    s.statics = clone(this.statics);
    s.query = clone(this.query);
    s.plugins = Array.prototype.slice.call(this.plugins);
    s._indexes = clone(this._indexes);
    s._searchIndexes = clone(this._searchIndexes);
    s.s.hooks = this.s.hooks.clone();
    s.tree = clone(this.tree);
    s.paths = Object.fromEntries(Object.entries(this.paths).map(([key, value]) => [key, value.clone()]));
    s.nested = clone(this.nested);
    s.subpaths = clone(this.subpaths);
    for (const schemaType of Object.values(s.paths)) {
      if (schemaType.$isSingleNested) {
        const path = schemaType.path;
        for (const key of Object.keys(schemaType.schema.paths)) {
          s.singleNestedPaths[path + "." + key] = schemaType.schema.paths[key];
        }
        for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {
          s.singleNestedPaths[path + "." + key] = schemaType.schema.singleNestedPaths[key];
        }
        for (const key of Object.keys(schemaType.schema.subpaths)) {
          s.singleNestedPaths[path + "." + key] = schemaType.schema.subpaths[key];
        }
        for (const key of Object.keys(schemaType.schema.nested)) {
          s.singleNestedPaths[path + "." + key] = "nested";
        }
      }
    }
    s._gatherChildSchemas();
    s.virtuals = clone(this.virtuals);
    s.$globalPluginsApplied = this.$globalPluginsApplied;
    s.$isRootDiscriminator = this.$isRootDiscriminator;
    s.$implicitlyCreated = this.$implicitlyCreated;
    s.$id = ++id;
    s.$originalSchemaId = this.$id;
    s.mapPaths = [].concat(this.mapPaths);
    if (this.discriminatorMapping != null) {
      s.discriminatorMapping = Object.assign({}, this.discriminatorMapping);
    }
    if (this.discriminators != null) {
      s.discriminators = Object.assign({}, this.discriminators);
    }
    if (this._applyDiscriminators != null) {
      s._applyDiscriminators = new Map(this._applyDiscriminators);
    }
    s.aliases = Object.assign({}, this.aliases);
    return s;
  };
  Schema.prototype.pick = function(paths, options) {
    const newSchema = new Schema({}, options || this.options);
    if (!Array.isArray(paths)) {
      throw new MongooseError("Schema#pick() only accepts an array argument, " + 'got "' + typeof paths + '"');
    }
    for (const path of paths) {
      if (this.nested[path]) {
        newSchema.add({ [path]: get(this.tree, path) });
      } else {
        const schematype = this.path(path);
        if (schematype == null) {
          throw new MongooseError("Path `" + path + "` is not in the schema");
        }
        newSchema.add({ [path]: schematype });
      }
    }
    return newSchema;
  };
  Schema.prototype.omit = function(paths, options) {
    const newSchema = new Schema(this, options || this.options);
    if (!Array.isArray(paths)) {
      throw new MongooseError("Schema#omit() only accepts an array argument, " + 'got "' + typeof paths + '"');
    }
    newSchema.remove(paths);
    for (const nested in newSchema.singleNestedPaths) {
      if (paths.includes(nested)) {
        delete newSchema.singleNestedPaths[nested];
      }
    }
    return newSchema;
  };
  Schema.prototype.defaultOptions = function(options) {
    this._userProvidedOptions = options == null ? {} : clone(options);
    const baseOptions = this.base && this.base.options || {};
    const strict = "strict" in baseOptions ? baseOptions.strict : true;
    const strictQuery = "strictQuery" in baseOptions ? baseOptions.strictQuery : false;
    const id2 = "id" in baseOptions ? baseOptions.id : true;
    options = {
      strict,
      strictQuery,
      bufferCommands: true,
      capped: false,
      versionKey: "__v",
      optimisticConcurrency: false,
      minimize: true,
      autoIndex: null,
      discriminatorKey: "__t",
      shardKey: null,
      read: null,
      validateBeforeSave: true,
      validateModifiedOnly: false,
      _id: true,
      id: id2,
      typeKey: "type",
      ...options
    };
    if (options.versionKey && typeof options.versionKey !== "string") {
      throw new MongooseError("`versionKey` must be falsy or string, got `" + typeof options.versionKey + "`");
    }
    if (typeof options.read === "string") {
      options.read = handleReadPreferenceAliases(options.read);
    } else if (Array.isArray(options.read) && typeof options.read[0] === "string") {
      options.read = {
        mode: handleReadPreferenceAliases(options.read[0]),
        tags: options.read[1]
      };
    }
    if (options.optimisticConcurrency && !options.versionKey) {
      throw new MongooseError("Must set `versionKey` if using `optimisticConcurrency`");
    }
    return options;
  };
  Schema.prototype.discriminator = function(name, schema, options) {
    this._applyDiscriminators = this._applyDiscriminators || new Map;
    this._applyDiscriminators.set(name, { schema, options });
    return this;
  };
  /*!
   * Get this schema's default toObject/toJSON options, including Mongoose global
   * options.
   */
  Schema.prototype._defaultToObjectOptions = function(json) {
    const path = json ? "toJSON" : "toObject";
    if (this._defaultToObjectOptionsMap && this._defaultToObjectOptionsMap[path]) {
      return this._defaultToObjectOptionsMap[path];
    }
    const baseOptions = this.base && this.base.options && this.base.options[path] || {};
    const schemaOptions = this.options[path] || {};
    const defaultOptions = Object.assign({}, baseOptions, schemaOptions);
    this._defaultToObjectOptionsMap = this._defaultToObjectOptionsMap || {};
    this._defaultToObjectOptionsMap[path] = defaultOptions;
    return defaultOptions;
  };
  Schema.prototype.add = function add(obj, prefix) {
    if (obj instanceof Schema || obj != null && obj.instanceOfSchema) {
      merge(this, obj);
      return this;
    }
    if (obj._id === false && prefix == null) {
      this.options._id = false;
    }
    prefix = prefix || "";
    if (prefix === "__proto__." || prefix === "constructor." || prefix === "prototype.") {
      return this;
    }
    const keys = Object.keys(obj);
    const typeKey = this.options.typeKey;
    for (const key of keys) {
      if (utils.specialProperties.has(key)) {
        continue;
      }
      const fullPath = prefix + key;
      const val = obj[key];
      if (val == null) {
        throw new TypeError("Invalid value for schema path `" + fullPath + '`, got value "' + val + '"');
      }
      if (key === "_id" && val === false) {
        continue;
      }
      let isMongooseTypeString = false;
      if (typeof val === "string") {
        const MongooseTypes2 = this.base != null ? this.base.Schema.Types : Schema.Types;
        const upperVal = val.charAt(0).toUpperCase() + val.substring(1);
        isMongooseTypeString = MongooseTypes2[upperVal] != null;
      }
      if (key !== "_id" && (typeof val !== "object" && typeof val !== "function" && !isMongooseTypeString || val == null)) {
        throw new TypeError(`Invalid schema configuration: \`${val}\` is not ` + `a valid type at path \`${key}\`. See ` + "https://bit.ly/mongoose-schematypes for a list of valid schema types.");
      }
      if (val instanceof VirtualType || (val.constructor && val.constructor.name || null) === "VirtualType") {
        this.virtual(val);
        continue;
      }
      if (Array.isArray(val) && val.length === 1 && val[0] == null) {
        throw new TypeError("Invalid value for schema Array path `" + fullPath + '`, got value "' + val[0] + '"');
      }
      if (!(isPOJO(val) || val instanceof SchemaTypeOptions)) {
        if (prefix) {
          this.nested[prefix.substring(0, prefix.length - 1)] = true;
        }
        this.path(prefix + key, val);
        if (val[0] != null && !val[0].instanceOfSchema && utils.isPOJO(val[0].discriminators)) {
          const schemaType = this.path(prefix + key);
          for (const key2 in val[0].discriminators) {
            schemaType.discriminator(key2, val[0].discriminators[key2]);
          }
        }
      } else if (Object.keys(val).length < 1) {
        if (prefix) {
          this.nested[prefix.substring(0, prefix.length - 1)] = true;
        }
        this.path(fullPath, val);
      } else if (!val[typeKey] || typeKey === "type" && isPOJO(val.type) && val.type.type) {
        this.nested[fullPath] = true;
        this.add(val, fullPath + ".");
      } else {
        const _typeDef = val[typeKey];
        if (isPOJO(_typeDef) && Object.keys(_typeDef).length > 0) {
          if (prefix) {
            this.nested[prefix.substring(0, prefix.length - 1)] = true;
          }
          const childSchemaOptions = {};
          if (this._userProvidedOptions.typeKey) {
            childSchemaOptions.typeKey = this._userProvidedOptions.typeKey;
          }
          if (this._userProvidedOptions.strict != null) {
            childSchemaOptions.strict = this._userProvidedOptions.strict;
          }
          if (this._userProvidedOptions.toObject != null) {
            childSchemaOptions.toObject = utils.omit(this._userProvidedOptions.toObject, ["transform"]);
          }
          if (this._userProvidedOptions.toJSON != null) {
            childSchemaOptions.toJSON = utils.omit(this._userProvidedOptions.toJSON, ["transform"]);
          }
          const _schema = new Schema(_typeDef, childSchemaOptions);
          _schema.$implicitlyCreated = true;
          const schemaWrappedPath = Object.assign({}, val, { [typeKey]: _schema });
          this.path(prefix + key, schemaWrappedPath);
        } else {
          if (prefix) {
            this.nested[prefix.substring(0, prefix.length - 1)] = true;
          }
          this.path(prefix + key, val);
          if (val != null && !val.instanceOfSchema && utils.isPOJO(val.discriminators)) {
            const schemaType = this.path(prefix + key);
            for (const key2 in val.discriminators) {
              schemaType.discriminator(key2, val.discriminators[key2]);
            }
          }
        }
      }
    }
    const aliasObj = Object.fromEntries(Object.entries(obj).map(([key]) => [prefix + key, null]));
    aliasFields(this, aliasObj);
    return this;
  };
  Schema.prototype.alias = function alias(path, alias) {
    aliasFields(this, { [path]: alias });
    return this;
  };
  Schema.prototype.removeIndex = function removeIndex(index) {
    if (arguments.length > 1) {
      throw new Error("removeIndex() takes only 1 argument");
    }
    if (typeof index !== "object" && typeof index !== "string") {
      throw new Error("removeIndex() may only take either an object or a string as an argument");
    }
    if (typeof index === "object") {
      for (let i = this._indexes.length - 1;i >= 0; --i) {
        if (isIndexSpecEqual(this._indexes[i][0], index)) {
          this._indexes.splice(i, 1);
        }
      }
    } else {
      for (let i = this._indexes.length - 1;i >= 0; --i) {
        if (this._indexes[i][1] != null && this._indexes[i][1].name === index) {
          this._indexes.splice(i, 1);
        }
      }
    }
    return this;
  };
  Schema.prototype.clearIndexes = function clearIndexes() {
    this._indexes.length = 0;
    return this;
  };
  Schema.prototype.searchIndex = function searchIndex(description) {
    this._searchIndexes.push(description);
    return this;
  };
  Schema.reserved = Object.create(null);
  Schema.prototype.reserved = Schema.reserved;
  var reserved = Schema.reserved;
  reserved["prototype"] = reserved.emit = reserved.listeners = reserved.removeListener = reserved.collection = reserved.errors = reserved.get = reserved.init = reserved.isModified = reserved.isNew = reserved.populated = reserved.remove = reserved.save = reserved.toObject = reserved.validate = 1;
  reserved.collection = 1;
  Schema.prototype.path = function(path, obj) {
    if (obj === undefined) {
      if (this.paths[path] != null) {
        return this.paths[path];
      }
      const cleanPath = _pathToPositionalSyntax(path);
      let schematype = _getPath(this, path, cleanPath);
      if (schematype != null) {
        return schematype;
      }
      const mapPath = getMapPath(this, path);
      if (mapPath != null) {
        return mapPath;
      }
      schematype = this.hasMixedParent(cleanPath);
      if (schematype != null) {
        return schematype;
      }
      return hasNumericSubpathRegex.test(path) ? getPositionalPath(this, path, cleanPath) : undefined;
    }
    const firstPieceOfPath = path.split(".")[0];
    if (reserved[firstPieceOfPath] && !this.options.suppressReservedKeysWarning) {
      const errorMessage = `\`${firstPieceOfPath}\` is a reserved schema pathname and may break some functionality. ` + "You are allowed to use it, but use at your own risk. " + "To disable this warning pass `suppressReservedKeysWarning` as a schema option.";
      utils.warn(errorMessage);
    }
    if (typeof obj === "object" && utils.hasUserDefinedProperty(obj, "ref")) {
      validateRef(obj.ref, path);
    }
    const subpaths = path.split(/\./);
    const last = subpaths.pop();
    let branch = this.tree;
    let fullPath = "";
    for (const sub of subpaths) {
      if (utils.specialProperties.has(sub)) {
        throw new Error("Cannot set special property `" + sub + "` on a schema");
      }
      fullPath = fullPath += (fullPath.length > 0 ? "." : "") + sub;
      if (!branch[sub]) {
        this.nested[fullPath] = true;
        branch[sub] = {};
      }
      if (typeof branch[sub] !== "object") {
        const msg = "Cannot set nested path `" + path + "`. " + "Parent path `" + fullPath + "` already set to type " + branch[sub].name + ".";
        throw new Error(msg);
      }
      branch = branch[sub];
    }
    branch[last] = clone(obj);
    this.paths[path] = this.interpretAsType(path, obj, this.options);
    const schemaType = this.paths[path];
    this.childSchemas = this.childSchemas.filter((childSchema) => childSchema.path !== path);
    if (schemaType.$isSchemaMap) {
      const mapPath = path + ".$*";
      this.paths[mapPath] = schemaType.$__schemaType;
      this.mapPaths.push(this.paths[mapPath]);
      if (schemaType.$__schemaType.$isSingleNested) {
        this.childSchemas.push({
          schema: schemaType.$__schemaType.schema,
          model: schemaType.$__schemaType.caster,
          path
        });
      }
    }
    if (schemaType.$isSingleNested) {
      for (const key of Object.keys(schemaType.schema.paths)) {
        this.singleNestedPaths[path + "." + key] = schemaType.schema.paths[key];
      }
      for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {
        this.singleNestedPaths[path + "." + key] = schemaType.schema.singleNestedPaths[key];
      }
      for (const key of Object.keys(schemaType.schema.subpaths)) {
        this.singleNestedPaths[path + "." + key] = schemaType.schema.subpaths[key];
      }
      for (const key of Object.keys(schemaType.schema.nested)) {
        this.singleNestedPaths[path + "." + key] = "nested";
      }
      Object.defineProperty(schemaType.schema, "base", {
        configurable: true,
        enumerable: false,
        writable: false,
        value: this.base
      });
      schemaType.caster.base = this.base;
      this.childSchemas.push({
        schema: schemaType.schema,
        model: schemaType.caster,
        path
      });
    } else if (schemaType.$isMongooseDocumentArray) {
      Object.defineProperty(schemaType.schema, "base", {
        configurable: true,
        enumerable: false,
        writable: false,
        value: this.base
      });
      schemaType.casterConstructor.base = this.base;
      this.childSchemas.push({
        schema: schemaType.schema,
        model: schemaType.casterConstructor,
        path
      });
    }
    if (schemaType.$isMongooseArray && schemaType.caster instanceof SchemaType) {
      let arrayPath = path;
      let _schemaType = schemaType;
      const toAdd = [];
      while (_schemaType.$isMongooseArray) {
        arrayPath = arrayPath + ".$";
        if (_schemaType.$isMongooseDocumentArray) {
          _schemaType.$embeddedSchemaType._arrayPath = arrayPath;
          _schemaType.$embeddedSchemaType._arrayParentPath = path;
          _schemaType = _schemaType.$embeddedSchemaType;
        } else {
          _schemaType.caster._arrayPath = arrayPath;
          _schemaType.caster._arrayParentPath = path;
          _schemaType = _schemaType.caster;
        }
        this.subpaths[arrayPath] = _schemaType;
      }
      for (const _schemaType2 of toAdd) {
        this.subpaths[_schemaType2.path] = _schemaType2;
      }
    }
    if (schemaType.$isMongooseDocumentArray) {
      for (const key of Object.keys(schemaType.schema.paths)) {
        const _schemaType = schemaType.schema.paths[key];
        this.subpaths[path + "." + key] = _schemaType;
        if (typeof _schemaType === "object" && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {
          _schemaType.$parentSchemaDocArray = schemaType;
        }
      }
      for (const key of Object.keys(schemaType.schema.subpaths)) {
        const _schemaType = schemaType.schema.subpaths[key];
        this.subpaths[path + "." + key] = _schemaType;
        if (typeof _schemaType === "object" && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {
          _schemaType.$parentSchemaDocArray = schemaType;
        }
      }
      for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {
        const _schemaType = schemaType.schema.singleNestedPaths[key];
        this.subpaths[path + "." + key] = _schemaType;
        if (typeof _schemaType === "object" && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {
          _schemaType.$parentSchemaDocArray = schemaType;
        }
      }
    }
    return this;
  };
  /*!
   * ignore
   */
  Schema.prototype._gatherChildSchemas = function _gatherChildSchemas() {
    const childSchemas = [];
    for (const path of Object.keys(this.paths)) {
      if (typeof path !== "string") {
        continue;
      }
      const schematype = this.paths[path];
      if (schematype.$isMongooseDocumentArray || schematype.$isSingleNested) {
        childSchemas.push({
          schema: schematype.schema,
          model: schematype.caster,
          path
        });
      } else if (schematype.$isSchemaMap && schematype.$__schemaType.$isSingleNested) {
        childSchemas.push({
          schema: schematype.$__schemaType.schema,
          model: schematype.$__schemaType.caster,
          path
        });
      }
    }
    this.childSchemas = childSchemas;
    return childSchemas;
  };
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  Object.defineProperty(Schema.prototype, "base", {
    configurable: true,
    enumerable: false,
    writable: true,
    value: null
  });
  Schema.prototype.interpretAsType = function(path, obj, options) {
    if (obj instanceof SchemaType) {
      if (obj.path === path) {
        return obj;
      }
      const clone2 = obj.clone();
      clone2.path = path;
      return clone2;
    }
    const MongooseTypes2 = this.base != null ? this.base.Schema.Types : Schema.Types;
    const Types = this.base != null ? this.base.Types : require_types();
    if (!utils.isPOJO(obj) && !(obj instanceof SchemaTypeOptions)) {
      const constructorName = utils.getFunctionName(obj.constructor);
      if (constructorName !== "Object") {
        const oldObj = obj;
        obj = {};
        obj[options.typeKey] = oldObj;
      }
    }
    let type = obj[options.typeKey] && (obj[options.typeKey] instanceof Function || options.typeKey !== "type" || !obj.type.type) ? obj[options.typeKey] : {};
    let name;
    if (utils.isPOJO(type) || type === "mixed") {
      return new MongooseTypes2.Mixed(path, obj);
    }
    if (Array.isArray(type) || type === Array || type === "array" || type === MongooseTypes2.Array) {
      let cast = type === Array || type === "array" ? obj.cast || obj.of : type[0];
      if (cast && cast.instanceOfSchema) {
        if (!(cast instanceof Schema)) {
          if (this.options._isMerging) {
            cast = new Schema(cast);
          } else {
            throw new TypeError("Schema for array path `" + path + "` is from a different copy of the Mongoose module. " + "Please make sure you\'re using the same version " + "of Mongoose everywhere with `npm list mongoose`. If you are still " + "getting this error, please add `new Schema()` around the path: " + `${path}: new Schema(...)`);
          }
        }
        return new MongooseTypes2.DocumentArray(path, cast, obj);
      }
      if (cast && cast[options.typeKey] && cast[options.typeKey].instanceOfSchema) {
        if (!(cast[options.typeKey] instanceof Schema)) {
          if (this.options._isMerging) {
            cast[options.typeKey] = new Schema(cast[options.typeKey]);
          } else {
            throw new TypeError("Schema for array path `" + path + "` is from a different copy of the Mongoose module. " + "Please make sure you\'re using the same version " + "of Mongoose everywhere with `npm list mongoose`. If you are still " + "getting this error, please add `new Schema()` around the path: " + `${path}: new Schema(...)`);
          }
        }
        return new MongooseTypes2.DocumentArray(path, cast[options.typeKey], obj, cast);
      }
      if (typeof cast !== "undefined") {
        if (Array.isArray(cast) || cast.type === Array || cast.type == "Array") {
          if (cast && cast.type == "Array") {
            cast.type = Array;
          }
          return new MongooseTypes2.Array(path, this.interpretAsType(path, cast, options), obj);
        }
      }
      const castFromTypeKey = cast != null && cast[options.typeKey] && (options.typeKey !== "type" || !cast.type.type) ? cast[options.typeKey] : cast;
      if (typeof cast === "string") {
        cast = MongooseTypes2[cast.charAt(0).toUpperCase() + cast.substring(1)];
      } else if (utils.isPOJO(castFromTypeKey)) {
        if (Object.keys(castFromTypeKey).length) {
          const childSchemaOptions = { minimize: options.minimize };
          if (options.typeKey) {
            childSchemaOptions.typeKey = options.typeKey;
          }
          if (options.hasOwnProperty("strict")) {
            childSchemaOptions.strict = options.strict;
          }
          if (options.hasOwnProperty("strictQuery")) {
            childSchemaOptions.strictQuery = options.strictQuery;
          }
          if (options.hasOwnProperty("toObject")) {
            childSchemaOptions.toObject = utils.omit(options.toObject, ["transform"]);
          }
          if (options.hasOwnProperty("toJSON")) {
            childSchemaOptions.toJSON = utils.omit(options.toJSON, ["transform"]);
          }
          if (this._userProvidedOptions.hasOwnProperty("_id")) {
            childSchemaOptions._id = this._userProvidedOptions._id;
          } else if (Schema.Types.DocumentArray.defaultOptions._id != null) {
            childSchemaOptions._id = Schema.Types.DocumentArray.defaultOptions._id;
          }
          const childSchema = new Schema(castFromTypeKey, childSchemaOptions);
          childSchema.$implicitlyCreated = true;
          return new MongooseTypes2.DocumentArray(path, childSchema, obj);
        } else {
          return new MongooseTypes2.Array(path, MongooseTypes2.Mixed, obj);
        }
      }
      if (cast) {
        type = cast[options.typeKey] && (options.typeKey !== "type" || !cast.type.type) ? cast[options.typeKey] : cast;
        if (Array.isArray(type)) {
          return new MongooseTypes2.Array(path, this.interpretAsType(path, type, options), obj);
        }
        name = typeof type === "string" ? type : type.schemaName || utils.getFunctionName(type);
        if (name === "ClockDate") {
          name = "Date";
        }
        if (name === undefined) {
          throw new TypeError("Invalid schema configuration: " + `Could not determine the embedded type for array \`${path}\`. ` + "See https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.");
        }
        if (!MongooseTypes2.hasOwnProperty(name)) {
          throw new TypeError("Invalid schema configuration: " + `\`${name}\` is not a valid type within the array \`${path}\`.` + "See https://bit.ly/mongoose-schematypes for a list of valid schema types.");
        }
      }
      return new MongooseTypes2.Array(path, cast || MongooseTypes2.Mixed, obj, options);
    }
    if (type && type.instanceOfSchema) {
      return new MongooseTypes2.Subdocument(type, path, obj);
    }
    if (Buffer.isBuffer(type)) {
      name = "Buffer";
    } else if (typeof type === "function" || typeof type === "object") {
      name = type.schemaName || utils.getFunctionName(type);
    } else if (type === Types.ObjectId) {
      name = "ObjectId";
    } else if (type === Types.Decimal128) {
      name = "Decimal128";
    } else {
      name = type == null ? "" + type : type.toString();
    }
    if (name) {
      name = name.charAt(0).toUpperCase() + name.substring(1);
    }
    if (name === "ObjectID") {
      name = "ObjectId";
    }
    if (name === "ClockDate") {
      name = "Date";
    }
    if (name === undefined) {
      throw new TypeError(`Invalid schema configuration: \`${path}\` schematype definition is ` + "invalid. See " + "https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.");
    }
    if (MongooseTypes2[name] == null) {
      throw new TypeError(`Invalid schema configuration: \`${name}\` is not ` + `a valid type at path \`${path}\`. See ` + "https://bit.ly/mongoose-schematypes for a list of valid schema types.");
    }
    const schemaType = new MongooseTypes2[name](path, obj);
    if (schemaType.$isSchemaMap) {
      createMapNestedSchemaType(this, schemaType, path, obj, options);
    }
    return schemaType;
  };
  /*!
   * ignore
   */
  Schema.prototype.eachPath = function(fn) {
    const keys = Object.keys(this.paths);
    const len = keys.length;
    for (let i = 0;i < len; ++i) {
      fn(keys[i], this.paths[keys[i]]);
    }
    return this;
  };
  Schema.prototype.requiredPaths = function requiredPaths(invalidate) {
    if (this._requiredpaths && !invalidate) {
      return this._requiredpaths;
    }
    const paths = Object.keys(this.paths);
    let i = paths.length;
    const ret = [];
    while (i--) {
      const path = paths[i];
      if (this.paths[path].isRequired) {
        ret.push(path);
      }
    }
    this._requiredpaths = ret;
    return this._requiredpaths;
  };
  Schema.prototype.indexedPaths = function indexedPaths() {
    if (this._indexedpaths) {
      return this._indexedpaths;
    }
    this._indexedpaths = this.indexes();
    return this._indexedpaths;
  };
  Schema.prototype.pathType = function(path) {
    if (this.paths.hasOwnProperty(path)) {
      return "real";
    }
    if (this.virtuals.hasOwnProperty(path)) {
      return "virtual";
    }
    if (this.nested.hasOwnProperty(path)) {
      return "nested";
    }
    const cleanPath = _pathToPositionalSyntax(path);
    if (this.subpaths.hasOwnProperty(cleanPath) || this.subpaths.hasOwnProperty(path)) {
      return "real";
    }
    const singleNestedPath = this.singleNestedPaths.hasOwnProperty(cleanPath) || this.singleNestedPaths.hasOwnProperty(path);
    if (singleNestedPath) {
      return singleNestedPath === "nested" ? "nested" : "real";
    }
    const mapPath = getMapPath(this, path);
    if (mapPath != null) {
      return "real";
    }
    if (/\.\d+\.|\.\d+$/.test(path)) {
      return getPositionalPathType(this, path, cleanPath);
    }
    return "adhocOrUndefined";
  };
  Schema.prototype.hasMixedParent = function(path) {
    const subpaths = path.split(/\./g);
    path = "";
    for (let i = 0;i < subpaths.length; ++i) {
      path = i > 0 ? path + "." + subpaths[i] : subpaths[i];
      if (this.paths.hasOwnProperty(path) && this.paths[path] instanceof MongooseTypes.Mixed) {
        return this.paths[path];
      }
    }
    return null;
  };
  Schema.prototype.setupTimestamp = function(timestamps) {
    return setupTimestamps(this, timestamps);
  };
  /*!
   * ignore
   */
  Schema.prototype.queue = function(name, args) {
    this.callQueue.push([name, args]);
    return this;
  };
  Schema.prototype.pre = function(name) {
    if (name instanceof RegExp) {
      const remainingArgs = Array.prototype.slice.call(arguments, 1);
      for (const fn of hookNames) {
        if (name.test(fn)) {
          this.pre.apply(this, [fn].concat(remainingArgs));
        }
      }
      return this;
    }
    if (Array.isArray(name)) {
      const remainingArgs = Array.prototype.slice.call(arguments, 1);
      for (const el of name) {
        this.pre.apply(this, [el].concat(remainingArgs));
      }
      return this;
    }
    this.s.hooks.pre.apply(this.s.hooks, arguments);
    return this;
  };
  Schema.prototype.post = function(name) {
    if (name instanceof RegExp) {
      const remainingArgs = Array.prototype.slice.call(arguments, 1);
      for (const fn of hookNames) {
        if (name.test(fn)) {
          this.post.apply(this, [fn].concat(remainingArgs));
        }
      }
      return this;
    }
    if (Array.isArray(name)) {
      const remainingArgs = Array.prototype.slice.call(arguments, 1);
      for (const el of name) {
        this.post.apply(this, [el].concat(remainingArgs));
      }
      return this;
    }
    this.s.hooks.post.apply(this.s.hooks, arguments);
    return this;
  };
  Schema.prototype.plugin = function(fn, opts) {
    if (typeof fn !== "function") {
      throw new Error("First param to `schema.plugin()` must be a function, " + 'got "' + typeof fn + '"');
    }
    if (opts && opts.deduplicate) {
      for (const plugin of this.plugins) {
        if (plugin.fn === fn) {
          return this;
        }
      }
    }
    this.plugins.push({ fn, opts });
    fn(this, opts);
    return this;
  };
  Schema.prototype.method = function(name, fn, options) {
    if (typeof name !== "string") {
      for (const i in name) {
        this.methods[i] = name[i];
        this.methodOptions[i] = clone(options);
      }
    } else {
      this.methods[name] = fn;
      this.methodOptions[name] = clone(options);
    }
    return this;
  };
  Schema.prototype.static = function(name, fn) {
    if (typeof name !== "string") {
      for (const i in name) {
        this.statics[i] = name[i];
      }
    } else {
      this.statics[name] = fn;
    }
    return this;
  };
  Schema.prototype.index = function(fields, options) {
    fields || (fields = {});
    options || (options = {});
    if (options.expires) {
      utils.expires(options);
    }
    for (const key in fields) {
      if (this.aliases[key]) {
        fields = utils.renameObjKey(fields, key, this.aliases[key]);
      }
    }
    for (const field of Object.keys(fields)) {
      if (fields[field] === "ascending" || fields[field] === "asc") {
        fields[field] = 1;
      } else if (fields[field] === "descending" || fields[field] === "desc") {
        fields[field] = -1;
      }
    }
    for (const existingIndex of this.indexes()) {
      if (options.name == null && existingIndex[1].name == null && isIndexSpecEqual(existingIndex[0], fields)) {
        utils.warn(`Duplicate schema index on ${JSON.stringify(fields)} found. This is often due to declaring an index using both "index: true" and "schema.index()". Please remove the duplicate index definition.`);
      }
    }
    this._indexes.push([fields, options]);
    return this;
  };
  Schema.prototype.set = function(key, value, tags) {
    if (arguments.length === 1) {
      return this.options[key];
    }
    switch (key) {
      case "read":
        if (typeof value === "string") {
          this.options[key] = { mode: handleReadPreferenceAliases(value), tags };
        } else if (Array.isArray(value) && typeof value[0] === "string") {
          this.options[key] = {
            mode: handleReadPreferenceAliases(value[0]),
            tags: value[1]
          };
        } else {
          this.options[key] = value;
        }
        this._userProvidedOptions[key] = this.options[key];
        break;
      case "timestamps":
        this.setupTimestamp(value);
        this.options[key] = value;
        this._userProvidedOptions[key] = this.options[key];
        break;
      case "_id":
        this.options[key] = value;
        this._userProvidedOptions[key] = this.options[key];
        if (value && !this.paths["_id"]) {
          addAutoId(this);
        } else if (!value && this.paths["_id"] != null && this.paths["_id"].auto) {
          this.remove("_id");
        }
        break;
      default:
        this.options[key] = value;
        this._userProvidedOptions[key] = this.options[key];
        break;
    }
    if (key === "strict") {
      _propagateOptionsToImplicitlyCreatedSchemas(this, { strict: value });
    }
    if (key === "strictQuery") {
      _propagateOptionsToImplicitlyCreatedSchemas(this, { strictQuery: value });
    }
    if (key === "toObject") {
      value = { ...value };
      delete value.transform;
      _propagateOptionsToImplicitlyCreatedSchemas(this, { toObject: value });
    }
    if (key === "toJSON") {
      value = { ...value };
      delete value.transform;
      _propagateOptionsToImplicitlyCreatedSchemas(this, { toJSON: value });
    }
    return this;
  };
  /*!
   * Recursively set options on implicitly created schemas
   */
  Schema.prototype.get = function(key) {
    return this.options[key];
  };
  var indexTypes = "2d 2dsphere hashed text".split(" ");
  Object.defineProperty(Schema, "indexTypes", {
    get: function() {
      return indexTypes;
    },
    set: function() {
      throw new Error("Cannot overwrite Schema.indexTypes");
    }
  });
  Schema.prototype.indexes = function() {
    return getIndexes(this);
  };
  Schema.prototype.virtual = function(name, options) {
    if (name instanceof VirtualType || getConstructorName(name) === "VirtualType") {
      return this.virtual(name.path, name.options);
    }
    options = new VirtualOptions(options);
    if (utils.hasUserDefinedProperty(options, ["ref", "refPath"])) {
      if (options.localField == null) {
        throw new Error("Reference virtuals require `localField` option");
      }
      if (options.foreignField == null) {
        throw new Error("Reference virtuals require `foreignField` option");
      }
      const virtual = this.virtual(name);
      virtual.options = options;
      this.pre("init", function virtualPreInit(obj, opts) {
        if (mpath.has(name, obj)) {
          const _v = mpath.get(name, obj);
          if (!this.$$populatedVirtuals) {
            this.$$populatedVirtuals = {};
          }
          if (options.justOne || options.count) {
            this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v[0] : _v;
          } else {
            this.$$populatedVirtuals[name] = Array.isArray(_v) ? _v : _v == null ? [] : [_v];
          }
          if (opts?.hydratedPopulatedDocs && !options.count) {
            const modelNames = virtual._getModelNamesForPopulate(this);
            const populatedVal = this.$$populatedVirtuals[name];
            if (!Array.isArray(populatedVal) && !populatedVal.$__ && modelNames?.length === 1) {
              const PopulateModel = this.db.model(modelNames[0]);
              this.$$populatedVirtuals[name] = PopulateModel.hydrate(populatedVal);
            } else if (Array.isArray(populatedVal) && modelNames?.length === 1) {
              const PopulateModel = this.db.model(modelNames[0]);
              for (let i = 0;i < populatedVal.length; ++i) {
                if (!populatedVal[i].$__) {
                  populatedVal[i] = PopulateModel.hydrate(populatedVal[i], null, { hydratedPopulatedDocs: true });
                }
              }
              const foreignField = options.foreignField;
              this.$populated(name, populatedVal.map((doc) => doc == null ? doc : doc.get(typeof foreignField === "function" ? foreignField.call(doc, doc) : foreignField)), { populateModelSymbol: PopulateModel });
            }
          }
          mpath.unset(name, obj);
        }
      });
      virtual.set(function(v) {
        if (!this.$$populatedVirtuals) {
          this.$$populatedVirtuals = {};
        }
        return setPopulatedVirtualValue(this.$$populatedVirtuals, name, v, options);
      });
      if (typeof options.get === "function") {
        virtual.get(options.get);
      }
      const parts2 = name.split(".");
      let cur = parts2[0];
      for (let i = 0;i < parts2.length - 1; ++i) {
        if (this.paths[cur] == null) {
          continue;
        }
        if (this.paths[cur].$isMongooseDocumentArray || this.paths[cur].$isSingleNested) {
          const remnant = parts2.slice(i + 1).join(".");
          this.paths[cur].schema.virtual(remnant, options);
          break;
        }
        cur += "." + parts2[i + 1];
      }
      return virtual;
    }
    const virtuals = this.virtuals;
    const parts = name.split(".");
    if (this.pathType(name) === "real") {
      throw new Error('Virtual path "' + name + '"' + " conflicts with a real path in the schema");
    }
    virtuals[name] = parts.reduce(function(mem, part, i) {
      mem[part] || (mem[part] = i === parts.length - 1 ? new VirtualType(options, name) : {});
      return mem[part];
    }, this.tree);
    if (options && options.applyToArray && parts.length > 1) {
      const path = this.path(parts.slice(0, -1).join("."));
      if (path && path.$isMongooseArray) {
        return path.virtual(parts[parts.length - 1], options);
      } else {
        throw new MongooseError(`Path "${path}" is not an array`);
      }
    }
    return virtuals[name];
  };
  Schema.prototype.virtualpath = function(name) {
    return this.virtuals.hasOwnProperty(name) ? this.virtuals[name] : null;
  };
  Schema.prototype.remove = function(path) {
    if (typeof path === "string") {
      path = [path];
    }
    if (Array.isArray(path)) {
      path.forEach(function(name) {
        if (this.path(name) == null && !this.nested[name]) {
          return;
        }
        if (this.nested[name]) {
          const allKeys = Object.keys(this.paths).concat(Object.keys(this.nested));
          for (const path2 of allKeys) {
            if (path2.startsWith(name + ".")) {
              delete this.paths[path2];
              delete this.nested[path2];
              _deletePath(this, path2);
            }
          }
          delete this.nested[name];
          _deletePath(this, name);
          return;
        }
        delete this.paths[name];
        _deletePath(this, name);
      }, this);
    }
    return this;
  };
  /*!
   * ignore
   */
  Schema.prototype.removeVirtual = function(path) {
    if (typeof path === "string") {
      path = [path];
    }
    if (Array.isArray(path)) {
      for (const virtual of path) {
        if (this.virtuals[virtual] == null) {
          throw new MongooseError(`Attempting to remove virtual "${virtual}" that does not exist.`);
        }
      }
      for (const virtual of path) {
        delete this.paths[virtual];
        delete this.virtuals[virtual];
        if (virtual.indexOf(".") !== -1) {
          mpath.unset(virtual, this.tree);
        } else {
          delete this.tree[virtual];
        }
      }
    }
    return this;
  };
  Schema.prototype.loadClass = function(model, virtualsOnly) {
    if (model === Object.prototype || model === Function.prototype || model.prototype.hasOwnProperty("$isMongooseModelPrototype") || model.prototype.hasOwnProperty("$isMongooseDocumentPrototype")) {
      return this;
    }
    this.loadClass(Object.getPrototypeOf(model), virtualsOnly);
    if (!virtualsOnly) {
      Object.getOwnPropertyNames(model).forEach(function(name) {
        if (name.match(/^(length|name|prototype|constructor|__proto__)$/)) {
          return;
        }
        const prop = Object.getOwnPropertyDescriptor(model, name);
        if (prop.hasOwnProperty("value")) {
          this.static(name, prop.value);
        }
      }, this);
    }
    Object.getOwnPropertyNames(model.prototype).forEach(function(name) {
      if (name.match(/^(constructor)$/)) {
        return;
      }
      const method = Object.getOwnPropertyDescriptor(model.prototype, name);
      if (!virtualsOnly) {
        if (typeof method.value === "function") {
          this.method(name, method.value);
        }
      }
      if (typeof method.get === "function") {
        if (this.virtuals[name]) {
          this.virtuals[name].getters = [];
        }
        this.virtual(name).get(method.get);
      }
      if (typeof method.set === "function") {
        if (this.virtuals[name]) {
          this.virtuals[name].setters = [];
        }
        this.virtual(name).set(method.set);
      }
    }, this);
    return this;
  };
  /*!
   * ignore
   */
  Schema.prototype._getSchema = function(path) {
    const _this = this;
    const pathschema = _this.path(path);
    const resultPath = [];
    if (pathschema) {
      pathschema.$fullPath = path;
      return pathschema;
    }
    function search(parts2, schema) {
      let p = parts2.length + 1;
      let foundschema;
      let trypath;
      while (p--) {
        trypath = parts2.slice(0, p).join(".");
        foundschema = schema.path(trypath);
        if (foundschema) {
          resultPath.push(trypath);
          if (foundschema.caster) {
            if (foundschema.caster instanceof MongooseTypes.Mixed) {
              foundschema.caster.$fullPath = resultPath.join(".");
              return foundschema.caster;
            }
            if (p !== parts2.length) {
              if (p + 1 === parts2.length && foundschema.$embeddedSchemaType && (parts2[p] === "$" || isArrayFilter(parts2[p]))) {
                return foundschema.$embeddedSchemaType;
              }
              if (foundschema.schema) {
                let ret;
                if (parts2[p] === "$" || isArrayFilter(parts2[p])) {
                  if (p + 1 === parts2.length) {
                    return foundschema.$embeddedSchemaType;
                  }
                  ret = search(parts2.slice(p + 1), foundschema.schema);
                  if (ret) {
                    ret.$parentSchemaDocArray = ret.$parentSchemaDocArray || (foundschema.schema.$isSingleNested ? null : foundschema);
                  }
                  return ret;
                }
                ret = search(parts2.slice(p), foundschema.schema);
                if (ret) {
                  ret.$parentSchemaDocArray = ret.$parentSchemaDocArray || (foundschema.schema.$isSingleNested ? null : foundschema);
                }
                return ret;
              }
            }
          } else if (foundschema.$isSchemaMap) {
            if (p >= parts2.length) {
              return foundschema;
            }
            if (p + 1 >= parts2.length) {
              return foundschema.$__schemaType;
            }
            if (foundschema.$__schemaType instanceof MongooseTypes.Mixed) {
              return foundschema.$__schemaType;
            }
            if (foundschema.$__schemaType.schema != null) {
              const ret = search(parts2.slice(p + 1), foundschema.$__schemaType.schema);
              return ret;
            }
          }
          foundschema.$fullPath = resultPath.join(".");
          return foundschema;
        }
      }
    }
    const parts = path.split(".");
    for (let i = 0;i < parts.length; ++i) {
      if (parts[i] === "$" || isArrayFilter(parts[i])) {
        parts[i] = "0";
      }
      if (numberRE.test(parts[i])) {
        parts[i] = "$";
      }
    }
    return search(parts, _this);
  };
  /*!
   * ignore
   */
  Schema.prototype._getPathType = function(path) {
    const _this = this;
    const pathschema = _this.path(path);
    if (pathschema) {
      return "real";
    }
    function search(parts, schema) {
      let p = parts.length + 1, foundschema, trypath;
      while (p--) {
        trypath = parts.slice(0, p).join(".");
        foundschema = schema.path(trypath);
        if (foundschema) {
          if (foundschema.caster) {
            if (foundschema.caster instanceof MongooseTypes.Mixed) {
              return { schema: foundschema, pathType: "mixed" };
            }
            if (p !== parts.length && foundschema.schema) {
              if (parts[p] === "$" || isArrayFilter(parts[p])) {
                if (p === parts.length - 1) {
                  return { schema: foundschema, pathType: "nested" };
                }
                return search(parts.slice(p + 1), foundschema.schema);
              }
              return search(parts.slice(p), foundschema.schema);
            }
            return {
              schema: foundschema,
              pathType: foundschema.$isSingleNested ? "nested" : "array"
            };
          }
          return { schema: foundschema, pathType: "real" };
        } else if (p === parts.length && schema.nested[trypath]) {
          return { schema, pathType: "nested" };
        }
      }
      return { schema: foundschema || schema, pathType: "undefined" };
    }
    return search(path.split("."), _this);
  };
  Schema.prototype._transformDuplicateKeyError = function _transformDuplicateKeyError(error) {
    if (!this._duplicateKeyErrorMessagesByPath) {
      return error;
    }
    if (error.code !== 11000 && error.code !== 11001) {
      return error;
    }
    if (error.keyPattern != null) {
      const keyPattern = error.keyPattern;
      const keys = Object.keys(keyPattern);
      if (keys.length !== 1) {
        return error;
      }
      const firstKey = keys[0];
      if (!this._duplicateKeyErrorMessagesByPath.hasOwnProperty(firstKey)) {
        return error;
      }
      return new MongooseError(this._duplicateKeyErrorMessagesByPath[firstKey], { cause: error });
    }
    return error;
  };
  /*!
   * ignore
   */
  Schema.prototype._preCompile = function _preCompile() {
    this.plugin(idGetter, { deduplicate: true });
  };
  Schema.prototype.toJSONSchema = function toJSONSchema(options) {
    const useBsonType = options?.useBsonType ?? false;
    const result = useBsonType ? { required: [], properties: {} } : { type: "object", required: [], properties: {} };
    for (const path of Object.keys(this.paths)) {
      const schemaType = this.paths[path];
      if (schemaType._presplitPath.indexOf("$*") !== -1) {
        continue;
      }
      const isNested = schemaType._presplitPath.length > 1;
      let jsonSchemaForPath = result;
      if (isNested) {
        for (let i = 0;i < schemaType._presplitPath.length - 1; ++i) {
          const subpath = schemaType._presplitPath[i];
          if (jsonSchemaForPath.properties[subpath] == null) {
            jsonSchemaForPath.properties[subpath] = useBsonType ? {
              bsonType: ["object", "null"],
              properties: {}
            } : {
              type: ["object", "null"],
              properties: {}
            };
          }
          jsonSchemaForPath = jsonSchemaForPath.properties[subpath];
        }
      }
      const lastSubpath = schemaType._presplitPath[schemaType._presplitPath.length - 1];
      let isRequired = false;
      if (path === "_id") {
        if (!jsonSchemaForPath.required) {
          jsonSchemaForPath.required = [];
        }
        jsonSchemaForPath.required.push("_id");
        isRequired = true;
      } else if (schemaType.options.required && typeof schemaType.options.required !== "function") {
        if (!jsonSchemaForPath.required) {
          jsonSchemaForPath.required = [];
        }
        jsonSchemaForPath.required.push(lastSubpath);
        isRequired = true;
      }
      jsonSchemaForPath.properties[lastSubpath] = schemaType.toJSONSchema(options);
      if (schemaType.options.enum) {
        jsonSchemaForPath.properties[lastSubpath].enum = isRequired ? schemaType.options.enum : [...schemaType.options.enum, null];
      }
    }
    if (result.required.length === 0) {
      delete result.required;
    }
    return result;
  };
  /*!
   * Module exports.
   */
  module.exports = exports = Schema;
  Schema.Types = MongooseTypes = require_schema();
  /*!
   * ignore
   */
  exports.ObjectId = MongooseTypes.ObjectId;
});

// node_modules/mongoose/lib/error/bulkWriteError.js
var require_bulkWriteError = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_error2();

  class MongooseBulkWriteError extends MongooseError {
    constructor(validationErrors, results, rawResult, operation) {
      let preview = validationErrors.map((e) => e.message).join(", ");
      if (preview.length > 200) {
        preview = preview.slice(0, 200) + "...";
      }
      super(`${operation} failed with ${validationErrors.length} Mongoose validation errors: ${preview}`);
      this.validationErrors = validationErrors;
      this.results = results;
      this.rawResult = rawResult;
      this.operation = operation;
    }
  }
  Object.defineProperty(MongooseBulkWriteError.prototype, "name", {
    value: "MongooseBulkWriteError"
  });
  /*!
   * exports
   */
  module.exports = MongooseBulkWriteError;
});

// node_modules/mongoose/lib/error/syncIndexes.js
var require_syncIndexes = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class SyncIndexesError extends MongooseError {
    constructor(message, errorsMap) {
      super(message);
      this.errors = errorsMap;
    }
  }
  Object.defineProperty(SyncIndexesError.prototype, "name", {
    value: "SyncIndexesError"
  });
  module.exports = SyncIndexesError;
});

// node_modules/mongoose/lib/helpers/schema/applyPlugins.js
var require_applyPlugins = __commonJS((exports, module) => {
  module.exports = function applyPlugins(schema, plugins, options, cacheKey2) {
    if (schema[cacheKey2]) {
      return;
    }
    schema[cacheKey2] = true;
    if (!options || !options.skipTopLevel) {
      let pluginTags = null;
      for (const plugin of plugins) {
        const tags = plugin[1] == null ? null : plugin[1].tags;
        if (!Array.isArray(tags)) {
          schema.plugin(plugin[0], plugin[1]);
          continue;
        }
        pluginTags = pluginTags || new Set(schema.options.pluginTags || []);
        if (!tags.find((tag) => pluginTags.has(tag))) {
          continue;
        }
        schema.plugin(plugin[0], plugin[1]);
      }
    }
    options = Object.assign({}, options);
    delete options.skipTopLevel;
    if (options.applyPluginsToChildSchemas !== false) {
      for (const path of Object.keys(schema.paths)) {
        const type = schema.paths[path];
        if (type.schema != null) {
          applyPlugins(type.schema, plugins, options, cacheKey2);
          type.caster.prototype.$__setSchema(type.schema);
        }
      }
    }
    const discriminators = schema.discriminators;
    if (discriminators == null) {
      return;
    }
    const applyPluginsToDiscriminators = options.applyPluginsToDiscriminators;
    const keys = Object.keys(discriminators);
    for (const discriminatorKey of keys) {
      const discriminatorSchema = discriminators[discriminatorKey];
      applyPlugins(discriminatorSchema, plugins, { skipTopLevel: !applyPluginsToDiscriminators }, cacheKey2);
    }
  };
});

// node_modules/mongoose/lib/driver.js
var require_driver = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  var driver = null;
  exports.get = function() {
    return driver;
  };
  exports.set = function(v) {
    driver = v;
  };
});

// node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js
var require_getDefaultBulkwriteResult = __commonJS((exports, module) => {
  function getDefaultBulkwriteResult() {
    return {
      result: {
        ok: 1,
        writeErrors: [],
        writeConcernErrors: [],
        insertedIds: [],
        nInserted: 0,
        nUpserted: 0,
        nMatched: 0,
        nModified: 0,
        nRemoved: 0,
        upserted: []
      },
      insertedCount: 0,
      matchedCount: 0,
      modifiedCount: 0,
      deletedCount: 0,
      upsertedCount: 0,
      upsertedIds: {},
      insertedIds: {},
      n: 0
    };
  }
  module.exports = getDefaultBulkwriteResult;
});

// node_modules/mongoose/lib/error/createCollectionsError.js
var require_createCollectionsError = __commonJS((exports, module) => {
  var MongooseError = require_mongooseError();

  class CreateCollectionsError extends MongooseError {
    constructor(message, errorsMap) {
      super(message);
      this.errors = errorsMap;
    }
  }
  Object.defineProperty(CreateCollectionsError.prototype, "name", {
    value: "CreateCollectionsError"
  });
  module.exports = CreateCollectionsError;
});

// node_modules/mongoose/lib/helpers/update/modifiedPaths.js
var require_modifiedPaths = __commonJS((exports, module) => {
  var _modifiedPaths = require_common3().modifiedPaths;
  module.exports = function modifiedPaths(update) {
    const keys = Object.keys(update);
    const res = {};
    const withoutDollarKeys = {};
    for (const key of keys) {
      if (key.startsWith("$")) {
        _modifiedPaths(update[key], "", res);
        continue;
      }
      withoutDollarKeys[key] = update[key];
    }
    _modifiedPaths(withoutDollarKeys, "", res);
    return res;
  };
});

// node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js
var require_updatedPathsByArrayFilter = __commonJS((exports, module) => {
  var modifiedPaths = require_modifiedPaths();
  module.exports = function updatedPathsByArrayFilter(update) {
    if (update == null) {
      return {};
    }
    const updatedPaths = modifiedPaths(update);
    return Object.keys(updatedPaths).reduce((cur, path) => {
      const matches = path.match(/\$\[[^\]]+\]/g);
      if (matches == null) {
        return cur;
      }
      for (const match of matches) {
        const firstMatch = path.indexOf(match);
        if (firstMatch !== path.lastIndexOf(match)) {
          throw new Error(`Path '${path}' contains the same array filter multiple times`);
        }
        cur[match.substring(2, match.length - 1)] = path.substring(0, firstMatch - 1).replace(/\$\[[^\]]+\]/g, "0");
      }
      return cur;
    }, {});
  };
});

// node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js
var require_getEmbeddedDiscriminatorPath2 = __commonJS((exports, module) => {
  var cleanPositionalOperators = require_cleanPositionalOperators();
  var get = require_get2();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var updatedPathsByArrayFilter = require_updatedPathsByArrayFilter();
  module.exports = function getEmbeddedDiscriminatorPath(schema, update, filter, path, options) {
    const parts = path.split(".");
    let schematype = null;
    let type = "adhocOrUndefined";
    filter = filter || {};
    update = update || {};
    const arrayFilters = options != null && Array.isArray(options.arrayFilters) ? options.arrayFilters : [];
    const updatedPathsByFilter = updatedPathsByArrayFilter(update);
    for (let i = 0;i < parts.length; ++i) {
      const originalSubpath = parts.slice(0, i + 1).join(".");
      const subpath = cleanPositionalOperators(originalSubpath);
      schematype = schema.path(subpath);
      if (schematype == null) {
        continue;
      }
      type = schema.pathType(subpath);
      if ((schematype.$isSingleNested || schematype.$isMongooseDocumentArrayElement) && schematype.schema.discriminators != null) {
        const key = get(schematype, "schema.options.discriminatorKey");
        const discriminatorValuePath = subpath + "." + key;
        const discriminatorFilterPath = discriminatorValuePath.replace(/\.\d+\./, ".");
        let discriminatorKey = null;
        if (discriminatorValuePath in filter) {
          discriminatorKey = filter[discriminatorValuePath];
        }
        if (discriminatorFilterPath in filter) {
          discriminatorKey = filter[discriminatorFilterPath];
        }
        const wrapperPath = subpath.replace(/\.\d+$/, "");
        if (schematype.$isMongooseDocumentArrayElement && get(filter[wrapperPath], "$elemMatch." + key) != null) {
          discriminatorKey = filter[wrapperPath].$elemMatch[key];
        }
        const discriminatorKeyUpdatePath = originalSubpath + "." + key;
        if (discriminatorKeyUpdatePath in update) {
          discriminatorKey = update[discriminatorKeyUpdatePath];
        }
        if (discriminatorValuePath in update) {
          discriminatorKey = update[discriminatorValuePath];
        }
        for (const filterKey of Object.keys(updatedPathsByFilter)) {
          const schemaKey = updatedPathsByFilter[filterKey] + "." + key;
          const arrayFilterKey = filterKey + "." + key;
          if (schemaKey === discriminatorFilterPath) {
            const filter2 = arrayFilters.find((filter3) => filter3.hasOwnProperty(arrayFilterKey));
            if (filter2 != null) {
              discriminatorKey = filter2[arrayFilterKey];
            }
          }
        }
        if (discriminatorKey == null) {
          continue;
        }
        const discriminator = getDiscriminatorByValue(schematype.caster.discriminators, discriminatorKey);
        const discriminatorSchema = discriminator && discriminator.schema;
        if (discriminatorSchema == null) {
          continue;
        }
        const rest = parts.slice(i + 1).join(".");
        schematype = discriminatorSchema.path(rest);
        if (schematype != null) {
          type = discriminatorSchema._getPathType(rest);
          break;
        }
      }
    }
    return { type, schematype };
  };
});

// node_modules/mongoose/lib/helpers/query/handleImmutable.js
var require_handleImmutable2 = __commonJS((exports, module) => {
  var StrictModeError = require_strict();
  module.exports = function handleImmutable(schematype, strict, obj, key, fullPath, options, ctx) {
    if (schematype == null || !schematype.options || !schematype.options.immutable) {
      return false;
    }
    let immutable = schematype.options.immutable;
    if (typeof immutable === "function") {
      immutable = immutable.call(ctx, ctx);
    }
    if (!immutable) {
      return false;
    }
    if (options && options.overwriteImmutable) {
      return false;
    }
    if (strict === false) {
      return false;
    }
    if (strict === "throw") {
      throw new StrictModeError(null, `Field ${fullPath} is immutable and strict = 'throw'`);
    }
    delete obj[key];
    return true;
  };
});

// node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js
var require_moveImmutableProperties = __commonJS((exports, module) => {
  function _walkUpdatePath(schema, op, path, update, ctx) {
    const schematype = schema.path(path);
    if (schematype == null) {
      return;
    }
    let immutable = get(schematype, "options.immutable", null);
    if (immutable == null) {
      return;
    }
    if (typeof immutable === "function") {
      immutable = immutable.call(ctx, ctx);
    }
    if (!immutable) {
      return;
    }
    update.$setOnInsert = update.$setOnInsert || {};
    update.$setOnInsert[path] = op[path];
    delete op[path];
  }
  var get = require_get2();
  module.exports = function moveImmutableProperties(schema, update, ctx) {
    if (update == null) {
      return;
    }
    const keys = Object.keys(update);
    for (const key of keys) {
      const isDollarKey = key.startsWith("$");
      if (key === "$set") {
        const updatedPaths = Object.keys(update[key]);
        for (const path of updatedPaths) {
          _walkUpdatePath(schema, update[key], path, update, ctx);
        }
      } else if (!isDollarKey) {
        _walkUpdatePath(schema, update, key, update, ctx);
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/path/setDottedPath.js
var require_setDottedPath = __commonJS((exports, module) => {
  var specialProperties = require_specialProperties();
  module.exports = function setDottedPath(obj, path, val) {
    if (path.indexOf(".") === -1) {
      if (specialProperties.has(path)) {
        return;
      }
      obj[path] = val;
      return;
    }
    const parts = path.split(".");
    const last = parts.pop();
    let cur = obj;
    for (const part of parts) {
      if (specialProperties.has(part)) {
        continue;
      }
      if (cur[part] == null) {
        cur[part] = {};
      }
      cur = cur[part];
    }
    if (!specialProperties.has(last)) {
      cur[last] = val;
    }
  };
});

// node_modules/mongoose/lib/helpers/query/castUpdate.js
var require_castUpdate = __commonJS((exports, module) => {
  function castPipelineOperator(op, val) {
    if (op === "$unset") {
      if (typeof val !== "string" && (!Array.isArray(val) || val.find((v) => typeof v !== "string"))) {
        throw new MongooseError("Invalid $unset in pipeline, must be " + " a string or an array of strings");
      }
      return val;
    }
    if (op === "$project") {
      if (val == null || typeof val !== "object") {
        throw new MongooseError("Invalid $project in pipeline, must be an object");
      }
      return val;
    }
    if (op === "$addFields" || op === "$set") {
      if (val == null || typeof val !== "object") {
        throw new MongooseError("Invalid " + op + " in pipeline, must be an object");
      }
      return val;
    } else if (op === "$replaceRoot" || op === "$replaceWith") {
      if (val == null || typeof val !== "object") {
        throw new MongooseError("Invalid " + op + " in pipeline, must be an object");
      }
      return val;
    }
    throw new MongooseError('Invalid update pipeline operator: "' + op + '"');
  }
  function walkUpdatePath(schema, obj, op, options, context, filter, pref) {
    const strict = options.strict;
    const prefix = pref ? pref + "." : "";
    const keys = Object.keys(obj);
    let i = keys.length;
    let hasKeys = false;
    let schematype;
    let key;
    let val;
    let aggregatedError = null;
    const strictMode = strict != null ? strict : schema.options.strict;
    while (i--) {
      key = keys[i];
      val = obj[key];
      if (op === "$pull") {
        schematype = schema._getSchema(prefix + key);
        if (schematype == null) {
          const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);
          if (_res.schematype != null) {
            schematype = _res.schematype;
          }
        }
        if (schematype != null && schematype.schema != null) {
          obj[key] = cast(schematype.schema, obj[key], options, context);
          hasKeys = true;
          continue;
        }
      }
      const discriminatorKey = prefix ? prefix + key : key;
      if (schema.discriminatorMapping != null && discriminatorKey === schema.options.discriminatorKey && schema.discriminatorMapping.value !== obj[key] && !options.overwriteDiscriminatorKey) {
        if (strictMode === "throw") {
          const err = new Error('Can\'t modify discriminator key "' + discriminatorKey + '" on discriminator model');
          aggregatedError = _appendError(err, context, discriminatorKey, aggregatedError);
          continue;
        } else if (strictMode) {
          delete obj[key];
          continue;
        }
      }
      if (getConstructorName(val) === "Object") {
        schematype = schema._getSchema(prefix + key);
        if (schematype == null) {
          const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);
          if (_res.schematype != null) {
            schematype = _res.schematype;
          }
        }
        if (op !== "$setOnInsert" && handleImmutable(schematype, strict, obj, key, prefix + key, options, context)) {
          continue;
        }
        if (schematype && schematype.caster && op in castOps) {
          if ("$each" in val) {
            hasKeys = true;
            try {
              obj[key] = {
                $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)
              };
            } catch (error) {
              aggregatedError = _appendError(error, context, key, aggregatedError);
            }
            if (val.$slice != null) {
              obj[key].$slice = val.$slice | 0;
            }
            if (val.$sort) {
              obj[key].$sort = val.$sort;
            }
            if (val.$position != null) {
              obj[key].$position = castNumber(val.$position);
            }
          } else {
            if (schematype != null && schematype.$isSingleNested) {
              const _strict = strict == null ? schematype.schema.options.strict : strict;
              try {
                obj[key] = schematype.castForQuery(null, val, context, { strict: _strict });
              } catch (error) {
                aggregatedError = _appendError(error, context, key, aggregatedError);
              }
            } else {
              try {
                obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
              } catch (error) {
                aggregatedError = _appendError(error, context, key, aggregatedError);
              }
            }
            if (obj[key] === undefined) {
              delete obj[key];
              continue;
            }
            hasKeys = true;
          }
        } else if (op === "$currentDate" || op in castOps && schematype) {
          try {
            obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
          } catch (error) {
            aggregatedError = _appendError(error, context, key, aggregatedError);
          }
          if (obj[key] === undefined) {
            delete obj[key];
            continue;
          }
          hasKeys = true;
        } else if (op === "$rename") {
          const schematype2 = new SchemaString(`${prefix}${key}.\$rename`);
          try {
            obj[key] = castUpdateVal(schematype2, val, op, key, context, prefix + key);
          } catch (error) {
            aggregatedError = _appendError(error, context, key, aggregatedError);
          }
          if (obj[key] === undefined) {
            delete obj[key];
            continue;
          }
          hasKeys = true;
        } else {
          const pathToCheck = prefix + key;
          const v = schema._getPathType(pathToCheck);
          let _strict = strict;
          if (v && v.schema && _strict == null) {
            _strict = v.schema.options.strict;
          }
          if (v.pathType === "undefined") {
            if (_strict === "throw") {
              throw new StrictModeError(pathToCheck);
            } else if (_strict) {
              delete obj[key];
              continue;
            }
          }
          hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) || utils.isObject(val) && Object.keys(val).length === 0;
        }
      } else {
        const checkPath = key === "$each" || key === "$or" || key === "$and" || key === "$in" ? pref : prefix + key;
        schematype = schema._getSchema(checkPath);
        if (op !== "$setOnInsert" && handleImmutable(schematype, strict, obj, key, prefix + key, options, context)) {
          continue;
        }
        let pathDetails = schema._getPathType(checkPath);
        if (schematype == null) {
          const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath, options);
          if (_res.schematype != null) {
            schematype = _res.schematype;
            pathDetails = _res.type;
          }
        }
        let isStrict = strict;
        if (pathDetails && pathDetails.schema && strict == null) {
          isStrict = pathDetails.schema.options.strict;
        }
        const skip = isStrict && !schematype && !/real|nested/.test(pathDetails.pathType);
        if (skip) {
          if (isStrict === "throw" && schema.virtuals[checkPath] == null) {
            throw new StrictModeError(prefix + key);
          } else {
            delete obj[key];
          }
        } else {
          if (op === "$rename") {
            if (obj[key] == null) {
              throw new CastError("String", obj[key], `${prefix}${key}.\$rename`);
            }
            const schematype2 = new SchemaString(`${prefix}${key}.\$rename`);
            obj[key] = schematype2.castForQuery(null, obj[key], context);
            continue;
          }
          try {
            if (prefix.length === 0 || key.indexOf(".") === -1) {
              obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);
            } else if (isStrict !== false || schematype != null) {
              setDottedPath(obj, key, castUpdateVal(schematype, val, op, key, context, prefix + key));
              delete obj[key];
            }
          } catch (error) {
            aggregatedError = _appendError(error, context, key, aggregatedError);
          }
          if (Array.isArray(obj[key]) && (op === "$addToSet" || op === "$push") && key !== "$each") {
            if (schematype && schematype.caster && !schematype.caster.$isMongooseArray && !schematype.caster[schemaMixedSymbol]) {
              obj[key] = { $each: obj[key] };
            }
          }
          if (obj[key] === undefined) {
            delete obj[key];
            continue;
          }
          hasKeys = true;
        }
      }
    }
    if (aggregatedError != null) {
      throw aggregatedError;
    }
    return hasKeys;
  }
  function _appendError(error, query, key, aggregatedError) {
    if (typeof query !== "object" || !query.options.multipleCastError) {
      throw error;
    }
    aggregatedError = aggregatedError || new ValidationError;
    aggregatedError.addError(key, error);
    return aggregatedError;
  }
  function castUpdateVal(schema, val, op, $conditional, context, path) {
    if (!schema) {
      if (op in numberOps) {
        try {
          return castNumber(val);
        } catch (err) {
          throw new CastError("number", val, path);
        }
      }
      return val;
    }
    const cond = schema.caster && op in castOps && (utils.isObject(val) || Array.isArray(val));
    if (cond && !overwriteOps[op]) {
      let schemaArrayDepth = 0;
      let cur = schema;
      while (cur.$isMongooseArray) {
        ++schemaArrayDepth;
        cur = cur.caster;
      }
      let arrayDepth = 0;
      let _val = val;
      while (Array.isArray(_val)) {
        ++arrayDepth;
        _val = _val[0];
      }
      const additionalNesting = schemaArrayDepth - arrayDepth;
      while (arrayDepth < schemaArrayDepth) {
        val = [val];
        ++arrayDepth;
      }
      let tmp = schema.applySetters(Array.isArray(val) ? val : [val], context);
      for (let i = 0;i < additionalNesting; ++i) {
        tmp = tmp[0];
      }
      return tmp;
    }
    if (op in noCastOps) {
      return val;
    }
    if (op in numberOps) {
      if (val == null) {
        throw new CastError("number", val, schema.path);
      }
      if (op === "$inc") {
        return schema.castForQuery(null, val, context);
      }
      try {
        return castNumber(val);
      } catch (error) {
        throw new CastError("number", val, schema.path);
      }
    }
    if (op === "$currentDate") {
      if (typeof val === "object") {
        return { $type: val.$type };
      }
      return Boolean(val);
    }
    if (mongodbUpdateOperators.has($conditional)) {
      return schema.castForQuery($conditional, val, context);
    }
    if (overwriteOps[op]) {
      const skipQueryCastForUpdate = val != null && schema.$isMongooseArray && schema.$fullPath != null && !schema.$fullPath.match(/\d+$/);
      const applySetters = schema[schemaMixedSymbol] != null;
      if (skipQueryCastForUpdate || applySetters) {
        return schema.applySetters(val, context);
      }
      return schema.castForQuery(null, val, context);
    }
    return schema.castForQuery(null, val, context);
  }
  var CastError = require_cast();
  var MongooseError = require_mongooseError();
  var SchemaString = require_string2();
  var StrictModeError = require_strict();
  var ValidationError = require_validation();
  var castNumber = require_number();
  var cast = require_cast2();
  var getConstructorName = require_getConstructorName();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var getEmbeddedDiscriminatorPath = require_getEmbeddedDiscriminatorPath2();
  var handleImmutable = require_handleImmutable2();
  var moveImmutableProperties = require_moveImmutableProperties();
  var schemaMixedSymbol = require_symbols2().schemaMixedSymbol;
  var setDottedPath = require_setDottedPath();
  var utils = require_utils4();
  var { internalToObjectOptions } = require_options();
  var mongodbUpdateOperators = new Set([
    "$currentDate",
    "$inc",
    "$min",
    "$max",
    "$mul",
    "$rename",
    "$set",
    "$setOnInsert",
    "$unset",
    "$addToSet",
    "$pop",
    "$pull",
    "$push",
    "$pullAll",
    "$bit"
  ]);
  module.exports = function castUpdate(schema, obj, options, context, filter) {
    if (obj == null) {
      return;
    }
    options = options || {};
    if (Array.isArray(obj)) {
      const len = obj.length;
      for (let i2 = 0;i2 < len; ++i2) {
        const ops2 = Object.keys(obj[i2]);
        for (const op of ops2) {
          obj[i2][op] = castPipelineOperator(op, obj[i2][op]);
        }
      }
      return obj;
    }
    if (schema != null && filter != null && utils.hasUserDefinedProperty(filter, schema.options.discriminatorKey) && typeof filter[schema.options.discriminatorKey] !== "object" && schema.discriminators != null) {
      const discriminatorValue = filter[schema.options.discriminatorKey];
      const byValue = getDiscriminatorByValue(context.model.discriminators, discriminatorValue);
      schema = schema.discriminators[discriminatorValue] || byValue && byValue.schema || schema;
    } else if (schema != null && options.overwriteDiscriminatorKey && utils.hasUserDefinedProperty(obj, schema.options.discriminatorKey) && schema.discriminators != null) {
      const discriminatorValue = obj[schema.options.discriminatorKey];
      const byValue = getDiscriminatorByValue(context.model.discriminators, discriminatorValue);
      schema = schema.discriminators[discriminatorValue] || byValue && byValue.schema || schema;
    } else if (schema != null && options.overwriteDiscriminatorKey && obj.$set != null && utils.hasUserDefinedProperty(obj.$set, schema.options.discriminatorKey) && schema.discriminators != null) {
      const discriminatorValue = obj.$set[schema.options.discriminatorKey];
      const byValue = getDiscriminatorByValue(context.model.discriminators, discriminatorValue);
      schema = schema.discriminators[discriminatorValue] || byValue && byValue.schema || schema;
    }
    if (options.upsert) {
      moveImmutableProperties(schema, obj, context);
    }
    const ops = Object.keys(obj);
    let i = ops.length;
    const ret = {};
    let val;
    let hasDollarKey = false;
    filter = filter || {};
    while (i--) {
      const op = ops[i];
      if (!mongodbUpdateOperators.has(op)) {
        if (!ret.$set) {
          if (obj.$set) {
            ret.$set = obj.$set;
          } else {
            ret.$set = {};
          }
        }
        ret.$set[op] = obj[op];
        ops.splice(i, 1);
        if (!~ops.indexOf("$set"))
          ops.push("$set");
      } else if (op === "$set") {
        if (!ret.$set) {
          ret[op] = obj[op];
        }
      } else {
        ret[op] = obj[op];
      }
    }
    i = ops.length;
    while (i--) {
      const op = ops[i];
      val = ret[op];
      hasDollarKey = hasDollarKey || op.startsWith("$");
      if (val != null && val.$__) {
        val = val.toObject(internalToObjectOptions);
        ret[op] = val;
      }
      if (val && typeof val === "object" && !Buffer.isBuffer(val) && mongodbUpdateOperators.has(op)) {
        walkUpdatePath(schema, val, op, options, context, filter);
      } else {
        const msg = "Invalid atomic update value for " + op + ". " + "Expected an object, received " + typeof val;
        throw new Error(msg);
      }
      if (op.startsWith("$") && utils.isEmptyObject(val)) {
        delete ret[op];
      }
    }
    if (Object.keys(ret).length === 0 && options.upsert && Object.keys(filter).length > 0) {
      return { $setOnInsert: { ...filter } };
    }
    return ret;
  };
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  var numberOps = {
    $pop: 1,
    $inc: 1
  };
  var noCastOps = {
    $unset: 1
  };
  var castOps = {
    $push: 1,
    $addToSet: 1,
    $set: 1,
    $setOnInsert: 1
  };
  /*!
   * ignore
   */
  var overwriteOps = {
    $set: 1,
    $setOnInsert: 1
  };
});

// node_modules/mongoose/lib/helpers/update/decorateUpdateWithVersionKey.js
var require_decorateUpdateWithVersionKey = __commonJS((exports, module) => {
  var modifiedPaths = require_modifiedPaths();
  module.exports = function decorateUpdateWithVersionKey(update, options, versionKey) {
    if (!versionKey || !(options && options.upsert || false)) {
      return;
    }
    const updatedPaths = modifiedPaths(update);
    if (!updatedPaths[versionKey]) {
      if (options.overwrite) {
        update[versionKey] = 0;
      } else {
        if (!update.$setOnInsert) {
          update.$setOnInsert = {};
        }
        update.$setOnInsert[versionKey] = 0;
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js
var require_setDefaultsOnInsert = __commonJS((exports, module) => {
  function isModified(modified, path) {
    if (modified[path]) {
      return true;
    }
    const sp = path.split(".");
    let cur = sp[0];
    for (let i = 1;i < sp.length; ++i) {
      if (modified[cur]) {
        return true;
      }
      cur += "." + sp[i];
    }
    const modifiedKeys = Object.keys(modified);
    if (modifiedKeys.length) {
      const parentPath = path + ".";
      for (const modifiedPath of modifiedKeys) {
        if (modifiedPath.slice(0, path.length + 1) === parentPath) {
          return true;
        }
      }
    }
    return false;
  }
  var modifiedPaths = require_common3().modifiedPaths;
  var get = require_get2();
  module.exports = function(filter, schema, castedDoc, options) {
    options = options || {};
    const shouldSetDefaultsOnInsert = options.setDefaultsOnInsert != null ? options.setDefaultsOnInsert : schema.base.options.setDefaultsOnInsert;
    if (!options.upsert || shouldSetDefaultsOnInsert === false) {
      return castedDoc;
    }
    const keys = Object.keys(castedDoc || {});
    const updatedKeys = {};
    const updatedValues = {};
    const numKeys = keys.length;
    const modified = {};
    let hasDollarUpdate = false;
    for (let i = 0;i < numKeys; ++i) {
      if (keys[i].startsWith("$")) {
        modifiedPaths(castedDoc[keys[i]], "", modified);
        hasDollarUpdate = true;
      }
    }
    if (!hasDollarUpdate) {
      modifiedPaths(castedDoc, "", modified);
    }
    const paths = Object.keys(filter);
    const numPaths = paths.length;
    for (let i = 0;i < numPaths; ++i) {
      const path = paths[i];
      const condition = filter[path];
      if (condition && typeof condition === "object") {
        const conditionKeys = Object.keys(condition);
        const numConditionKeys = conditionKeys.length;
        let hasDollarKey = false;
        for (let j = 0;j < numConditionKeys; ++j) {
          if (conditionKeys[j].startsWith("$")) {
            hasDollarKey = true;
            break;
          }
        }
        if (hasDollarKey) {
          continue;
        }
      }
      updatedKeys[path] = true;
      modified[path] = true;
    }
    if (options && options.overwrite && !hasDollarUpdate) {
      return castedDoc;
    }
    schema.eachPath(function(path, schemaType) {
      if (schemaType.path === "_id" && schemaType.options.auto) {
        return;
      }
      const def = schemaType.getDefault(null, true);
      if (isModified(modified, path)) {
        return;
      }
      if (typeof def === "undefined") {
        return;
      }
      if (schemaType.splitPath().includes("$*")) {
        return;
      }
      castedDoc = castedDoc || {};
      castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};
      if (get(castedDoc, path) == null) {
        castedDoc.$setOnInsert[path] = def;
      }
      updatedValues[path] = def;
    });
    return castedDoc;
  };
});

// node_modules/mongoose/lib/helpers/model/castBulkWrite.js
var require_castBulkWrite = __commonJS((exports, module) => {
  function _addDiscriminatorToObject(schema, obj) {
    if (schema == null) {
      return;
    }
    if (schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {
      obj[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;
    }
  }
  function decideModelByObject(model, object) {
    const discriminatorKey = model.schema.options.discriminatorKey;
    if (object != null && object.hasOwnProperty(discriminatorKey)) {
      model = getDiscriminatorByValue(model.discriminators, object[discriminatorKey]) || model;
    }
    return model;
  }
  function getTimestampsOpt(opCommand, options) {
    const opLevelOpt = opCommand.timestamps;
    const bulkLevelOpt = options.timestamps;
    if (opLevelOpt != null) {
      return opLevelOpt;
    } else if (bulkLevelOpt != null) {
      return bulkLevelOpt;
    }
    return true;
  }
  var MongooseError = require_mongooseError();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var applyTimestampsToChildren = require_applyTimestampsToChildren();
  var applyTimestampsToUpdate = require_applyTimestampsToUpdate();
  var cast = require_cast2();
  var castUpdate = require_castUpdate();
  var clone = require_clone2();
  var decorateUpdateWithVersionKey = require_decorateUpdateWithVersionKey();
  var { inspect } = import.meta.require("util");
  var setDefaultsOnInsert = require_setDefaultsOnInsert();
  module.exports = function castBulkWrite(originalModel, op, options) {
    const now = originalModel.base.now();
    if (op["insertOne"]) {
      return (callback) => module.exports.castInsertOne(originalModel, op["insertOne"], options).then(() => callback(null), (err) => callback(err));
    } else if (op["updateOne"]) {
      return (callback) => {
        try {
          module.exports.castUpdateOne(originalModel, op["updateOne"], options, now);
          callback(null);
        } catch (err) {
          callback(err);
        }
      };
    } else if (op["updateMany"]) {
      return (callback) => {
        try {
          module.exports.castUpdateMany(originalModel, op["updateMany"], options, now);
          callback(null);
        } catch (err) {
          callback(err);
        }
      };
    } else if (op["replaceOne"]) {
      return (callback) => {
        module.exports.castReplaceOne(originalModel, op["replaceOne"], options).then(() => callback(null), (err) => callback(err));
      };
    } else if (op["deleteOne"]) {
      return (callback) => {
        try {
          module.exports.castDeleteOne(originalModel, op["deleteOne"]);
          callback(null);
        } catch (err) {
          callback(err);
        }
      };
    } else if (op["deleteMany"]) {
      return (callback) => {
        try {
          module.exports.castDeleteMany(originalModel, op["deleteMany"]);
          callback(null);
        } catch (err) {
          callback(err);
        }
      };
    } else {
      return (callback) => {
        const error = new MongooseError(`Invalid op passed to \`bulkWrite()\`: ${inspect(op)}`);
        callback(error, null);
      };
    }
  };
  module.exports.castInsertOne = async function castInsertOne(originalModel, insertOne, options) {
    const model = decideModelByObject(originalModel, insertOne["document"]);
    const doc = new model(insertOne["document"]);
    if (model.schema.options.timestamps && getTimestampsOpt(insertOne, options)) {
      doc.initializeTimestamps();
    }
    if (options.session != null) {
      doc.$session(options.session);
    }
    const versionKey = model?.schema?.options?.versionKey;
    if (versionKey && doc[versionKey] == null) {
      doc[versionKey] = 0;
    }
    insertOne["document"] = doc;
    if (options.skipValidation || insertOne.skipValidation) {
      return insertOne;
    }
    await insertOne["document"].$validate();
    return insertOne;
  };
  module.exports.castUpdateOne = function castUpdateOne(originalModel, updateOne, options, now) {
    if (!updateOne["filter"]) {
      throw new Error("Must provide a filter object.");
    }
    if (!updateOne["update"]) {
      throw new Error("Must provide an update object.");
    }
    const model = decideModelByObject(originalModel, updateOne["filter"]);
    const schema = model.schema;
    const strict = options.strict != null ? options.strict : model.schema.options.strict;
    const update = clone(updateOne["update"]);
    _addDiscriminatorToObject(schema, updateOne["filter"]);
    const doInitTimestamps = getTimestampsOpt(updateOne, options);
    if (model.schema.$timestamps != null && doInitTimestamps) {
      const createdAt = model.schema.$timestamps.createdAt;
      const updatedAt = model.schema.$timestamps.updatedAt;
      applyTimestampsToUpdate(now, createdAt, updatedAt, update, {});
    }
    if (doInitTimestamps) {
      applyTimestampsToChildren(now, update, model.schema);
    }
    const globalSetDefaultsOnInsert = originalModel.base.options.setDefaultsOnInsert;
    const shouldSetDefaultsOnInsert = updateOne.setDefaultsOnInsert == null ? globalSetDefaultsOnInsert : updateOne.setDefaultsOnInsert;
    if (shouldSetDefaultsOnInsert !== false) {
      setDefaultsOnInsert(updateOne["filter"], model.schema, update, {
        setDefaultsOnInsert: true,
        upsert: updateOne.upsert
      });
    }
    decorateUpdateWithVersionKey(update, updateOne, model.schema.options.versionKey);
    updateOne["filter"] = cast(model.schema, updateOne["filter"], {
      strict,
      upsert: updateOne.upsert
    });
    updateOne["update"] = castUpdate(model.schema, update, {
      strict,
      upsert: updateOne.upsert,
      arrayFilters: updateOne.arrayFilters,
      overwriteDiscriminatorKey: updateOne.overwriteDiscriminatorKey
    }, model, updateOne["filter"]);
    return updateOne;
  };
  module.exports.castUpdateMany = function castUpdateMany(originalModel, updateMany, options, now) {
    if (!updateMany["filter"]) {
      throw new Error("Must provide a filter object.");
    }
    if (!updateMany["update"]) {
      throw new Error("Must provide an update object.");
    }
    const model = decideModelByObject(originalModel, updateMany["filter"]);
    const schema = model.schema;
    const strict = options.strict != null ? options.strict : model.schema.options.strict;
    const globalSetDefaultsOnInsert = originalModel.base.options.setDefaultsOnInsert;
    const shouldSetDefaultsOnInsert = updateMany.setDefaultsOnInsert == null ? globalSetDefaultsOnInsert : updateMany.setDefaultsOnInsert;
    if (shouldSetDefaultsOnInsert !== false) {
      setDefaultsOnInsert(updateMany["filter"], model.schema, updateMany["update"], {
        setDefaultsOnInsert: true,
        upsert: updateMany.upsert
      });
    }
    const doInitTimestamps = getTimestampsOpt(updateMany, options);
    if (model.schema.$timestamps != null && doInitTimestamps) {
      const createdAt = model.schema.$timestamps.createdAt;
      const updatedAt = model.schema.$timestamps.updatedAt;
      applyTimestampsToUpdate(now, createdAt, updatedAt, updateMany["update"], {});
    }
    if (doInitTimestamps) {
      applyTimestampsToChildren(now, updateMany["update"], model.schema);
    }
    _addDiscriminatorToObject(schema, updateMany["filter"]);
    decorateUpdateWithVersionKey(updateMany["update"], updateMany, model.schema.options.versionKey);
    updateMany["filter"] = cast(model.schema, updateMany["filter"], {
      strict,
      upsert: updateMany.upsert
    });
    updateMany["update"] = castUpdate(model.schema, updateMany["update"], {
      strict,
      upsert: updateMany.upsert,
      arrayFilters: updateMany.arrayFilters,
      overwriteDiscriminatorKey: updateMany.overwriteDiscriminatorKey
    }, model, updateMany["filter"]);
  };
  module.exports.castReplaceOne = async function castReplaceOne(originalModel, replaceOne, options) {
    const model = decideModelByObject(originalModel, replaceOne["filter"]);
    const schema = model.schema;
    const strict = options.strict != null ? options.strict : model.schema.options.strict;
    _addDiscriminatorToObject(schema, replaceOne["filter"]);
    replaceOne["filter"] = cast(model.schema, replaceOne["filter"], {
      strict,
      upsert: replaceOne.upsert
    });
    const doc = new model(replaceOne["replacement"], strict, true);
    if (model.schema.options.timestamps && getTimestampsOpt(replaceOne, options)) {
      doc.initializeTimestamps();
    }
    if (options.session != null) {
      doc.$session(options.session);
    }
    const versionKey = model?.schema?.options?.versionKey;
    if (versionKey && doc[versionKey] == null) {
      doc[versionKey] = 0;
    }
    replaceOne["replacement"] = doc;
    if (options.skipValidation || replaceOne.skipValidation) {
      replaceOne["replacement"] = replaceOne["replacement"].toBSON();
      return;
    }
    await replaceOne["replacement"].$validate();
    replaceOne["replacement"] = replaceOne["replacement"].toBSON();
  };
  module.exports.castDeleteOne = function castDeleteOne(originalModel, deleteOne) {
    const model = decideModelByObject(originalModel, deleteOne["filter"]);
    const schema = model.schema;
    _addDiscriminatorToObject(schema, deleteOne["filter"]);
    deleteOne["filter"] = cast(model.schema, deleteOne["filter"]);
  };
  module.exports.castDeleteMany = function castDeleteMany(originalModel, deleteMany) {
    const model = decideModelByObject(originalModel, deleteMany["filter"]);
    const schema = model.schema;
    _addDiscriminatorToObject(schema, deleteMany["filter"]);
    deleteMany["filter"] = cast(model.schema, deleteMany["filter"]);
  };
  module.exports.cast = {
    insertOne: module.exports.castInsertOne,
    updateOne: module.exports.castUpdateOne,
    updateMany: module.exports.castUpdateMany,
    replaceOne: module.exports.castReplaceOne,
    deleteOne: module.exports.castDeleteOne,
    deleteMany: module.exports.castDeleteMany
  };
});

// node_modules/mongoose/lib/connection.js
var require_connection2 = __commonJS((exports, module) => {
  function Connection(base) {
    this.base = base;
    this.collections = {};
    this.models = {};
    this.config = {};
    this.replica = false;
    this.options = null;
    this.otherDbs = [];
    this.relatedDbs = {};
    this.states = STATES;
    this._readyState = STATES.disconnected;
    this._closeCalled = false;
    this._hasOpened = false;
    this.plugins = [];
    if (typeof base === "undefined" || !base.connections.length) {
      this.id = 0;
    } else {
      this.id = base.nextConnectionId;
    }
    this._queue = [];
  }
  async function _wrapUserTransaction(fn, session, mongoose) {
    try {
      const res = mongoose.transactionAsyncLocalStorage == null ? await fn(session) : await new Promise((resolve) => {
        mongoose.transactionAsyncLocalStorage.run({ session }, () => resolve(fn(session)));
      });
      return res;
    } catch (err) {
      _resetSessionDocuments(session);
      throw err;
    }
  }
  function _resetSessionDocuments(session) {
    for (const doc of session[sessionNewDocuments].keys()) {
      const state = session[sessionNewDocuments].get(doc);
      if (state.hasOwnProperty("isNew")) {
        doc.$isNew = state.isNew;
      }
      if (state.hasOwnProperty("versionKey")) {
        doc.set(doc.schema.options.versionKey, state.versionKey);
      }
      if (state.modifiedPaths.length > 0 && doc.$__.activePaths.states.modify == null) {
        doc.$__.activePaths.states.modify = {};
      }
      for (const path of state.modifiedPaths) {
        const currentState = doc.$__.activePaths.paths[path];
        if (currentState != null) {
          delete doc.$__.activePaths[currentState][path];
        }
        doc.$__.activePaths.paths[path] = "modify";
        doc.$__.activePaths.states.modify[path] = true;
      }
      for (const path of state.atomics.keys()) {
        const val = doc.$__getValue(path);
        if (val == null) {
          continue;
        }
        val[arrayAtomicsSymbol] = state.atomics.get(path);
      }
    }
  }
  function _validateArgs(uri, options, callback) {
    if (typeof options === "function" && callback == null) {
      throw new MongooseError("Connection.prototype.openUri() no longer accepts a callback");
    } else if (typeof callback === "function") {
      throw new MongooseError("Connection.prototype.openUri() no longer accepts a callback");
    }
  }
  function _handleConnectionErrors(err) {
    if (err?.name === "MongoServerSelectionError") {
      const originalError = err;
      err = new ServerSelectionError;
      err.assimilateError(originalError);
    }
    return err;
  }
  /*!
   * Module dependencies.
   */
  var ChangeStream = require_changeStream();
  var EventEmitter = import.meta.require("events").EventEmitter;
  var Schema = require_schema2();
  var STATES = require_connectionState();
  var MongooseBulkWriteError = require_bulkWriteError();
  var MongooseError = require_error2();
  var ServerSelectionError = require_serverSelection();
  var SyncIndexesError = require_syncIndexes();
  var applyPlugins = require_applyPlugins();
  var clone = require_clone2();
  var driver = require_driver();
  var get = require_get2();
  var getDefaultBulkwriteResult = require_getDefaultBulkwriteResult();
  var immediate = require_immediate();
  var utils = require_utils4();
  var CreateCollectionsError = require_createCollectionsError();
  var castBulkWrite = require_castBulkWrite();
  var { modelSymbol } = require_symbols();
  var isPromise = require_isPromise();
  var arrayAtomicsSymbol = require_symbols().arrayAtomicsSymbol;
  var sessionNewDocuments = require_symbols().sessionNewDocuments;
  var noPasswordAuthMechanisms = [
    "MONGODB-X509"
  ];
  /*!
   * Inherit from EventEmitter
   */
  Object.setPrototypeOf(Connection.prototype, EventEmitter.prototype);
  Object.defineProperty(Connection.prototype, "readyState", {
    get: function() {
      if (this._readyState === STATES.connected && this._lastHeartbeatAt != null && this.client?.topology?.s?.description?.type !== "LoadBalanced" && typeof this.client?.topology?.s?.description?.heartbeatFrequencyMS === "number" && Date.now() - this._lastHeartbeatAt >= this.client.topology.s.description.heartbeatFrequencyMS * 2) {
        return STATES.disconnected;
      }
      return this._readyState;
    },
    set: function(val) {
      if (!(val in STATES)) {
        throw new Error("Invalid connection state: " + val);
      }
      if (this._readyState !== val) {
        this._readyState = val;
        for (const db of this.otherDbs) {
          db.readyState = val;
        }
        if (STATES.connected === val) {
          this._hasOpened = true;
        }
        this.emit(STATES[val]);
      }
    }
  });
  Connection.prototype.get = function getOption(key) {
    if (this.config.hasOwnProperty(key)) {
      return this.config[key];
    }
    return get(this.options, key);
  };
  Connection.prototype.set = function setOption(key, val) {
    if (this.config.hasOwnProperty(key)) {
      this.config[key] = val;
      return val;
    }
    this.options = this.options || {};
    this.options[key] = val;
    return val;
  };
  Connection.prototype.collections;
  Connection.prototype.name;
  Connection.prototype.models;
  Connection.prototype.id;
  Object.defineProperty(Connection.prototype, "plugins", {
    configurable: false,
    enumerable: true,
    writable: true
  });
  Object.defineProperty(Connection.prototype, "host", {
    configurable: true,
    enumerable: true,
    writable: true
  });
  Object.defineProperty(Connection.prototype, "port", {
    configurable: true,
    enumerable: true,
    writable: true
  });
  Object.defineProperty(Connection.prototype, "user", {
    configurable: true,
    enumerable: true,
    writable: true
  });
  Object.defineProperty(Connection.prototype, "pass", {
    configurable: true,
    enumerable: true,
    writable: true
  });
  Connection.prototype.db;
  Connection.prototype.client;
  Connection.prototype.config;
  Connection.prototype.createCollection = async function createCollection(collection, options) {
    if (typeof options === "function" || arguments.length >= 3 && typeof arguments[2] === "function") {
      throw new MongooseError("Connection.prototype.createCollection() no longer accepts a callback");
    }
    await this._waitForConnect();
    return this.db.createCollection(collection, options);
  };
  Connection.prototype.bulkWrite = async function bulkWrite(ops, options) {
    await this._waitForConnect();
    options = options || {};
    const ordered = options.ordered == null ? true : options.ordered;
    const asyncLocalStorage = this.base.transactionAsyncLocalStorage?.getStore();
    if ((!options || !options.hasOwnProperty("session")) && asyncLocalStorage?.session != null) {
      options = { ...options, session: asyncLocalStorage.session };
    }
    const now = this.base.now();
    let res = null;
    if (ordered) {
      const opsToSend = [];
      for (const op of ops) {
        if (typeof op.model !== "string" && !op.model?.[modelSymbol]) {
          throw new MongooseError("Must specify model in Connection.prototype.bulkWrite() operations");
        }
        const Model = op.model[modelSymbol] ? op.model : this.model(op.model);
        if (op.name == null) {
          throw new MongooseError("Must specify operation name in Connection.prototype.bulkWrite()");
        }
        if (!castBulkWrite.cast.hasOwnProperty(op.name)) {
          throw new MongooseError(`Unrecognized bulkWrite() operation name ${op.name}`);
        }
        await castBulkWrite.cast[op.name](Model, op, options, now);
        opsToSend.push({ ...op, namespace: Model.namespace() });
      }
      res = await this.client.bulkWrite(opsToSend, options);
    } else {
      const validOps = [];
      const validOpIndexes = [];
      let validationErrors = [];
      const asyncValidations = [];
      const results = [];
      for (let i = 0;i < ops.length; ++i) {
        const op = ops[i];
        if (typeof op.model !== "string" && !op.model?.[modelSymbol]) {
          const error2 = new MongooseError("Must specify model in Connection.prototype.bulkWrite() operations");
          validationErrors.push({ index: i, error: error2 });
          results[i] = error2;
          continue;
        }
        let Model;
        try {
          Model = op.model[modelSymbol] ? op.model : this.model(op.model);
        } catch (error2) {
          validationErrors.push({ index: i, error: error2 });
          continue;
        }
        if (op.name == null) {
          const error2 = new MongooseError("Must specify operation name in Connection.prototype.bulkWrite()");
          validationErrors.push({ index: i, error: error2 });
          results[i] = error2;
          continue;
        }
        if (!castBulkWrite.cast.hasOwnProperty(op.name)) {
          const error2 = new MongooseError(`Unrecognized bulkWrite() operation name ${op.name}`);
          validationErrors.push({ index: i, error: error2 });
          results[i] = error2;
          continue;
        }
        let maybePromise = null;
        try {
          maybePromise = castBulkWrite.cast[op.name](Model, op, options, now);
        } catch (error2) {
          validationErrors.push({ index: i, error: error2 });
          results[i] = error2;
          continue;
        }
        if (isPromise(maybePromise)) {
          asyncValidations.push(maybePromise.then(() => {
            validOps.push({ ...op, namespace: Model.namespace() });
            validOpIndexes.push(i);
          }, (error2) => {
            validationErrors.push({ index: i, error: error2 });
            results[i] = error2;
          }));
        } else {
          validOps.push({ ...op, namespace: Model.namespace() });
          validOpIndexes.push(i);
        }
      }
      if (asyncValidations.length > 0) {
        await Promise.all(asyncValidations);
      }
      validationErrors = validationErrors.sort((v1, v2) => v1.index - v2.index).map((v) => v.error);
      if (validOps.length === 0) {
        if (options.throwOnValidationError && validationErrors.length) {
          throw new MongooseBulkWriteError(validationErrors, results, res, "bulkWrite");
        }
        return getDefaultBulkwriteResult();
      }
      let error;
      [res, error] = await this.client.bulkWrite(validOps, options).then((res2) => [res2, null]).catch((err) => [null, err]);
      if (error) {
        if (validationErrors.length > 0) {
          error.mongoose = error.mongoose || {};
          error.mongoose.validationErrors = validationErrors;
        }
      }
      for (let i = 0;i < validOpIndexes.length; ++i) {
        results[validOpIndexes[i]] = null;
      }
      if (validationErrors.length > 0) {
        if (options.throwOnValidationError) {
          throw new MongooseBulkWriteError(validationErrors, results, res, "bulkWrite");
        } else {
          res.mongoose = res.mongoose || {};
          res.mongoose.validationErrors = validationErrors;
          res.mongoose.results = results;
        }
      }
    }
    return res;
  };
  Connection.prototype.createCollections = async function createCollections(options = {}) {
    const result = {};
    const errorsMap = {};
    const { continueOnError } = options;
    delete options.continueOnError;
    for (const model of Object.values(this.models)) {
      try {
        result[model.modelName] = await model.createCollection({});
      } catch (err) {
        if (!continueOnError) {
          errorsMap[model.modelName] = err;
          break;
        } else {
          result[model.modelName] = err;
        }
      }
    }
    if (!continueOnError && Object.keys(errorsMap).length) {
      const message = Object.entries(errorsMap).map(([modelName, err]) => `${modelName}: ${err.message}`).join(", ");
      const createCollectionsError = new CreateCollectionsError(message, errorsMap);
      throw createCollectionsError;
    }
    return result;
  };
  Connection.prototype.withSession = async function withSession(executor) {
    if (arguments.length === 0) {
      throw new Error("Please provide an executor function");
    }
    return await this.client.withSession(executor);
  };
  Connection.prototype.startSession = async function startSession(options) {
    if (arguments.length >= 2 && typeof arguments[1] === "function") {
      throw new MongooseError("Connection.prototype.startSession() no longer accepts a callback");
    }
    await this._waitForConnect();
    const session = this.client.startSession(options);
    return session;
  };
  Connection.prototype.transaction = function transaction(fn, options) {
    return this.startSession().then((session) => {
      session[sessionNewDocuments] = new Map;
      return session.withTransaction(() => _wrapUserTransaction(fn, session, this.base), options).then((res) => {
        delete session[sessionNewDocuments];
        return res;
      }).catch((err) => {
        delete session[sessionNewDocuments];
        throw err;
      }).finally(() => {
        session.endSession().catch(() => {
        });
      });
    });
  };
  /*!
   * Reset document state in between transaction retries re: gh-13698
   */
  /*!
   * If transaction was aborted, we need to reset newly inserted documents' `isNew`.
   */
  Connection.prototype.dropCollection = async function dropCollection(collection) {
    if (arguments.length >= 2 && typeof arguments[1] === "function") {
      throw new MongooseError("Connection.prototype.dropCollection() no longer accepts a callback");
    }
    await this._waitForConnect();
    return this.db.dropCollection(collection);
  };
  Connection.prototype._waitForConnect = async function _waitForConnect(noTimeout) {
    if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {
      const bufferTimeoutMS = this._getBufferTimeoutMS();
      let timeout = null;
      let timedOut = false;
      const queueElement = {};
      const waitForConnectPromise = new Promise((resolve) => {
        queueElement.fn = resolve;
        this._queue.push(queueElement);
      });
      if (noTimeout) {
        await waitForConnectPromise;
      } else {
        await Promise.race([
          waitForConnectPromise,
          new Promise((resolve) => {
            timeout = setTimeout(() => {
              timedOut = true;
              resolve();
            }, bufferTimeoutMS);
          })
        ]);
      }
      if (timedOut) {
        const index = this._queue.indexOf(queueElement);
        if (index !== -1) {
          this._queue.splice(index, 1);
        }
        const message = "Connection operation buffering timed out after " + bufferTimeoutMS + "ms";
        throw new MongooseError(message);
      } else if (timeout != null) {
        clearTimeout(timeout);
      }
    }
  };
  /*!
   * Get the default buffer timeout for this connection
   */
  Connection.prototype._getBufferTimeoutMS = function _getBufferTimeoutMS() {
    if (this.config.bufferTimeoutMS != null) {
      return this.config.bufferTimeoutMS;
    }
    if (this.base != null && this.base.get("bufferTimeoutMS") != null) {
      return this.base.get("bufferTimeoutMS");
    }
    return 1e4;
  };
  Connection.prototype.listCollections = async function listCollections() {
    await this._waitForConnect();
    const cursor = this.db.listCollections();
    return await cursor.toArray();
  };
  Connection.prototype.listDatabases = async function listDatabases() {
    throw new MongooseError("listDatabases() not implemented by driver");
  };
  Connection.prototype.dropDatabase = async function dropDatabase() {
    if (arguments.length >= 1 && typeof arguments[0] === "function") {
      throw new MongooseError("Connection.prototype.dropDatabase() no longer accepts a callback");
    }
    await this._waitForConnect();
    for (const model of Object.values(this.models)) {
      delete model.$init;
    }
    return this.db.dropDatabase();
  };
  /*!
   * ignore
   */
  Connection.prototype._shouldBufferCommands = function _shouldBufferCommands() {
    if (this.config.bufferCommands != null) {
      return this.config.bufferCommands;
    }
    if (this.base.get("bufferCommands") != null) {
      return this.base.get("bufferCommands");
    }
    return true;
  };
  Connection.prototype.error = function error(err, callback) {
    if (callback) {
      callback(err);
      return null;
    }
    if (this.listeners("error").length > 0) {
      this.emit("error", err);
    }
    return Promise.reject(err);
  };
  Connection.prototype.onOpen = function() {
    this.readyState = STATES.connected;
    for (const d of this._queue) {
      d.fn.apply(d.ctx, d.args);
    }
    this._queue = [];
    for (const i in this.collections) {
      if (utils.object.hasOwnProperty(this.collections, i)) {
        this.collections[i].onOpen();
      }
    }
    this.emit("open");
  };
  Connection.prototype.openUri = async function openUri(uri, options) {
    if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {
      if (this._connectionString === uri) {
        return this;
      }
    }
    this._closeCalled = false;
    let _fireAndForget = false;
    if (options && "_fireAndForget" in options) {
      _fireAndForget = options._fireAndForget;
      delete options._fireAndForget;
    }
    try {
      _validateArgs.apply(arguments);
    } catch (err) {
      if (_fireAndForget) {
        throw err;
      }
      this.$initialConnection = Promise.reject(err);
      throw err;
    }
    this.$initialConnection = this.createClient(uri, options).then(() => this).catch((err) => {
      this.readyState = STATES.disconnected;
      if (this.listeners("error").length > 0) {
        immediate(() => this.emit("error", err));
      }
      throw err;
    });
    for (const model of Object.values(this.models)) {
      model.init().catch(function $modelInitNoop() {
      });
    }
    if (_fireAndForget) {
      return this;
    }
    try {
      await this.$initialConnection;
    } catch (err) {
      throw _handleConnectionErrors(err);
    }
    return this;
  };
  Connection.prototype.on = function on(event, callback) {
    if (event === "error" && this.$initialConnection) {
      this.$initialConnection.catch(() => {
      });
    }
    return EventEmitter.prototype.on.call(this, event, callback);
  };
  Connection.prototype.once = function on(event, callback) {
    if (event === "error" && this.$initialConnection) {
      this.$initialConnection.catch(() => {
      });
    }
    return EventEmitter.prototype.once.call(this, event, callback);
  };
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  Connection.prototype.destroy = async function destroy(force) {
    if (typeof force === "function" || arguments.length === 2 && typeof arguments[1] === "function") {
      throw new MongooseError("Connection.prototype.destroy() no longer accepts a callback");
    }
    if (force != null && typeof force === "object") {
      this.$wasForceClosed = !!force.force;
    } else {
      this.$wasForceClosed = !!force;
    }
    return this._close(force, true);
  };
  Connection.prototype.close = async function close(force) {
    if (typeof force === "function" || arguments.length === 2 && typeof arguments[1] === "function") {
      throw new MongooseError("Connection.prototype.close() no longer accepts a callback");
    }
    if (force != null && typeof force === "object") {
      this.$wasForceClosed = !!force.force;
    } else {
      this.$wasForceClosed = !!force;
    }
    if (this._lastHeartbeatAt != null) {
      this._lastHeartbeatAt = null;
    }
    for (const model of Object.values(this.models)) {
      delete model.$init;
    }
    return this._close(force, false);
  };
  Connection.prototype._close = async function _close(force, destroy) {
    const _this = this;
    const closeCalled = this._closeCalled;
    this._closeCalled = true;
    this._destroyCalled = destroy;
    if (this.client != null) {
      this.client._closeCalled = true;
      this.client._destroyCalled = destroy;
    }
    const conn = this;
    switch (this.readyState) {
      case STATES.disconnected:
        if (destroy && this.base.connections.indexOf(conn) !== -1) {
          this.base.connections.splice(this.base.connections.indexOf(conn), 1);
        }
        if (!closeCalled) {
          await this.doClose(force);
          this.onClose(force);
        }
        break;
      case STATES.connected:
        this.readyState = STATES.disconnecting;
        await this.doClose(force);
        if (destroy && _this.base.connections.indexOf(conn) !== -1) {
          this.base.connections.splice(this.base.connections.indexOf(conn), 1);
        }
        this.onClose(force);
        break;
      case STATES.connecting:
        return new Promise((resolve, reject) => {
          const _rerunClose = () => {
            this.removeListener("open", _rerunClose);
            this.removeListener("error", _rerunClose);
            if (destroy) {
              this.destroy(force).then(resolve, reject);
            } else {
              this.close(force).then(resolve, reject);
            }
          };
          this.once("open", _rerunClose);
          this.once("error", _rerunClose);
        });
      case STATES.disconnecting:
        return new Promise((resolve) => {
          this.once("close", () => {
            if (destroy && this.base.connections.indexOf(conn) !== -1) {
              this.base.connections.splice(this.base.connections.indexOf(conn), 1);
            }
            resolve();
          });
        });
    }
    return this;
  };
  Connection.prototype.doClose = function doClose() {
    throw new Error("Connection#doClose unimplemented by driver");
  };
  Connection.prototype.onClose = function onClose(force) {
    this.readyState = STATES.disconnected;
    for (const i in this.collections) {
      if (utils.object.hasOwnProperty(this.collections, i)) {
        this.collections[i].onClose(force);
      }
    }
    this.emit("close", force);
    for (const db of this.otherDbs) {
      this._destroyCalled ? db.destroy({ force, skipCloseClient: true }) : db.close({ force, skipCloseClient: true });
    }
  };
  Connection.prototype.collection = function(name, options) {
    const defaultOptions = {
      autoIndex: this.config.autoIndex != null ? this.config.autoIndex : this.base.options.autoIndex,
      autoCreate: this.config.autoCreate != null ? this.config.autoCreate : this.base.options.autoCreate,
      autoSearchIndex: this.config.autoSearchIndex != null ? this.config.autoSearchIndex : this.base.options.autoSearchIndex
    };
    options = Object.assign({}, defaultOptions, options ? clone(options) : {});
    options.$wasForceClosed = this.$wasForceClosed;
    const Collection = this.base && this.base.__driver && this.base.__driver.Collection || driver.get().Collection;
    if (!(name in this.collections)) {
      this.collections[name] = new Collection(name, this, options);
    }
    return this.collections[name];
  };
  Connection.prototype.plugin = function(fn, opts) {
    this.plugins.push([fn, opts]);
    return this;
  };
  Connection.prototype.model = function model(name, schema, collection, options) {
    if (!(this instanceof Connection)) {
      throw new MongooseError("`connection.model()` should not be run with " + "`new`. If you are doing `new db.model(foo)(bar)`, use " + "`db.model(foo)(bar)` instead");
    }
    let fn;
    if (typeof name === "function") {
      fn = name;
      name = fn.name;
    }
    if (typeof schema === "string") {
      collection = schema;
      schema = false;
    }
    if (utils.isObject(schema)) {
      if (!schema.instanceOfSchema) {
        schema = new Schema(schema);
      } else if (!(schema instanceof this.base.Schema)) {
        schema = schema._clone(this.base.Schema);
      }
    }
    if (schema && !schema.instanceOfSchema) {
      throw new Error("The 2nd parameter to `mongoose.model()` should be a " + "schema or a POJO");
    }
    const defaultOptions = { cache: false, overwriteModels: this.base.options.overwriteModels };
    const opts = Object.assign(defaultOptions, options, { connection: this });
    if (this.models[name] && !collection && opts.overwriteModels !== true) {
      if (schema && schema.instanceOfSchema && schema !== this.models[name].schema) {
        throw new MongooseError.OverwriteModelError(name);
      }
      return this.models[name];
    }
    let model;
    if (schema && schema.instanceOfSchema) {
      applyPlugins(schema, this.plugins, null, "$connectionPluginsApplied");
      model = this.base._model(fn || name, schema, collection, opts);
      if (!this.models[name]) {
        this.models[name] = model;
      }
      model.init().catch(function $modelInitNoop() {
      });
      return model;
    }
    if (this.models[name] && collection) {
      model = this.models[name];
      schema = model.prototype.schema;
      const sub = model.__subclass(this, schema, collection);
      return sub;
    }
    if (arguments.length === 1) {
      model = this.models[name];
      if (!model) {
        throw new MongooseError.MissingSchemaError(name);
      }
      return model;
    }
    if (!model) {
      throw new MongooseError.MissingSchemaError(name);
    }
    if (this === model.prototype.db && (!collection || collection === model.collection.name)) {
      if (!this.models[name]) {
        this.models[name] = model;
      }
      return model;
    }
    this.models[name] = model.__subclass(this, schema, collection);
    return this.models[name];
  };
  Connection.prototype.deleteModel = function deleteModel(name) {
    if (typeof name === "string") {
      const model = this.model(name);
      if (model == null) {
        return this;
      }
      const collectionName = model.collection.name;
      delete this.models[name];
      delete this.collections[collectionName];
      this.emit("deleteModel", model);
    } else if (name instanceof RegExp) {
      const pattern = name;
      const names = this.modelNames();
      for (const name2 of names) {
        if (pattern.test(name2)) {
          this.deleteModel(name2);
        }
      }
    } else {
      throw new Error("First parameter to `deleteModel()` must be a string " + 'or regexp, got "' + name + '"');
    }
    return this;
  };
  Connection.prototype.watch = function watch(pipeline, options) {
    const changeStreamThunk = (cb) => {
      immediate(() => {
        if (this.readyState === STATES.connecting) {
          this.once("open", function() {
            const driverChangeStream = this.db.watch(pipeline, options);
            cb(null, driverChangeStream);
          });
        } else {
          const driverChangeStream = this.db.watch(pipeline, options);
          cb(null, driverChangeStream);
        }
      });
    };
    const changeStream = new ChangeStream(changeStreamThunk, pipeline, options);
    return changeStream;
  };
  Connection.prototype.asPromise = async function asPromise() {
    try {
      await this.$initialConnection;
      return this;
    } catch (err) {
      throw _handleConnectionErrors(err);
    }
  };
  Connection.prototype.modelNames = function modelNames() {
    return Object.keys(this.models);
  };
  Connection.prototype.shouldAuthenticate = function shouldAuthenticate() {
    return this.user != null && (this.pass != null || this.authMechanismDoesNotRequirePassword());
  };
  Connection.prototype.authMechanismDoesNotRequirePassword = function authMechanismDoesNotRequirePassword() {
    if (this.options && this.options.auth) {
      return noPasswordAuthMechanisms.indexOf(this.options.auth.authMechanism) >= 0;
    }
    return true;
  };
  Connection.prototype.optionsProvideAuthenticationData = function optionsProvideAuthenticationData(options) {
    return options && options.user && (options.pass || this.authMechanismDoesNotRequirePassword());
  };
  Connection.prototype.getClient = function getClient() {
    return this.client;
  };
  Connection.prototype.setClient = function setClient() {
    throw new MongooseError("Connection#setClient not implemented by driver");
  };
  /*!
   * Called internally by `openUri()` to create a MongoClient instance.
   */
  Connection.prototype.createClient = function createClient() {
    throw new MongooseError("Connection#createClient not implemented by driver");
  };
  Connection.prototype.syncIndexes = async function syncIndexes(options = {}) {
    const result = {};
    const errorsMap = {};
    const { continueOnError } = options;
    delete options.continueOnError;
    for (const model of Object.values(this.models)) {
      try {
        result[model.modelName] = await model.syncIndexes(options);
      } catch (err) {
        if (!continueOnError) {
          errorsMap[model.modelName] = err;
          break;
        } else {
          result[model.modelName] = err;
        }
      }
    }
    if (!continueOnError && Object.keys(errorsMap).length) {
      const message = Object.entries(errorsMap).map(([modelName, err]) => `${modelName}: ${err.message}`).join(", ");
      const syncIndexesError = new SyncIndexesError(message, errorsMap);
      throw syncIndexesError;
    }
    return result;
  };
  /*!
   * Module exports.
   */
  Connection.STATES = STATES;
  module.exports = Connection;
});

// node_modules/mongoose/package.json
var require_package3 = __commonJS((exports, module) => {
  module.exports = {
    name: "mongoose",
    description: "Mongoose MongoDB ODM",
    version: "8.10.1",
    author: "Guillermo Rauch <guillermo@learnboost.com>",
    keywords: [
      "mongodb",
      "document",
      "model",
      "schema",
      "database",
      "odm",
      "data",
      "datastore",
      "query",
      "nosql",
      "orm",
      "db"
    ],
    type: "commonjs",
    license: "MIT",
    dependencies: {
      bson: "^6.10.1",
      kareem: "2.6.3",
      mongodb: "~6.13.0",
      mpath: "0.9.0",
      mquery: "5.0.0",
      ms: "2.1.3",
      sift: "17.1.3"
    },
    devDependencies: {
      "@babel/core": "7.26.7",
      "@babel/preset-env": "7.26.7",
      "@typescript-eslint/eslint-plugin": "^8.19.1",
      "@typescript-eslint/parser": "^8.19.1",
      acquit: "1.3.0",
      "acquit-ignore": "0.2.1",
      "acquit-require": "0.1.1",
      ajv: "8.17.1",
      "assert-browserify": "2.0.0",
      "babel-loader": "8.2.5",
      "broken-link-checker": "^0.7.8",
      buffer: "^5.6.0",
      cheerio: "1.0.0",
      "crypto-browserify": "3.12.1",
      dox: "1.0.0",
      eslint: "8.57.1",
      "eslint-plugin-markdown": "^5.1.0",
      "eslint-plugin-mocha-no-only": "1.2.0",
      express: "^4.19.2",
      "fs-extra": "~11.3.0",
      "highlight.js": "11.11.1",
      "lodash.isequal": "4.5.0",
      "lodash.isequalwith": "4.4.0",
      "markdownlint-cli2": "^0.17.1",
      marked: "15.0.6",
      mkdirp: "^3.0.1",
      mocha: "11.1.0",
      moment: "2.30.1",
      "mongodb-memory-server": "10.1.3",
      ncp: "^2.0.0",
      nyc: "15.1.0",
      pug: "3.0.3",
      q: "1.5.1",
      sinon: "19.0.2",
      "stream-browserify": "3.0.0",
      tsd: "0.31.2",
      typescript: "5.7.3",
      uuid: "11.0.5",
      webpack: "5.97.1"
    },
    directories: {
      lib: "./lib/mongoose"
    },
    scripts: {
      "docs:clean": "npm run docs:clean:stable",
      "docs:clean:stable": "rimraf index.html && rimraf -rf ./docs/*.html  && rimraf -rf ./docs/api && rimraf -rf ./docs/tutorials/*.html && rimraf -rf ./docs/typescript/*.html && rimraf -rf ./docs/*.html && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp",
      "docs:clean:5x": "rimraf index.html && rimraf -rf ./docs/5.x && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp",
      "docs:clean:6x": "rimraf index.html && rimraf -rf ./docs/6.x && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp",
      "docs:copy:tmp": "mkdirp ./tmp/docs/css && mkdirp ./tmp/docs/js && mkdirp ./tmp/docs/images && mkdirp ./tmp/docs/tutorials && mkdirp ./tmp/docs/typescript && mkdirp ./tmp/docs/api && ncp ./docs/css ./tmp/docs/css --filter=.css$ && ncp ./docs/js ./tmp/docs/js --filter=.js$ && ncp ./docs/images ./tmp/docs/images && ncp ./docs/tutorials ./tmp/docs/tutorials && ncp ./docs/typescript ./tmp/docs/typescript && ncp ./docs/api ./tmp/docs/api && cp index.html ./tmp && cp docs/*.html ./tmp/docs/",
      "docs:copy:tmp:5x": "rimraf ./docs/5.x && ncp ./tmp ./docs/5.x",
      "docs:copy:tmp:6x": "rimraf ./docs/6.x && ncp ./tmp ./docs/6.x",
      "docs:generate": "node ./scripts/website.js",
      "docs:generate:sponsorData": "node ./scripts/loadSponsorData.js",
      "docs:test": "npm run docs:generate",
      "docs:view": "node ./scripts/static.js",
      "docs:prepare:publish:stable": "git checkout gh-pages && git merge master && npm run docs:generate",
      "docs:prepare:publish:5x": "git checkout 5.x && git merge 5.x && npm run docs:clean:stable && npm run docs:generate && npm run docs:copy:tmp && git checkout gh-pages && npm run docs:copy:tmp:5x",
      "docs:prepare:publish:6x": "git checkout 6.x && git merge 6.x && npm run docs:clean:stable && env DOCS_DEPLOY=true npm run docs:generate && mv ./docs/6.x ./tmp && git checkout gh-pages && npm run docs:copy:tmp:6x",
      "docs:prepare:publish:7x": "env DOCS_DEPLOY=true npm run docs:generate && git checkout gh-pages && rimraf ./docs/7.x && mv ./tmp ./docs/7.x",
      "docs:check-links": "blc http://127.0.0.1:8089 -ro",
      lint: "eslint .",
      "lint-js": "eslint . --ext .js --ext .cjs",
      "lint-ts": "eslint . --ext .ts",
      "lint-md": "markdownlint-cli2 \"**/*.md\" \"#node_modules\" \"#benchmarks\"",
      "build-browser": "(rm ./dist/* || true) && node ./scripts/build-browser.js",
      prepublishOnly: "npm run build-browser",
      release: "git pull && git push origin master --tags && npm publish",
      "release-5x": "git pull origin 5.x && git push origin 5.x && git push origin 5.x --tags && npm publish --tag 5x",
      "release-6x": "git pull origin 6.x && git push origin 6.x && git push origin 6.x --tags && npm publish --tag 6x",
      mongo: "node ./tools/repl.js",
      "publish-7x": "npm publish --tag 7x",
      test: "mocha --exit ./test/*.test.js",
      "test-deno": "deno run --allow-env --allow-read --allow-net --allow-run --allow-sys --allow-write ./test/deno.js",
      "test-rs": "START_REPLICA_SET=1 mocha --timeout 30000 --exit ./test/*.test.js",
      "test-tsd": "node ./test/types/check-types-filename && tsd",
      "setup-test-encryption": "bash scripts/configure-cluster-with-encryption.sh",
      "test-encryption": "mocha --exit ./test/encryption/*.test.js",
      tdd: "mocha ./test/*.test.js --inspect --watch --recursive --watch-files ./**/*.{js,ts}",
      "test-coverage": "nyc --reporter=html --reporter=text npm test",
      "ts-benchmark": "cd ./benchmarks/typescript/simple && npm install && npm run benchmark | node ../../../scripts/tsc-diagnostics-check"
    },
    main: "./index.js",
    types: "./types/index.d.ts",
    engines: {
      node: ">=16.20.1"
    },
    bugs: {
      url: "https://github.com/Automattic/mongoose/issues/new"
    },
    repository: {
      type: "git",
      url: "git://github.com/Automattic/mongoose.git"
    },
    homepage: "https://mongoosejs.com",
    browser: "./dist/browser.umd.js",
    config: {
      mongodbMemoryServer: {
        disablePostinstall: true
      }
    },
    funding: {
      type: "opencollective",
      url: "https://opencollective.com/mongoose"
    },
    tsd: {
      directory: "test/types",
      compilerOptions: {
        esModuleInterop: false,
        strict: true,
        allowSyntheticDefaultImports: true,
        strictPropertyInitialization: false,
        noImplicitAny: false,
        strictNullChecks: true,
        module: "commonjs",
        target: "ES2017"
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/processConnectionOptions.js
var require_processConnectionOptions = __commonJS((exports, module) => {
  function processConnectionOptions(uri, options) {
    const opts = options ? options : {};
    const readPreference = opts.readPreference ? opts.readPreference : getUriReadPreference(uri);
    const clonedOpts = clone(opts);
    const resolvedOpts = readPreference && readPreference !== "primary" && readPreference !== "primaryPreferred" ? resolveOptsConflicts(readPreference, clonedOpts) : clonedOpts;
    return resolvedOpts;
  }
  function resolveOptsConflicts(pref, opts) {
    if (setsIndexOptions(opts) && setsSecondaryRead(pref)) {
      throwReadPreferenceError();
    } else {
      return defaultIndexOptsToFalse(opts);
    }
  }
  function setsIndexOptions(opts) {
    const configIdx = opts.config && opts.config.autoIndex;
    const { autoCreate, autoIndex } = opts;
    return !!(configIdx || autoCreate || autoIndex);
  }
  function setsSecondaryRead(prefString) {
    return !!(prefString === "secondary" || prefString === "secondaryPreferred");
  }
  function getUriReadPreference(connectionString) {
    const exp = /(?:&|\?)readPreference=(\w+)(?:&|$)/;
    const match = exp.exec(connectionString);
    return match ? match[1] : null;
  }
  function defaultIndexOptsToFalse(opts) {
    opts.config = { autoIndex: false };
    opts.autoCreate = false;
    opts.autoIndex = false;
    return opts;
  }
  function throwReadPreferenceError() {
    throw new MongooseError("MongoDB prohibits index creation on connections that read from " + 'non-primary replicas.  Connections that set "readPreference" to "secondary" or ' + '"secondaryPreferred" may not opt-in to the following connection options: ' + "autoCreate, autoIndex");
  }
  var clone = require_clone2();
  var MongooseError = require_error2();
  module.exports = processConnectionOptions;
});

// node_modules/mongoose/lib/helpers/timers.js
var require_timers = __commonJS((exports) => {
  exports.setTimeout = setTimeout;
});

// node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js
var require_connection3 = __commonJS((exports, module) => {
  function NativeConnection() {
    MongooseConnection.apply(this, arguments);
    this._listening = false;
    this._lastHeartbeatAt = null;
  }
  function _setClient(conn, client, options, dbName) {
    const db = dbName != null ? client.db(dbName) : client.db();
    conn.db = db;
    conn.client = client;
    conn.host = client && client.s && client.s.options && client.s.options.hosts && client.s.options.hosts[0] && client.s.options.hosts[0].host || undefined;
    conn.port = client && client.s && client.s.options && client.s.options.hosts && client.s.options.hosts[0] && client.s.options.hosts[0].port || undefined;
    conn.name = dbName != null ? dbName : db.databaseName;
    conn._closeCalled = client._closeCalled;
    const _handleReconnect = () => {
      if (conn.readyState !== STATES.connected) {
        conn.readyState = STATES.connected;
        conn.emit("reconnect");
        conn.emit("reconnected");
        conn.onOpen();
      }
    };
    const type = client && client.topology && client.topology.description && client.topology.description.type || "";
    if (type === "Single") {
      client.on("serverDescriptionChanged", (ev) => {
        const newDescription = ev.newDescription;
        if (newDescription.type === "Unknown") {
          conn.readyState = STATES.disconnected;
        } else {
          _handleReconnect();
        }
      });
    } else if (type.startsWith("ReplicaSet")) {
      client.on("topologyDescriptionChanged", (ev) => {
        const description = ev.newDescription;
        if (conn.readyState === STATES.connected && description.type !== "ReplicaSetWithPrimary") {
          conn.readyState = STATES.disconnected;
        } else if (conn.readyState === STATES.disconnected && description.type === "ReplicaSetWithPrimary") {
          _handleReconnect();
        }
      });
    }
    conn._lastHeartbeatAt = null;
    client.on("serverHeartbeatSucceeded", () => {
      conn._lastHeartbeatAt = Date.now();
    });
    if (options.monitorCommands) {
      client.on("commandStarted", (data) => conn.emit("commandStarted", data));
      client.on("commandFailed", (data) => conn.emit("commandFailed", data));
      client.on("commandSucceeded", (data) => conn.emit("commandSucceeded", data));
    }
    conn.onOpen();
    for (const i in conn.collections) {
      if (utils.object.hasOwnProperty(conn.collections, i)) {
        conn.collections[i].onOpen();
      }
    }
  }
  /*!
   * Module dependencies.
   */
  var MongooseConnection = require_connection2();
  var MongooseError = require_error2();
  var STATES = require_connectionState();
  var mongodb = require_lib3();
  var pkg = require_package3();
  var processConnectionOptions = require_processConnectionOptions();
  var setTimeout2 = require_timers().setTimeout;
  var utils = require_utils4();
  NativeConnection.STATES = STATES;
  /*!
   * Inherits from Connection.
   */
  Object.setPrototypeOf(NativeConnection.prototype, MongooseConnection.prototype);
  NativeConnection.prototype.useDb = function(name, options) {
    options = options || {};
    if (options.useCache && this.relatedDbs[name]) {
      return this.relatedDbs[name];
    }
    const newConn = new this.constructor;
    newConn.name = name;
    newConn.base = this.base;
    newConn.collections = {};
    newConn.models = {};
    newConn.replica = this.replica;
    newConn.config = Object.assign({}, this.config, newConn.config);
    newConn.name = this.name;
    newConn.options = this.options;
    newConn._readyState = this._readyState;
    newConn._closeCalled = this._closeCalled;
    newConn._hasOpened = this._hasOpened;
    newConn._listening = false;
    newConn._parent = this;
    newConn.host = this.host;
    newConn.port = this.port;
    newConn.user = this.user;
    newConn.pass = this.pass;
    const _this = this;
    newConn.client = _this.client;
    if (this.db && this._readyState === STATES.connected) {
      wireup();
    } else {
      this._queue.push({ fn: wireup });
    }
    function wireup() {
      newConn.client = _this.client;
      const _opts = {};
      if (options.hasOwnProperty("noListener")) {
        _opts.noListener = options.noListener;
      }
      newConn.db = _this.client.db(name, _opts);
      newConn._lastHeartbeatAt = _this._lastHeartbeatAt;
      newConn.onOpen();
    }
    newConn.name = name;
    if (options.noListener !== true) {
      this.otherDbs.push(newConn);
    }
    newConn.otherDbs.push(this);
    if (options && options.useCache) {
      this.relatedDbs[newConn.name] = newConn;
      newConn.relatedDbs = this.relatedDbs;
    }
    return newConn;
  };
  NativeConnection.prototype.aggregate = function aggregate(pipeline, options) {
    return new this.base.Aggregate(null, this).append(pipeline).option(options ?? {});
  };
  NativeConnection.prototype.removeDb = function removeDb(name) {
    const dbs = this.otherDbs.filter((db) => db.name === name);
    if (!dbs.length) {
      throw new MongooseError(`No connections to database "${name}" found`);
    }
    for (const db of dbs) {
      db._closeCalled = true;
      db._destroyCalled = true;
      db._readyState = STATES.disconnected;
      db.$wasForceClosed = true;
    }
    delete this.relatedDbs[name];
    this.otherDbs = this.otherDbs.filter((db) => db.name !== name);
  };
  NativeConnection.prototype.doClose = async function doClose(force) {
    if (this.client == null) {
      return this;
    }
    let skipCloseClient = false;
    if (force != null && typeof force === "object") {
      skipCloseClient = force.skipCloseClient;
      force = force.force;
    }
    if (skipCloseClient) {
      return this;
    }
    await this.client.close(force);
    await new Promise((resolve) => setTimeout2(resolve, 1));
    return this;
  };
  NativeConnection.prototype.listDatabases = async function listDatabases() {
    await this._waitForConnect();
    return await this.db.admin().listDatabases();
  };
  /*!
   * ignore
   */
  NativeConnection.prototype.createClient = async function createClient(uri, options) {
    if (typeof uri !== "string") {
      throw new MongooseError("The `uri` parameter to `openUri()` must be a " + `string, got "${typeof uri}". Make sure the first parameter to ` + "`mongoose.connect()` or `mongoose.createConnection()` is a string.");
    }
    if (this._destroyCalled) {
      throw new MongooseError("Connection has been closed and destroyed, and cannot be used for re-opening the connection. " + "Please create a new connection with `mongoose.createConnection()` or `mongoose.connect()`.");
    }
    if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {
      if (this._connectionString !== uri) {
        throw new MongooseError("Can\'t call `openUri()` on an active connection with " + "different connection strings. Make sure you aren\'t calling `mongoose.connect()` " + "multiple times. See: https://mongoosejs.com/docs/connections.html#multiple_connections");
      }
    }
    options = processConnectionOptions(uri, options);
    if (options) {
      const autoIndex = options.config && options.config.autoIndex != null ? options.config.autoIndex : options.autoIndex;
      if (autoIndex != null) {
        this.config.autoIndex = autoIndex !== false;
        delete options.config;
        delete options.autoIndex;
      }
      if ("autoCreate" in options) {
        this.config.autoCreate = !!options.autoCreate;
        delete options.autoCreate;
      }
      if ("sanitizeFilter" in options) {
        this.config.sanitizeFilter = options.sanitizeFilter;
        delete options.sanitizeFilter;
      }
      if ("autoSearchIndex" in options) {
        this.config.autoSearchIndex = options.autoSearchIndex;
        delete options.autoSearchIndex;
      }
      if ("bufferTimeoutMS" in options) {
        this.config.bufferTimeoutMS = options.bufferTimeoutMS;
        delete options.bufferTimeoutMS;
      }
      if (options.user || options.pass) {
        options.auth = options.auth || {};
        options.auth.username = options.user;
        options.auth.password = options.pass;
        this.user = options.user;
        this.pass = options.pass;
      }
      delete options.user;
      delete options.pass;
      if (options.bufferCommands != null) {
        this.config.bufferCommands = options.bufferCommands;
        delete options.bufferCommands;
      }
    } else {
      options = {};
    }
    this._connectionOptions = options;
    const dbName = options.dbName;
    if (dbName != null) {
      this.$dbName = dbName;
    }
    delete options.dbName;
    if (!utils.hasUserDefinedProperty(options, "driverInfo")) {
      options.driverInfo = {
        name: "Mongoose",
        version: pkg.version
      };
    }
    this.readyState = STATES.connecting;
    this._connectionString = uri;
    let client;
    try {
      client = new mongodb.MongoClient(uri, options);
    } catch (error) {
      this.readyState = STATES.disconnected;
      throw error;
    }
    this.client = client;
    client.setMaxListeners(0);
    await client.connect();
    _setClient(this, client, options, dbName);
    for (const db of this.otherDbs) {
      _setClient(db, client, {}, db.name);
    }
    return this;
  };
  /*!
   * ignore
   */
  NativeConnection.prototype.setClient = function setClient(client) {
    if (!(client instanceof mongodb.MongoClient)) {
      throw new MongooseError("Must call `setClient()` with an instance of MongoClient");
    }
    if (this.readyState !== STATES.disconnected) {
      throw new MongooseError("Cannot call `setClient()` on a connection that is already connected.");
    }
    if (client.topology == null) {
      throw new MongooseError("Cannot call `setClient()` with a MongoClient that you have not called `connect()` on yet.");
    }
    this._connectionString = client.s.url;
    _setClient(this, client, {}, client.s.options.dbName);
    for (const model of Object.values(this.models)) {
      model.init().catch(function $modelInitNoop() {
      });
    }
    return this;
  };
  /*!
   * ignore
   */
  /*!
   * Module exports.
   */
  module.exports = NativeConnection;
});

// node_modules/mongoose/lib/drivers/node-mongodb-native/index.js
var require_node_mongodb_native = __commonJS((exports) => {
  /*!
   * Module exports.
   */
  exports.Collection = require_collection3();
  exports.Connection = require_connection3();
});

// node_modules/mongoose/lib/validOptions.js
var require_validOptions = __commonJS((exports, module) => {
  /*!
   * Valid mongoose options
   */
  var VALID_OPTIONS = Object.freeze([
    "allowDiskUse",
    "applyPluginsToChildSchemas",
    "applyPluginsToDiscriminators",
    "autoCreate",
    "autoIndex",
    "autoSearchIndex",
    "bufferCommands",
    "bufferTimeoutMS",
    "cloneSchemas",
    "createInitialConnection",
    "debug",
    "forceRepopulate",
    "id",
    "timestamps.createdAt.immutable",
    "maxTimeMS",
    "objectIdGetter",
    "overwriteModels",
    "returnOriginal",
    "runValidators",
    "sanitizeFilter",
    "sanitizeProjection",
    "selectPopulatedPaths",
    "setDefaultsOnInsert",
    "strict",
    "strictPopulate",
    "strictQuery",
    "toJSON",
    "toObject",
    "transactionAsyncLocalStorage",
    "translateAliases"
  ]);
  module.exports = VALID_OPTIONS;
});

// node_modules/mongoose/lib/error/eachAsyncMultiError.js
var require_eachAsyncMultiError = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class EachAsyncMultiError extends MongooseError {
    constructor(errors) {
      let preview = errors.map((e) => e.message).join(", ");
      if (preview.length > 50) {
        preview = preview.slice(0, 50) + "...";
      }
      super(`eachAsync() finished with ${errors.length} errors: ${preview}`);
      this.errors = errors;
    }
  }
  Object.defineProperty(EachAsyncMultiError.prototype, "name", {
    value: "EachAsyncMultiError"
  });
  /*!
   * exports
   */
  module.exports = EachAsyncMultiError;
});

// node_modules/mongoose/lib/helpers/cursor/eachAsync.js
var require_eachAsync = __commonJS((exports, module) => {
  function asyncQueue() {
    const _queue = [];
    let inProgress = null;
    let id = 0;
    return function enqueue(fn) {
      if (inProgress === null && _queue.length === 0) {
        inProgress = id++;
        return fn(_step);
      }
      _queue.push(fn);
    };
    function _step() {
      if (_queue.length !== 0) {
        inProgress = id++;
        const fn = _queue.shift();
        fn(_step);
      } else {
        inProgress = null;
      }
    }
  }
  function createEachAsyncMultiError(aggregatedErrors) {
    if (aggregatedErrors.length === 0) {
      return null;
    }
    return new EachAsyncMultiError(aggregatedErrors);
  }
  /*!
   * Module dependencies.
   */
  var EachAsyncMultiError = require_eachAsyncMultiError();
  var immediate = require_immediate();
  module.exports = async function eachAsync(next, fn, options) {
    const parallel = options.parallel || 1;
    const batchSize = options.batchSize;
    const signal = options.signal;
    const continueOnError = options.continueOnError;
    const aggregatedErrors = [];
    const enqueue = asyncQueue();
    let aborted = false;
    return new Promise((resolve, reject) => {
      if (signal != null) {
        if (signal.aborted) {
          return resolve(null);
        }
        signal.addEventListener("abort", () => {
          aborted = true;
          return resolve(null);
        }, { once: true });
      }
      if (batchSize != null) {
        if (typeof batchSize !== "number") {
          throw new TypeError("batchSize must be a number");
        } else if (!Number.isInteger(batchSize)) {
          throw new TypeError("batchSize must be an integer");
        } else if (batchSize < 1) {
          throw new TypeError("batchSize must be at least 1");
        }
      }
      iterate((err, res) => {
        if (err != null) {
          return reject(err);
        }
        resolve(res);
      });
    });
    function iterate(finalCallback) {
      let handleResultsInProgress = 0;
      let currentDocumentIndex = 0;
      let error = null;
      for (let i = 0;i < parallel; ++i) {
        enqueue(createFetch());
      }
      function createFetch() {
        let documentsBatch = [];
        let drained = false;
        return fetch2;
        function fetch2(done) {
          if (drained || aborted) {
            return done();
          } else if (error) {
            return done();
          }
          next(function(err, doc) {
            if (error != null) {
              return done();
            }
            if (err != null) {
              if (err.name === "MongoCursorExhaustedError") {
                doc = null;
              } else if (continueOnError) {
                aggregatedErrors.push(err);
              } else {
                error = err;
                finalCallback(err);
                return done();
              }
            }
            if (doc == null) {
              drained = true;
              if (handleResultsInProgress <= 0) {
                const finalErr = continueOnError ? createEachAsyncMultiError(aggregatedErrors) : error;
                finalCallback(finalErr);
              } else if (batchSize && documentsBatch.length) {
                handleNextResult(documentsBatch, currentDocumentIndex++, handleNextResultCallBack);
              }
              return done();
            }
            ++handleResultsInProgress;
            immediate(() => done());
            if (batchSize) {
              documentsBatch.push(doc);
            }
            if (batchSize && documentsBatch.length !== batchSize) {
              immediate(() => enqueue(fetch2));
              return;
            }
            const docsToProcess = batchSize ? documentsBatch : doc;
            function handleNextResultCallBack(err2) {
              if (batchSize) {
                handleResultsInProgress -= documentsBatch.length;
                documentsBatch = [];
              } else {
                --handleResultsInProgress;
              }
              if (err2 != null) {
                if (continueOnError) {
                  aggregatedErrors.push(err2);
                } else {
                  error = err2;
                  return finalCallback(err2);
                }
              }
              if ((drained || aborted) && handleResultsInProgress <= 0) {
                const finalErr = continueOnError ? createEachAsyncMultiError(aggregatedErrors) : error;
                return finalCallback(finalErr);
              }
              immediate(() => enqueue(fetch2));
            }
            handleNextResult(docsToProcess, currentDocumentIndex++, handleNextResultCallBack);
          });
        }
      }
    }
    function handleNextResult(doc, i, callback) {
      let maybePromise;
      try {
        maybePromise = fn(doc, i);
      } catch (err) {
        return callback(err);
      }
      if (maybePromise && typeof maybePromise.then === "function") {
        maybePromise.then(function() {
          callback(null);
        }, function(error) {
          callback(error || new Error("`eachAsync()` promise rejected without error"));
        });
      } else {
        callback(null);
      }
    }
  };
});

// node_modules/mongoose/lib/cursor/queryCursor.js
var require_queryCursor = __commonJS((exports, module) => {
  function QueryCursor(query) {
    Readable2.call(this, { autoDestroy: true, objectMode: true });
    this.cursor = null;
    this.skipped = false;
    this.query = query;
    this._closed = false;
    const model = query.model;
    this._mongooseOptions = {};
    this._transforms = [];
    this.model = model;
    this.options = {};
    model.hooks.execPre("find", query, (err) => {
      if (err != null) {
        if (err instanceof kareem.skipWrappedFunction) {
          const resultValue = err.args[0];
          if (resultValue != null && (!Array.isArray(resultValue) || resultValue.length)) {
            const err2 = new MongooseError("Cannot `skipMiddlewareFunction()` with a value when using " + '`.find().cursor()`, value must be nullish or empty array, got "' + util.inspect(resultValue) + '".');
            this._markError(err2);
            this.listeners("error").length > 0 && this.emit("error", err2);
            return;
          }
          this.skipped = true;
          this.emit("cursor", null);
          return;
        }
        this._markError(err);
        this.listeners("error").length > 0 && this.emit("error", err);
        return;
      }
      Object.assign(this.options, query._optionsForExec());
      this._transforms = this._transforms.concat(query._transforms.slice());
      if (this.options.transform) {
        this._transforms.push(this.options.transform);
      }
      if (this.options.batchSize) {
        this.options._populateBatchSize = Math.min(this.options.batchSize, 5000);
      }
      if (model.collection._shouldBufferCommands() && model.collection.buffer) {
        model.collection.queue.push([
          () => _getRawCursor(query, this)
        ]);
      } else {
        _getRawCursor(query, this);
      }
    });
  }
  function _getRawCursor(query, queryCursor) {
    try {
      const cursor = query.model.collection.find(query._conditions, queryCursor.options);
      queryCursor.cursor = cursor;
      queryCursor.emit("cursor", cursor);
    } catch (err) {
      queryCursor._markError(err);
      queryCursor.listeners("error").length > 0 && queryCursor.emit("error", queryCursor._error);
    }
  }
  function _transformForAsyncIterator(doc) {
    return doc == null ? { done: true } : { value: doc, done: false };
  }
  function _next(ctx, cb) {
    let callback = cb;
    if (ctx._transforms.length) {
      callback = function(err, doc) {
        if (err || doc === null && !ctx._mongooseOptions.transformNull) {
          return cb(err, doc);
        }
        cb(err, ctx._transforms.reduce(function(doc2, fn) {
          return fn.call(ctx, doc2);
        }, doc));
      };
    }
    if (ctx._error) {
      return immediate(function() {
        callback(ctx._error);
      });
    }
    if (ctx.skipped) {
      return immediate(() => callback(null, null));
    }
    if (ctx.cursor) {
      if (ctx.query._mongooseOptions.populate && !ctx._pop) {
        ctx._pop = helpers.preparePopulationOptionsMQ(ctx.query, ctx.query._mongooseOptions);
        ctx._pop.__noPromise = true;
      }
      if (ctx.query._mongooseOptions.populate && ctx.options._populateBatchSize > 1) {
        if (ctx._batchDocs && ctx._batchDocs.length) {
          return _nextDoc(ctx, ctx._batchDocs.shift(), ctx._pop, callback);
        } else if (ctx._batchExhausted) {
          return callback(null, null);
        } else {
          ctx._batchDocs = [];
          ctx.cursor.next().then((res) => {
            _onNext.call({ ctx, callback }, null, res);
          }, (err) => {
            _onNext.call({ ctx, callback }, err);
          });
          return;
        }
      } else {
        return ctx.cursor.next().then((doc) => {
          if (!doc) {
            callback(null, null);
            return;
          }
          if (!ctx.query._mongooseOptions.populate) {
            return _nextDoc(ctx, doc, null, callback);
          }
          ctx.query.model.populate(doc, ctx._pop).then((doc2) => {
            _nextDoc(ctx, doc2, ctx._pop, callback);
          }, (err) => {
            callback(err);
          });
        }, (error) => {
          callback(error);
        });
      }
    } else {
      ctx.once("error", cb);
      ctx.once("cursor", function(cursor) {
        ctx.removeListener("error", cb);
        if (cursor == null) {
          if (ctx.skipped) {
            return cb(null, null);
          }
          return;
        }
        _next(ctx, cb);
      });
    }
  }
  function _onNext(error, doc) {
    if (error) {
      return this.callback(error);
    }
    if (!doc) {
      this.ctx._batchExhausted = true;
      return _populateBatch.call(this);
    }
    this.ctx._batchDocs.push(doc);
    if (this.ctx._batchDocs.length < this.ctx.options._populateBatchSize) {
      immediate(() => this.ctx.cursor.next().then((res) => {
        _onNext.call(this, null, res);
      }, (err) => {
        _onNext.call(this, err);
      }));
    } else {
      _populateBatch.call(this);
    }
  }
  function _populateBatch() {
    if (!this.ctx._batchDocs.length) {
      return this.callback(null, null);
    }
    this.ctx.query.model.populate(this.ctx._batchDocs, this.ctx._pop).then(() => {
      _nextDoc(this.ctx, this.ctx._batchDocs.shift(), this.ctx._pop, this.callback);
    }, (err) => {
      this.callback(err);
    });
  }
  function _nextDoc(ctx, doc, pop, callback) {
    if (ctx.query._mongooseOptions.lean) {
      return ctx.model.hooks.execPost("find", ctx.query, [[doc]], (err) => {
        if (err != null) {
          return callback(err);
        }
        callback(null, doc);
      });
    }
    const { model, _fields, _userProvidedFields, options } = ctx.query;
    helpers.createModelAndInit(model, doc, _fields, _userProvidedFields, options, pop, (err, doc2) => {
      if (err != null) {
        return callback(err);
      }
      ctx.model.hooks.execPost("find", ctx.query, [[doc2]], (err2) => {
        if (err2 != null) {
          return callback(err2);
        }
        callback(null, doc2);
      });
    });
  }
  function _waitForCursor(ctx, cb) {
    if (ctx.cursor) {
      return cb();
    }
    ctx.once("cursor", function(cursor) {
      if (cursor == null) {
        return;
      }
      cb();
    });
  }
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();
  var Readable2 = import.meta.require("stream").Readable;
  var eachAsync = require_eachAsync();
  var helpers = require_queryHelpers();
  var kareem = require_kareem();
  var immediate = require_immediate();
  var { once } = import.meta.require("events");
  var util = import.meta.require("util");
  util.inherits(QueryCursor, Readable2);
  /*!
   * ignore
   */
  QueryCursor.prototype._read = function() {
    _next(this, (error, doc) => {
      if (error) {
        return this.emit("error", error);
      }
      if (!doc) {
        this.push(null);
        this.cursor.close(function(error2) {
          if (error2) {
            return this.emit("error", error2);
          }
        });
        return;
      }
      this.push(doc);
    });
  };
  QueryCursor.prototype.getDriverCursor = async function getDriverCursor() {
    if (this.cursor) {
      return this.cursor;
    }
    await once(this, "cursor");
    return this.cursor;
  };
  Object.defineProperty(QueryCursor.prototype, "map", {
    value: function(fn) {
      this._transforms.push(fn);
      return this;
    },
    enumerable: true,
    configurable: true,
    writable: true
  });
  QueryCursor.prototype._markError = function(error) {
    this._error = error;
    return this;
  };
  QueryCursor.prototype.close = async function close() {
    if (typeof arguments[0] === "function") {
      throw new MongooseError("QueryCursor.prototype.close() no longer accepts a callback");
    }
    try {
      await this.cursor.close();
      this._closed = true;
      this.emit("close");
    } catch (error) {
      this.listeners("error").length > 0 && this.emit("error", error);
      throw error;
    }
  };
  QueryCursor.prototype._destroy = function _destroy(_err, callback) {
    let waitForCursor = null;
    if (!this.cursor) {
      waitForCursor = new Promise((resolve) => {
        this.once("cursor", resolve);
      });
    } else {
      waitForCursor = Promise.resolve();
    }
    waitForCursor.then(() => {
      this.cursor.close();
    }).then(() => {
      this._closed = true;
      callback();
    }).catch((error) => {
      callback(error);
    });
    return this;
  };
  QueryCursor.prototype.rewind = function() {
    _waitForCursor(this, () => {
      this.cursor.rewind();
    });
    return this;
  };
  QueryCursor.prototype.next = async function next() {
    if (typeof arguments[0] === "function") {
      throw new MongooseError("QueryCursor.prototype.next() no longer accepts a callback");
    }
    if (this._closed) {
      throw new MongooseError("Cannot call `next()` on a closed cursor");
    }
    return new Promise((resolve, reject) => {
      _next(this, function(error, doc) {
        if (error) {
          return reject(error);
        }
        resolve(doc);
      });
    });
  };
  QueryCursor.prototype.eachAsync = function(fn, opts) {
    if (typeof arguments[2] === "function") {
      throw new MongooseError("QueryCursor.prototype.eachAsync() no longer accepts a callback");
    }
    if (typeof opts === "function") {
      opts = {};
    }
    opts = opts || {};
    return eachAsync((cb) => _next(this, cb), fn, opts);
  };
  QueryCursor.prototype.options;
  QueryCursor.prototype.addCursorFlag = function(flag, value) {
    _waitForCursor(this, () => {
      this.cursor.addCursorFlag(flag, value);
    });
    return this;
  };
  /*!
   * ignore
   */
  QueryCursor.prototype.transformNull = function(val) {
    if (arguments.length === 0) {
      val = true;
    }
    this._mongooseOptions.transformNull = val;
    return this;
  };
  /*!
   * ignore
   */
  QueryCursor.prototype._transformForAsyncIterator = function() {
    if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {
      this.map(_transformForAsyncIterator);
    }
    return this;
  };
  if (Symbol.asyncIterator != null) {
    QueryCursor.prototype[Symbol.asyncIterator] = function() {
      return this.transformNull()._transformForAsyncIterator();
    };
  }
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  module.exports = QueryCursor;
});

// node_modules/mongoose/lib/helpers/query/applyGlobalOption.js
var require_applyGlobalOption = __commonJS((exports, module) => {
  function applyGlobalMaxTimeMS(options, connectionOptions, baseOptions) {
    applyGlobalOption(options, connectionOptions, baseOptions, "maxTimeMS");
  }
  function applyGlobalDiskUse(options, connectionOptions, baseOptions) {
    applyGlobalOption(options, connectionOptions, baseOptions, "allowDiskUse");
  }
  function applyGlobalOption(options, connectionOptions, baseOptions, optionName) {
    if (utils.hasUserDefinedProperty(options, optionName)) {
      return;
    }
    if (utils.hasUserDefinedProperty(connectionOptions, optionName)) {
      options[optionName] = connectionOptions[optionName];
    } else if (utils.hasUserDefinedProperty(baseOptions, optionName)) {
      options[optionName] = baseOptions[optionName];
    }
  }
  var utils = require_utils4();
  module.exports = {
    applyGlobalMaxTimeMS,
    applyGlobalDiskUse
  };
});

// node_modules/mongoose/lib/helpers/schema/applyReadConcern.js
var require_applyReadConcern = __commonJS((exports, module) => {
  module.exports = function applyReadConcern(schema, options) {
    if (options.readConcern !== undefined) {
      return;
    }
    if (options && options.session && options.session.transaction) {
      return;
    }
    const level = schema.options?.readConcern?.level;
    if (level != null) {
      options.readConcern = { level };
    }
  };
});

// node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js
var require_applyWriteConcern = __commonJS((exports, module) => {
  module.exports = function applyWriteConcern(schema, options) {
    if (options.writeConcern != null) {
      return;
    }
    if (options && options.session && options.session.transaction) {
      return;
    }
    const writeConcern = schema.options.writeConcern ?? {};
    if (Object.keys(writeConcern).length != 0) {
      options.writeConcern = {};
      if (!("w" in options) && writeConcern.w != null) {
        options.writeConcern.w = writeConcern.w;
      }
      if (!("j" in options) && writeConcern.j != null) {
        options.writeConcern.j = writeConcern.j;
      }
      if (!("wtimeout" in options) && writeConcern.wtimeout != null) {
        options.writeConcern.wtimeout = writeConcern.wtimeout;
      }
    } else {
      if (!("w" in options) && writeConcern.w != null) {
        options.w = writeConcern.w;
      }
      if (!("j" in options) && writeConcern.j != null) {
        options.j = writeConcern.j;
      }
      if (!("wtimeout" in options) && writeConcern.wtimeout != null) {
        options.wtimeout = writeConcern.wtimeout;
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/query/castFilterPath.js
var require_castFilterPath = __commonJS((exports, module) => {
  var isOperator = require_isOperator();
  module.exports = function castFilterPath(ctx, schematype, val) {
    const any$conditionals = Object.keys(val).some(isOperator);
    if (!any$conditionals) {
      return schematype.castForQuery(null, val, ctx);
    }
    const ks = Object.keys(val);
    let k = ks.length;
    while (k--) {
      const $cond = ks[k];
      const nested = val[$cond];
      if ($cond === "$not") {
        if (nested && schematype && !schematype.caster) {
          const _keys = Object.keys(nested);
          if (_keys.length && isOperator(_keys[0])) {
            for (const key of Object.keys(nested)) {
              nested[key] = schematype.castForQuery(key, nested[key], ctx);
            }
          } else {
            val[$cond] = schematype.castForQuery($cond, nested, ctx);
          }
          continue;
        }
      } else {
        val[$cond] = schematype.castForQuery($cond, nested, ctx);
      }
    }
    return val;
  };
});

// node_modules/mongoose/lib/helpers/schema/getPath.js
var require_getPath = __commonJS((exports, module) => {
  var numberRE = /^\d+$/;
  module.exports = function getPath(schema, path) {
    let schematype = schema.path(path);
    if (schematype != null) {
      return schematype;
    }
    const pieces = path.split(".");
    let cur = "";
    let isArray = false;
    for (const piece of pieces) {
      if (isArray && numberRE.test(piece)) {
        continue;
      }
      cur = cur.length === 0 ? piece : cur + "." + piece;
      schematype = schema.path(cur);
      if (schematype != null && schematype.schema) {
        schema = schematype.schema;
        cur = "";
        if (!isArray && schematype.$isMongooseDocumentArray) {
          isArray = true;
        }
      }
    }
    return schematype;
  };
});

// node_modules/mongoose/lib/helpers/update/castArrayFilters.js
var require_castArrayFilters = __commonJS((exports, module) => {
  function _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query) {
    if (!Array.isArray(arrayFilters)) {
      return;
    }
    for (const filter of arrayFilters) {
      if (filter == null) {
        throw new Error(`Got null array filter in ${arrayFilters}`);
      }
      const keys = Object.keys(filter).filter((key) => filter[key] != null);
      if (keys.length === 0) {
        continue;
      }
      const firstKey = keys[0];
      if (firstKey === "$and" || firstKey === "$or") {
        for (const key of keys) {
          _castArrayFilters(filter[key], schema, strictQuery, updatedPathsByFilter, query);
        }
        continue;
      }
      const dot = firstKey.indexOf(".");
      const filterWildcardPath = dot === -1 ? firstKey : firstKey.substring(0, dot);
      if (updatedPathsByFilter[filterWildcardPath] == null) {
        continue;
      }
      const baseFilterPath = cleanPositionalOperators(updatedPathsByFilter[filterWildcardPath]);
      const baseSchematype = getPath2(schema, baseFilterPath);
      let filterBaseSchema = baseSchematype != null ? baseSchematype.schema : null;
      if (filterBaseSchema != null && filterBaseSchema.discriminators != null && filter[filterWildcardPath + "." + filterBaseSchema.options.discriminatorKey]) {
        filterBaseSchema = filterBaseSchema.discriminators[filter[filterWildcardPath + "." + filterBaseSchema.options.discriminatorKey]] || filterBaseSchema;
      }
      for (const key of keys) {
        if (updatedPathsByFilter[key] === null) {
          continue;
        }
        if (Object.keys(updatedPathsByFilter).length === 0) {
          continue;
        }
        const dot2 = key.indexOf(".");
        let filterPathRelativeToBase = dot2 === -1 ? null : key.substring(dot2);
        let schematype;
        if (filterPathRelativeToBase == null || filterBaseSchema == null) {
          schematype = baseSchematype;
        } else {
          filterPathRelativeToBase = cleanPositionalOperators(filterPathRelativeToBase);
          schematype = getPath2(filterBaseSchema, filterPathRelativeToBase);
        }
        if (schematype == null) {
          if (!strictQuery) {
            return;
          }
          const filterPath = filterPathRelativeToBase == null ? baseFilterPath + ".0" : baseFilterPath + ".0" + filterPathRelativeToBase;
          throw new Error(`Could not find path "${filterPath}" in schema`);
        }
        if (typeof filter[key] === "object") {
          filter[key] = castFilterPath(query, schematype, filter[key]);
        } else {
          filter[key] = schematype.castForQuery(null, filter[key]);
        }
      }
    }
  }
  var castFilterPath = require_castFilterPath();
  var cleanPositionalOperators = require_cleanPositionalOperators();
  var getPath2 = require_getPath();
  var updatedPathsByArrayFilter = require_updatedPathsByArrayFilter();
  module.exports = function castArrayFilters(query) {
    const arrayFilters = query.options.arrayFilters;
    const update = query.getUpdate();
    const schema = query.schema;
    const updatedPathsByFilter = updatedPathsByArrayFilter(update);
    let strictQuery = schema.options.strict;
    if (query._mongooseOptions.strict != null) {
      strictQuery = query._mongooseOptions.strict;
    }
    if (query.model && query.model.base.options.strictQuery != null) {
      strictQuery = query.model.base.options.strictQuery;
    }
    if (schema._userProvidedOptions.strictQuery != null) {
      strictQuery = schema._userProvidedOptions.strictQuery;
    }
    if (query._mongooseOptions.strictQuery != null) {
      strictQuery = query._mongooseOptions.strictQuery;
    }
    _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query);
  };
});

// node_modules/mongoose/lib/helpers/projection/isInclusive.js
var require_isInclusive = __commonJS((exports, module) => {
  var isDefiningProjection = require_isDefiningProjection();
  var isPOJO = require_isPOJO();
  /*!
   * ignore
   */
  module.exports = function isInclusive(projection) {
    if (projection == null) {
      return false;
    }
    const props = Object.keys(projection);
    const numProps = props.length;
    if (numProps === 0) {
      return false;
    }
    for (let i = 0;i < numProps; ++i) {
      const prop = props[i];
      if (prop.startsWith("+")) {
        continue;
      }
      if (isDefiningProjection(projection[prop]) && !!projection[prop]) {
        if (isPOJO(projection[prop])) {
          return isInclusive(projection[prop]);
        } else {
          return !!projection[prop];
        }
      }
    }
    return false;
  };
});

// node_modules/mongoose/lib/helpers/projection/isSubpath.js
var require_isSubpath = __commonJS((exports, module) => {
  module.exports = function isSubpath(path1, path2) {
    return path1 === path2 || path2.startsWith(path1 + ".");
  };
});

// node_modules/mquery/lib/utils.js
var require_utils5 = __commonJS((exports) => {
  function create(proto) {
    if (arguments.length > 1) {
      throw new Error("Adding properties is not supported");
    }
    function F() {
    }
    F.prototype = proto;
    return new F;
  }
  /*!
   * Module dependencies.
   */
  var specialProperties = ["__proto__", "constructor", "prototype"];
  var clone = exports.clone = function clone(obj, options) {
    if (obj === undefined || obj === null)
      return obj;
    if (Array.isArray(obj))
      return exports.cloneArray(obj, options);
    if (obj.constructor) {
      if (/ObjectI[dD]$/.test(obj.constructor.name)) {
        return typeof obj.clone == "function" ? obj.clone() : new obj.constructor(obj.id);
      }
      if (obj.constructor.name === "ReadPreference") {
        return new obj.constructor(obj.mode, clone(obj.tags, options));
      }
      if (obj._bsontype == "Binary" && obj.buffer && obj.value) {
        return typeof obj.clone == "function" ? obj.clone() : new obj.constructor(obj.value(true), obj.sub_type);
      }
      if (obj.constructor.name === "Date" || obj.constructor.name === "Function")
        return new obj.constructor(+obj);
      if (obj.constructor.name === "RegExp")
        return new RegExp(obj);
      if (obj.constructor.name === "Buffer")
        return Buffer.from(obj);
    }
    if (isObject(obj))
      return exports.cloneObject(obj, options);
    if (obj.valueOf)
      return obj.valueOf();
  };
  /*!
   * ignore
   */
  exports.cloneObject = function cloneObject(obj, options) {
    const minimize = options && options.minimize, ret = {}, keys = Object.keys(obj), len = keys.length;
    let hasKeys = false, val, k = "", i = 0;
    for (i = 0;i < len; ++i) {
      k = keys[i];
      if (specialProperties.indexOf(k) !== -1) {
        continue;
      }
      val = clone(obj[k], options);
      if (!minimize || typeof val !== "undefined") {
        hasKeys || (hasKeys = true);
        ret[k] = val;
      }
    }
    return minimize ? hasKeys && ret : ret;
  };
  exports.cloneArray = function cloneArray(arr, options) {
    const ret = [], l = arr.length;
    let i = 0;
    for (;i < l; i++)
      ret.push(clone(arr[i], options));
    return ret;
  };
  exports.merge = function merge(to, from) {
    const keys = Object.keys(from);
    for (const key of keys) {
      if (specialProperties.indexOf(key) !== -1) {
        continue;
      }
      if (typeof to[key] === "undefined") {
        to[key] = from[key];
      } else {
        if (exports.isObject(from[key])) {
          merge(to[key], from[key]);
        } else {
          to[key] = from[key];
        }
      }
    }
  };
  exports.mergeClone = function mergeClone(to, from) {
    const keys = Object.keys(from);
    for (const key of keys) {
      if (specialProperties.indexOf(key) !== -1) {
        continue;
      }
      if (typeof to[key] === "undefined") {
        to[key] = clone(from[key]);
      } else {
        if (exports.isObject(from[key])) {
          mergeClone(to[key], from[key]);
        } else {
          to[key] = clone(from[key]);
        }
      }
    }
  };
  exports.readPref = function readPref(pref) {
    switch (pref) {
      case "p":
        pref = "primary";
        break;
      case "pp":
        pref = "primaryPreferred";
        break;
      case "s":
        pref = "secondary";
        break;
      case "sp":
        pref = "secondaryPreferred";
        break;
      case "n":
        pref = "nearest";
        break;
    }
    return pref;
  };
  exports.readConcern = function readConcern(concern) {
    if (typeof concern === "string") {
      switch (concern) {
        case "l":
          concern = "local";
          break;
        case "a":
          concern = "available";
          break;
        case "m":
          concern = "majority";
          break;
        case "lz":
          concern = "linearizable";
          break;
        case "s":
          concern = "snapshot";
          break;
      }
      concern = { level: concern };
    }
    return concern;
  };
  var _toString = Object.prototype.toString;
  exports.toString = function(arg) {
    return _toString.call(arg);
  };
  var isObject = exports.isObject = function(arg) {
    return exports.toString(arg) == "[object Object]";
  };
  exports.keys = Object.keys;
  exports.create = typeof Object.create == "function" ? Object.create : create;
  exports.inherits = function(ctor, superCtor) {
    ctor.prototype = exports.create(superCtor.prototype);
    ctor.prototype.constructor = ctor;
  };
  exports.isArgumentsObject = function(v) {
    return Object.prototype.toString.call(v) === "[object Arguments]";
  };
});

// node_modules/debug/src/common.js
var require_common4 = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  exports.log = console.debug || console.log || (() => {
  });
  module.exports = require_common4()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }
  var os = import.meta.require("os");
  var tty = import.meta.require("tty");
  var hasFlag = require_has_flag();
  var { env } = process;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    forceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
});

// node_modules/debug/src/node.js
var require_node2 = __commonJS((exports, module) => {
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log2(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + "\n");
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  }
  var tty = import.meta.require("tty");
  var util = import.meta.require("util");
  exports.init = init;
  exports.log = log2;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  module.exports = require_common4()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node2();
  }
});

// node_modules/mquery/lib/permissions.js
var require_permissions = __commonJS((exports) => {
  var denied = exports;
  denied.distinct = function(self2) {
    if (self2._fields && Object.keys(self2._fields).length > 0) {
      return "field selection and slice";
    }
    const keys = Object.keys(denied.distinct);
    let err;
    keys.every(function(option) {
      if (self2.options[option]) {
        err = option;
        return false;
      }
      return true;
    });
    return err;
  };
  denied.distinct.select = denied.distinct.slice = denied.distinct.sort = denied.distinct.limit = denied.distinct.skip = denied.distinct.batchSize = denied.distinct.hint = denied.distinct.tailable = true;
  denied.findOneAndUpdate = denied.findOneAndRemove = function(self2) {
    const keys = Object.keys(denied.findOneAndUpdate);
    let err;
    keys.every(function(option) {
      if (self2.options[option]) {
        err = option;
        return false;
      }
      return true;
    });
    return err;
  };
  denied.findOneAndUpdate.limit = denied.findOneAndUpdate.skip = denied.findOneAndUpdate.batchSize = denied.findOneAndUpdate.tailable = true;
  denied.count = function(self2) {
    if (self2._fields && Object.keys(self2._fields).length > 0) {
      return "field selection and slice";
    }
    const keys = Object.keys(denied.count);
    let err;
    keys.every(function(option) {
      if (self2.options[option]) {
        err = option;
        return false;
      }
      return true;
    });
    return err;
  };
  denied.count.slice = denied.count.batchSize = denied.count.tailable = true;
});

// node_modules/mquery/lib/env.js
var require_env = __commonJS((exports, module) => {
  exports.isNode = typeof process != "undefined" && typeof module == "object" && typeof global == "object" && typeof Buffer == "function" && process.argv;
  exports.isMongo = !exports.isNode && typeof printjson == "function" && typeof ObjectId == "function" && typeof rs == "function" && typeof sh == "function";
  exports.isBrowser = !exports.isNode && !exports.isMongo && typeof window != "undefined";
  exports.type = exports.isNode ? "node" : exports.isMongo ? "mongo" : exports.isBrowser ? "browser" : "unknown";
});

// node_modules/mquery/lib/collection/collection.js
var require_collection4 = __commonJS((exports, module) => {
  function Collection() {
  }
  function notImplemented(method) {
    return function() {
      throw new Error("collection." + method + " not implemented");
    };
  }
  var methods = [
    "find",
    "findOne",
    "updateMany",
    "updateOne",
    "replaceOne",
    "count",
    "distinct",
    "findOneAndDelete",
    "findOneAndUpdate",
    "aggregate",
    "findCursor",
    "deleteOne",
    "deleteMany"
  ];
  for (let i = 0, len = methods.length;i < len; ++i) {
    const method = methods[i];
    Collection.prototype[method] = notImplemented(method);
  }
  module.exports = exports = Collection;
  Collection.methods = methods;
});

// node_modules/mquery/lib/collection/node.js
var require_node3 = __commonJS((exports, module) => {
  var Collection = require_collection4();

  class NodeCollection extends Collection {
    constructor(col) {
      super();
      this.collection = col;
      this.collectionName = col.collectionName;
    }
    async find(match, options) {
      const cursor = this.collection.find(match, options);
      return cursor.toArray();
    }
    async findOne(match, options) {
      return this.collection.findOne(match, options);
    }
    async count(match, options) {
      return this.collection.count(match, options);
    }
    async distinct(prop, match, options) {
      return this.collection.distinct(prop, match, options);
    }
    async updateMany(match, update, options) {
      return this.collection.updateMany(match, update, options);
    }
    async updateOne(match, update, options) {
      return this.collection.updateOne(match, update, options);
    }
    async replaceOne(match, update, options) {
      return this.collection.replaceOne(match, update, options);
    }
    async deleteOne(match, options) {
      return this.collection.deleteOne(match, options);
    }
    async deleteMany(match, options) {
      return this.collection.deleteMany(match, options);
    }
    async findOneAndDelete(match, options) {
      return this.collection.findOneAndDelete(match, options);
    }
    async findOneAndUpdate(match, update, options) {
      return this.collection.findOneAndUpdate(match, update, options);
    }
    findCursor(match, options) {
      return this.collection.find(match, options);
    }
  }
  module.exports = exports = NodeCollection;
});

// node_modules/mquery/lib/collection/index.js
var require_collection5 = __commonJS((exports, module) => {
  var env = require_env();
  if (env.type == "unknown") {
    throw new Error("Unknown environment");
  }
  module.exports = env.isNode ? require_node3() : env.isMongo ? require_collection4() : require_collection4();
});

// node_modules/mquery/lib/mquery.js
var require_mquery = __commonJS((exports, module) => {
  function Query(criteria, options) {
    if (!(this instanceof Query))
      return new Query(criteria, options);
    const proto = this.constructor.prototype;
    this.op = proto.op || undefined;
    this.options = Object.assign({}, proto.options);
    this._conditions = proto._conditions ? utils.clone(proto._conditions) : {};
    this._fields = proto._fields ? utils.clone(proto._fields) : undefined;
    this._updateDoc = proto._updateDoc ? utils.clone(proto._updateDoc) : undefined;
    this._path = proto._path || undefined;
    this._distinctDoc = proto._distinctDoc || undefined;
    this._collection = proto._collection || undefined;
    this._traceFunction = proto._traceFunction || undefined;
    if (options) {
      this.setOptions(options);
    }
    if (criteria) {
      this.find(criteria);
    }
  }
  function push(opts, field, value) {
    if (Array.isArray(opts.sort)) {
      throw new TypeError("Can\'t mix sort syntaxes. Use either array or object:" + "\n- `.sort([[\'field\', 1], [\'test\', -1]])`" + "\n- `.sort({ field: 1, test: -1 })`");
    }
    let s;
    if (value && value.$meta) {
      s = opts.sort || (opts.sort = {});
      s[field] = { $meta: value.$meta };
      return;
    }
    s = opts.sort || (opts.sort = {});
    let val = String(value || 1).toLowerCase();
    val = _validSortValue[val];
    if (!val)
      throw new TypeError("Invalid sort value: { " + field + ": " + value + " }");
    s[field] = val;
  }
  function _pushArr(opts, field, value) {
    opts.sort = opts.sort || [];
    if (!Array.isArray(opts.sort)) {
      throw new TypeError("Can\'t mix sort syntaxes. Use either array or object:" + "\n- `.sort([[\'field\', 1], [\'test\', -1]])`" + "\n- `.sort({ field: 1, test: -1 })`");
    }
    let val = String(value || 1).toLowerCase();
    val = _validSortValue[val];
    if (!val)
      throw new TypeError("Invalid sort value: [ " + field + ", " + value + " ]");
    opts.sort.push([field, val]);
  }
  function _pushMap(opts, map) {
    opts.sort = opts.sort || new Map;
    if (!(opts.sort instanceof Map)) {
      throw new TypeError("Can\'t mix sort syntaxes. Use either array or " + "object or map consistently");
    }
    map.forEach(function(value, key) {
      let val = String(value || 1).toLowerCase();
      val = _validSortValue[val];
      if (!val)
        throw new TypeError("Invalid sort value: < " + key + ": " + value + " >");
      opts.sort.set(key, val);
    });
  }
  function _update(query, op, criteria, doc, options) {
    query.op = op;
    if (Query.canMerge(criteria)) {
      query.merge(criteria);
    }
    if (doc) {
      query._mergeUpdate(doc);
    }
    if (utils.isObject(options)) {
      query.setOptions(options);
    }
    return query;
  }
  async function _updateExec(query, op) {
    const options = query._optionsForExec();
    const criteria = query._conditions;
    const doc = query._updateForExec();
    debug("update", query._collection.collectionName, criteria, doc, options);
    return query._collection[op](criteria, doc, options);
  }
  var assert = import.meta.require("assert");
  var util = import.meta.require("util");
  var utils = require_utils5();
  var debug = require_src()("mquery");
  var $withinCmd = "$geoWithin";
  Object.defineProperty(Query, "use$geoWithin", {
    get: function() {
      return $withinCmd == "$geoWithin";
    },
    set: function(v) {
      if (v === true) {
        $withinCmd = "$geoWithin";
      } else {
        $withinCmd = "$within";
      }
    }
  });
  Query.prototype.toConstructor = function toConstructor() {
    function CustomQuery(criteria, options) {
      if (!(this instanceof CustomQuery))
        return new CustomQuery(criteria, options);
      Query.call(this, criteria, options);
    }
    utils.inherits(CustomQuery, Query);
    const p = CustomQuery.prototype;
    p.options = {};
    p.setOptions(this.options);
    p.op = this.op;
    p._conditions = utils.clone(this._conditions);
    p._fields = utils.clone(this._fields);
    p._updateDoc = utils.clone(this._updateDoc);
    p._path = this._path;
    p._distinctDoc = this._distinctDoc;
    p._collection = this._collection;
    p._traceFunction = this._traceFunction;
    return CustomQuery;
  };
  Query.prototype.setOptions = function(options) {
    if (!(options && utils.isObject(options)))
      return this;
    const methods = utils.keys(options);
    let method;
    for (let i = 0;i < methods.length; ++i) {
      method = methods[i];
      if (typeof this[method] == "function") {
        const args = Array.isArray(options[method]) ? options[method] : [options[method]];
        this[method].apply(this, args);
      } else {
        this.options[method] = options[method];
      }
    }
    return this;
  };
  Query.prototype.collection = function collection(coll) {
    this._collection = new Query.Collection(coll);
    return this;
  };
  Query.prototype.collation = function(value) {
    this.options.collation = value;
    return this;
  };
  Query.prototype.$where = function(js) {
    this._conditions.$where = js;
    return this;
  };
  Query.prototype.where = function() {
    if (!arguments.length)
      return this;
    if (!this.op)
      this.op = "find";
    const type = typeof arguments[0];
    if (type == "string") {
      this._path = arguments[0];
      if (arguments.length === 2) {
        this._conditions[this._path] = arguments[1];
      }
      return this;
    }
    if (type == "object" && !Array.isArray(arguments[0])) {
      return this.merge(arguments[0]);
    }
    throw new TypeError("path must be a string or object");
  };
  Query.prototype.equals = function equals(val) {
    this._ensurePath("equals");
    const path = this._path;
    this._conditions[path] = val;
    return this;
  };
  Query.prototype.eq = function eq(val) {
    this._ensurePath("eq");
    const path = this._path;
    this._conditions[path] = val;
    return this;
  };
  Query.prototype.or = function or(array) {
    const or = this._conditions.$or || (this._conditions.$or = []);
    if (!Array.isArray(array))
      array = [array];
    or.push.apply(or, array);
    return this;
  };
  Query.prototype.nor = function nor(array) {
    const nor = this._conditions.$nor || (this._conditions.$nor = []);
    if (!Array.isArray(array))
      array = [array];
    nor.push.apply(nor, array);
    return this;
  };
  Query.prototype.and = function and(array) {
    const and = this._conditions.$and || (this._conditions.$and = []);
    if (!Array.isArray(array))
      array = [array];
    and.push.apply(and, array);
    return this;
  };
  /*!
   * gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance
   *
   *     Thing.where('type').nin(array)
   */
  "gt gte lt lte ne in nin all regex size maxDistance minDistance".split(" ").forEach(function($conditional) {
    Query.prototype[$conditional] = function() {
      let path, val;
      if (arguments.length === 1) {
        this._ensurePath($conditional);
        val = arguments[0];
        path = this._path;
      } else {
        val = arguments[1];
        path = arguments[0];
      }
      const conds = this._conditions[path] === null || typeof this._conditions[path] === "object" ? this._conditions[path] : this._conditions[path] = {};
      conds["$" + $conditional] = val;
      return this;
    };
  });
  Query.prototype.mod = function() {
    let val, path;
    if (arguments.length === 1) {
      this._ensurePath("mod");
      val = arguments[0];
      path = this._path;
    } else if (arguments.length === 2 && !Array.isArray(arguments[1])) {
      this._ensurePath("mod");
      val = [arguments[0], arguments[1]];
      path = this._path;
    } else if (arguments.length === 3) {
      val = [arguments[1], arguments[2]];
      path = arguments[0];
    } else {
      val = arguments[1];
      path = arguments[0];
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds.$mod = val;
    return this;
  };
  Query.prototype.exists = function() {
    let path, val;
    if (arguments.length === 0) {
      this._ensurePath("exists");
      path = this._path;
      val = true;
    } else if (arguments.length === 1) {
      if (typeof arguments[0] === "boolean") {
        this._ensurePath("exists");
        path = this._path;
        val = arguments[0];
      } else {
        path = arguments[0];
        val = true;
      }
    } else if (arguments.length === 2) {
      path = arguments[0];
      val = arguments[1];
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds.$exists = val;
    return this;
  };
  Query.prototype.elemMatch = function() {
    if (arguments[0] == null)
      throw new TypeError("Invalid argument");
    let fn, path, criteria;
    if (typeof arguments[0] === "function") {
      this._ensurePath("elemMatch");
      path = this._path;
      fn = arguments[0];
    } else if (utils.isObject(arguments[0])) {
      this._ensurePath("elemMatch");
      path = this._path;
      criteria = arguments[0];
    } else if (typeof arguments[1] === "function") {
      path = arguments[0];
      fn = arguments[1];
    } else if (arguments[1] && utils.isObject(arguments[1])) {
      path = arguments[0];
      criteria = arguments[1];
    } else {
      throw new TypeError("Invalid argument");
    }
    if (fn) {
      criteria = new Query;
      fn(criteria);
      criteria = criteria._conditions;
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds.$elemMatch = criteria;
    return this;
  };
  Query.prototype.within = function within() {
    this._ensurePath("within");
    this._geoComparison = $withinCmd;
    if (arguments.length === 0) {
      return this;
    }
    if (arguments.length === 2) {
      return this.box.apply(this, arguments);
    } else if (2 < arguments.length) {
      return this.polygon.apply(this, arguments);
    }
    const area = arguments[0];
    if (!area)
      throw new TypeError("Invalid argument");
    if (area.center)
      return this.circle(area);
    if (area.box)
      return this.box.apply(this, area.box);
    if (area.polygon)
      return this.polygon.apply(this, area.polygon);
    if (area.type && area.coordinates)
      return this.geometry(area);
    throw new TypeError("Invalid argument");
  };
  Query.prototype.box = function() {
    let path, box;
    if (arguments.length === 3) {
      path = arguments[0];
      box = [arguments[1], arguments[2]];
    } else if (arguments.length === 2) {
      this._ensurePath("box");
      path = this._path;
      box = [arguments[0], arguments[1]];
    } else {
      throw new TypeError("Invalid argument");
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds[this._geoComparison || $withinCmd] = { $box: box };
    return this;
  };
  Query.prototype.polygon = function() {
    let val, path;
    if (typeof arguments[0] == "string") {
      val = Array.from(arguments);
      path = val.shift();
    } else {
      this._ensurePath("polygon");
      path = this._path;
      val = Array.from(arguments);
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds[this._geoComparison || $withinCmd] = { $polygon: val };
    return this;
  };
  Query.prototype.circle = function() {
    let path, val;
    if (arguments.length === 1) {
      this._ensurePath("circle");
      path = this._path;
      val = arguments[0];
    } else if (arguments.length === 2) {
      path = arguments[0];
      val = arguments[1];
    } else {
      throw new TypeError("Invalid argument");
    }
    if (!(("radius" in val) && val.center))
      throw new Error("center and radius are required");
    const conds = this._conditions[path] || (this._conditions[path] = {});
    const type = val.spherical ? "$centerSphere" : "$center";
    const wKey = this._geoComparison || $withinCmd;
    conds[wKey] = {};
    conds[wKey][type] = [val.center, val.radius];
    if ("unique" in val)
      conds[wKey].$uniqueDocs = !!val.unique;
    return this;
  };
  Query.prototype.near = function near() {
    let path, val;
    this._geoComparison = "$near";
    if (arguments.length === 0) {
      return this;
    } else if (arguments.length === 1) {
      this._ensurePath("near");
      path = this._path;
      val = arguments[0];
    } else if (arguments.length === 2) {
      path = arguments[0];
      val = arguments[1];
    } else {
      throw new TypeError("Invalid argument");
    }
    if (!val.center) {
      throw new Error("center is required");
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    const type = val.spherical ? "$nearSphere" : "$near";
    if (Array.isArray(val.center)) {
      conds[type] = val.center;
      const radius = "maxDistance" in val ? val.maxDistance : null;
      if (radius != null) {
        conds.$maxDistance = radius;
      }
      if (val.minDistance != null) {
        conds.$minDistance = val.minDistance;
      }
    } else {
      if (val.center.type != "Point" || !Array.isArray(val.center.coordinates)) {
        throw new Error(util.format("Invalid GeoJSON specified for %s", type));
      }
      conds[type] = { $geometry: val.center };
      if ("maxDistance" in val) {
        conds[type]["$maxDistance"] = val.maxDistance;
      }
      if ("minDistance" in val) {
        conds[type]["$minDistance"] = val.minDistance;
      }
    }
    return this;
  };
  Query.prototype.intersects = function intersects() {
    this._ensurePath("intersects");
    this._geoComparison = "$geoIntersects";
    if (arguments.length === 0) {
      return this;
    }
    const area = arguments[0];
    if (area != null && area.type && area.coordinates)
      return this.geometry(area);
    throw new TypeError("Invalid argument");
  };
  Query.prototype.geometry = function geometry() {
    if (!(this._geoComparison == "$within" || this._geoComparison == "$geoWithin" || this._geoComparison == "$near" || this._geoComparison == "$geoIntersects")) {
      throw new Error("geometry() must come after `within()`, `intersects()`, or `near()");
    }
    let val, path;
    if (arguments.length === 1) {
      this._ensurePath("geometry");
      path = this._path;
      val = arguments[0];
    } else {
      throw new TypeError("Invalid argument");
    }
    if (!(val.type && Array.isArray(val.coordinates))) {
      throw new TypeError("Invalid argument");
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds[this._geoComparison] = { $geometry: val };
    return this;
  };
  Query.prototype.select = function select() {
    let arg = arguments[0];
    if (!arg)
      return this;
    if (arguments.length !== 1) {
      throw new Error("Invalid select: select only takes 1 argument");
    }
    this._validate("select");
    const fields = this._fields || (this._fields = {});
    const type = typeof arg;
    let i, len;
    if ((type == "string" || utils.isArgumentsObject(arg)) && typeof arg.length == "number" || Array.isArray(arg)) {
      if (type == "string")
        arg = arg.split(/\s+/);
      for (i = 0, len = arg.length;i < len; ++i) {
        let field = arg[i];
        if (!field)
          continue;
        const include = field[0] == "-" ? 0 : 1;
        if (include === 0)
          field = field.substring(1);
        fields[field] = include;
      }
      return this;
    }
    if (utils.isObject(arg)) {
      const keys = utils.keys(arg);
      for (i = 0;i < keys.length; ++i) {
        fields[keys[i]] = arg[keys[i]];
      }
      return this;
    }
    throw new TypeError("Invalid select() argument. Must be string or object.");
  };
  Query.prototype.slice = function() {
    if (arguments.length === 0)
      return this;
    this._validate("slice");
    let path, val;
    if (arguments.length === 1) {
      const arg = arguments[0];
      if (typeof arg === "object" && !Array.isArray(arg)) {
        const keys = Object.keys(arg);
        const numKeys = keys.length;
        for (let i = 0;i < numKeys; ++i) {
          this.slice(keys[i], arg[keys[i]]);
        }
        return this;
      }
      this._ensurePath("slice");
      path = this._path;
      val = arguments[0];
    } else if (arguments.length === 2) {
      if (typeof arguments[0] === "number") {
        this._ensurePath("slice");
        path = this._path;
        val = [arguments[0], arguments[1]];
      } else {
        path = arguments[0];
        val = arguments[1];
      }
    } else if (arguments.length === 3) {
      path = arguments[0];
      val = [arguments[1], arguments[2]];
    }
    const myFields = this._fields || (this._fields = {});
    myFields[path] = { $slice: val };
    return this;
  };
  Query.prototype.sort = function(arg) {
    if (!arg)
      return this;
    let i, len, field;
    this._validate("sort");
    const type = typeof arg;
    if (Array.isArray(arg)) {
      len = arg.length;
      for (i = 0;i < arg.length; ++i) {
        if (!Array.isArray(arg[i])) {
          throw new Error("Invalid sort() argument, must be array of arrays");
        }
        _pushArr(this.options, arg[i][0], arg[i][1]);
      }
      return this;
    }
    if (arguments.length === 1 && type == "string") {
      arg = arg.split(/\s+/);
      len = arg.length;
      for (i = 0;i < len; ++i) {
        field = arg[i];
        if (!field)
          continue;
        const ascend = field[0] == "-" ? -1 : 1;
        if (ascend === -1)
          field = field.substring(1);
        push(this.options, field, ascend);
      }
      return this;
    }
    if (utils.isObject(arg)) {
      const keys = utils.keys(arg);
      for (i = 0;i < keys.length; ++i) {
        field = keys[i];
        push(this.options, field, arg[field]);
      }
      return this;
    }
    if (typeof Map !== "undefined" && arg instanceof Map) {
      _pushMap(this.options, arg);
      return this;
    }
    throw new TypeError("Invalid sort() argument. Must be a string, object, or array.");
  };
  /*!
   * @ignore
   */
  var _validSortValue = {
    1: 1,
    "-1": -1,
    asc: 1,
    ascending: 1,
    desc: -1,
    descending: -1
  };
  /*!
   * limit, skip, batchSize, comment
   *
   * Sets these associated options.
   *
   *     query.comment('feed query');
   */
  ["limit", "skip", "batchSize", "comment"].forEach(function(method) {
    Query.prototype[method] = function(v) {
      this._validate(method);
      this.options[method] = v;
      return this;
    };
  });
  Query.prototype.maxTime = Query.prototype.maxTimeMS = function(ms) {
    this._validate("maxTime");
    this.options.maxTimeMS = ms;
    return this;
  };
  Query.prototype.hint = function() {
    if (arguments.length === 0)
      return this;
    this._validate("hint");
    const arg = arguments[0];
    if (utils.isObject(arg)) {
      const hint = this.options.hint || (this.options.hint = {});
      for (const k in arg) {
        hint[k] = arg[k];
      }
      return this;
    }
    if (typeof arg === "string") {
      this.options.hint = arg;
      return this;
    }
    throw new TypeError("Invalid hint. " + arg);
  };
  Query.prototype.j = function j(val) {
    this.options.j = val;
    return this;
  };
  Query.prototype.slaveOk = function(v) {
    this.options.slaveOk = arguments.length ? !!v : true;
    return this;
  };
  Query.prototype.read = Query.prototype.setReadPreference = function(pref) {
    if (arguments.length > 1 && !Query.prototype.read.deprecationWarningIssued) {
      console.error("Deprecation warning: \'tags\' argument is not supported anymore in Query.read() method. Please use mongodb.ReadPreference object instead.");
      Query.prototype.read.deprecationWarningIssued = true;
    }
    this.options.readPreference = utils.readPref(pref);
    return this;
  };
  Query.prototype.readConcern = Query.prototype.r = function(level) {
    this.options.readConcern = utils.readConcern(level);
    return this;
  };
  Query.prototype.tailable = function() {
    this._validate("tailable");
    this.options.tailable = arguments.length ? !!arguments[0] : true;
    return this;
  };
  Query.prototype.writeConcern = Query.prototype.w = function writeConcern(concern) {
    if (typeof concern === "object") {
      if (typeof concern.j !== "undefined")
        this.options.j = concern.j;
      if (typeof concern.w !== "undefined")
        this.options.w = concern.w;
      if (typeof concern.wtimeout !== "undefined")
        this.options.wtimeout = concern.wtimeout;
    } else {
      this.options.w = concern === "m" ? "majority" : concern;
    }
    return this;
  };
  Query.prototype.wtimeout = Query.prototype.wTimeout = function wtimeout(ms) {
    this.options.wtimeout = ms;
    return this;
  };
  Query.prototype.merge = function(source) {
    if (!source)
      return this;
    if (!Query.canMerge(source))
      throw new TypeError("Invalid argument. Expected instanceof mquery or plain object");
    if (source instanceof Query) {
      if (source._conditions) {
        utils.merge(this._conditions, source._conditions);
      }
      if (source._fields) {
        this._fields || (this._fields = {});
        utils.merge(this._fields, source._fields);
      }
      if (source.options) {
        this.options || (this.options = {});
        utils.merge(this.options, source.options);
      }
      if (source._updateDoc) {
        this._updateDoc || (this._updateDoc = {});
        utils.mergeClone(this._updateDoc, source._updateDoc);
      }
      if (source._distinctDoc) {
        this._distinctDoc = source._distinctDoc;
      }
      return this;
    }
    utils.merge(this._conditions, source);
    return this;
  };
  Query.prototype.find = function(criteria) {
    this.op = "find";
    if (Query.canMerge(criteria)) {
      this.merge(criteria);
    }
    return this;
  };
  Query.prototype._find = async function _find() {
    const conds = this._conditions;
    const options = this._optionsForExec();
    if (this.$useProjection) {
      options.projection = this._fieldsForExec();
    } else {
      options.fields = this._fieldsForExec();
    }
    debug("_find", this._collection.collectionName, conds, options);
    return this._collection.find(conds, options);
  };
  Query.prototype.cursor = function cursor(criteria) {
    if (this.op) {
      if (this.op !== "find") {
        throw new TypeError(".cursor only support .find method");
      }
    } else {
      this.find(criteria);
    }
    const conds = this._conditions;
    const options = this._optionsForExec();
    if (this.$useProjection) {
      options.projection = this._fieldsForExec();
    } else {
      options.fields = this._fieldsForExec();
    }
    debug("findCursor", this._collection.collectionName, conds, options);
    return this._collection.findCursor(conds, options);
  };
  Query.prototype.findOne = function(criteria) {
    this.op = "findOne";
    if (Query.canMerge(criteria)) {
      this.merge(criteria);
    }
    return this;
  };
  Query.prototype._findOne = async function _findOne() {
    const conds = this._conditions;
    const options = this._optionsForExec();
    if (this.$useProjection) {
      options.projection = this._fieldsForExec();
    } else {
      options.fields = this._fieldsForExec();
    }
    debug("findOne", this._collection.collectionName, conds, options);
    return this._collection.findOne(conds, options);
  };
  Query.prototype.count = function(criteria) {
    this.op = "count";
    this._validate();
    if (Query.canMerge(criteria)) {
      this.merge(criteria);
    }
    return this;
  };
  Query.prototype._count = async function _count() {
    const conds = this._conditions, options = this._optionsForExec();
    debug("count", this._collection.collectionName, conds, options);
    return this._collection.count(conds, options);
  };
  Query.prototype.distinct = function(criteria, field) {
    this.op = "distinct";
    this._validate();
    if (!field && typeof criteria === "string") {
      field = criteria;
      criteria = undefined;
    }
    if (typeof field == "string") {
      this._distinctDoc = field;
    }
    if (Query.canMerge(criteria)) {
      this.merge(criteria);
    }
    return this;
  };
  Query.prototype._distinct = async function _distinct() {
    if (!this._distinctDoc) {
      throw new Error("No value for `distinct` has been declared");
    }
    const conds = this._conditions, options = this._optionsForExec();
    debug("distinct", this._collection.collectionName, conds, options);
    return this._collection.distinct(this._distinctDoc, conds, options);
  };
  Query.prototype.updateMany = function updateMany(criteria, doc, options) {
    if (arguments.length === 1) {
      doc = criteria;
      criteria = options = undefined;
    }
    return _update(this, "updateMany", criteria, doc, options);
  };
  Query.prototype._updateMany = async function() {
    return _updateExec(this, "updateMany");
  };
  Query.prototype.updateOne = function updateOne(criteria, doc, options) {
    if (arguments.length === 1) {
      doc = criteria;
      criteria = options = undefined;
    }
    return _update(this, "updateOne", criteria, doc, options);
  };
  Query.prototype._updateOne = async function() {
    return _updateExec(this, "updateOne");
  };
  Query.prototype.replaceOne = function replaceOne(criteria, doc, options) {
    if (arguments.length === 1) {
      doc = criteria;
      criteria = options = undefined;
    }
    this.setOptions({ overwrite: true });
    return _update(this, "replaceOne", criteria, doc, options);
  };
  Query.prototype._replaceOne = async function() {
    return _updateExec(this, "replaceOne");
  };
  /*!
   * Internal helper for updateMany, updateOne
   */
  Query.prototype.deleteOne = function(criteria) {
    this.op = "deleteOne";
    if (Query.canMerge(criteria)) {
      this.merge(criteria);
    }
    return this;
  };
  Query.prototype._deleteOne = async function() {
    const options = this._optionsForExec();
    delete options.justOne;
    const conds = this._conditions;
    debug("deleteOne", this._collection.collectionName, conds, options);
    return this._collection.deleteOne(conds, options);
  };
  Query.prototype.deleteMany = function(criteria) {
    this.op = "deleteMany";
    if (Query.canMerge(criteria)) {
      this.merge(criteria);
    }
    return this;
  };
  Query.prototype._deleteMany = async function() {
    const options = this._optionsForExec();
    delete options.justOne;
    const conds = this._conditions;
    debug("deleteOne", this._collection.collectionName, conds, options);
    return this._collection.deleteMany(conds, options);
  };
  Query.prototype.findOneAndUpdate = function(criteria, doc, options) {
    this.op = "findOneAndUpdate";
    this._validate();
    if (arguments.length === 1) {
      doc = criteria;
      criteria = options = undefined;
    }
    if (Query.canMerge(criteria)) {
      this.merge(criteria);
    }
    if (doc) {
      this._mergeUpdate(doc);
    }
    options && this.setOptions(options);
    return this;
  };
  Query.prototype._findOneAndUpdate = async function() {
    const conds = this._conditions;
    const update = this._updateForExec();
    const options = this._optionsForExec();
    return this._collection.findOneAndUpdate(conds, update, options);
  };
  Query.prototype.findOneAndRemove = Query.prototype.findOneAndDelete = function(conditions, options) {
    this.op = "findOneAndRemove";
    this._validate();
    if (Query.canMerge(conditions)) {
      this.merge(conditions);
    }
    options && this.setOptions(options);
    return this;
  };
  Query.prototype._findOneAndRemove = async function() {
    const options = this._optionsForExec();
    const conds = this._conditions;
    return this._collection.findOneAndDelete(conds, options);
  };
  Query.prototype.setTraceFunction = function(traceFunction) {
    this._traceFunction = traceFunction;
    return this;
  };
  Query.prototype.exec = async function exec(op) {
    if (typeof op === "string") {
      this.op = op;
    }
    assert.ok(this.op, "Missing query type: (find, etc)");
    const fnName = "_" + this.op;
    if (typeof this[fnName] !== "function") {
      throw new TypeError(`this[${fnName}] is not a function`);
    }
    return this[fnName]();
  };
  Query.prototype.then = async function(res, rej) {
    return this.exec().then(res, rej);
  };
  Query.prototype.cursor = function() {
    if (this.op != "find")
      throw new Error("cursor() is only available for find");
    const conds = this._conditions;
    const options = this._optionsForExec();
    if (this.$useProjection) {
      options.projection = this._fieldsForExec();
    } else {
      options.fields = this._fieldsForExec();
    }
    debug("cursor", this._collection.collectionName, conds, options);
    return this._collection.findCursor(conds, options);
  };
  Query.prototype.selected = function selected() {
    return !!(this._fields && Object.keys(this._fields).length > 0);
  };
  Query.prototype.selectedInclusively = function selectedInclusively() {
    if (!this._fields)
      return false;
    const keys = Object.keys(this._fields);
    if (keys.length === 0)
      return false;
    for (let i = 0;i < keys.length; ++i) {
      const key = keys[i];
      if (this._fields[key] === 0)
        return false;
      if (this._fields[key] && typeof this._fields[key] === "object" && this._fields[key].$meta) {
        return false;
      }
    }
    return true;
  };
  Query.prototype.selectedExclusively = function selectedExclusively() {
    if (!this._fields)
      return false;
    const keys = Object.keys(this._fields);
    if (keys.length === 0)
      return false;
    for (let i = 0;i < keys.length; ++i) {
      const key = keys[i];
      if (this._fields[key] === 0)
        return true;
    }
    return false;
  };
  Query.prototype._mergeUpdate = function(doc) {
    if (!this._updateDoc)
      this._updateDoc = {};
    if (doc instanceof Query) {
      if (doc._updateDoc) {
        utils.mergeClone(this._updateDoc, doc._updateDoc);
      }
    } else {
      utils.mergeClone(this._updateDoc, doc);
    }
  };
  Query.prototype._optionsForExec = function() {
    const options = utils.clone(this.options);
    return options;
  };
  Query.prototype._fieldsForExec = function() {
    return utils.clone(this._fields);
  };
  Query.prototype._updateForExec = function() {
    const update = utils.clone(this._updateDoc);
    const ops = utils.keys(update);
    const ret = {};
    for (const op of ops) {
      if (this.options.overwrite) {
        ret[op] = update[op];
        continue;
      }
      if (op[0] !== "$") {
        if (!ret.$set) {
          if (update.$set) {
            ret.$set = update.$set;
          } else {
            ret.$set = {};
          }
        }
        ret.$set[op] = update[op];
        if (!~ops.indexOf("$set"))
          ops.push("$set");
      } else if (op === "$set") {
        if (!ret.$set) {
          ret[op] = update[op];
        }
      } else {
        ret[op] = update[op];
      }
    }
    this._compiledUpdate = ret;
    return ret;
  };
  Query.prototype._ensurePath = function(method) {
    if (!this._path) {
      const msg = method + "() must be used after where() " + "when called with these arguments";
      throw new Error(msg);
    }
  };
  /*!
   * Permissions
   */
  Query.permissions = require_permissions();
  Query._isPermitted = function(a, b) {
    const denied = Query.permissions[b];
    if (!denied)
      return true;
    return denied[a] !== true;
  };
  Query.prototype._validate = function(action) {
    let fail;
    let validator;
    if (action === undefined) {
      validator = Query.permissions[this.op];
      if (typeof validator != "function")
        return true;
      fail = validator(this);
    } else if (!Query._isPermitted(action, this.op)) {
      fail = action;
    }
    if (fail) {
      throw new Error(fail + " cannot be used with " + this.op);
    }
  };
  Query.canMerge = function(conds) {
    return conds instanceof Query || utils.isObject(conds);
  };
  Query.setGlobalTraceFunction = function(traceFunction) {
    Query.traceFunction = traceFunction;
  };
  /*!
   * Exports.
   */
  Query.utils = utils;
  Query.env = require_env();
  Query.Collection = require_collection5();
  Query.BaseCollection = require_collection4();
  module.exports = exports = Query;
});

// node_modules/mongoose/lib/helpers/projection/parseProjection.js
var require_parseProjection = __commonJS((exports, module) => {
  module.exports = function parseProjection(v, retainMinusPaths) {
    const type = typeof v;
    if (type === "string") {
      v = v.split(/\s+/);
    }
    if (!Array.isArray(v) && Object.prototype.toString.call(v) !== "[object Arguments]") {
      return v;
    }
    const len = v.length;
    const ret = {};
    for (let i = 0;i < len; ++i) {
      let field = v[i];
      if (!field) {
        continue;
      }
      const include = field[0] == "-" ? 0 : 1;
      if (!retainMinusPaths && include === 0) {
        field = field.substring(1);
      }
      ret[field] = include;
    }
    return ret;
  };
});

// node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js
var require_removeUnusedArrayFilters = __commonJS((exports, module) => {
  function _checkSingleFilterKey(arrayFilter, updateKeys) {
    const firstKey = Object.keys(arrayFilter)[0];
    if (firstKey === "$and" || firstKey === "$or") {
      if (!Array.isArray(arrayFilter[firstKey])) {
        return false;
      }
      return arrayFilter[firstKey].find((filter) => _checkSingleFilterKey(filter, updateKeys)) != null;
    }
    const firstDot = firstKey.indexOf(".");
    const arrayFilterKey = firstDot === -1 ? firstKey : firstKey.slice(0, firstDot);
    return updateKeys.find((key) => key.includes("$[" + arrayFilterKey + "]")) != null;
  }
  module.exports = function removeUnusedArrayFilters(update, arrayFilters) {
    const updateKeys = Object.keys(update).map((key) => Object.keys(update[key])).reduce((cur, arr) => cur.concat(arr), []);
    return arrayFilters.filter((obj) => {
      return _checkSingleFilterKey(obj, updateKeys);
    });
  };
});

// node_modules/mongoose/lib/helpers/query/hasDollarKeys.js
var require_hasDollarKeys = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  module.exports = function hasDollarKeys(obj) {
    if (typeof obj !== "object" || obj === null) {
      return false;
    }
    const keys = Object.keys(obj);
    const len = keys.length;
    for (let i = 0;i < len; ++i) {
      if (keys[i][0] === "$") {
        return true;
      }
    }
    return false;
  };
});

// node_modules/mongoose/lib/helpers/query/sanitizeFilter.js
var require_sanitizeFilter = __commonJS((exports, module) => {
  var hasDollarKeys = require_hasDollarKeys();
  var { trustedSymbol } = require_trusted();
  module.exports = function sanitizeFilter(filter) {
    if (filter == null || typeof filter !== "object") {
      return filter;
    }
    if (Array.isArray(filter)) {
      for (const subfilter of filter) {
        sanitizeFilter(subfilter);
      }
      return filter;
    }
    const filterKeys = Object.keys(filter);
    for (const key of filterKeys) {
      const value = filter[key];
      if (value != null && value[trustedSymbol]) {
        continue;
      }
      if (key === "$and" || key === "$or") {
        sanitizeFilter(value);
        continue;
      }
      if (hasDollarKeys(value)) {
        const keys = Object.keys(value);
        if (keys.length === 1 && keys[0] === "$eq") {
          continue;
        }
        filter[key] = { $eq: filter[key] };
      }
    }
    return filter;
  };
});

// node_modules/mongoose/lib/helpers/query/sanitizeProjection.js
var require_sanitizeProjection = __commonJS((exports, module) => {
  module.exports = function sanitizeProjection(projection) {
    if (projection == null) {
      return;
    }
    const keys = Object.keys(projection);
    for (let i = 0;i < keys.length; ++i) {
      if (typeof projection[keys[i]] === "string") {
        projection[keys[i]] = 1;
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js
var require_selectPopulatedFields = __commonJS((exports, module) => {
  function isPathInFields(userProvidedFields, path) {
    const pieces = path.split(".");
    const len = pieces.length;
    let cur = pieces[0];
    for (let i = 1;i < len; ++i) {
      if (userProvidedFields[cur] != null || userProvidedFields[cur + ".$"] != null) {
        return true;
      }
      cur += "." + pieces[i];
    }
    return userProvidedFields[cur] != null || userProvidedFields[cur + ".$"] != null;
  }
  var isExclusive = require_isExclusive();
  var isInclusive = require_isInclusive();
  /*!
   * ignore
   */
  module.exports = function selectPopulatedFields(fields, userProvidedFields, populateOptions) {
    if (populateOptions == null) {
      return;
    }
    const paths = Object.keys(populateOptions);
    userProvidedFields = userProvidedFields || {};
    if (isInclusive(fields)) {
      for (const path of paths) {
        if (!isPathInFields(userProvidedFields, path)) {
          fields[path] = 1;
        } else if (userProvidedFields[path] === 0) {
          delete fields[path];
        }
        const refPath = populateOptions[path]?.refPath;
        if (typeof refPath === "string") {
          if (!isPathInFields(userProvidedFields, refPath)) {
            fields[refPath] = 1;
          } else if (userProvidedFields[refPath] === 0) {
            delete fields[refPath];
          }
        }
      }
    } else if (isExclusive(fields)) {
      for (const path of paths) {
        if (userProvidedFields[path] == null) {
          delete fields[path];
        }
        const refPath = populateOptions[path]?.refPath;
        if (typeof refPath === "string" && userProvidedFields[refPath] == null) {
          delete fields[refPath];
        }
      }
    }
  };
  /*!
   * ignore
   */
});

// node_modules/mongoose/lib/helpers/updateValidators.js
var require_updateValidators = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var ValidationError = require_validation();
  var cleanPositionalOperators = require_cleanPositionalOperators();
  var flatten = require_common3().flatten;
  var modifiedPaths = require_common3().modifiedPaths;
  module.exports = function(query, schema, castedDoc, options, callback) {
    const keys = Object.keys(castedDoc || {});
    let updatedKeys = {};
    let updatedValues = {};
    const isPull = {};
    const arrayAtomicUpdates = {};
    const numKeys = keys.length;
    let hasDollarUpdate = false;
    const modified = {};
    let currentUpdate;
    let key;
    let i;
    for (i = 0;i < numKeys; ++i) {
      if (keys[i].startsWith("$")) {
        hasDollarUpdate = true;
        if (keys[i] === "$push" || keys[i] === "$addToSet") {
          const _keys = Object.keys(castedDoc[keys[i]]);
          for (let ii = 0;ii < _keys.length; ++ii) {
            currentUpdate = castedDoc[keys[i]][_keys[ii]];
            if (currentUpdate && currentUpdate.$each) {
              arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat(currentUpdate.$each);
            } else {
              arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).concat([currentUpdate]);
            }
          }
          continue;
        }
        modifiedPaths(castedDoc[keys[i]], "", modified);
        const flat = flatten(castedDoc[keys[i]], null, null, schema);
        const paths = Object.keys(flat);
        const numPaths = paths.length;
        for (let j = 0;j < numPaths; ++j) {
          const updatedPath = cleanPositionalOperators(paths[j]);
          key = keys[i];
          if (updatedPath.includes("$")) {
            continue;
          }
          if (key === "$set" || key === "$setOnInsert" || key === "$pull" || key === "$pullAll") {
            updatedValues[updatedPath] = flat[paths[j]];
            isPull[updatedPath] = key === "$pull" || key === "$pullAll";
          } else if (key === "$unset") {
            updatedValues[updatedPath] = undefined;
          }
          updatedKeys[updatedPath] = true;
        }
      }
    }
    if (!hasDollarUpdate) {
      modifiedPaths(castedDoc, "", modified);
      updatedValues = flatten(castedDoc, null, null, schema);
      updatedKeys = Object.keys(updatedValues);
    }
    const updates = Object.keys(updatedValues);
    const numUpdates = updates.length;
    const validatorsToExecute = [];
    const validationErrors = [];
    const alreadyValidated = [];
    const context = query;
    function iter(i2, v) {
      const schemaPath = schema._getSchema(updates[i2]);
      if (schemaPath == null) {
        return;
      }
      if (schemaPath.instance === "Mixed" && schemaPath.path !== updates[i2]) {
        return;
      }
      if (v && Array.isArray(v.$in)) {
        v.$in.forEach((v2, i3) => {
          validatorsToExecute.push(function(callback2) {
            schemaPath.doValidate(v2, function(err) {
              if (err) {
                err.path = updates[i3] + ".$in." + i3;
                validationErrors.push(err);
              }
              callback2(null);
            }, context, { updateValidator: true });
          });
        });
      } else {
        if (isPull[updates[i2]] && schemaPath.$isMongooseArray) {
          return;
        }
        if (schemaPath.$isMongooseDocumentArrayElement && v != null && v.$__ != null) {
          alreadyValidated.push(updates[i2]);
          validatorsToExecute.push(function(callback2) {
            schemaPath.doValidate(v, function(err) {
              if (err) {
                if (err.errors) {
                  for (const key2 of Object.keys(err.errors)) {
                    const _err = err.errors[key2];
                    _err.path = updates[i2] + "." + key2;
                    validationErrors.push(_err);
                  }
                } else {
                  err.path = updates[i2];
                  validationErrors.push(err);
                }
              }
              return callback2(null);
            }, context, { updateValidator: true });
          });
        } else {
          validatorsToExecute.push(function(callback2) {
            for (const path of alreadyValidated) {
              if (updates[i2].startsWith(path + ".")) {
                return callback2(null);
              }
            }
            schemaPath.doValidate(v, function(err) {
              if (schemaPath.schema != null && schemaPath.schema.options.storeSubdocValidationError === false && err instanceof ValidationError) {
                return callback2(null);
              }
              if (err) {
                err.path = updates[i2];
                validationErrors.push(err);
              }
              callback2(null);
            }, context, { updateValidator: true });
          });
        }
      }
    }
    for (i = 0;i < numUpdates; ++i) {
      iter(i, updatedValues[updates[i]]);
    }
    const arrayUpdates = Object.keys(arrayAtomicUpdates);
    for (const arrayUpdate of arrayUpdates) {
      let schemaPath = schema._getSchema(arrayUpdate);
      if (schemaPath && schemaPath.$isMongooseDocumentArray) {
        validatorsToExecute.push(function(callback2) {
          schemaPath.doValidate(arrayAtomicUpdates[arrayUpdate], getValidationCallback(arrayUpdate, validationErrors, callback2), options && options.context === "query" ? query : null);
        });
      } else {
        schemaPath = schema._getSchema(arrayUpdate + ".0");
        for (const atomicUpdate of arrayAtomicUpdates[arrayUpdate]) {
          validatorsToExecute.push(function(callback2) {
            schemaPath.doValidate(atomicUpdate, getValidationCallback(arrayUpdate, validationErrors, callback2), options && options.context === "query" ? query : null, { updateValidator: true });
          });
        }
      }
    }
    if (callback != null) {
      let numValidators = validatorsToExecute.length;
      if (numValidators === 0) {
        return _done(callback);
      }
      for (const validator of validatorsToExecute) {
        validator(function() {
          if (--numValidators <= 0) {
            _done(callback);
          }
        });
      }
      return;
    }
    return function(callback2) {
      let numValidators = validatorsToExecute.length;
      if (numValidators === 0) {
        return _done(callback2);
      }
      for (const validator of validatorsToExecute) {
        validator(function() {
          if (--numValidators <= 0) {
            _done(callback2);
          }
        });
      }
    };
    function _done(callback2) {
      if (validationErrors.length) {
        const err = new ValidationError(null);
        for (const validationError of validationErrors) {
          err.addError(validationError.path, validationError);
        }
        return callback2(err);
      }
      callback2(null);
    }
    function getValidationCallback(arrayUpdate, validationErrors2, callback2) {
      return function(err) {
        if (err) {
          err.path = arrayUpdate;
          validationErrors2.push(err);
        }
        callback2(null);
      };
    }
  };
});

// node_modules/mongoose/lib/query.js
var require_query = __commonJS((exports, module) => {
  function Query(conditions, options, model, collection) {
    if (!this._mongooseOptions) {
      this._mongooseOptions = {};
    }
    options = options || {};
    this._transforms = [];
    this._hooks = new Kareem;
    this._executionStack = null;
    const keys = Object.keys(options);
    for (const key of keys) {
      this._mongooseOptions[key] = options[key];
    }
    if (collection) {
      this.mongooseCollection = collection;
    }
    if (model) {
      this.model = model;
      this.schema = model.schema;
    }
    if (this.model && this.model._mapreduce) {
      this.lean();
    }
    mquery.call(this, null, options);
    if (collection) {
      this.collection(collection);
    }
    if (conditions) {
      this.find(conditions);
    }
    this.options = this.options || {};
    this.$useProjection = true;
    const collation = this && this.schema && this.schema.options && this.schema.options.collation || null;
    if (collation != null) {
      this.options.collation = collation;
    }
  }
  function _castArrayFilters(query) {
    try {
      castArrayFilters(query);
    } catch (err) {
      query.error(err);
    }
  }
  function _handleSortValue(val, key) {
    if (val === 1 || val === "asc" || val === "ascending") {
      return 1;
    }
    if (val === -1 || val === "desc" || val === "descending") {
      return -1;
    }
    if (val?.$meta != null) {
      return { $meta: val.$meta };
    }
    throw new TypeError("Invalid sort value: { " + key + ": " + val + " }");
  }
  function completeOne(model, doc, res, options, fields, userProvidedFields, pop, callback) {
    if (options.includeResultMetadata && doc == null) {
      _init(null);
      return null;
    }
    helpers.createModelAndInit(model, doc, fields, userProvidedFields, options, pop, _init);
    function _init(err, casted) {
      if (err) {
        return callback(err);
      }
      if (options.includeResultMetadata) {
        if (doc && casted) {
          if (options.session != null) {
            casted.$session(options.session);
          }
          res.value = casted;
        } else {
          res.value = null;
        }
        return callback(null, res);
      }
      if (options.session != null) {
        casted.$session(options.session);
      }
      callback(null, casted);
    }
  }
  function prepareDiscriminatorCriteria(query) {
    if (!query || !query.model || !query.model.schema) {
      return;
    }
    const schema = query.model.schema;
    if (schema && schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {
      query._conditions[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;
    }
  }
  function convertNewToReturnDocument(options) {
    if ("new" in options) {
      options.returnDocument = options["new"] ? "after" : "before";
      delete options["new"];
    }
    if ("returnOriginal" in options) {
      options.returnDocument = options["returnOriginal"] ? "before" : "after";
      delete options["returnOriginal"];
    }
    if (typeof options.returnDocument === "string") {
      options.returnOriginal = options.returnDocument === "before";
    }
  }
  function _getOption(query, option, def) {
    const opts = query._optionsForExec(query.model);
    if (option in opts) {
      return opts[option];
    }
    if (option in query.model.base.options) {
      return query.model.base.options[option];
    }
    return def;
  }
  function _completeOneLean(schema, doc, path, res, opts, callback) {
    if (opts.lean && typeof opts.lean.transform === "function") {
      opts.lean.transform(doc);
      for (let i = 0;i < schema.childSchemas.length; i++) {
        const childPath = path ? path + "." + schema.childSchemas[i].model.path : schema.childSchemas[i].model.path;
        const _schema = schema.childSchemas[i].schema;
        const obj = mpath.get(childPath, doc);
        if (obj == null) {
          continue;
        }
        if (Array.isArray(obj)) {
          for (let i2 = 0;i2 < obj.length; i2++) {
            opts.lean.transform(obj[i2]);
          }
        } else {
          opts.lean.transform(obj);
        }
        _completeOneLean(_schema, obj, childPath, res, opts);
      }
      if (callback) {
        return callback(null, doc);
      } else {
        return;
      }
    }
    if (opts.includeResultMetadata) {
      return callback(null, res);
    }
    return callback(null, doc);
  }
  function _completeManyLean(schema, docs, path, opts) {
    if (opts.lean && typeof opts.lean.transform === "function") {
      for (const doc of docs) {
        opts.lean.transform(doc);
      }
      for (let i = 0;i < schema.childSchemas.length; i++) {
        const childPath = path ? path + "." + schema.childSchemas[i].model.path : schema.childSchemas[i].model.path;
        const _schema = schema.childSchemas[i].schema;
        let doc = mpath.get(childPath, docs);
        if (doc == null) {
          continue;
        }
        doc = doc.flat();
        for (let i2 = 0;i2 < doc.length; i2++) {
          opts.lean.transform(doc[i2]);
        }
        _completeManyLean(_schema, doc, childPath, opts);
      }
    }
    return docs;
  }
  async function _updateThunk(op) {
    this._applyTranslateAliases();
    this._castConditions();
    _castArrayFilters(this);
    if (this.error() != null) {
      throw this.error();
    }
    const castedQuery = this._conditions;
    const options = this._optionsForExec(this.model);
    this._update = clone(this._update, options);
    const isOverwriting = op === "replaceOne";
    if (isOverwriting) {
      this._update = new this.model(this._update, null, true);
    } else {
      this._update = this._castUpdate(this._update);
      if (this._update == null || Object.keys(this._update).length === 0) {
        return { acknowledged: false };
      }
      const _opts = Object.assign({}, options, {
        setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert
      });
      this._update = setDefaultsOnInsert(this._conditions, this.model.schema, this._update, _opts);
    }
    if (Array.isArray(options.arrayFilters)) {
      options.arrayFilters = removeUnusedArrayFilters(this._update, options.arrayFilters);
    }
    const runValidators = _getOption(this, "runValidators", false);
    if (runValidators) {
      await this.validate(this._update, options, isOverwriting);
    }
    if (this._update.toBSON) {
      this._update = this._update.toBSON();
    }
    return this.mongooseCollection[op](castedQuery, this._update, options);
  }
  function _update(query, op, filter, doc, options, callback) {
    query.op = op;
    query._validateOp();
    doc = doc || {};
    if (options != null) {
      if ("strict" in options) {
        query._mongooseOptions.strict = options.strict;
      }
    }
    if (!(filter instanceof Query) && filter != null && filter.toString() !== "[object Object]") {
      query.error(new ObjectParameterError(filter, "filter", op));
    } else {
      query.merge(filter);
    }
    if (utils.isObject(options)) {
      query.setOptions(options);
    }
    query._mergeUpdate(doc);
    if (callback) {
      query.exec(callback);
      return query;
    }
    return query;
  }
  function _orFailError(err, query) {
    if (typeof err === "function") {
      err = err.call(query);
    }
    if (err == null) {
      err = new DocumentNotFoundError(query.getQuery(), query.model.modelName);
    }
    return err;
  }
  function _executePostExecHooks(query) {
    return new Promise((resolve, reject) => {
      query._hooks.execPost("exec", query, [], {}, (error) => {
        if (error) {
          return reject(error);
        }
        resolve();
      });
    });
  }
  function _executePostHooks(query, res, error, op) {
    if (query._queryMiddleware == null) {
      if (error != null) {
        throw error;
      }
      return res;
    }
    return new Promise((resolve, reject) => {
      const opts = error ? { error } : {};
      query._queryMiddleware.execPost(op || query.op, query, [res], opts, (error2, res2) => {
        if (error2) {
          return reject(error2);
        }
        resolve(res2);
      });
    });
  }
  function _executePreExecHooks(query) {
    return new Promise((resolve, reject) => {
      query._hooks.execPre("exec", query, [], (error) => {
        if (error != null) {
          return reject(error);
        }
        resolve();
      });
    });
  }
  function _executePreHooks(query, op) {
    if (query._queryMiddleware == null) {
      return;
    }
    return new Promise((resolve, reject) => {
      query._queryMiddleware.execPre(op || query.op, query, [], (error) => {
        if (error != null) {
          return reject(error);
        }
        resolve();
      });
    });
  }
  function _getPopulatedPaths(list, arr, prefix) {
    for (const pop of arr) {
      list.push(prefix + pop.path);
      if (!Array.isArray(pop.populate)) {
        continue;
      }
      _getPopulatedPaths(list, pop.populate, prefix + pop.path + ".");
    }
  }
  /*!
   * Module dependencies.
   */
  var CastError = require_cast();
  var DocumentNotFoundError = require_notFound();
  var Kareem = require_kareem();
  var MongooseError = require_mongooseError();
  var ObjectParameterError = require_objectParameter();
  var QueryCursor = require_queryCursor();
  var ValidationError = require_validation();
  var { applyGlobalMaxTimeMS, applyGlobalDiskUse } = require_applyGlobalOption();
  var handleReadPreferenceAliases = require_handleReadPreferenceAliases();
  var applyReadConcern = require_applyReadConcern();
  var applyWriteConcern = require_applyWriteConcern();
  var cast = require_cast2();
  var castArrayFilters = require_castArrayFilters();
  var castNumber = require_number();
  var castUpdate = require_castUpdate();
  var clone = require_clone2();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var helpers = require_queryHelpers();
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var isExclusive = require_isExclusive();
  var isInclusive = require_isInclusive();
  var isPathSelectedInclusive = require_isPathSelectedInclusive();
  var isSubpath = require_isSubpath();
  var mpath = require_mpath();
  var mquery = require_mquery();
  var parseProjection = require_parseProjection();
  var removeUnusedArrayFilters = require_removeUnusedArrayFilters();
  var sanitizeFilter = require_sanitizeFilter();
  var sanitizeProjection = require_sanitizeProjection();
  var selectPopulatedFields = require_selectPopulatedFields();
  var setDefaultsOnInsert = require_setDefaultsOnInsert();
  var specialProperties = require_specialProperties();
  var updateValidators = require_updateValidators();
  var util = import.meta.require("util");
  var utils = require_utils4();
  var queryMiddlewareFunctions = require_constants3().queryMiddlewareFunctions;
  var queryOptionMethods = new Set([
    "allowDiskUse",
    "batchSize",
    "collation",
    "comment",
    "explain",
    "hint",
    "j",
    "lean",
    "limit",
    "maxTimeMS",
    "populate",
    "projection",
    "read",
    "select",
    "skip",
    "slice",
    "sort",
    "tailable",
    "w",
    "writeConcern",
    "wtimeout"
  ]);
  var opToThunk = new Map([
    ["countDocuments", "_countDocuments"],
    ["distinct", "__distinct"],
    ["estimatedDocumentCount", "_estimatedDocumentCount"],
    ["find", "_find"],
    ["findOne", "_findOne"],
    ["findOneAndReplace", "_findOneAndReplace"],
    ["findOneAndUpdate", "_findOneAndUpdate"],
    ["replaceOne", "_replaceOne"],
    ["updateMany", "_updateMany"],
    ["updateOne", "_updateOne"],
    ["deleteMany", "_deleteMany"],
    ["deleteOne", "_deleteOne"],
    ["findOneAndDelete", "_findOneAndDelete"]
  ]);
  /*!
   * inherit mquery
   */
  Query.prototype = new mquery;
  Query.prototype.constructor = Query;
  Query.prototype.count = undefined;
  Query.prototype.findOneAndRemove = undefined;
  Query.base = mquery.prototype;
  /*!
   * Overwrite mquery's `_distinct`, because Mongoose uses that name
   * to store the field to apply distinct on.
   */
  Object.defineProperty(Query.prototype, "_distinct", {
    configurable: true,
    writable: true,
    enumerable: true,
    value: undefined
  });
  Query.use$geoWithin = mquery.use$geoWithin;
  Query.prototype.toConstructor = function toConstructor() {
    const model = this.model;
    const coll = this.mongooseCollection;
    const CustomQuery = function(criteria, options2) {
      if (!(this instanceof CustomQuery)) {
        return new CustomQuery(criteria, options2);
      }
      this._mongooseOptions = clone(p._mongooseOptions);
      Query.call(this, criteria, options2 || null, model, coll);
    };
    util.inherits(CustomQuery, model.Query);
    const p = CustomQuery.prototype;
    p.options = {};
    const options = Object.assign({}, this.options);
    if (options.sort != null) {
      p.sort(options.sort);
      delete options.sort;
    }
    p.setOptions(options);
    p.op = this.op;
    p._validateOp();
    p._conditions = clone(this._conditions);
    p._fields = clone(this._fields);
    p._update = clone(this._update, {
      flattenDecimals: false
    });
    p._path = this._path;
    p._distinct = this._distinct;
    p._collection = this._collection;
    p._mongooseOptions = this._mongooseOptions;
    return CustomQuery;
  };
  Query.prototype.clone = function() {
    const model = this.model;
    const collection = this.mongooseCollection;
    const q = new this.model.Query({}, {}, model, collection);
    const options = Object.assign({}, this.options);
    if (options.sort != null) {
      q.sort(options.sort);
      delete options.sort;
    }
    q.setOptions(options);
    q.op = this.op;
    q._validateOp();
    q._conditions = clone(this._conditions);
    q._fields = clone(this._fields);
    q._update = clone(this._update, {
      flattenDecimals: false
    });
    q._path = this._path;
    q._distinct = this._distinct;
    q._collection = this._collection;
    q._mongooseOptions = this._mongooseOptions;
    return q;
  };
  Query.prototype.slice = function() {
    if (arguments.length === 0) {
      return this;
    }
    this._validate("slice");
    let path;
    let val;
    if (arguments.length === 1) {
      const arg = arguments[0];
      if (typeof arg === "object" && !Array.isArray(arg)) {
        const keys = Object.keys(arg);
        const numKeys = keys.length;
        for (let i = 0;i < numKeys; ++i) {
          this.slice(keys[i], arg[keys[i]]);
        }
        return this;
      }
      this._ensurePath("slice");
      path = this._path;
      val = arguments[0];
    } else if (arguments.length === 2) {
      if (typeof arguments[0] === "number") {
        this._ensurePath("slice");
        path = this._path;
        val = [arguments[0], arguments[1]];
      } else {
        path = arguments[0];
        val = arguments[1];
      }
    } else if (arguments.length === 3) {
      path = arguments[0];
      val = [arguments[1], arguments[2]];
    }
    const p = {};
    p[path] = { $slice: val };
    this.select(p);
    return this;
  };
  /*!
   * ignore
   */
  var validOpsSet = new Set(queryMiddlewareFunctions);
  Query.prototype._validateOp = function() {
    if (this.op != null && !validOpsSet.has(this.op)) {
      this.error(new Error('Query has invalid `op`: "' + this.op + '"'));
    }
  };
  Query.prototype.mod = function() {
    let val;
    let path;
    if (arguments.length === 1) {
      this._ensurePath("mod");
      val = arguments[0];
      path = this._path;
    } else if (arguments.length === 2 && !Array.isArray(arguments[1])) {
      this._ensurePath("mod");
      val = [arguments[0], arguments[1]];
      path = this._path;
    } else if (arguments.length === 3) {
      val = [arguments[1], arguments[2]];
      path = arguments[0];
    } else {
      val = arguments[1];
      path = arguments[0];
    }
    const conds = this._conditions[path] || (this._conditions[path] = {});
    conds.$mod = val;
    return this;
  };
  Query.prototype.limit = function limit(v) {
    this._validate("limit");
    if (typeof v === "string") {
      try {
        v = castNumber(v);
      } catch (err) {
        throw new CastError("Number", v, "limit");
      }
    }
    this.options.limit = v;
    return this;
  };
  Query.prototype.skip = function skip(v) {
    this._validate("skip");
    if (typeof v === "string") {
      try {
        v = castNumber(v);
      } catch (err) {
        throw new CastError("Number", v, "skip");
      }
    }
    this.options.skip = v;
    return this;
  };
  Query.prototype.projection = function(arg) {
    if (arguments.length === 0) {
      return this._fields;
    }
    this._fields = {};
    this._userProvidedFields = {};
    this.select(arg);
    return this._fields;
  };
  Query.prototype.select = function select() {
    let arg = arguments[0];
    if (!arg)
      return this;
    if (arguments.length !== 1) {
      throw new Error("Invalid select: select only takes 1 argument");
    }
    this._validate("select");
    const fields = this._fields || (this._fields = {});
    const userProvidedFields = this._userProvidedFields || (this._userProvidedFields = {});
    let sanitizeProjection2 = undefined;
    if (this.model != null && utils.hasUserDefinedProperty(this.model.db.options, "sanitizeProjection")) {
      sanitizeProjection2 = this.model.db.options.sanitizeProjection;
    } else if (this.model != null && utils.hasUserDefinedProperty(this.model.base.options, "sanitizeProjection")) {
      sanitizeProjection2 = this.model.base.options.sanitizeProjection;
    } else {
      sanitizeProjection2 = this._mongooseOptions.sanitizeProjection;
    }
    function sanitizeValue(value) {
      return typeof value === "string" && sanitizeProjection2 ? value = 1 : value;
    }
    arg = parseProjection(arg, true);
    if (utils.isObject(arg)) {
      if (this.selectedInclusively()) {
        Object.entries(arg).forEach(([key, value]) => {
          if (value) {
            if (fields["-" + key] != null) {
              delete fields["-" + key];
            }
            fields[key] = userProvidedFields[key] = sanitizeValue(value);
          } else {
            Object.keys(userProvidedFields).forEach((field) => {
              if (isSubpath(key, field)) {
                delete fields[field];
                delete userProvidedFields[field];
              }
            });
          }
        });
      } else if (this.selectedExclusively()) {
        Object.entries(arg).forEach(([key, value]) => {
          if (!value) {
            if (fields["+" + key] != null) {
              delete fields["+" + key];
            }
            fields[key] = userProvidedFields[key] = sanitizeValue(value);
          } else {
            Object.keys(userProvidedFields).forEach((field) => {
              if (isSubpath(key, field)) {
                delete fields[field];
                delete userProvidedFields[field];
              }
            });
          }
        });
      } else {
        const keys = Object.keys(arg);
        for (let i = 0;i < keys.length; ++i) {
          const value = arg[keys[i]];
          const key = keys[i];
          fields[key] = sanitizeValue(value);
          userProvidedFields[key] = sanitizeValue(value);
        }
      }
      return this;
    }
    throw new TypeError("Invalid select() argument. Must be string or object.");
  };
  Query.prototype.schemaLevelProjections = function schemaLevelProjections(value) {
    this._mongooseOptions.schemaLevelProjections = value;
    return this;
  };
  Query.prototype.sanitizeProjection = function sanitizeProjection(value) {
    this._mongooseOptions.sanitizeProjection = value;
    return this;
  };
  Query.prototype.read = function read(mode, tags) {
    if (typeof mode === "string") {
      mode = handleReadPreferenceAliases(mode);
      this.options.readPreference = { mode, tags };
    } else {
      this.options.readPreference = mode;
    }
    return this;
  };
  Query.prototype.toString = function toString() {
    if (this.op === "count" || this.op === "countDocuments" || this.op === "find" || this.op === "findOne" || this.op === "deleteMany" || this.op === "deleteOne" || this.op === "findOneAndDelete" || this.op === "remove") {
      return `${this.model.modelName}.${this.op}(${util.inspect(this._conditions)})`;
    }
    if (this.op === "distinct") {
      return `${this.model.modelName}.distinct('${this._distinct}', ${util.inspect(this._conditions)})`;
    }
    if (this.op === "findOneAndReplace" || this.op === "findOneAndUpdate" || this.op === "replaceOne" || this.op === "update" || this.op === "updateMany" || this.op === "updateOne") {
      return `${this.model.modelName}.${this.op}(${util.inspect(this._conditions)}, ${util.inspect(this._update)})`;
    }
    return `${this.model.modelName}.${this.op}()`;
  };
  Query.prototype.session = function session(v) {
    if (v == null) {
      delete this.options.session;
    }
    this.options.session = v;
    return this;
  };
  Query.prototype.writeConcern = function writeConcern(val) {
    if (val == null) {
      delete this.options.writeConcern;
      return this;
    }
    this.options.writeConcern = val;
    return this;
  };
  Query.prototype.w = function w(val) {
    if (val == null) {
      delete this.options.w;
    }
    if (this.options.writeConcern != null) {
      this.options.writeConcern.w = val;
    } else {
      this.options.w = val;
    }
    return this;
  };
  Query.prototype.j = function j(val) {
    if (val == null) {
      delete this.options.j;
    }
    if (this.options.writeConcern != null) {
      this.options.writeConcern.j = val;
    } else {
      this.options.j = val;
    }
    return this;
  };
  Query.prototype.wtimeout = function wtimeout(ms) {
    if (ms == null) {
      delete this.options.wtimeout;
    }
    if (this.options.writeConcern != null) {
      this.options.writeConcern.wtimeout = ms;
    } else {
      this.options.wtimeout = ms;
    }
    return this;
  };
  Query.prototype.getOptions = function() {
    return this.options;
  };
  Query.prototype.setOptions = function(options, overwrite) {
    if (overwrite) {
      this._mongooseOptions = options && clone(options) || {};
      this.options = options || {};
      if ("populate" in options) {
        this.populate(this._mongooseOptions);
      }
      return this;
    }
    if (options == null) {
      return this;
    }
    if (typeof options !== "object") {
      throw new Error('Options must be an object, got "' + options + '"');
    }
    options = Object.assign({}, options);
    if (Array.isArray(options.populate)) {
      const populate = options.populate;
      delete options.populate;
      const _numPopulate = populate.length;
      for (let i = 0;i < _numPopulate; ++i) {
        this.populate(populate[i]);
      }
    }
    if ("setDefaultsOnInsert" in options) {
      this._mongooseOptions.setDefaultsOnInsert = options.setDefaultsOnInsert;
      delete options.setDefaultsOnInsert;
    }
    if ("overwriteDiscriminatorKey" in options) {
      this._mongooseOptions.overwriteDiscriminatorKey = options.overwriteDiscriminatorKey;
      delete options.overwriteDiscriminatorKey;
    }
    if ("overwriteImmutable" in options) {
      this._mongooseOptions.overwriteImmutable = options.overwriteImmutable;
      delete options.overwriteImmutable;
    }
    if ("sanitizeProjection" in options) {
      if (options.sanitizeProjection && !this._mongooseOptions.sanitizeProjection) {
        sanitizeProjection(this._fields);
      }
      this._mongooseOptions.sanitizeProjection = options.sanitizeProjection;
      delete options.sanitizeProjection;
    }
    if ("sanitizeFilter" in options) {
      this._mongooseOptions.sanitizeFilter = options.sanitizeFilter;
      delete options.sanitizeFilter;
    }
    if ("timestamps" in options) {
      this._mongooseOptions.timestamps = options.timestamps;
      delete options.timestamps;
    }
    if ("defaults" in options) {
      this._mongooseOptions.defaults = options.defaults;
    }
    if ("translateAliases" in options) {
      this._mongooseOptions.translateAliases = options.translateAliases;
      delete options.translateAliases;
    }
    if ("schemaLevelProjections" in options) {
      this._mongooseOptions.schemaLevelProjections = options.schemaLevelProjections;
      delete options.schemaLevelProjections;
    }
    if (options.lean == null && this.schema && "lean" in this.schema.options) {
      this._mongooseOptions.lean = this.schema.options.lean;
    }
    if (typeof options.limit === "string") {
      try {
        options.limit = castNumber(options.limit);
      } catch (err) {
        throw new CastError("Number", options.limit, "limit");
      }
    }
    if (typeof options.skip === "string") {
      try {
        options.skip = castNumber(options.skip);
      } catch (err) {
        throw new CastError("Number", options.skip, "skip");
      }
    }
    for (const key of Object.keys(options)) {
      if (queryOptionMethods.has(key)) {
        const args = Array.isArray(options[key]) ? options[key] : [options[key]];
        this[key].apply(this, args);
      } else {
        this.options[key] = options[key];
      }
    }
    return this;
  };
  Query.prototype.explain = function explain(verbose) {
    if (arguments.length === 0) {
      this.options.explain = true;
    } else if (verbose === false) {
      delete this.options.explain;
    } else {
      this.options.explain = verbose;
    }
    return this;
  };
  Query.prototype.allowDiskUse = function(v) {
    if (arguments.length === 0) {
      this.options.allowDiskUse = true;
    } else if (v === false) {
      delete this.options.allowDiskUse;
    } else {
      this.options.allowDiskUse = v;
    }
    return this;
  };
  Query.prototype.maxTimeMS = function(ms) {
    this.options.maxTimeMS = ms;
    return this;
  };
  Query.prototype.getFilter = function() {
    return this._conditions;
  };
  Query.prototype.getQuery = function() {
    return this._conditions;
  };
  Query.prototype.setQuery = function(val) {
    this._conditions = val;
  };
  Query.prototype.getUpdate = function() {
    return this._update;
  };
  Query.prototype.setUpdate = function(val) {
    this._update = val;
  };
  Query.prototype._fieldsForExec = function() {
    if (this._fields == null) {
      return null;
    }
    if (Object.keys(this._fields).length === 0) {
      return null;
    }
    return clone(this._fields);
  };
  Query.prototype._updateForExec = function() {
    const update = clone(this._update, {
      transform: false,
      depopulate: true
    });
    const ops = Object.keys(update);
    let i = ops.length;
    const ret = {};
    while (i--) {
      const op = ops[i];
      if (op[0] !== "$") {
        if (!ret.$set) {
          if (update.$set) {
            ret.$set = update.$set;
          } else {
            ret.$set = {};
          }
        }
        ret.$set[op] = update[op];
        ops.splice(i, 1);
        if (!~ops.indexOf("$set"))
          ops.push("$set");
      } else if (op === "$set") {
        if (!ret.$set) {
          ret[op] = update[op];
        }
      } else {
        ret[op] = update[op];
      }
    }
    return ret;
  };
  Query.prototype._optionsForExec = function(model) {
    const options = clone(this.options);
    delete options.populate;
    model = model || this.model;
    if (!model) {
      return options;
    }
    applyReadConcern(model.schema, options);
    applyWriteConcern(model.schema, options);
    const asyncLocalStorage = this.model?.db?.base.transactionAsyncLocalStorage?.getStore();
    if (!this.options.hasOwnProperty("session") && asyncLocalStorage?.session != null) {
      options.session = asyncLocalStorage.session;
    }
    const readPreference = model && model.schema && model.schema.options && model.schema.options.read;
    if (!("readPreference" in options) && readPreference) {
      options.readPreference = readPreference;
    }
    if (options.upsert !== undefined) {
      options.upsert = !!options.upsert;
    }
    if (options.writeConcern) {
      if (options.j) {
        options.writeConcern.j = options.j;
        delete options.j;
      }
      if (options.w) {
        options.writeConcern.w = options.w;
        delete options.w;
      }
      if (options.wtimeout) {
        options.writeConcern.wtimeout = options.wtimeout;
        delete options.wtimeout;
      }
    }
    this._applyPaths();
    if (this._fields != null) {
      this._fields = this._castFields(this._fields);
      const projection = this._fieldsForExec();
      if (projection != null) {
        options.projection = projection;
      }
    }
    return options;
  };
  Query.prototype.lean = function(v) {
    this._mongooseOptions.lean = arguments.length ? v : true;
    return this;
  };
  Query.prototype.set = function(path, val) {
    if (typeof path === "object") {
      const keys = Object.keys(path);
      for (const key of keys) {
        this.set(key, path[key]);
      }
      return this;
    }
    this._update = this._update || {};
    if (path in this._update) {
      delete this._update[path];
    }
    this._update.$set = this._update.$set || {};
    this._update.$set[path] = val;
    return this;
  };
  Query.prototype.get = function get(path) {
    const update = this._update;
    if (update == null) {
      return;
    }
    const $set = update.$set;
    if ($set == null) {
      return update[path];
    }
    if (utils.hasUserDefinedProperty(update, path)) {
      return update[path];
    }
    if (utils.hasUserDefinedProperty($set, path)) {
      return $set[path];
    }
    return;
  };
  Query.prototype.error = function error(err) {
    if (arguments.length === 0) {
      return this._error;
    }
    this._error = err;
    return this;
  };
  Query.prototype._unsetCastError = function _unsetCastError() {
    if (this._error == null || !(this._error instanceof CastError)) {
      return;
    }
    return this.error(null);
  };
  Query.prototype.mongooseOptions = function(v) {
    if (arguments.length > 0) {
      this._mongooseOptions = v;
    }
    return this._mongooseOptions;
  };
  Query.prototype._castConditions = function() {
    let sanitizeFilterOpt = undefined;
    if (this.model?.db.options?.sanitizeFilter != null) {
      sanitizeFilterOpt = this.model.db.options.sanitizeFilter;
    } else if (this.model?.base.options?.sanitizeFilter != null) {
      sanitizeFilterOpt = this.model.base.options.sanitizeFilter;
    } else {
      sanitizeFilterOpt = this._mongooseOptions.sanitizeFilter;
    }
    if (sanitizeFilterOpt) {
      sanitizeFilter(this._conditions);
    }
    try {
      this.cast(this.model);
      this._unsetCastError();
    } catch (err) {
      this.error(err);
    }
  };
  /*!
   * ignore
   */
  Query.prototype._find = async function _find() {
    this._applyTranslateAliases();
    this._castConditions();
    if (this.error() != null) {
      throw this.error();
    }
    const mongooseOptions = this._mongooseOptions;
    const userProvidedFields = this._userProvidedFields || {};
    applyGlobalMaxTimeMS(this.options, this.model.db.options, this.model.base.options);
    applyGlobalDiskUse(this.options, this.model.db.options, this.model.base.options);
    const completeManyOptions = {
      session: this && this.options && this.options.session || null,
      lean: mongooseOptions.lean || null
    };
    const options = this._optionsForExec();
    const filter = this._conditions;
    const fields = options.projection;
    const cursor = await this.mongooseCollection.find(filter, options);
    if (options.explain) {
      return cursor.explain();
    }
    let docs = await cursor.toArray();
    if (docs.length === 0) {
      return docs;
    }
    if (!mongooseOptions.populate) {
      const versionKey = this.schema.options.versionKey;
      if (mongooseOptions.lean && mongooseOptions.lean.versionKey === false && versionKey) {
        docs.forEach((doc) => {
          if (versionKey in doc) {
            delete doc[versionKey];
          }
        });
      }
      return mongooseOptions.lean ? _completeManyLean(this.model.schema, docs, null, completeManyOptions) : this._completeMany(docs, fields, userProvidedFields, completeManyOptions);
    }
    const pop = helpers.preparePopulationOptionsMQ(this, mongooseOptions);
    if (mongooseOptions.lean) {
      return this.model.populate(docs, pop);
    }
    docs = await this._completeMany(docs, fields, userProvidedFields, completeManyOptions);
    await this.model.populate(docs, pop);
    return docs;
  };
  Query.prototype.find = function(conditions) {
    if (typeof conditions === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Query.prototype.find() no longer accepts a callback");
    }
    this.op = "find";
    if (mquery.canMerge(conditions)) {
      this.merge(conditions);
      prepareDiscriminatorCriteria(this);
    } else if (conditions != null) {
      this.error(new ObjectParameterError(conditions, "filter", "find"));
    }
    return this;
  };
  Query.prototype.merge = function(source) {
    if (!source) {
      return this;
    }
    const opts = { overwrite: true };
    if (source instanceof Query) {
      if (source._conditions) {
        opts.omit = {};
        if (this._conditions && this._conditions.$and && source._conditions.$and) {
          opts.omit["$and"] = true;
          this._conditions.$and = this._conditions.$and.concat(source._conditions.$and);
        }
        if (this._conditions && this._conditions.$or && source._conditions.$or) {
          opts.omit["$or"] = true;
          this._conditions.$or = this._conditions.$or.concat(source._conditions.$or);
        }
        utils.merge(this._conditions, source._conditions, opts);
      }
      if (source._fields) {
        this._fields || (this._fields = {});
        utils.merge(this._fields, source._fields, opts);
      }
      if (source.options) {
        this.options || (this.options = {});
        utils.merge(this.options, source.options, opts);
      }
      if (source._update) {
        this._update || (this._update = {});
        utils.mergeClone(this._update, source._update);
      }
      if (source._distinct) {
        this._distinct = source._distinct;
      }
      utils.merge(this._mongooseOptions, source._mongooseOptions);
      return this;
    } else if (this.model != null && source instanceof this.model.base.Types.ObjectId) {
      utils.merge(this._conditions, { _id: source }, opts);
      return this;
    } else if (source && source.$__) {
      source = source.toObject(internalToObjectOptions);
    }
    opts.omit = {};
    if (Array.isArray(source.$and)) {
      opts.omit["$and"] = true;
      if (!this._conditions) {
        this._conditions = {};
      }
      this._conditions.$and = (this._conditions.$and || []).concat(source.$and.map((el) => utils.isPOJO(el) ? utils.merge({}, el) : el));
    }
    if (Array.isArray(source.$or)) {
      opts.omit["$or"] = true;
      if (!this._conditions) {
        this._conditions = {};
      }
      this._conditions.$or = (this._conditions.$or || []).concat(source.$or.map((el) => utils.isPOJO(el) ? utils.merge({}, el) : el));
    }
    utils.merge(this._conditions, source, opts);
    return this;
  };
  Query.prototype.collation = function(value) {
    if (this.options == null) {
      this.options = {};
    }
    this.options.collation = value;
    return this;
  };
  Query.prototype._completeOne = function(doc, res, projection, callback) {
    if (!doc && !this.options.includeResultMetadata) {
      return callback(null, null);
    }
    const model = this.model;
    const userProvidedFields = this._userProvidedFields || {};
    const mongooseOptions = this._mongooseOptions;
    const options = this.options;
    if (!options.lean && mongooseOptions.lean) {
      options.lean = mongooseOptions.lean;
    }
    if (options.explain) {
      return callback(null, doc);
    }
    if (!mongooseOptions.populate) {
      const versionKey = this.schema.options.versionKey;
      if (mongooseOptions.lean && mongooseOptions.lean.versionKey === false && versionKey) {
        if (versionKey in doc) {
          delete doc[versionKey];
        }
      }
      return mongooseOptions.lean ? _completeOneLean(model.schema, doc, null, res, options, callback) : completeOne(model, doc, res, options, projection, userProvidedFields, null, callback);
    }
    const pop = helpers.preparePopulationOptionsMQ(this, this._mongooseOptions);
    if (mongooseOptions.lean) {
      return model.populate(doc, pop).then((doc2) => {
        _completeOneLean(model.schema, doc2, null, res, options, callback);
      }, (error) => {
        callback(error);
      });
    }
    completeOne(model, doc, res, options, projection, userProvidedFields, [], (err, doc2) => {
      if (err != null) {
        return callback(err);
      }
      model.populate(doc2, pop).then((res2) => {
        callback(null, res2);
      }, (err2) => {
        callback(err2);
      });
    });
  };
  Query.prototype._completeMany = async function _completeMany(docs, fields, userProvidedFields, opts) {
    const model = this.model;
    return Promise.all(docs.map((doc) => new Promise((resolve, reject) => {
      const rawDoc = doc;
      doc = helpers.createModel(model, doc, fields, userProvidedFields);
      if (opts.session != null) {
        doc.$session(opts.session);
      }
      doc.$init(rawDoc, opts, (err) => {
        if (err != null) {
          return reject(err);
        }
        resolve(doc);
      });
    })));
  };
  Query.prototype._findOne = async function _findOne() {
    this._applyTranslateAliases();
    this._castConditions();
    if (this.error()) {
      const err = this.error();
      throw err;
    }
    applyGlobalMaxTimeMS(this.options, this.model.db.options, this.model.base.options);
    applyGlobalDiskUse(this.options, this.model.db.options, this.model.base.options);
    const options = this._optionsForExec();
    const doc = await this.mongooseCollection.findOne(this._conditions, options);
    return new Promise((resolve, reject) => {
      this._completeOne(doc, null, options.projection, (err, res) => {
        if (err) {
          return reject(err);
        }
        resolve(res);
      });
    });
  };
  Query.prototype.findOne = function(conditions, projection, options) {
    if (typeof conditions === "function" || typeof projection === "function" || typeof options === "function" || typeof arguments[3] === "function") {
      throw new MongooseError("Query.prototype.findOne() no longer accepts a callback");
    }
    this.op = "findOne";
    this._validateOp();
    if (options) {
      this.setOptions(options);
    }
    if (projection) {
      this.select(projection);
    }
    if (mquery.canMerge(conditions)) {
      this.merge(conditions);
      prepareDiscriminatorCriteria(this);
    } else if (conditions != null) {
      this.error(new ObjectParameterError(conditions, "filter", "findOne"));
    }
    return this;
  };
  Query.prototype._countDocuments = async function _countDocuments() {
    this._applyTranslateAliases();
    try {
      this.cast(this.model);
    } catch (err) {
      this.error(err);
    }
    if (this.error()) {
      throw this.error();
    }
    applyGlobalMaxTimeMS(this.options, this.model.db.options, this.model.base.options);
    applyGlobalDiskUse(this.options, this.model.db.options, this.model.base.options);
    const options = this._optionsForExec();
    const conds = this._conditions;
    return this.mongooseCollection.countDocuments(conds, options);
  };
  /*!
   * If `translateAliases` option is set, call `Model.translateAliases()`
   * on the following query properties: filter, projection, update, distinct.
   */
  Query.prototype._applyTranslateAliases = function _applyTranslateAliases() {
    let applyTranslateAliases = false;
    if ("translateAliases" in this._mongooseOptions) {
      applyTranslateAliases = this._mongooseOptions.translateAliases;
    } else if (this.model?.schema?._userProvidedOptions?.translateAliases != null) {
      applyTranslateAliases = this.model.schema._userProvidedOptions.translateAliases;
    } else if (this.model?.base?.options?.translateAliases != null) {
      applyTranslateAliases = this.model.base.options.translateAliases;
    }
    if (!applyTranslateAliases) {
      return;
    }
    if (this.model?.schema?.aliases && Object.keys(this.model.schema.aliases).length > 0) {
      this.model.translateAliases(this._conditions, true);
      this.model.translateAliases(this._fields, true);
      this.model.translateAliases(this._update, true);
      if (this._distinct != null && this.model.schema.aliases[this._distinct] != null) {
        this._distinct = this.model.schema.aliases[this._distinct];
      }
    }
  };
  Query.prototype._estimatedDocumentCount = async function _estimatedDocumentCount() {
    if (this.error()) {
      throw this.error();
    }
    const options = this._optionsForExec();
    return this.mongooseCollection.estimatedDocumentCount(options);
  };
  Query.prototype.estimatedDocumentCount = function(options) {
    if (typeof options === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Query.prototype.estimatedDocumentCount() no longer accepts a callback");
    }
    this.op = "estimatedDocumentCount";
    this._validateOp();
    if (options != null) {
      this.setOptions(options);
    }
    return this;
  };
  Query.prototype.countDocuments = function(conditions, options) {
    if (typeof conditions === "function" || typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Query.prototype.countDocuments() no longer accepts a callback");
    }
    this.op = "countDocuments";
    this._validateOp();
    if (mquery.canMerge(conditions)) {
      this.merge(conditions);
    }
    if (options != null) {
      this.setOptions(options);
    }
    return this;
  };
  Query.prototype.__distinct = async function __distinct() {
    this._applyTranslateAliases();
    this._castConditions();
    if (this.error()) {
      throw this.error();
    }
    applyGlobalMaxTimeMS(this.options, this.model.db.options, this.model.base.options);
    applyGlobalDiskUse(this.options, this.model.db.options, this.model.base.options);
    const options = this._optionsForExec();
    return this.mongooseCollection.distinct(this._distinct, this._conditions, options);
  };
  Query.prototype.distinct = function(field, conditions, options) {
    if (typeof field === "function" || typeof conditions === "function" || typeof options === "function" || typeof arguments[3] === "function") {
      throw new MongooseError("Query.prototype.distinct() no longer accepts a callback");
    }
    this.op = "distinct";
    this._validateOp();
    if (mquery.canMerge(conditions)) {
      this.merge(conditions);
      prepareDiscriminatorCriteria(this);
    } else if (conditions != null) {
      this.error(new ObjectParameterError(conditions, "filter", "distinct"));
    }
    if (field != null) {
      this._distinct = field;
    }
    if (options != null) {
      this.setOptions(options);
    }
    return this;
  };
  Query.prototype.sort = function(arg, options) {
    if (arguments.length > 2) {
      throw new Error("sort() takes at most 2 arguments");
    }
    if (options != null && typeof options !== "object") {
      throw new Error("sort() options argument must be an object or nullish");
    }
    if (this.options.sort == null) {
      this.options.sort = {};
    }
    if (options && options.override) {
      this.options.sort = {};
    }
    const sort = this.options.sort;
    if (typeof arg === "string") {
      const properties = arg.indexOf(" ") === -1 ? [arg] : arg.split(" ");
      for (let property of properties) {
        const ascend = property[0] == "-" ? -1 : 1;
        if (ascend === -1) {
          property = property.slice(1);
        }
        if (specialProperties.has(property)) {
          continue;
        }
        sort[property] = ascend;
      }
    } else if (Array.isArray(arg)) {
      for (const pair of arg) {
        if (!Array.isArray(pair)) {
          throw new TypeError("Invalid sort() argument, must be array of arrays");
        }
        const key = "" + pair[0];
        if (specialProperties.has(key)) {
          continue;
        }
        sort[key] = _handleSortValue(pair[1], key);
      }
    } else if (typeof arg === "object" && arg != null && !(arg instanceof Map)) {
      for (const key of Object.keys(arg)) {
        if (specialProperties.has(key)) {
          continue;
        }
        sort[key] = _handleSortValue(arg[key], key);
      }
    } else if (arg instanceof Map) {
      for (let key of arg.keys()) {
        key = "" + key;
        if (specialProperties.has(key)) {
          continue;
        }
        sort[key] = _handleSortValue(arg.get(key), key);
      }
    } else if (arg != null) {
      throw new TypeError("Invalid sort() argument. Must be a string, object, array, or map.");
    }
    return this;
  };
  /*!
   * Convert sort values
   */
  Query.prototype.deleteOne = function deleteOne(filter, options) {
    if (typeof filter === "function" || typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Query.prototype.deleteOne() no longer accepts a callback");
    }
    this.op = "deleteOne";
    this.setOptions(options);
    if (mquery.canMerge(filter)) {
      this.merge(filter);
      prepareDiscriminatorCriteria(this);
    } else if (filter != null) {
      this.error(new ObjectParameterError(filter, "filter", "deleteOne"));
    }
    return this;
  };
  Query.prototype._deleteOne = async function _deleteOne() {
    this._applyTranslateAliases();
    this._castConditions();
    if (this.error() != null) {
      throw this.error();
    }
    const options = this._optionsForExec();
    return this.mongooseCollection.deleteOne(this._conditions, options);
  };
  Query.prototype.deleteMany = function(filter, options) {
    if (typeof filter === "function" || typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Query.prototype.deleteMany() no longer accepts a callback");
    }
    this.setOptions(options);
    this.op = "deleteMany";
    if (mquery.canMerge(filter)) {
      this.merge(filter);
      prepareDiscriminatorCriteria(this);
    } else if (filter != null) {
      this.error(new ObjectParameterError(filter, "filter", "deleteMany"));
    }
    return this;
  };
  Query.prototype._deleteMany = async function _deleteMany() {
    this._applyTranslateAliases();
    this._castConditions();
    if (this.error() != null) {
      throw this.error();
    }
    const options = this._optionsForExec();
    return this.mongooseCollection.deleteMany(this._conditions, options);
  };
  Query.prototype.findOneAndUpdate = function(filter, doc, options) {
    if (typeof filter === "function" || typeof doc === "function" || typeof options === "function" || typeof arguments[3] === "function") {
      throw new MongooseError("Query.prototype.findOneAndUpdate() no longer accepts a callback");
    }
    this.op = "findOneAndUpdate";
    this._validateOp();
    this._validate();
    switch (arguments.length) {
      case 2:
        options = undefined;
        break;
      case 1:
        doc = filter;
        filter = options = undefined;
        break;
    }
    if (mquery.canMerge(filter)) {
      this.merge(filter);
    } else if (filter != null) {
      this.error(new ObjectParameterError(filter, "filter", "findOneAndUpdate"));
    }
    if (doc) {
      this._mergeUpdate(doc);
    }
    options = options ? clone(options) : {};
    if (options.projection) {
      this.select(options.projection);
      delete options.projection;
    }
    if (options.fields) {
      this.select(options.fields);
      delete options.fields;
    }
    const returnOriginal = this && this.model && this.model.base && this.model.base.options && this.model.base.options.returnOriginal;
    if (options.new == null && options.returnDocument == null && options.returnOriginal == null && returnOriginal != null) {
      options.returnOriginal = returnOriginal;
    }
    this.setOptions(options);
    return this;
  };
  Query.prototype._findOneAndUpdate = async function _findOneAndUpdate() {
    this._applyTranslateAliases();
    this._castConditions();
    _castArrayFilters(this);
    if (this.error()) {
      throw this.error();
    }
    applyGlobalMaxTimeMS(this.options, this.model.db.options, this.model.base.options);
    applyGlobalDiskUse(this.options, this.model.db.options, this.model.base.options);
    if ("strict" in this.options) {
      this._mongooseOptions.strict = this.options.strict;
    }
    const options = this._optionsForExec(this.model);
    convertNewToReturnDocument(options);
    this._update = this._castUpdate(this._update);
    const _opts = Object.assign({}, options, {
      setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert
    });
    this._update = setDefaultsOnInsert(this._conditions, this.model.schema, this._update, _opts);
    if (!this._update || Object.keys(this._update).length === 0) {
      if (options.upsert) {
        const $set = clone(this._update);
        delete $set._id;
        this._update = { $set };
      } else {
        this._executionStack = null;
        const res2 = await this._findOne();
        return res2;
      }
    } else if (this._update instanceof Error) {
      throw this._update;
    } else {
      if (this._update.$set && Object.keys(this._update.$set).length === 0) {
        delete this._update.$set;
      }
    }
    const runValidators = _getOption(this, "runValidators", false);
    if (runValidators) {
      await this.validate(this._update, options, false);
    }
    if (this._update.toBSON) {
      this._update = this._update.toBSON();
    }
    let res = await this.mongooseCollection.findOneAndUpdate(this._conditions, this._update, options);
    for (const fn of this._transforms) {
      res = fn(res);
    }
    const doc = !options.includeResultMetadata ? res : res.value;
    return new Promise((resolve, reject) => {
      this._completeOne(doc, res, options.projection, (err, res2) => {
        if (err) {
          return reject(err);
        }
        resolve(res2);
      });
    });
  };
  Query.prototype.findOneAndDelete = function(filter, options) {
    if (typeof filter === "function" || typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Query.prototype.findOneAndDelete() no longer accepts a callback");
    }
    this.op = "findOneAndDelete";
    this._validateOp();
    this._validate();
    if (mquery.canMerge(filter)) {
      this.merge(filter);
    }
    options && this.setOptions(options);
    return this;
  };
  Query.prototype._findOneAndDelete = async function _findOneAndDelete() {
    this._applyTranslateAliases();
    this._castConditions();
    if (this.error() != null) {
      throw this.error();
    }
    const includeResultMetadata = this.options.includeResultMetadata;
    const filter = this._conditions;
    const options = this._optionsForExec(this.model);
    let res = await this.mongooseCollection.findOneAndDelete(filter, options);
    for (const fn of this._transforms) {
      res = fn(res);
    }
    const doc = !includeResultMetadata ? res : res.value;
    return new Promise((resolve, reject) => {
      this._completeOne(doc, res, options.projection, (err, res2) => {
        if (err) {
          return reject(err);
        }
        resolve(res2);
      });
    });
  };
  Query.prototype.findOneAndReplace = function(filter, replacement, options) {
    if (typeof filter === "function" || typeof replacement === "function" || typeof options === "function" || typeof arguments[4] === "function") {
      throw new MongooseError("Query.prototype.findOneAndReplace() no longer accepts a callback");
    }
    this.op = "findOneAndReplace";
    this._validateOp();
    this._validate();
    if (mquery.canMerge(filter)) {
      this.merge(filter);
    } else if (filter != null) {
      this.error(new ObjectParameterError(filter, "filter", "findOneAndReplace"));
    }
    if (replacement != null) {
      this._mergeUpdate(replacement);
    }
    options = options || {};
    const returnOriginal = this && this.model && this.model.base && this.model.base.options && this.model.base.options.returnOriginal;
    if (options.new == null && options.returnDocument == null && options.returnOriginal == null && returnOriginal != null) {
      options.returnOriginal = returnOriginal;
    }
    this.setOptions(options);
    return this;
  };
  Query.prototype._findOneAndReplace = async function _findOneAndReplace() {
    this._applyTranslateAliases();
    this._castConditions();
    if (this.error() != null) {
      throw this.error();
    }
    if ("strict" in this.options) {
      this._mongooseOptions.strict = this.options.strict;
      delete this.options.strict;
    }
    const filter = this._conditions;
    const options = this._optionsForExec();
    convertNewToReturnDocument(options);
    const includeResultMetadata = this.options.includeResultMetadata;
    const modelOpts = { skipId: true };
    if ("strict" in this._mongooseOptions) {
      modelOpts.strict = this._mongooseOptions.strict;
    }
    const runValidators = _getOption(this, "runValidators", false);
    try {
      const update = new this.model(this._update, null, modelOpts);
      if (runValidators) {
        await update.validate();
      } else if (update.$__.validationError) {
        throw update.$__.validationError;
      }
      this._update = update.toBSON();
    } catch (err) {
      if (err instanceof ValidationError) {
        throw err;
      }
      const validationError = new ValidationError;
      validationError.errors[err.path] = err;
      throw validationError;
    }
    let res = await this.mongooseCollection.findOneAndReplace(filter, this._update, options);
    for (const fn of this._transforms) {
      res = fn(res);
    }
    const doc = !includeResultMetadata ? res : res.value;
    return new Promise((resolve, reject) => {
      this._completeOne(doc, res, options.projection, (err, res2) => {
        if (err) {
          return reject(err);
        }
        resolve(res2);
      });
    });
  };
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  Query.prototype._mergeUpdate = function(doc) {
    if (!this._update) {
      this._update = Array.isArray(doc) ? [] : {};
    }
    if (doc == null || typeof doc === "object" && Object.keys(doc).length === 0) {
      return;
    }
    if (doc instanceof Query) {
      if (Array.isArray(this._update)) {
        throw new Error("Cannot mix array and object updates");
      }
      if (doc._update) {
        utils.mergeClone(this._update, doc._update);
      }
    } else if (Array.isArray(doc)) {
      if (!Array.isArray(this._update)) {
        throw new Error("Cannot mix array and object updates");
      }
      this._update = this._update.concat(doc);
    } else {
      if (Array.isArray(this._update)) {
        throw new Error("Cannot mix array and object updates");
      }
      utils.mergeClone(this._update, doc);
    }
  };
  /*!
   * ignore
   */
  Query.prototype.validate = async function validate(castedDoc, options, isOverwriting) {
    if (typeof arguments[3] === "function") {
      throw new MongooseError("Query.prototype.validate() no longer accepts a callback");
    }
    await _executePreHooks(this, "validate");
    if (isOverwriting) {
      await castedDoc.$validate();
    } else {
      await new Promise((resolve, reject) => {
        updateValidators(this, this.model.schema, castedDoc, options, (err) => {
          if (err != null) {
            return reject(err);
          }
          resolve();
        });
      });
    }
    await _executePostHooks(this, null, null, "validate");
  };
  Query.prototype._updateMany = async function _updateMany() {
    return _updateThunk.call(this, "updateMany");
  };
  Query.prototype._updateOne = async function _updateOne() {
    return _updateThunk.call(this, "updateOne");
  };
  Query.prototype._replaceOne = async function _replaceOne() {
    return _updateThunk.call(this, "replaceOne");
  };
  Query.prototype.updateMany = function(conditions, doc, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    } else if (typeof doc === "function") {
      callback = doc;
      doc = conditions;
      conditions = {};
      options = null;
    } else if (typeof conditions === "function") {
      callback = conditions;
      conditions = undefined;
      doc = undefined;
      options = undefined;
    } else if (typeof conditions === "object" && !doc && !options && !callback) {
      doc = conditions;
      conditions = undefined;
      options = undefined;
      callback = undefined;
    }
    return _update(this, "updateMany", conditions, doc, options, callback);
  };
  Query.prototype.updateOne = function(conditions, doc, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    } else if (typeof doc === "function") {
      callback = doc;
      doc = conditions;
      conditions = {};
      options = null;
    } else if (typeof conditions === "function") {
      callback = conditions;
      conditions = undefined;
      doc = undefined;
      options = undefined;
    } else if (typeof conditions === "object" && !doc && !options && !callback) {
      doc = conditions;
      conditions = undefined;
      options = undefined;
      callback = undefined;
    }
    return _update(this, "updateOne", conditions, doc, options, callback);
  };
  Query.prototype.replaceOne = function(conditions, doc, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = null;
    } else if (typeof doc === "function") {
      callback = doc;
      doc = conditions;
      conditions = {};
      options = null;
    } else if (typeof conditions === "function") {
      callback = conditions;
      conditions = undefined;
      doc = undefined;
      options = undefined;
    } else if (typeof conditions === "object" && !doc && !options && !callback) {
      doc = conditions;
      conditions = undefined;
      options = undefined;
      callback = undefined;
    }
    return _update(this, "replaceOne", conditions, doc, options, callback);
  };
  Query.prototype.transform = function(fn) {
    this._transforms.push(fn);
    return this;
  };
  Query.prototype.orFail = function(err) {
    this.transform((res) => {
      switch (this.op) {
        case "find":
          if (res.length === 0) {
            throw _orFailError(err, this);
          }
          break;
        case "findOne":
          if (res == null) {
            throw _orFailError(err, this);
          }
          break;
        case "replaceOne":
        case "updateMany":
        case "updateOne":
          if (res && res.matchedCount === 0) {
            throw _orFailError(err, this);
          }
          break;
        case "findOneAndDelete":
        case "findOneAndUpdate":
        case "findOneAndReplace":
          if (this.options.includeResultMetadata && res != null && res.value == null) {
            throw _orFailError(err, this);
          }
          if (!this.options.includeResultMetadata && res == null) {
            throw _orFailError(err, this);
          }
          break;
        case "deleteMany":
        case "deleteOne":
          if (res.deletedCount === 0) {
            throw _orFailError(err, this);
          }
          break;
        default:
          break;
      }
      return res;
    });
    return this;
  };
  Query.prototype.isPathSelectedInclusive = function(path) {
    return isPathSelectedInclusive(this._fields, path);
  };
  Query.prototype.exec = async function exec(op) {
    if (typeof op === "function" || arguments.length >= 2 && typeof arguments[1] === "function") {
      throw new MongooseError("Query.prototype.exec() no longer accepts a callback");
    }
    if (typeof op === "string") {
      this.op = op;
    }
    if (this.op == null) {
      throw new MongooseError("Query must have `op` before executing");
    }
    if (this.model == null) {
      throw new MongooseError("Query must have an associated model before executing");
    }
    const thunk = opToThunk.get(this.op);
    if (!thunk) {
      throw new MongooseError('Query has invalid `op`: "' + this.op + '"');
    }
    if (this.options && this.options.sort && typeof this.options.sort === "object" && this.options.sort.hasOwnProperty("")) {
      throw new Error('Invalid field "" passed to sort()');
    }
    if (this._executionStack != null) {
      let str = this.toString();
      if (str.length > 60) {
        str = str.slice(0, 60) + "...";
      }
      const err = new MongooseError("Query was already executed: " + str);
      err.originalStack = this._executionStack;
      throw err;
    } else {
      this._executionStack = new Error().stack;
    }
    let skipWrappedFunction = null;
    try {
      await _executePreExecHooks(this);
    } catch (err) {
      if (err instanceof Kareem.skipWrappedFunction) {
        skipWrappedFunction = err;
      } else {
        throw err;
      }
    }
    let res;
    let error = null;
    try {
      await _executePreHooks(this);
      res = skipWrappedFunction ? skipWrappedFunction.args[0] : await this[thunk]();
      for (const fn of this._transforms) {
        res = fn(res);
      }
    } catch (err) {
      if (err instanceof Kareem.skipWrappedFunction) {
        res = err.args[0];
      } else {
        error = err;
      }
      error = this.model.schema._transformDuplicateKeyError(error);
    }
    res = await _executePostHooks(this, res, error);
    await _executePostExecHooks(this);
    return res;
  };
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  Query.prototype.then = function(resolve, reject) {
    return this.exec().then(resolve, reject);
  };
  Query.prototype.catch = function(reject) {
    return this.exec().then(null, reject);
  };
  Query.prototype.finally = function(onFinally) {
    return this.exec().finally(onFinally);
  };
  Query.prototype[Symbol.toStringTag] = function toString() {
    return `Query { ${this.op} }`;
  };
  Query.prototype.pre = function(fn) {
    this._hooks.pre("exec", fn);
    return this;
  };
  Query.prototype.post = function(fn) {
    this._hooks.post("exec", fn);
    return this;
  };
  Query.prototype._castUpdate = function _castUpdate(obj) {
    let schema = this.schema;
    const discriminatorKey = schema.options.discriminatorKey;
    const baseSchema = schema._baseSchema ? schema._baseSchema : schema;
    if (this._mongooseOptions.overwriteDiscriminatorKey && obj[discriminatorKey] != null && baseSchema.discriminators) {
      const _schema = Object.values(baseSchema.discriminators).find((discriminator) => discriminator.discriminatorMapping.value === obj[discriminatorKey]);
      if (_schema != null) {
        schema = _schema;
      }
    }
    let upsert;
    if ("upsert" in this.options) {
      upsert = this.options.upsert;
    }
    return castUpdate(schema, obj, {
      strict: this._mongooseOptions.strict,
      upsert,
      arrayFilters: this.options.arrayFilters,
      overwriteDiscriminatorKey: this._mongooseOptions.overwriteDiscriminatorKey,
      overwriteImmutable: this._mongooseOptions.overwriteImmutable
    }, this, this._conditions);
  };
  Query.prototype.populate = function() {
    const args = Array.from(arguments);
    if (!args.some(Boolean)) {
      return this;
    }
    const res = utils.populate.apply(null, args);
    if (this.options != null) {
      const readConcern = this.options.readConcern;
      const readPref = this.options.readPreference;
      for (const populateOptions of res) {
        if (readConcern != null && (populateOptions && populateOptions.options && populateOptions.options.readConcern) == null) {
          populateOptions.options = populateOptions.options || {};
          populateOptions.options.readConcern = readConcern;
        }
        if (readPref != null && (populateOptions && populateOptions.options && populateOptions.options.readPreference) == null) {
          populateOptions.options = populateOptions.options || {};
          populateOptions.options.readPreference = readPref;
        }
      }
    }
    const opts = this._mongooseOptions;
    if (opts.lean != null) {
      const lean = opts.lean;
      for (const populateOptions of res) {
        if ((populateOptions && populateOptions.options && populateOptions.options.lean) == null) {
          populateOptions.options = populateOptions.options || {};
          populateOptions.options.lean = lean;
        }
      }
    }
    if (!utils.isObject(opts.populate)) {
      opts.populate = {};
    }
    const pop = opts.populate;
    for (const populateOptions of res) {
      const path = populateOptions.path;
      if (pop[path] && pop[path].populate && populateOptions.populate) {
        populateOptions.populate = pop[path].populate.concat(populateOptions.populate);
      }
      pop[populateOptions.path] = populateOptions;
    }
    return this;
  };
  Query.prototype.getPopulatedPaths = function getPopulatedPaths() {
    const obj = this._mongooseOptions.populate || {};
    const ret = Object.keys(obj);
    for (const path of Object.keys(obj)) {
      const pop = obj[path];
      if (!Array.isArray(pop.populate)) {
        continue;
      }
      _getPopulatedPaths(ret, pop.populate, path + ".");
    }
    return ret;
  };
  /*!
   * ignore
   */
  Query.prototype.cast = function(model, obj) {
    obj || (obj = this._conditions);
    model = model || this.model;
    const discriminatorKey = model.schema.options.discriminatorKey;
    if (obj != null && obj.hasOwnProperty(discriminatorKey)) {
      model = getDiscriminatorByValue(model.discriminators, obj[discriminatorKey]) || model;
    }
    const opts = { upsert: this.options && this.options.upsert };
    if (this.options) {
      if ("strict" in this.options) {
        opts.strict = this.options.strict;
      }
      if ("strictQuery" in this.options) {
        opts.strictQuery = this.options.strictQuery;
      }
    }
    if ("sanitizeFilter" in this._mongooseOptions) {
      opts.sanitizeFilter = this._mongooseOptions.sanitizeFilter;
    }
    try {
      return cast(model.schema, obj, opts, this);
    } catch (err) {
      if (typeof err.setModel === "function") {
        err.setModel(model);
      }
      throw err;
    }
  };
  Query.prototype._castFields = function _castFields(fields) {
    let selected, elemMatchKeys, keys, key, out;
    if (fields) {
      keys = Object.keys(fields);
      elemMatchKeys = [];
      for (let i = 0;i < keys.length; ++i) {
        key = keys[i];
        if (fields[key].$elemMatch) {
          selected || (selected = {});
          selected[key] = fields[key];
          elemMatchKeys.push(key);
        }
      }
    }
    if (selected) {
      try {
        out = this.cast(this.model, selected);
      } catch (err) {
        return err;
      }
      for (let i = 0;i < elemMatchKeys.length; ++i) {
        key = elemMatchKeys[i];
        fields[key] = out[key];
      }
    }
    return fields;
  };
  Query.prototype._applyPaths = function applyPaths() {
    if (!this.model) {
      return;
    }
    this._fields = this._fields || {};
    let sanitizeProjection2 = undefined;
    if (this.model != null && utils.hasUserDefinedProperty(this.model.db.options, "sanitizeProjection")) {
      sanitizeProjection2 = this.model.db.options.sanitizeProjection;
    } else if (this.model != null && utils.hasUserDefinedProperty(this.model.base.options, "sanitizeProjection")) {
      sanitizeProjection2 = this.model.base.options.sanitizeProjection;
    } else {
      sanitizeProjection2 = this._mongooseOptions.sanitizeProjection;
    }
    const schemaLevelProjections = this._mongooseOptions.schemaLevelProjections ?? true;
    if (schemaLevelProjections) {
      helpers.applyPaths(this._fields, this.model.schema, sanitizeProjection2);
    }
    let _selectPopulatedPaths = true;
    if ("selectPopulatedPaths" in this.model.base.options) {
      _selectPopulatedPaths = this.model.base.options.selectPopulatedPaths;
    }
    if ("selectPopulatedPaths" in this.model.schema.options) {
      _selectPopulatedPaths = this.model.schema.options.selectPopulatedPaths;
    }
    if (_selectPopulatedPaths) {
      selectPopulatedFields(this._fields, this._userProvidedFields, this._mongooseOptions.populate);
    }
  };
  Query.prototype.cursor = function cursor(opts) {
    if (opts) {
      this.setOptions(opts);
    }
    try {
      this.cast(this.model);
    } catch (err) {
      return new QueryCursor(this)._markError(err);
    }
    return new QueryCursor(this);
  };
  Query.prototype.tailable = function(val, opts) {
    if (val != null && typeof val.constructor === "function" && val.constructor.name === "Object") {
      opts = val;
      val = true;
    }
    if (val === undefined) {
      val = true;
    }
    if (opts && typeof opts === "object") {
      for (const key of Object.keys(opts)) {
        if (key === "awaitData" || key === "awaitdata") {
          this.options["awaitData"] = !!opts[key];
        } else {
          this.options[key] = opts[key];
        }
      }
    }
    this.options.tailable = arguments.length ? !!val : true;
    return this;
  };
  Query.prototype.near = function() {
    const params = [];
    const sphere = this._mongooseOptions.nearSphere;
    if (arguments.length === 1) {
      if (Array.isArray(arguments[0])) {
        params.push({ center: arguments[0], spherical: sphere });
      } else if (typeof arguments[0] === "string") {
        params.push(arguments[0]);
      } else if (utils.isObject(arguments[0])) {
        if (typeof arguments[0].spherical !== "boolean") {
          arguments[0].spherical = sphere;
        }
        params.push(arguments[0]);
      } else {
        throw new TypeError("invalid argument");
      }
    } else if (arguments.length === 2) {
      if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
        params.push({ center: [arguments[0], arguments[1]], spherical: sphere });
      } else if (typeof arguments[0] === "string" && Array.isArray(arguments[1])) {
        params.push(arguments[0]);
        params.push({ center: arguments[1], spherical: sphere });
      } else if (typeof arguments[0] === "string" && utils.isObject(arguments[1])) {
        params.push(arguments[0]);
        if (typeof arguments[1].spherical !== "boolean") {
          arguments[1].spherical = sphere;
        }
        params.push(arguments[1]);
      } else {
        throw new TypeError("invalid argument");
      }
    } else if (arguments.length === 3) {
      if (typeof arguments[0] === "string" && typeof arguments[1] === "number" && typeof arguments[2] === "number") {
        params.push(arguments[0]);
        params.push({ center: [arguments[1], arguments[2]], spherical: sphere });
      } else {
        throw new TypeError("invalid argument");
      }
    } else {
      throw new TypeError("invalid argument");
    }
    return Query.base.near.apply(this, params);
  };
  Query.prototype.nearSphere = function() {
    this._mongooseOptions.nearSphere = true;
    this.near.apply(this, arguments);
    return this;
  };
  if (Symbol.asyncIterator != null) {
    Query.prototype[Symbol.asyncIterator] = function() {
      return this.cursor().transformNull()._transformForAsyncIterator();
    };
  }
  Query.prototype.box = function(ll, ur) {
    if (!Array.isArray(ll) && utils.isObject(ll)) {
      ur = ll.ur;
      ll = ll.ll;
    }
    return Query.base.box.call(this, ll, ur);
  };
  Query.prototype.center = Query.base.circle;
  Query.prototype.centerSphere = function() {
    if (arguments[0] != null && typeof arguments[0].constructor === "function" && arguments[0].constructor.name === "Object") {
      arguments[0].spherical = true;
    }
    if (arguments[1] != null && typeof arguments[1].constructor === "function" && arguments[1].constructor.name === "Object") {
      arguments[1].spherical = true;
    }
    Query.base.circle.apply(this, arguments);
  };
  Query.prototype.selectedInclusively = function selectedInclusively() {
    return isInclusive(this._fields);
  };
  Query.prototype.selectedExclusively = function selectedExclusively() {
    return isExclusive(this._fields);
  };
  Query.prototype.model;
  /*!
   * Export
   */
  module.exports = Query;
});

// node_modules/mongoose/lib/cursor/aggregationCursor.js
var require_aggregationCursor = __commonJS((exports, module) => {
  function AggregationCursor(agg) {
    Readable2.call(this, { autoDestroy: true, objectMode: true });
    this.cursor = null;
    this.agg = agg;
    this._transforms = [];
    const connection = agg._connection;
    const model = agg._model;
    delete agg.options.cursor.useMongooseAggCursor;
    this._mongooseOptions = {};
    if (connection) {
      this.cursor = connection.db.aggregate(agg._pipeline, agg.options || {});
      setImmediate(() => this.emit("cursor", this.cursor));
    } else {
      _init(model, this, agg);
    }
  }
  function _init(model, c, agg) {
    if (!model.collection.buffer) {
      model.hooks.execPre("aggregate", agg, function() {
        if (typeof agg.options?.cursor?.transform === "function") {
          c._transforms.push(agg.options.cursor.transform);
        }
        c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});
        c.emit("cursor", c.cursor);
      });
    } else {
      model.collection.emitter.once("queue", function() {
        model.hooks.execPre("aggregate", agg, function() {
          if (typeof agg.options?.cursor?.transform === "function") {
            c._transforms.push(agg.options.cursor.transform);
          }
          c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});
          c.emit("cursor", c.cursor);
        });
      });
    }
  }
  function _transformForAsyncIterator(doc) {
    return doc == null ? { done: true } : { value: doc, done: false };
  }
  function _waitForCursor(ctx, cb) {
    if (ctx.cursor) {
      return cb();
    }
    ctx.once("cursor", function() {
      cb();
    });
  }
  function _next(ctx, cb) {
    let callback = cb;
    if (ctx._transforms.length) {
      callback = function(err, doc) {
        if (err || doc === null && !ctx._mongooseOptions.transformNull) {
          return cb(err, doc);
        }
        cb(err, ctx._transforms.reduce(function(doc2, fn) {
          return fn(doc2);
        }, doc));
      };
    }
    if (ctx._error) {
      return immediate(function() {
        callback(ctx._error);
      });
    }
    if (ctx.cursor) {
      return ctx.cursor.next().then((doc) => {
        if (!doc) {
          return callback(null, null);
        }
        callback(null, doc);
      }, (err) => callback(err));
    } else {
      ctx.once("cursor", function() {
        _next(ctx, cb);
      });
    }
  }
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();
  var Readable2 = import.meta.require("stream").Readable;
  var eachAsync = require_eachAsync();
  var immediate = require_immediate();
  var util = import.meta.require("util");
  util.inherits(AggregationCursor, Readable2);
  /*!
   * ignore
   */
  AggregationCursor.prototype._read = function() {
    const _this = this;
    _next(this, function(error, doc) {
      if (error) {
        return _this.emit("error", error);
      }
      if (!doc) {
        _this.push(null);
        _this.cursor.close(function(error2) {
          if (error2) {
            return _this.emit("error", error2);
          }
        });
        return;
      }
      _this.push(doc);
    });
  };
  if (Symbol.asyncIterator != null) {
    const msg = "Mongoose does not support using async iterators with an " + "existing aggregation cursor. See https://bit.ly/mongoose-async-iterate-aggregation";
    AggregationCursor.prototype[Symbol.asyncIterator] = function() {
      throw new MongooseError(msg);
    };
  }
  Object.defineProperty(AggregationCursor.prototype, "map", {
    value: function(fn) {
      this._transforms.push(fn);
      return this;
    },
    enumerable: true,
    configurable: true,
    writable: true
  });
  AggregationCursor.prototype._markError = function(error) {
    this._error = error;
    return this;
  };
  AggregationCursor.prototype.close = async function close() {
    if (typeof arguments[0] === "function") {
      throw new MongooseError("AggregationCursor.prototype.close() no longer accepts a callback");
    }
    try {
      await this.cursor.close();
    } catch (error) {
      this.listeners("error").length > 0 && this.emit("error", error);
      throw error;
    }
    this.emit("close");
  };
  AggregationCursor.prototype._destroy = function _destroy(_err, callback) {
    let waitForCursor = null;
    if (!this.cursor) {
      waitForCursor = new Promise((resolve) => {
        this.once("cursor", resolve);
      });
    } else {
      waitForCursor = Promise.resolve();
    }
    waitForCursor.then(() => this.cursor.close()).then(() => {
      this._closed = true;
      callback();
    }).catch((error) => {
      callback(error);
    });
    return this;
  };
  AggregationCursor.prototype.next = async function next() {
    if (typeof arguments[0] === "function") {
      throw new MongooseError("AggregationCursor.prototype.next() no longer accepts a callback");
    }
    return new Promise((resolve, reject) => {
      _next(this, (err, res) => {
        if (err != null) {
          return reject(err);
        }
        resolve(res);
      });
    });
  };
  AggregationCursor.prototype.eachAsync = function(fn, opts) {
    if (typeof arguments[2] === "function") {
      throw new MongooseError("AggregationCursor.prototype.eachAsync() no longer accepts a callback");
    }
    const _this = this;
    if (typeof opts === "function") {
      opts = {};
    }
    opts = opts || {};
    return eachAsync(function(cb) {
      return _next(_this, cb);
    }, fn, opts);
  };
  if (Symbol.asyncIterator != null) {
    AggregationCursor.prototype[Symbol.asyncIterator] = function() {
      return this.transformNull()._transformForAsyncIterator();
    };
  }
  /*!
   * ignore
   */
  AggregationCursor.prototype._transformForAsyncIterator = function() {
    if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {
      this.map(_transformForAsyncIterator);
    }
    return this;
  };
  /*!
   * ignore
   */
  AggregationCursor.prototype.transformNull = function(val) {
    if (arguments.length === 0) {
      val = true;
    }
    this._mongooseOptions.transformNull = val;
    return this;
  };
  /*!
   * ignore
   */
  AggregationCursor.prototype.addCursorFlag = function(flag, value) {
    const _this = this;
    _waitForCursor(this, function() {
      _this.cursor.addCursorFlag(flag, value);
    });
    return this;
  };
  /*!
   * ignore
   */
  module.exports = AggregationCursor;
});

// node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js
var require_prepareDiscriminatorPipeline = __commonJS((exports, module) => {
  module.exports = function prepareDiscriminatorPipeline(pipeline, schema, prefix) {
    const discriminatorMapping = schema && schema.discriminatorMapping;
    prefix = prefix || "";
    if (discriminatorMapping && !discriminatorMapping.isRoot) {
      const originalPipeline = pipeline;
      const filterKey = (prefix.length > 0 ? prefix + "." : prefix) + discriminatorMapping.key;
      const discriminatorValue = discriminatorMapping.value;
      if (originalPipeline[0] != null && originalPipeline[0].$match && (originalPipeline[0].$match[filterKey] === undefined || originalPipeline[0].$match[filterKey] === discriminatorValue)) {
        originalPipeline[0].$match[filterKey] = discriminatorValue;
      } else if (originalPipeline[0] != null && originalPipeline[0].$geoNear) {
        originalPipeline[0].$geoNear.query = originalPipeline[0].$geoNear.query || {};
        originalPipeline[0].$geoNear.query[filterKey] = discriminatorValue;
      } else if (originalPipeline[0] != null && originalPipeline[0].$search) {
        if (originalPipeline[1] && originalPipeline[1].$match != null) {
          originalPipeline[1].$match[filterKey] = originalPipeline[1].$match[filterKey] || discriminatorValue;
        } else {
          const match = {};
          match[filterKey] = discriminatorValue;
          originalPipeline.splice(1, 0, { $match: match });
        }
      } else {
        const match = {};
        match[filterKey] = discriminatorValue;
        originalPipeline.unshift({ $match: match });
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js
var require_stringifyFunctionOperators = __commonJS((exports, module) => {
  function handleAccumulator(operator) {
    if (operator == null || operator.$accumulator == null) {
      return;
    }
    for (const key of ["init", "accumulate", "merge", "finalize"]) {
      if (typeof operator.$accumulator[key] === "function") {
        operator.$accumulator[key] = String(operator.$accumulator[key]);
      }
    }
  }
  module.exports = function stringifyFunctionOperators(pipeline) {
    if (!Array.isArray(pipeline)) {
      return;
    }
    for (const stage of pipeline) {
      if (stage == null) {
        continue;
      }
      const canHaveAccumulator = stage.$group || stage.$bucket || stage.$bucketAuto;
      if (canHaveAccumulator != null) {
        for (const key of Object.keys(canHaveAccumulator)) {
          handleAccumulator(canHaveAccumulator[key]);
        }
      }
      const stageType = Object.keys(stage)[0];
      if (stageType && typeof stage[stageType] === "object") {
        const stageOptions = stage[stageType];
        for (const key of Object.keys(stageOptions)) {
          if (stageOptions[key] != null && stageOptions[key].$function != null && typeof stageOptions[key].$function.body === "function") {
            stageOptions[key].$function.body = stageOptions[key].$function.body.toString();
          }
        }
      }
      if (stage.$facet != null) {
        for (const key of Object.keys(stage.$facet)) {
          stringifyFunctionOperators(stage.$facet[key]);
        }
      }
    }
  };
});

// node_modules/mongoose/lib/aggregate.js
var require_aggregate2 = __commonJS((exports, module) => {
  function Aggregate(pipeline, modelOrConn) {
    this._pipeline = [];
    if (modelOrConn == null || modelOrConn[modelSymbol]) {
      this._model = modelOrConn;
    } else {
      this._connection = modelOrConn;
    }
    this.options = {};
    if (arguments.length === 1 && Array.isArray(pipeline)) {
      this.append.apply(this, pipeline);
    }
  }
  function isOperator(obj) {
    if (typeof obj !== "object" || obj === null) {
      return false;
    }
    const k = Object.keys(obj);
    return k.length === 1 && k[0][0] === "$";
  }
  /*!
   * Module dependencies
   */
  var AggregationCursor = require_aggregationCursor();
  var MongooseError = require_mongooseError();
  var Query = require_query();
  var { applyGlobalMaxTimeMS, applyGlobalDiskUse } = require_applyGlobalOption();
  var clone = require_clone2();
  var getConstructorName = require_getConstructorName();
  var prepareDiscriminatorPipeline = require_prepareDiscriminatorPipeline();
  var stringifyFunctionOperators = require_stringifyFunctionOperators();
  var utils = require_utils4();
  var { modelSymbol } = require_symbols();
  var read = Query.prototype.read;
  var readConcern = Query.prototype.readConcern;
  var validRedactStringValues = new Set(["$$DESCEND", "$$PRUNE", "$$KEEP"]);
  Aggregate.prototype.options;
  Aggregate.prototype._optionsForExec = function() {
    const options = this.options || {};
    const asyncLocalStorage = this.model()?.db?.base.transactionAsyncLocalStorage?.getStore();
    if (!options.hasOwnProperty("session") && asyncLocalStorage?.session != null) {
      options.session = asyncLocalStorage.session;
    }
    return options;
  };
  Aggregate.prototype.model = function(model) {
    if (arguments.length === 0) {
      return this._model;
    }
    this._model = model;
    if (model.schema != null) {
      if (this.options.readPreference == null && model.schema.options.read != null) {
        this.options.readPreference = model.schema.options.read;
      }
      if (this.options.collation == null && model.schema.options.collation != null) {
        this.options.collation = model.schema.options.collation;
      }
    }
    return model;
  };
  Aggregate.prototype.append = function() {
    const args = arguments.length === 1 && Array.isArray(arguments[0]) ? arguments[0] : [...arguments];
    if (!args.every(isOperator)) {
      throw new Error("Arguments must be aggregate pipeline operators");
    }
    this._pipeline = this._pipeline.concat(args);
    return this;
  };
  Aggregate.prototype.addFields = function(arg) {
    if (typeof arg !== "object" || arg === null || Array.isArray(arg)) {
      throw new Error("Invalid addFields() argument. Must be an object");
    }
    return this.append({ $addFields: Object.assign({}, arg) });
  };
  Aggregate.prototype.project = function(arg) {
    const fields = {};
    if (typeof arg === "object" && !Array.isArray(arg)) {
      Object.keys(arg).forEach(function(field) {
        fields[field] = arg[field];
      });
    } else if (arguments.length === 1 && typeof arg === "string") {
      arg.split(/\s+/).forEach(function(field) {
        if (!field) {
          return;
        }
        const include = field[0] === "-" ? 0 : 1;
        if (include === 0) {
          field = field.substring(1);
        }
        fields[field] = include;
      });
    } else {
      throw new Error("Invalid project() argument. Must be string or object");
    }
    return this.append({ $project: fields });
  };
  Aggregate.prototype.near = function(arg) {
    if (arg == null) {
      throw new MongooseError("Aggregate `near()` must be called with non-nullish argument");
    }
    if (arg.near == null) {
      throw new MongooseError("Aggregate `near()` argument must have a `near` property");
    }
    const coordinates = Array.isArray(arg.near) ? arg.near : arg.near.coordinates;
    if (typeof arg.near === "object" && (!Array.isArray(coordinates) || coordinates.length < 2 || coordinates.find((c) => typeof c !== "number"))) {
      throw new MongooseError(`Aggregate \`near()\` argument has invalid coordinates, got "${coordinates}"`);
    }
    const op = {};
    op.$geoNear = arg;
    return this.append(op);
  };
  /*!
   * define methods
   */
  "group match skip limit out densify fill".split(" ").forEach(function($operator) {
    Aggregate.prototype[$operator] = function(arg) {
      const op = {};
      op["$" + $operator] = arg;
      return this.append(op);
    };
  });
  Aggregate.prototype.unwind = function() {
    const args = [...arguments];
    const res = [];
    for (const arg of args) {
      if (arg && typeof arg === "object") {
        res.push({ $unwind: arg });
      } else if (typeof arg === "string") {
        res.push({
          $unwind: arg[0] === "$" ? arg : "$" + arg
        });
      } else {
        throw new Error('Invalid arg "' + arg + '" to unwind(), ' + "must be string or object");
      }
    }
    return this.append.apply(this, res);
  };
  Aggregate.prototype.replaceRoot = function(newRoot) {
    let ret;
    if (typeof newRoot === "string") {
      ret = newRoot.startsWith("$") ? newRoot : "$" + newRoot;
    } else {
      ret = newRoot;
    }
    return this.append({
      $replaceRoot: {
        newRoot: ret
      }
    });
  };
  Aggregate.prototype.count = function(fieldName) {
    return this.append({ $count: fieldName });
  };
  Aggregate.prototype.sortByCount = function(arg) {
    if (arg && typeof arg === "object") {
      return this.append({ $sortByCount: arg });
    } else if (typeof arg === "string") {
      return this.append({
        $sortByCount: arg[0] === "$" ? arg : "$" + arg
      });
    } else {
      throw new TypeError('Invalid arg "' + arg + '" to sortByCount(), ' + "must be string or object");
    }
  };
  Aggregate.prototype.lookup = function(options) {
    return this.append({ $lookup: options });
  };
  Aggregate.prototype.graphLookup = function(options) {
    const cloneOptions = {};
    if (options) {
      if (!utils.isObject(options)) {
        throw new TypeError("Invalid graphLookup() argument. Must be an object.");
      }
      utils.mergeClone(cloneOptions, options);
      const startWith = cloneOptions.startWith;
      if (startWith && typeof startWith === "string") {
        cloneOptions.startWith = cloneOptions.startWith.startsWith("$") ? cloneOptions.startWith : "$" + cloneOptions.startWith;
      }
    }
    return this.append({ $graphLookup: cloneOptions });
  };
  Aggregate.prototype.sample = function(size) {
    return this.append({ $sample: { size } });
  };
  Aggregate.prototype.sort = function(arg) {
    const sort = {};
    if (getConstructorName(arg) === "Object") {
      const desc = ["desc", "descending", -1];
      Object.keys(arg).forEach(function(field) {
        if (arg[field] instanceof Object && arg[field].$meta) {
          sort[field] = arg[field];
          return;
        }
        sort[field] = desc.indexOf(arg[field]) === -1 ? 1 : -1;
      });
    } else if (arguments.length === 1 && typeof arg === "string") {
      arg.split(/\s+/).forEach(function(field) {
        if (!field) {
          return;
        }
        const ascend = field[0] === "-" ? -1 : 1;
        if (ascend === -1) {
          field = field.substring(1);
        }
        sort[field] = ascend;
      });
    } else {
      throw new TypeError("Invalid sort() argument. Must be a string or object.");
    }
    return this.append({ $sort: sort });
  };
  Aggregate.prototype.unionWith = function(options) {
    return this.append({ $unionWith: options });
  };
  Aggregate.prototype.read = function(pref, tags) {
    read.call(this, pref, tags);
    return this;
  };
  Aggregate.prototype.readConcern = function(level) {
    readConcern.call(this, level);
    return this;
  };
  Aggregate.prototype.redact = function(expression, thenExpr, elseExpr) {
    if (arguments.length === 3) {
      if (typeof thenExpr === "string" && !validRedactStringValues.has(thenExpr) || typeof elseExpr === "string" && !validRedactStringValues.has(elseExpr)) {
        throw new Error("If thenExpr or elseExpr is string, it must be either $$DESCEND, $$PRUNE or $$KEEP");
      }
      expression = {
        $cond: {
          if: expression,
          then: thenExpr,
          else: elseExpr
        }
      };
    } else if (arguments.length !== 1) {
      throw new TypeError("Invalid arguments");
    }
    return this.append({ $redact: expression });
  };
  Aggregate.prototype.explain = async function explain(verbosity) {
    if (typeof verbosity === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Aggregate.prototype.explain() no longer accepts a callback");
    }
    const model = this._model;
    if (!this._pipeline.length) {
      throw new Error("Aggregate has empty pipeline");
    }
    prepareDiscriminatorPipeline(this._pipeline, this._model.schema);
    await new Promise((resolve, reject) => {
      model.hooks.execPre("aggregate", this, (error) => {
        if (error) {
          const _opts2 = { error };
          return model.hooks.execPost("aggregate", this, [null], _opts2, (error2) => {
            reject(error2);
          });
        } else {
          resolve();
        }
      });
    });
    const cursor = model.collection.aggregate(this._pipeline, this.options);
    if (verbosity == null) {
      verbosity = true;
    }
    let result = null;
    try {
      result = await cursor.explain(verbosity);
    } catch (error) {
      await new Promise((resolve, reject) => {
        const _opts2 = { error };
        model.hooks.execPost("aggregate", this, [null], _opts2, (error2) => {
          if (error2) {
            return reject(error2);
          }
          return resolve();
        });
      });
    }
    const _opts = { error: null };
    await new Promise((resolve, reject) => {
      model.hooks.execPost("aggregate", this, [result], _opts, (error) => {
        if (error) {
          return reject(error);
        }
        return resolve();
      });
    });
    return result;
  };
  Aggregate.prototype.allowDiskUse = function(value) {
    this.options.allowDiskUse = value;
    return this;
  };
  Aggregate.prototype.hint = function(value) {
    this.options.hint = value;
    return this;
  };
  Aggregate.prototype.session = function(session) {
    if (session == null) {
      delete this.options.session;
    } else {
      this.options.session = session;
    }
    return this;
  };
  Aggregate.prototype.option = function(value) {
    for (const key in value) {
      this.options[key] = value[key];
    }
    return this;
  };
  Aggregate.prototype.cursor = function(options) {
    this._optionsForExec();
    this.options.cursor = options || {};
    return new AggregationCursor(this);
  };
  Aggregate.prototype.collation = function(collation) {
    this.options.collation = collation;
    return this;
  };
  Aggregate.prototype.facet = function(options) {
    return this.append({ $facet: options });
  };
  Aggregate.prototype.search = function(options) {
    return this.append({ $search: options });
  };
  Aggregate.prototype.pipeline = function() {
    return this._pipeline;
  };
  Aggregate.prototype.exec = async function exec() {
    if (!this._model && !this._connection) {
      throw new Error("Aggregate not bound to any Model");
    }
    if (typeof arguments[0] === "function") {
      throw new MongooseError("Aggregate.prototype.exec() no longer accepts a callback");
    }
    if (this._connection) {
      if (!this._pipeline.length) {
        throw new MongooseError("Aggregate has empty pipeline");
      }
      this._optionsForExec();
      const cursor = await this._connection.client.db().aggregate(this._pipeline, this.options);
      return await cursor.toArray();
    }
    const model = this._model;
    const collection = this._model.collection;
    applyGlobalMaxTimeMS(this.options, model.db.options, model.base.options);
    applyGlobalDiskUse(this.options, model.db.options, model.base.options);
    this._optionsForExec();
    if (this.options && this.options.cursor) {
      return new AggregationCursor(this);
    }
    prepareDiscriminatorPipeline(this._pipeline, this._model.schema);
    stringifyFunctionOperators(this._pipeline);
    await new Promise((resolve, reject) => {
      model.hooks.execPre("aggregate", this, (error) => {
        if (error) {
          const _opts2 = { error };
          return model.hooks.execPost("aggregate", this, [null], _opts2, (error2) => {
            reject(error2);
          });
        } else {
          resolve();
        }
      });
    });
    if (!this._pipeline.length) {
      throw new MongooseError("Aggregate has empty pipeline");
    }
    const options = clone(this.options || {});
    let result;
    try {
      const cursor = await collection.aggregate(this._pipeline, options);
      result = await cursor.toArray();
    } catch (error) {
      await new Promise((resolve, reject) => {
        const _opts2 = { error };
        model.hooks.execPost("aggregate", this, [null], _opts2, (error2) => {
          if (error2) {
            return reject(error2);
          }
          resolve();
        });
      });
    }
    const _opts = { error: null };
    await new Promise((resolve, reject) => {
      model.hooks.execPost("aggregate", this, [result], _opts, (error) => {
        if (error) {
          return reject(error);
        }
        return resolve();
      });
    });
    return result;
  };
  Aggregate.prototype.then = function(resolve, reject) {
    return this.exec().then(resolve, reject);
  };
  Aggregate.prototype.catch = function(reject) {
    return this.exec().then(null, reject);
  };
  Aggregate.prototype.finally = function(onFinally) {
    return this.exec().finally(onFinally);
  };
  if (Symbol.asyncIterator != null) {
    Aggregate.prototype[Symbol.asyncIterator] = function() {
      return this.cursor({ useMongooseAggCursor: true }).transformNull()._transformForAsyncIterator();
    };
  }
  /*!
   * Helpers
   */
  Aggregate._prepareDiscriminatorPipeline = prepareDiscriminatorPipeline;
  /*!
   * Exports
   */
  module.exports = Aggregate;
});

// node_modules/mongoose/lib/options/saveOptions.js
var require_saveOptions = __commonJS((exports, module) => {
  var clone = require_clone2();

  class SaveOptions {
    constructor(obj) {
      if (obj == null) {
        return;
      }
      Object.assign(this, clone(obj));
    }
  }
  SaveOptions.prototype.__subdocs = null;
  module.exports = SaveOptions;
});

// node_modules/mongoose/lib/helpers/model/applyDefaultsToPOJO.js
var require_applyDefaultsToPOJO = __commonJS((exports, module) => {
  module.exports = function applyDefaultsToPOJO(doc, schema) {
    const paths = Object.keys(schema.paths);
    const plen = paths.length;
    for (let i = 0;i < plen; ++i) {
      let curPath = "";
      const p = paths[i];
      const type = schema.paths[p];
      const path = type.splitPath();
      const len = path.length;
      let doc_ = doc;
      for (let j = 0;j < len; ++j) {
        if (doc_ == null) {
          break;
        }
        const piece = path[j];
        curPath += (!curPath.length ? "" : ".") + piece;
        if (j === len - 1) {
          if (typeof doc_[piece] !== "undefined") {
            if (type.$isSingleNested) {
              applyDefaultsToPOJO(doc_[piece], type.caster.schema);
            } else if (type.$isMongooseDocumentArray && Array.isArray(doc_[piece])) {
              doc_[piece].forEach((el) => applyDefaultsToPOJO(el, type.schema));
            }
            break;
          }
          const def = type.getDefault(doc, false, { skipCast: true });
          if (typeof def !== "undefined") {
            doc_[piece] = def;
            if (type.$isSingleNested) {
              applyDefaultsToPOJO(def, type.caster.schema);
            } else if (type.$isMongooseDocumentArray && Array.isArray(def)) {
              def.forEach((el) => applyDefaultsToPOJO(el, type.schema));
            }
          }
        } else {
          if (doc_[piece] == null) {
            doc_[piece] = {};
          }
          doc_ = doc_[piece];
        }
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/discriminator/applyEmbeddedDiscriminators.js
var require_applyEmbeddedDiscriminators = __commonJS((exports, module) => {
  function applyEmbeddedDiscriminators(schema, seen = new WeakSet, overwriteExisting = false) {
    if (seen.has(schema)) {
      return;
    }
    seen.add(schema);
    for (const path of Object.keys(schema.paths)) {
      const schemaType = schema.paths[path];
      if (!schemaType.schema) {
        continue;
      }
      applyEmbeddedDiscriminators(schemaType.schema, seen);
      if (!schemaType.schema._applyDiscriminators) {
        continue;
      }
      if (schemaType._appliedDiscriminators && !overwriteExisting) {
        continue;
      }
      for (const discriminatorKey of schemaType.schema._applyDiscriminators.keys()) {
        const {
          schema: discriminatorSchema,
          options
        } = schemaType.schema._applyDiscriminators.get(discriminatorKey);
        applyEmbeddedDiscriminators(discriminatorSchema, seen);
        schemaType.discriminator(discriminatorKey, discriminatorSchema, overwriteExisting ? { ...options, overwriteExisting: true } : options);
      }
      schemaType._appliedDiscriminators = true;
    }
  }
  module.exports = applyEmbeddedDiscriminators;
});

// node_modules/mongoose/lib/helpers/model/applyMethods.js
var require_applyMethods = __commonJS((exports, module) => {
  var get = require_get2();
  var utils = require_utils4();
  module.exports = function applyMethods(model, schema) {
    const Model = require_model();
    function apply(method, schema2) {
      Object.defineProperty(model.prototype, method, {
        get: function() {
          const h = {};
          for (const k in schema2.methods[method]) {
            h[k] = schema2.methods[method][k].bind(this);
          }
          return h;
        },
        configurable: true
      });
    }
    for (const method of Object.keys(schema.methods)) {
      const fn = schema.methods[method];
      if (schema.tree.hasOwnProperty(method)) {
        throw new Error("You have a method and a property in your schema both " + 'named "' + method + '"');
      }
      if (typeof fn === "function" && Model.prototype[method] === fn) {
        delete schema.methods[method];
        continue;
      }
      if (schema.reserved[method] && !get(schema, `methodOptions.${method}.suppressWarning`, false)) {
        utils.warn(`mongoose: the method name "${method}" is used by mongoose ` + "internally, overwriting it may cause bugs. If you\'re sure you know " + "what you\'re doing, you can suppress this error by using " + `\`schema.method('${method}', fn, { suppressWarning: true })\`.`);
      }
      if (typeof fn === "function") {
        model.prototype[method] = fn;
      } else {
        apply(method, schema);
      }
    }
    model.$appliedMethods = true;
    for (const key of Object.keys(schema.paths)) {
      const type = schema.paths[key];
      if (type.$isSingleNested && !type.caster.$appliedMethods) {
        applyMethods(type.caster, type.schema);
      }
      if (type.$isMongooseDocumentArray && !type.Constructor.$appliedMethods) {
        applyMethods(type.Constructor, type.schema);
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/projection/applyProjection.js
var require_applyProjection = __commonJS((exports, module) => {
  function applyExclusiveProjection(doc, projection, hasIncludedChildren2, projectionLimb, prefix) {
    if (doc == null || typeof doc !== "object") {
      return doc;
    }
    if (Array.isArray(doc)) {
      return doc.map((el) => applyExclusiveProjection(el, projection, hasIncludedChildren2, projectionLimb, prefix));
    }
    const ret = { ...doc };
    projectionLimb = prefix ? projectionLimb || {} : projection;
    for (const key of Object.keys(ret)) {
      const fullPath = prefix ? prefix + "." + key : key;
      if (projection.hasOwnProperty(fullPath) || projectionLimb.hasOwnProperty(key)) {
        if (isPOJO(projection[fullPath]) || isPOJO(projectionLimb[key])) {
          ret[key] = applyExclusiveProjection(ret[key], projection, hasIncludedChildren2, projectionLimb[key], fullPath);
        } else {
          delete ret[key];
        }
      } else if (hasIncludedChildren2[fullPath]) {
        ret[key] = applyExclusiveProjection(ret[key], projection, hasIncludedChildren2, projectionLimb[key], fullPath);
      }
    }
    return ret;
  }
  function applyInclusiveProjection(doc, projection, hasIncludedChildren2, projectionLimb, prefix) {
    if (doc == null || typeof doc !== "object") {
      return doc;
    }
    if (Array.isArray(doc)) {
      return doc.map((el) => applyInclusiveProjection(el, projection, hasIncludedChildren2, projectionLimb, prefix));
    }
    const ret = { ...doc };
    projectionLimb = prefix ? projectionLimb || {} : projection;
    for (const key of Object.keys(ret)) {
      const fullPath = prefix ? prefix + "." + key : key;
      if (projection.hasOwnProperty(fullPath) || projectionLimb.hasOwnProperty(key)) {
        if (isPOJO(projection[fullPath]) || isPOJO(projectionLimb[key])) {
          ret[key] = applyInclusiveProjection(ret[key], projection, hasIncludedChildren2, projectionLimb[key], fullPath);
        }
        continue;
      } else if (hasIncludedChildren2[fullPath]) {
        ret[key] = applyInclusiveProjection(ret[key], projection, hasIncludedChildren2, projectionLimb[key], fullPath);
      } else {
        delete ret[key];
      }
    }
    return ret;
  }
  var hasIncludedChildren = require_hasIncludedChildren();
  var isExclusive = require_isExclusive();
  var isInclusive = require_isInclusive();
  var isPOJO = require_utils4().isPOJO;
  module.exports = function applyProjection(doc, projection, _hasIncludedChildren) {
    if (projection == null) {
      return doc;
    }
    if (doc == null) {
      return doc;
    }
    let exclude = null;
    if (isInclusive(projection)) {
      exclude = false;
    } else if (isExclusive(projection)) {
      exclude = true;
    }
    if (exclude == null) {
      return doc;
    } else if (exclude) {
      _hasIncludedChildren = _hasIncludedChildren || hasIncludedChildren(projection);
      return applyExclusiveProjection(doc, projection, _hasIncludedChildren);
    } else {
      _hasIncludedChildren = _hasIncludedChildren || hasIncludedChildren(projection);
      return applyInclusiveProjection(doc, projection, _hasIncludedChildren);
    }
  };
});

// node_modules/mongoose/lib/helpers/indexes/isTextIndex.js
var require_isTextIndex = __commonJS((exports, module) => {
  module.exports = function isTextIndex(indexKeys) {
    let isTextIndex = false;
    for (const key of Object.keys(indexKeys)) {
      if (indexKeys[key] === "text") {
        isTextIndex = true;
      }
    }
    return isTextIndex;
  };
});

// node_modules/mongoose/lib/helpers/indexes/applySchemaCollation.js
var require_applySchemaCollation = __commonJS((exports, module) => {
  var isTextIndex = require_isTextIndex();
  module.exports = function applySchemaCollation(indexKeys, indexOptions, schemaOptions) {
    if (isTextIndex(indexKeys)) {
      return;
    }
    if (schemaOptions.hasOwnProperty("collation") && !indexOptions.hasOwnProperty("collation")) {
      indexOptions.collation = schemaOptions.collation;
    }
  };
});

// node_modules/mongoose/lib/helpers/model/applyStaticHooks.js
var require_applyStaticHooks = __commonJS((exports, module) => {
  var promiseOrCallback = require_promiseOrCallback();
  var { queryMiddlewareFunctions, aggregateMiddlewareFunctions, modelMiddlewareFunctions, documentMiddlewareFunctions } = require_constants3();
  var middlewareFunctions = Array.from(new Set([
    ...queryMiddlewareFunctions,
    ...aggregateMiddlewareFunctions,
    ...modelMiddlewareFunctions,
    ...documentMiddlewareFunctions
  ]));
  module.exports = function applyStaticHooks(model, hooks, statics) {
    const kareemOptions = {
      useErrorHandlers: true,
      numCallbackParams: 1
    };
    model.$__insertMany = hooks.createWrapper("insertMany", model.$__insertMany, model, kareemOptions);
    hooks = hooks.filter((hook) => {
      if (middlewareFunctions.indexOf(hook.name) !== -1) {
        return !!hook.model;
      }
      return hook.model !== false;
    });
    for (const key of Object.keys(statics)) {
      if (hooks.hasHooks(key)) {
        const original = model[key];
        model[key] = function() {
          const numArgs = arguments.length;
          const lastArg = numArgs > 0 ? arguments[numArgs - 1] : null;
          const cb = typeof lastArg === "function" ? lastArg : null;
          const args = Array.prototype.slice.call(arguments, 0, cb == null ? numArgs : numArgs - 1);
          return promiseOrCallback(cb, (callback) => {
            hooks.execPre(key, model, args, function(err) {
              if (err != null) {
                return callback(err);
              }
              let postCalled = 0;
              const ret = original.apply(model, args.concat(post));
              if (ret != null && typeof ret.then === "function") {
                ret.then((res) => post(null, res), (err2) => post(err2));
              }
              function post(error, res) {
                if (postCalled++ > 0) {
                  return;
                }
                if (error != null) {
                  return callback(error);
                }
                hooks.execPost(key, model, [res], function(error2) {
                  if (error2 != null) {
                    return callback(error2);
                  }
                  callback(null, res);
                });
              }
            });
          }, model.events);
        };
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/model/applyStatics.js
var require_applyStatics = __commonJS((exports, module) => {
  module.exports = function applyStatics(model, schema) {
    for (const i in schema.statics) {
      model[i] = schema.statics[i];
    }
  };
});

// node_modules/mongoose/lib/helpers/document/applyTimestamps.js
var require_applyTimestamps = __commonJS((exports, module) => {
  function applyTimestamps(schema, obj, options) {
    if (obj == null) {
      return obj;
    }
    applyTimestampsToChildren(schema, obj, options);
    return applyTimestampsToDoc(schema, obj, options);
  }
  function applyTimestampsToChildren(schema, res, options) {
    for (const childSchema of schema.childSchemas) {
      const _path = childSchema.model.path;
      const _schema = childSchema.schema;
      if (!_path) {
        continue;
      }
      const _obj = mpath.get(_path, res);
      if (_obj == null || Array.isArray(_obj) && _obj.flat(Infinity).length === 0) {
        continue;
      }
      applyTimestamps(_schema, _obj, options);
    }
  }
  function applyTimestampsToDoc(schema, obj, options) {
    if (obj == null || typeof obj !== "object") {
      return;
    }
    if (Array.isArray(obj)) {
      for (const el of obj) {
        applyTimestampsToDoc(schema, el, options);
      }
      return;
    }
    if (schema.discriminators && Object.keys(schema.discriminators).length > 0) {
      for (const discriminatorKey of Object.keys(schema.discriminators)) {
        const discriminator = schema.discriminators[discriminatorKey];
        const key = discriminator.discriminatorMapping.key;
        const value = discriminator.discriminatorMapping.value;
        if (obj[key] == value) {
          schema = discriminator;
          break;
        }
      }
    }
    const createdAt = handleTimestampOption(schema.options.timestamps, "createdAt");
    const updatedAt = handleTimestampOption(schema.options.timestamps, "updatedAt");
    const currentTime = options?.currentTime;
    let ts = null;
    if (currentTime != null) {
      ts = currentTime();
    } else if (schema.base?.now) {
      ts = schema.base.now();
    } else {
      ts = new Date;
    }
    if (createdAt && obj[createdAt] == null && !options?.isUpdate) {
      obj[createdAt] = ts;
    }
    if (updatedAt) {
      obj[updatedAt] = ts;
    }
  }
  var handleTimestampOption = require_handleTimestampOption();
  var mpath = require_mpath();
  module.exports = applyTimestamps;
});

// node_modules/mongoose/lib/helpers/document/applyVirtuals.js
var require_applyVirtuals = __commonJS((exports, module) => {
  function applyVirtuals(schema, obj, virtuals) {
    if (obj == null) {
      return obj;
    }
    let virtualsForChildren = virtuals;
    let toApply = null;
    if (Array.isArray(virtuals)) {
      virtualsForChildren = [];
      toApply = [];
      for (const virtual of virtuals) {
        if (virtual.length === 1) {
          toApply.push(virtual[0]);
        } else {
          virtualsForChildren.push(virtual);
        }
      }
    }
    applyVirtualsToChildren(schema, obj, virtualsForChildren);
    return applyVirtualsToDoc(schema, obj, toApply);
  }
  function applyVirtualsToChildren(schema, res, virtuals) {
    let attachedVirtuals = false;
    for (const childSchema of schema.childSchemas) {
      const _path = childSchema.model.path;
      const _schema = childSchema.schema;
      if (!_path) {
        continue;
      }
      const _obj = mpath.get(_path, res);
      if (_obj == null || Array.isArray(_obj) && _obj.flat(Infinity).length === 0) {
        continue;
      }
      let virtualsForChild = null;
      if (Array.isArray(virtuals)) {
        virtualsForChild = [];
        for (const virtual of virtuals) {
          if (virtual[0] == _path) {
            virtualsForChild.push(virtual.slice(1));
          }
        }
        if (virtualsForChild.length === 0) {
          continue;
        }
      }
      applyVirtuals(_schema, _obj, virtualsForChild);
      attachedVirtuals = true;
    }
    if (virtuals && virtuals.length && !attachedVirtuals) {
      applyVirtualsToDoc(schema, res, virtuals);
    }
  }
  function applyVirtualsToDoc(schema, obj, virtuals) {
    if (obj == null || typeof obj !== "object") {
      return;
    }
    if (Array.isArray(obj)) {
      for (const el of obj) {
        applyVirtualsToDoc(schema, el, virtuals);
      }
      return;
    }
    if (schema.discriminators && Object.keys(schema.discriminators).length > 0) {
      for (const discriminatorKey of Object.keys(schema.discriminators)) {
        const discriminator = schema.discriminators[discriminatorKey];
        const key = discriminator.discriminatorMapping.key;
        const value = discriminator.discriminatorMapping.value;
        if (obj[key] == value) {
          schema = discriminator;
          break;
        }
      }
    }
    if (virtuals == null) {
      virtuals = Object.keys(schema.virtuals);
    }
    for (const virtual of virtuals) {
      if (schema.virtuals[virtual] == null) {
        continue;
      }
      const virtualType = schema.virtuals[virtual];
      const sp = Array.isArray(virtual) ? virtual : virtual.indexOf(".") === -1 ? [virtual] : virtual.split(".");
      let cur = obj;
      for (let i = 0;i < sp.length - 1; ++i) {
        cur[sp[i]] = sp[i] in cur ? cur[sp[i]] : {};
        cur = cur[sp[i]];
      }
      let val = virtualType.applyGetters(cur[sp[sp.length - 1]], obj);
      const isPopulateVirtual = virtualType.options && (virtualType.options.ref || virtualType.options.refPath);
      if (isPopulateVirtual && val === undefined) {
        if (virtualType.options.justOne) {
          val = null;
        } else {
          val = [];
        }
      }
      cur[sp[sp.length - 1]] = val;
    }
  }
  var mpath = require_mpath();
  module.exports = applyVirtuals;
});

// node_modules/mongoose/lib/helpers/populate/skipPopulateValue.js
var require_skipPopulateValue = __commonJS((exports, module) => {
  module.exports = function SkipPopulateValue(val) {
    if (!(this instanceof SkipPopulateValue)) {
      return new SkipPopulateValue(val);
    }
    this.val = val;
    return this;
  };
});

// node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js
var require_leanPopulateMap = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  module.exports = new WeakMap;
});

// node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js
var require_assignRawDocsToIdStructure = __commonJS((exports, module) => {
  function assignRawDocsToIdStructure(rawIds, resultDocs, resultOrder, options, recursed) {
    const newOrder = [];
    const sorting = options.isVirtual && options.justOne && rawIds.length > 1 ? false : options.sort && rawIds.length > 1;
    const nullIfNotFound = options.$nullIfNotFound;
    let doc;
    let sid;
    let id;
    if (utils.isMongooseArray(rawIds)) {
      rawIds = rawIds.__array;
    }
    let i = 0;
    const len = rawIds.length;
    if (sorting && recursed && options[kHasArray] === undefined) {
      options[kHasArray] = false;
      for (const key in resultOrder) {
        if (Array.isArray(resultOrder[key])) {
          options[kHasArray] = true;
          break;
        }
      }
    }
    for (i = 0;i < len; ++i) {
      id = rawIds[i];
      if (Array.isArray(id)) {
        assignRawDocsToIdStructure(id, resultDocs, resultOrder, options, true);
        newOrder.push(id);
        continue;
      }
      if (id === null && sorting === false) {
        newOrder.push(id);
        continue;
      }
      sid = String(id);
      doc = resultDocs[sid];
      if (options.clone && doc != null) {
        if (options.lean) {
          const _model = leanPopulateMap.get(doc);
          doc = clone(doc);
          leanPopulateMap.set(doc, _model);
        } else {
          doc = doc.constructor.hydrate(doc._doc);
        }
      }
      if (recursed) {
        if (doc) {
          if (sorting) {
            const _resultOrder = resultOrder[sid];
            if (options[kHasArray]) {
              newOrder.push(doc);
            } else {
              newOrder[_resultOrder] = doc;
            }
          } else {
            newOrder.push(doc);
          }
        } else if (id != null && id[modelSymbol] != null) {
          newOrder.push(id);
        } else {
          newOrder.push(options.retainNullValues || nullIfNotFound ? null : id);
        }
      } else {
        newOrder[i] = doc || null;
      }
    }
    rawIds.length = 0;
    if (newOrder.length) {
      newOrder.forEach(function(doc2, i2) {
        rawIds[i2] = doc2;
      });
    }
  }
  var clone = require_clone2();
  var leanPopulateMap = require_leanPopulateMap();
  var modelSymbol = require_symbols().modelSymbol;
  var utils = require_utils4();
  module.exports = assignRawDocsToIdStructure;
  var kHasArray = Symbol("mongoose#assignRawDocsToIdStructure#hasArray");
});

// node_modules/mongoose/lib/helpers/populate/getVirtual.js
var require_getVirtual = __commonJS((exports, module) => {
  function getVirtual(schema, name) {
    if (schema.virtuals[name]) {
      return { virtual: schema.virtuals[name], path: undefined };
    }
    const parts = name.split(".");
    let cur = "";
    let nestedSchemaPath = "";
    for (let i = 0;i < parts.length; ++i) {
      cur += (cur.length > 0 ? "." : "") + parts[i];
      if (schema.virtuals[cur]) {
        if (i === parts.length - 1) {
          return { virtual: schema.virtuals[cur], path: nestedSchemaPath };
        }
        continue;
      }
      if (schema.nested[cur]) {
        continue;
      }
      if (schema.paths[cur] && schema.paths[cur].schema) {
        schema = schema.paths[cur].schema;
        const rest = parts.slice(i + 1).join(".");
        if (schema.virtuals[rest]) {
          if (i === parts.length - 2) {
            return {
              virtual: schema.virtuals[rest],
              nestedSchemaPath: [nestedSchemaPath, cur].filter((v) => !!v).join(".")
            };
          }
          continue;
        }
        if (i + 1 < parts.length && schema.discriminators) {
          for (const key of Object.keys(schema.discriminators)) {
            const res = getVirtual(schema.discriminators[key], rest);
            if (res != null) {
              const _path = [nestedSchemaPath, cur, res.nestedSchemaPath].filter((v) => !!v).join(".");
              return {
                virtual: res.virtual,
                nestedSchemaPath: _path
              };
            }
          }
        }
        nestedSchemaPath += (nestedSchemaPath.length > 0 ? "." : "") + cur;
        cur = "";
        continue;
      }
      if (schema.discriminators) {
        for (const discriminatorKey of Object.keys(schema.discriminators)) {
          const virtualFromDiscriminator = getVirtual(schema.discriminators[discriminatorKey], name);
          if (virtualFromDiscriminator)
            return virtualFromDiscriminator;
        }
      }
      return null;
    }
  }
  module.exports = getVirtual;
  /*!
   * ignore
   */
});

// node_modules/sift/lib/index.js
var require_lib5 = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.sift = {}));
  })(exports, function(exports2) {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    function __extends(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    }
    typeof SuppressedError === "function" && SuppressedError;
    var typeChecker = function(type) {
      var typeString = "[object " + type + "]";
      return function(value) {
        return getClassName(value) === typeString;
      };
    };
    var getClassName = function(value) {
      return Object.prototype.toString.call(value);
    };
    var comparable = function(value) {
      if (value instanceof Date) {
        return value.getTime();
      } else if (isArray(value)) {
        return value.map(comparable);
      } else if (value && typeof value.toJSON === "function") {
        return value.toJSON();
      }
      return value;
    };
    var coercePotentiallyNull = function(value) {
      return value == null ? null : value;
    };
    var isArray = typeChecker("Array");
    var isObject = typeChecker("Object");
    var isFunction = typeChecker("Function");
    var isProperty = function(item, key) {
      return item.hasOwnProperty(key) && !isFunction(item[key]);
    };
    var isVanillaObject = function(value) {
      return value && (value.constructor === Object || value.constructor === Array || value.constructor.toString() === "function Object() { [native code] }" || value.constructor.toString() === "function Array() { [native code] }") && !value.toJSON;
    };
    var equals = function(a, b) {
      if (a == null && a == b) {
        return true;
      }
      if (a === b) {
        return true;
      }
      if (Object.prototype.toString.call(a) !== Object.prototype.toString.call(b)) {
        return false;
      }
      if (isArray(a)) {
        if (a.length !== b.length) {
          return false;
        }
        for (var i = 0, length_1 = a.length;i < length_1; i++) {
          if (!equals(a[i], b[i]))
            return false;
        }
        return true;
      } else if (isObject(a)) {
        if (Object.keys(a).length !== Object.keys(b).length) {
          return false;
        }
        for (var key in a) {
          if (!equals(a[key], b[key]))
            return false;
        }
        return true;
      }
      return false;
    };
    var walkKeyPathValues = function(item, keyPath, next, depth, key, owner) {
      var currentKey = keyPath[depth];
      if (isArray(item) && isNaN(Number(currentKey)) && !isProperty(item, currentKey)) {
        for (var i = 0, length_1 = item.length;i < length_1; i++) {
          if (!walkKeyPathValues(item[i], keyPath, next, depth, i, item)) {
            return false;
          }
        }
      }
      if (depth === keyPath.length || item == null) {
        return next(item, key, owner, depth === 0, depth === keyPath.length);
      }
      return walkKeyPathValues(item[currentKey], keyPath, next, depth + 1, currentKey, item);
    };
    var BaseOperation = function() {
      function BaseOperation2(params, owneryQuery, options, name) {
        this.params = params;
        this.owneryQuery = owneryQuery;
        this.options = options;
        this.name = name;
        this.init();
      }
      BaseOperation2.prototype.init = function() {
      };
      BaseOperation2.prototype.reset = function() {
        this.done = false;
        this.keep = false;
      };
      return BaseOperation2;
    }();
    var GroupOperation = function(_super) {
      __extends(GroupOperation2, _super);
      function GroupOperation2(params, owneryQuery, options, children) {
        var _this = _super.call(this, params, owneryQuery, options) || this;
        _this.children = children;
        return _this;
      }
      GroupOperation2.prototype.reset = function() {
        this.keep = false;
        this.done = false;
        for (var i = 0, length_2 = this.children.length;i < length_2; i++) {
          this.children[i].reset();
        }
      };
      GroupOperation2.prototype.childrenNext = function(item, key, owner, root, leaf) {
        var done = true;
        var keep = true;
        for (var i = 0, length_3 = this.children.length;i < length_3; i++) {
          var childOperation = this.children[i];
          if (!childOperation.done) {
            childOperation.next(item, key, owner, root, leaf);
          }
          if (!childOperation.keep) {
            keep = false;
          }
          if (childOperation.done) {
            if (!childOperation.keep) {
              break;
            }
          } else {
            done = false;
          }
        }
        this.done = done;
        this.keep = keep;
      };
      return GroupOperation2;
    }(BaseOperation);
    var NamedGroupOperation = function(_super) {
      __extends(NamedGroupOperation2, _super);
      function NamedGroupOperation2(params, owneryQuery, options, children, name) {
        var _this = _super.call(this, params, owneryQuery, options, children) || this;
        _this.name = name;
        return _this;
      }
      return NamedGroupOperation2;
    }(GroupOperation);
    var QueryOperation = function(_super) {
      __extends(QueryOperation2, _super);
      function QueryOperation2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = true;
        return _this;
      }
      QueryOperation2.prototype.next = function(item, key, parent, root) {
        this.childrenNext(item, key, parent, root);
      };
      return QueryOperation2;
    }(GroupOperation);
    var NestedOperation = function(_super) {
      __extends(NestedOperation2, _super);
      function NestedOperation2(keyPath, params, owneryQuery, options, children) {
        var _this = _super.call(this, params, owneryQuery, options, children) || this;
        _this.keyPath = keyPath;
        _this.propop = true;
        _this._nextNestedValue = function(value, key, owner, root, leaf) {
          _this.childrenNext(value, key, owner, root, leaf);
          return !_this.done;
        };
        return _this;
      }
      NestedOperation2.prototype.next = function(item, key, parent) {
        walkKeyPathValues(item, this.keyPath, this._nextNestedValue, 0, key, parent);
      };
      return NestedOperation2;
    }(GroupOperation);
    var createTester = function(a, compare) {
      if (a instanceof Function) {
        return a;
      }
      if (a instanceof RegExp) {
        return function(b) {
          var result = typeof b === "string" && a.test(b);
          a.lastIndex = 0;
          return result;
        };
      }
      var comparableA = comparable(a);
      return function(b) {
        return compare(comparableA, comparable(b));
      };
    };
    var EqualsOperation = function(_super) {
      __extends(EqualsOperation2, _super);
      function EqualsOperation2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = true;
        return _this;
      }
      EqualsOperation2.prototype.init = function() {
        this._test = createTester(this.params, this.options.compare);
      };
      EqualsOperation2.prototype.next = function(item, key, parent) {
        if (!Array.isArray(parent) || parent.hasOwnProperty(key)) {
          if (this._test(item, key, parent)) {
            this.done = true;
            this.keep = true;
          }
        }
      };
      return EqualsOperation2;
    }(BaseOperation);
    var createEqualsOperation = function(params, owneryQuery, options) {
      return new EqualsOperation(params, owneryQuery, options);
    };
    var numericalOperationCreator = function(createNumericalOperation) {
      return function(params, owneryQuery, options, name) {
        return createNumericalOperation(params, owneryQuery, options, name);
      };
    };
    var numericalOperation = function(createTester2) {
      return numericalOperationCreator(function(params, owneryQuery, options, name) {
        var typeofParams = typeof comparable(params);
        var test = createTester2(params);
        return new EqualsOperation(function(b) {
          var actualValue = coercePotentiallyNull(b);
          return typeof comparable(actualValue) === typeofParams && test(actualValue);
        }, owneryQuery, options, name);
      });
    };
    var createNamedOperation = function(name, params, parentQuery, options) {
      var operationCreator = options.operations[name];
      if (!operationCreator) {
        throwUnsupportedOperation(name);
      }
      return operationCreator(params, parentQuery, options, name);
    };
    var throwUnsupportedOperation = function(name) {
      throw new Error("Unsupported operation: ".concat(name));
    };
    var containsOperation = function(query, options) {
      for (var key in query) {
        if (options.operations.hasOwnProperty(key) || key.charAt(0) === "$")
          return true;
      }
      return false;
    };
    var createNestedOperation = function(keyPath, nestedQuery, parentKey, owneryQuery, options) {
      if (containsOperation(nestedQuery, options)) {
        var _a = createQueryOperations(nestedQuery, parentKey, options), selfOperations = _a[0], nestedOperations = _a[1];
        if (nestedOperations.length) {
          throw new Error("Property queries must contain only operations, or exact objects.");
        }
        return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, selfOperations);
      }
      return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, [
        new EqualsOperation(nestedQuery, owneryQuery, options)
      ]);
    };
    var createQueryOperation = function(query, owneryQuery, _a) {
      if (owneryQuery === undefined) {
        owneryQuery = null;
      }
      var _b = _a === undefined ? {} : _a, compare = _b.compare, operations = _b.operations;
      var options = {
        compare: compare || equals,
        operations: Object.assign({}, operations || {})
      };
      var _c = createQueryOperations(query, null, options), selfOperations = _c[0], nestedOperations = _c[1];
      var ops = [];
      if (selfOperations.length) {
        ops.push(new NestedOperation([], query, owneryQuery, options, selfOperations));
      }
      ops.push.apply(ops, nestedOperations);
      if (ops.length === 1) {
        return ops[0];
      }
      return new QueryOperation(query, owneryQuery, options, ops);
    };
    var createQueryOperations = function(query, parentKey, options) {
      var selfOperations = [];
      var nestedOperations = [];
      if (!isVanillaObject(query)) {
        selfOperations.push(new EqualsOperation(query, query, options));
        return [selfOperations, nestedOperations];
      }
      for (var key in query) {
        if (options.operations.hasOwnProperty(key)) {
          var op = createNamedOperation(key, query[key], query, options);
          if (op) {
            if (!op.propop && parentKey && !options.operations[parentKey]) {
              throw new Error("Malformed query. ".concat(key, " cannot be matched against property."));
            }
          }
          if (op != null) {
            selfOperations.push(op);
          }
        } else if (key.charAt(0) === "$") {
          throwUnsupportedOperation(key);
        } else {
          nestedOperations.push(createNestedOperation(key.split("."), query[key], key, query, options));
        }
      }
      return [selfOperations, nestedOperations];
    };
    var createOperationTester = function(operation) {
      return function(item, key, owner) {
        operation.reset();
        operation.next(item, key, owner);
        return operation.keep;
      };
    };
    var createQueryTester = function(query, options) {
      if (options === undefined) {
        options = {};
      }
      return createOperationTester(createQueryOperation(query, null, options));
    };
    var $Ne = function(_super) {
      __extends($Ne2, _super);
      function $Ne2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = true;
        return _this;
      }
      $Ne2.prototype.init = function() {
        this._test = createTester(this.params, this.options.compare);
      };
      $Ne2.prototype.reset = function() {
        _super.prototype.reset.call(this);
        this.keep = true;
      };
      $Ne2.prototype.next = function(item) {
        if (this._test(item)) {
          this.done = true;
          this.keep = false;
        }
      };
      return $Ne2;
    }(BaseOperation);
    var $ElemMatch = function(_super) {
      __extends($ElemMatch2, _super);
      function $ElemMatch2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = true;
        return _this;
      }
      $ElemMatch2.prototype.init = function() {
        if (!this.params || typeof this.params !== "object") {
          throw new Error("Malformed query. $elemMatch must by an object.");
        }
        this._queryOperation = createQueryOperation(this.params, this.owneryQuery, this.options);
      };
      $ElemMatch2.prototype.reset = function() {
        _super.prototype.reset.call(this);
        this._queryOperation.reset();
      };
      $ElemMatch2.prototype.next = function(item) {
        if (isArray(item)) {
          for (var i = 0, length_1 = item.length;i < length_1; i++) {
            this._queryOperation.reset();
            var child = item[i];
            this._queryOperation.next(child, i, item, false);
            this.keep = this.keep || this._queryOperation.keep;
          }
          this.done = true;
        } else {
          this.done = false;
          this.keep = false;
        }
      };
      return $ElemMatch2;
    }(BaseOperation);
    var $Not = function(_super) {
      __extends($Not2, _super);
      function $Not2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = true;
        return _this;
      }
      $Not2.prototype.init = function() {
        this._queryOperation = createQueryOperation(this.params, this.owneryQuery, this.options);
      };
      $Not2.prototype.reset = function() {
        _super.prototype.reset.call(this);
        this._queryOperation.reset();
      };
      $Not2.prototype.next = function(item, key, owner, root) {
        this._queryOperation.next(item, key, owner, root);
        this.done = this._queryOperation.done;
        this.keep = !this._queryOperation.keep;
      };
      return $Not2;
    }(BaseOperation);
    var $Size = function(_super) {
      __extends($Size2, _super);
      function $Size2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = true;
        return _this;
      }
      $Size2.prototype.init = function() {
      };
      $Size2.prototype.next = function(item) {
        if (isArray(item) && item.length === this.params) {
          this.done = true;
          this.keep = true;
        }
      };
      return $Size2;
    }(BaseOperation);
    var assertGroupNotEmpty = function(values) {
      if (values.length === 0) {
        throw new Error("$and/$or/$nor must be a nonempty array");
      }
    };
    var $Or = function(_super) {
      __extends($Or2, _super);
      function $Or2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = false;
        return _this;
      }
      $Or2.prototype.init = function() {
        var _this = this;
        assertGroupNotEmpty(this.params);
        this._ops = this.params.map(function(op) {
          return createQueryOperation(op, null, _this.options);
        });
      };
      $Or2.prototype.reset = function() {
        this.done = false;
        this.keep = false;
        for (var i = 0, length_2 = this._ops.length;i < length_2; i++) {
          this._ops[i].reset();
        }
      };
      $Or2.prototype.next = function(item, key, owner) {
        var done = false;
        var success = false;
        for (var i = 0, length_3 = this._ops.length;i < length_3; i++) {
          var op = this._ops[i];
          op.next(item, key, owner);
          if (op.keep) {
            done = true;
            success = op.keep;
            break;
          }
        }
        this.keep = success;
        this.done = done;
      };
      return $Or2;
    }(BaseOperation);
    var $Nor = function(_super) {
      __extends($Nor2, _super);
      function $Nor2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = false;
        return _this;
      }
      $Nor2.prototype.next = function(item, key, owner) {
        _super.prototype.next.call(this, item, key, owner);
        this.keep = !this.keep;
      };
      return $Nor2;
    }($Or);
    var $In = function(_super) {
      __extends($In2, _super);
      function $In2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = true;
        return _this;
      }
      $In2.prototype.init = function() {
        var _this = this;
        var params = Array.isArray(this.params) ? this.params : [this.params];
        this._testers = params.map(function(value) {
          if (containsOperation(value, _this.options)) {
            throw new Error("cannot nest $ under ".concat(_this.name.toLowerCase()));
          }
          return createTester(value, _this.options.compare);
        });
      };
      $In2.prototype.next = function(item, key, owner) {
        var done = false;
        var success = false;
        for (var i = 0, length_4 = this._testers.length;i < length_4; i++) {
          var test = this._testers[i];
          if (test(item)) {
            done = true;
            success = true;
            break;
          }
        }
        this.keep = success;
        this.done = done;
      };
      return $In2;
    }(BaseOperation);
    var $Nin = function(_super) {
      __extends($Nin2, _super);
      function $Nin2(params, ownerQuery, options, name) {
        var _this = _super.call(this, params, ownerQuery, options, name) || this;
        _this.propop = true;
        _this._in = new $In(params, ownerQuery, options, name);
        return _this;
      }
      $Nin2.prototype.next = function(item, key, owner, root) {
        this._in.next(item, key, owner);
        if (isArray(owner) && !root) {
          if (this._in.keep) {
            this.keep = false;
            this.done = true;
          } else if (key == owner.length - 1) {
            this.keep = true;
            this.done = true;
          }
        } else {
          this.keep = !this._in.keep;
          this.done = true;
        }
      };
      $Nin2.prototype.reset = function() {
        _super.prototype.reset.call(this);
        this._in.reset();
      };
      return $Nin2;
    }(BaseOperation);
    var $Exists = function(_super) {
      __extends($Exists2, _super);
      function $Exists2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.propop = true;
        return _this;
      }
      $Exists2.prototype.next = function(item, key, owner, root, leaf) {
        if (!leaf) {
          this.done = true;
          this.keep = !this.params;
        } else if (owner.hasOwnProperty(key) === this.params) {
          this.done = true;
          this.keep = true;
        }
      };
      return $Exists2;
    }(BaseOperation);
    var $And = function(_super) {
      __extends($And2, _super);
      function $And2(params, owneryQuery, options, name) {
        var _this = _super.call(this, params, owneryQuery, options, params.map(function(query) {
          return createQueryOperation(query, owneryQuery, options);
        }), name) || this;
        _this.propop = false;
        assertGroupNotEmpty(params);
        return _this;
      }
      $And2.prototype.next = function(item, key, owner, root) {
        this.childrenNext(item, key, owner, root);
      };
      return $And2;
    }(NamedGroupOperation);
    var $All = function(_super) {
      __extends($All2, _super);
      function $All2(params, owneryQuery, options, name) {
        var _this = _super.call(this, params, owneryQuery, options, params.map(function(query) {
          return createQueryOperation(query, owneryQuery, options);
        }), name) || this;
        _this.propop = true;
        return _this;
      }
      $All2.prototype.next = function(item, key, owner, root) {
        this.childrenNext(item, key, owner, root);
      };
      return $All2;
    }(NamedGroupOperation);
    var $eq = function(params, owneryQuery, options) {
      return new EqualsOperation(params, owneryQuery, options);
    };
    var $ne = function(params, owneryQuery, options, name) {
      return new $Ne(params, owneryQuery, options, name);
    };
    var $or = function(params, owneryQuery, options, name) {
      return new $Or(params, owneryQuery, options, name);
    };
    var $nor = function(params, owneryQuery, options, name) {
      return new $Nor(params, owneryQuery, options, name);
    };
    var $elemMatch = function(params, owneryQuery, options, name) {
      return new $ElemMatch(params, owneryQuery, options, name);
    };
    var $nin = function(params, owneryQuery, options, name) {
      return new $Nin(params, owneryQuery, options, name);
    };
    var $in = function(params, owneryQuery, options, name) {
      return new $In(params, owneryQuery, options, name);
    };
    var $lt = numericalOperation(function(params) {
      return function(b) {
        return b != null && b < params;
      };
    });
    var $lte = numericalOperation(function(params) {
      return function(b) {
        return b === params || b <= params;
      };
    });
    var $gt = numericalOperation(function(params) {
      return function(b) {
        return b != null && b > params;
      };
    });
    var $gte = numericalOperation(function(params) {
      return function(b) {
        return b === params || b >= params;
      };
    });
    var $mod = function(_a, owneryQuery, options) {
      var mod = _a[0], equalsValue = _a[1];
      return new EqualsOperation(function(b) {
        return comparable(b) % mod === equalsValue;
      }, owneryQuery, options);
    };
    var $exists = function(params, owneryQuery, options, name) {
      return new $Exists(params, owneryQuery, options, name);
    };
    var $regex = function(pattern, owneryQuery, options) {
      return new EqualsOperation(new RegExp(pattern, owneryQuery.$options), owneryQuery, options);
    };
    var $not = function(params, owneryQuery, options, name) {
      return new $Not(params, owneryQuery, options, name);
    };
    var typeAliases = {
      number: function(v) {
        return typeof v === "number";
      },
      string: function(v) {
        return typeof v === "string";
      },
      bool: function(v) {
        return typeof v === "boolean";
      },
      array: function(v) {
        return Array.isArray(v);
      },
      null: function(v) {
        return v === null;
      },
      timestamp: function(v) {
        return v instanceof Date;
      }
    };
    var $type = function(clazz, owneryQuery, options) {
      return new EqualsOperation(function(b) {
        if (typeof clazz === "string") {
          if (!typeAliases[clazz]) {
            throw new Error("Type alias does not exist");
          }
          return typeAliases[clazz](b);
        }
        return b != null ? b instanceof clazz || b.constructor === clazz : false;
      }, owneryQuery, options);
    };
    var $and = function(params, ownerQuery, options, name) {
      return new $And(params, ownerQuery, options, name);
    };
    var $all = function(params, ownerQuery, options, name) {
      return new $All(params, ownerQuery, options, name);
    };
    var $size = function(params, ownerQuery, options) {
      return new $Size(params, ownerQuery, options, "$size");
    };
    var $options = function() {
      return null;
    };
    var $where = function(params, ownerQuery, options) {
      var test;
      if (isFunction(params)) {
        test = params;
      } else if (!process.env.CSP_ENABLED) {
        test = new Function("obj", "return " + params);
      } else {
        throw new Error("In CSP mode, sift does not support strings in \"$where\" condition");
      }
      return new EqualsOperation(function(b) {
        return test.bind(b)(b);
      }, ownerQuery, options);
    };
    var defaultOperations = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      $Size,
      $all,
      $and,
      $elemMatch,
      $eq,
      $exists,
      $gt,
      $gte,
      $in,
      $lt,
      $lte,
      $mod,
      $ne,
      $nin,
      $nor,
      $not,
      $options,
      $or,
      $regex,
      $size,
      $type,
      $where
    });
    var createDefaultQueryOperation = function(query, ownerQuery, _a) {
      var _b = _a === undefined ? {} : _a, compare = _b.compare, operations = _b.operations;
      return createQueryOperation(query, ownerQuery, {
        compare,
        operations: Object.assign({}, defaultOperations, operations || {})
      });
    };
    var createDefaultQueryTester = function(query, options) {
      if (options === undefined) {
        options = {};
      }
      var op = createDefaultQueryOperation(query, null, options);
      return createOperationTester(op);
    };
    exports2.$Size = $Size;
    exports2.$all = $all;
    exports2.$and = $and;
    exports2.$elemMatch = $elemMatch;
    exports2.$eq = $eq;
    exports2.$exists = $exists;
    exports2.$gt = $gt;
    exports2.$gte = $gte;
    exports2.$in = $in;
    exports2.$lt = $lt;
    exports2.$lte = $lte;
    exports2.$mod = $mod;
    exports2.$ne = $ne;
    exports2.$nin = $nin;
    exports2.$nor = $nor;
    exports2.$not = $not;
    exports2.$options = $options;
    exports2.$or = $or;
    exports2.$regex = $regex;
    exports2.$size = $size;
    exports2.$type = $type;
    exports2.$where = $where;
    exports2.EqualsOperation = EqualsOperation;
    exports2.createDefaultQueryOperation = createDefaultQueryOperation;
    exports2.createEqualsOperation = createEqualsOperation;
    exports2.createOperationTester = createOperationTester;
    exports2.createQueryOperation = createQueryOperation;
    exports2.createQueryTester = createQueryTester;
    exports2.default = createDefaultQueryTester;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
});

// node_modules/sift/index.js
var require_sift = __commonJS((exports, module) => {
  var lib = require_lib5();
  module.exports = lib.default;
  Object.assign(module.exports, lib);
});

// node_modules/mongoose/lib/helpers/populate/assignVals.js
var require_assignVals = __commonJS((exports, module) => {
  function numDocs(v) {
    if (Array.isArray(v)) {
      if (v.some((el) => Array.isArray(el) || el === null)) {
        return v.map((el) => {
          if (el == null) {
            return 0;
          }
          if (Array.isArray(el)) {
            return el.filter((el2) => el2 != null).length;
          }
          return 1;
        });
      }
      return v.filter((el) => el != null).length;
    }
    return v == null ? 0 : 1;
  }
  function valueFilter(val, assignmentOpts, populateOptions, allIds) {
    const userSpecifiedTransform = typeof populateOptions.transform === "function";
    const transform = userSpecifiedTransform ? populateOptions.transform : (v) => v;
    if (Array.isArray(val)) {
      const ret = [];
      const numValues = val.length;
      for (let i2 = 0;i2 < numValues; ++i2) {
        let subdoc = val[i2];
        const _allIds = Array.isArray(allIds) ? allIds[i2] : allIds;
        if (!isPopulatedObject(subdoc) && (!populateOptions.retainNullValues || subdoc != null) && !userSpecifiedTransform) {
          continue;
        } else if (!populateOptions.retainNullValues && subdoc == null) {
          continue;
        } else if (userSpecifiedTransform) {
          subdoc = transform(isPopulatedObject(subdoc) ? subdoc : null, _allIds);
        }
        maybeRemoveId(subdoc, assignmentOpts);
        ret.push(subdoc);
        if (assignmentOpts.originalLimit && ret.length >= assignmentOpts.originalLimit) {
          break;
        }
      }
      const rLen = ret.length;
      while (val.length > rLen) {
        Array.prototype.pop.apply(val, []);
      }
      let i = 0;
      if (utils.isMongooseArray(val)) {
        for (i = 0;i < rLen; ++i) {
          val.set(i, ret[i], true);
        }
      } else {
        for (i = 0;i < rLen; ++i) {
          val[i] = ret[i];
        }
      }
      return val;
    }
    if (isPopulatedObject(val) || utils.isPOJO(val)) {
      maybeRemoveId(val, assignmentOpts);
      return transform(val, allIds);
    }
    if (val instanceof Map) {
      return val;
    }
    if (populateOptions.justOne === false) {
      return [];
    }
    return val == null ? transform(val, allIds) : transform(null, allIds);
  }
  function maybeRemoveId(subdoc, assignmentOpts) {
    if (subdoc != null && assignmentOpts.excludeId) {
      if (typeof subdoc.$__setValue === "function") {
        delete subdoc._doc._id;
      } else {
        delete subdoc._id;
      }
    }
  }
  function isPopulatedObject(obj) {
    if (obj == null) {
      return false;
    }
    return Array.isArray(obj) || obj.$isMongooseMap || obj.$__ != null || leanPopulateMap.has(obj);
  }
  var MongooseMap = require_map2();
  var SkipPopulateValue = require_skipPopulateValue();
  var assignRawDocsToIdStructure = require_assignRawDocsToIdStructure();
  var get = require_get2();
  var getVirtual = require_getVirtual();
  var leanPopulateMap = require_leanPopulateMap();
  var lookupLocalFields = require_lookupLocalFields();
  var markArraySubdocsPopulated = require_markArraySubdocsPopulated();
  var mpath = require_mpath();
  var sift = require_sift().default;
  var utils = require_utils4();
  var { populateModelSymbol } = require_symbols();
  module.exports = function assignVals(o) {
    const userOptions = Object.assign({}, get(o, "allOptions.options.options"), get(o, "allOptions.options"));
    const populateOptions = Object.assign({}, o.options, userOptions, {
      justOne: o.justOne,
      isVirtual: o.isVirtual
    });
    populateOptions.$nullIfNotFound = o.isVirtual;
    const populatedModel = o.populatedModel;
    const originalIds = [].concat(o.rawIds);
    o.allIds = [].concat(o.allIds);
    assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, populateOptions);
    const docs = o.docs;
    const rawIds = o.rawIds;
    const options = o.options;
    const count = o.count && o.isVirtual;
    let i;
    let setValueIndex = 0;
    function setValue(val) {
      ++setValueIndex;
      if (count) {
        return val;
      }
      if (val instanceof SkipPopulateValue) {
        return val.val;
      }
      if (val === undefined) {
        return val;
      }
      const _allIds = o.allIds[i];
      if (o.path.endsWith(".$*")) {
        return valueFilter(val, options, populateOptions, _allIds);
      }
      if (o.justOne === true && Array.isArray(val)) {
        const ret = [];
        for (const doc of val) {
          const _docPopulatedModel = leanPopulateMap.get(doc);
          if (_docPopulatedModel == null || _docPopulatedModel === populatedModel) {
            ret.push(doc);
          }
        }
        while (val.length > ret.length) {
          Array.prototype.pop.apply(val, []);
        }
        for (let i2 = 0;i2 < ret.length; ++i2) {
          val[i2] = ret[i2];
        }
        return valueFilter(val[0], options, populateOptions, _allIds);
      } else if (o.justOne === false && !Array.isArray(val)) {
        return valueFilter([val], options, populateOptions, _allIds);
      } else if (o.justOne === true && !Array.isArray(val) && Array.isArray(_allIds)) {
        return valueFilter(val, options, populateOptions, val == null ? val : _allIds[setValueIndex - 1]);
      }
      return valueFilter(val, options, populateOptions, _allIds);
    }
    for (i = 0;i < docs.length; ++i) {
      setValueIndex = 0;
      const _path = o.path.endsWith(".$*") ? o.path.slice(0, -3) : o.path;
      const existingVal = mpath.get(_path, docs[i], lookupLocalFields);
      if (existingVal == null && !getVirtual(o.originalModel.schema, _path)) {
        continue;
      }
      let valueToSet;
      if (count) {
        valueToSet = numDocs(rawIds[i]);
      } else if (Array.isArray(o.match)) {
        valueToSet = Array.isArray(rawIds[i]) ? rawIds[i].filter((v) => v == null || sift(o.match[i])(v)) : [rawIds[i]].filter((v) => v == null || sift(o.match[i])(v))[0];
      } else {
        valueToSet = rawIds[i];
      }
      const originalSchema = o.originalModel.schema;
      const isDoc = get(docs[i], "$__", null) != null;
      let isMap = isDoc ? existingVal instanceof Map : utils.isPOJO(existingVal);
      isMap = isMap && get(originalSchema._getSchema(_path), "$isSchemaMap");
      if (!o.isVirtual && isMap) {
        const _keys = existingVal instanceof Map ? Array.from(existingVal.keys()) : Object.keys(existingVal);
        valueToSet = valueToSet.reduce((cur2, v, i2) => {
          cur2.set(_keys[i2], v);
          return cur2;
        }, new Map);
      }
      if (isDoc && Array.isArray(valueToSet)) {
        for (const val of valueToSet) {
          if (val != null && val.$__ != null) {
            val.$__.parent = docs[i];
          }
        }
      } else if (isDoc && valueToSet != null && valueToSet.$__ != null) {
        valueToSet.$__.parent = docs[i];
      }
      if (o.isVirtual && isDoc) {
        docs[i].$populated(_path, o.justOne ? originalIds[0] : originalIds, o.allOptions);
        if (Array.isArray(valueToSet)) {
          valueToSet = valueToSet.map((v) => v == null ? undefined : v);
        }
        mpath.set(_path, valueToSet, docs[i], undefined, setValue, false);
        continue;
      }
      const parts = _path.split(".");
      let cur = docs[i];
      for (let j = 0;j < parts.length - 1; ++j) {
        if (Array.isArray(cur) && !utils.isArrayIndex(parts[j])) {
          break;
        }
        if (parts[j] === "$*") {
          break;
        }
        if (cur[parts[j]] == null) {
          const curPath = parts.slice(0, j + 1).join(".");
          const schematype = originalSchema._getSchema(curPath);
          if (valueToSet == null && schematype != null && schematype.$isMongooseArray) {
            break;
          }
          cur[parts[j]] = {};
        }
        cur = cur[parts[j]];
        if (typeof cur !== "object") {
          break;
        }
      }
      if (docs[i].$__) {
        o.allOptions.options[populateModelSymbol] = o.allOptions.model;
        docs[i].$populated(_path, o.unpopulatedValues[i], o.allOptions.options);
        if (valueToSet != null && valueToSet.$__ != null) {
          valueToSet.$__.wasPopulated = { value: o.unpopulatedValues[i] };
        }
        if (valueToSet instanceof Map && !valueToSet.$isMongooseMap) {
          valueToSet = new MongooseMap(valueToSet, _path, docs[i], docs[i].schema.path(_path).$__schemaType);
        }
      }
      mpath.set(_path, valueToSet, docs[i], lookupLocalFields, setValue, false);
      if (docs[i].$__) {
        markArraySubdocsPopulated(docs[i], [o.allOptions.options]);
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js
var require_createPopulateQueryFilter = __commonJS((exports, module) => {
  function _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds) {
    ids = ids.filter((v) => !(v instanceof SkipPopulateValue));
    if (!skipInvalidIds) {
      return ids;
    }
    return ids.filter((id) => {
      try {
        foreignSchemaType.cast(id);
        return true;
      } catch (err) {
        return false;
      }
    });
  }
  function _formatMatch(match) {
    if (Array.isArray(match)) {
      if (match.length > 1) {
        return { $or: [].concat(match.map((m) => Object.assign({}, m))) };
      }
      return Object.assign({}, match[0]);
    }
    return Object.assign({}, match);
  }
  var SkipPopulateValue = require_skipPopulateValue();
  var parentPaths = require_parentPaths();
  var { trusted } = require_trusted();
  var hasDollarKeys = require_hasDollarKeys();
  module.exports = function createPopulateQueryFilter(ids, _match, _foreignField, model, skipInvalidIds) {
    const match = _formatMatch(_match);
    if (_foreignField.size === 1) {
      const foreignField = Array.from(_foreignField)[0];
      const foreignSchemaType = model.schema.path(foreignField);
      if (foreignField !== "_id" || !match["_id"]) {
        ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);
        match[foreignField] = trusted({ $in: ids });
      } else if (foreignField === "_id" && match["_id"]) {
        const userSpecifiedMatch = hasDollarKeys(match[foreignField]) ? match[foreignField] : { $eq: match[foreignField] };
        match[foreignField] = { ...trusted({ $in: ids }), ...userSpecifiedMatch };
      }
      const _parentPaths = parentPaths(foreignField);
      for (let i = 0;i < _parentPaths.length - 1; ++i) {
        const cur = _parentPaths[i];
        if (match[cur] != null && match[cur].$elemMatch != null) {
          match[cur].$elemMatch[foreignField.slice(cur.length + 1)] = trusted({ $in: ids });
          delete match[foreignField];
          break;
        }
      }
    } else {
      const $or = [];
      if (Array.isArray(match.$or)) {
        match.$and = [{ $or: match.$or }, { $or }];
        delete match.$or;
      } else {
        match.$or = $or;
      }
      for (const foreignField of _foreignField) {
        if (foreignField !== "_id" || !match["_id"]) {
          const foreignSchemaType = model.schema.path(foreignField);
          ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);
          $or.push({ [foreignField]: { $in: ids } });
        } else if (foreignField === "_id" && match["_id"]) {
          const userSpecifiedMatch = hasDollarKeys(match[foreignField]) ? match[foreignField] : { $eq: match[foreignField] };
          match[foreignField] = { ...trusted({ $in: ids }), ...userSpecifiedMatch };
        }
      }
    }
    return match;
  };
});

// node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js
var require_getSchemaTypes = __commonJS((exports, module) => {
  /*!
   * ignore
   */
  var Mixed = require_mixed();
  var get = require_get2();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var leanPopulateMap = require_leanPopulateMap();
  var mpath = require_mpath();
  var populateModelSymbol = require_symbols().populateModelSymbol;
  module.exports = function getSchemaTypes(model, schema, doc, path) {
    const pathschema = schema.path(path);
    const topLevelDoc = doc;
    if (pathschema) {
      return pathschema;
    }
    const discriminatorKey = schema.discriminatorMapping && schema.discriminatorMapping.key;
    if (discriminatorKey && model != null) {
      if (doc != null && doc[discriminatorKey] != null) {
        const discriminator = getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);
        schema = discriminator ? discriminator.schema : schema;
      } else if (model.discriminators != null) {
        return Object.keys(model.discriminators).reduce((arr, name) => {
          const disc = model.discriminators[name];
          return arr.concat(getSchemaTypes(disc, disc.schema, null, path));
        }, []);
      }
    }
    function search(parts2, schema2, subdoc, nestedPath) {
      let p = parts2.length + 1;
      let foundschema;
      let trypath;
      while (p--) {
        trypath = parts2.slice(0, p).join(".");
        foundschema = schema2.path(trypath);
        if (foundschema == null) {
          continue;
        }
        if (foundschema.caster) {
          if (foundschema.caster instanceof Mixed) {
            return foundschema.caster;
          }
          let schemas = null;
          if (foundschema.schema != null && foundschema.schema.discriminators != null) {
            const discriminators = foundschema.schema.discriminators;
            const discriminatorKeyPath = trypath + "." + foundschema.schema.options.discriminatorKey;
            const keys = subdoc ? mpath.get(discriminatorKeyPath, subdoc) || [] : [];
            schemas = Object.keys(discriminators).reduce(function(cur, discriminator) {
              const tiedValue = discriminators[discriminator].discriminatorMapping.value;
              if (doc == null || keys.indexOf(discriminator) !== -1 || keys.indexOf(tiedValue) !== -1) {
                cur.push(discriminators[discriminator]);
              }
              return cur;
            }, []);
          }
          if (p !== parts2.length && foundschema.schema) {
            let ret;
            if (parts2[p] === "$") {
              if (p + 1 === parts2.length) {
                return foundschema;
              }
              ret = search(parts2.slice(p + 1), schema2, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts2.slice(0, p)));
              if (ret) {
                ret.$parentSchemaDocArray = ret.$parentSchemaDocArray || (foundschema.schema.$isSingleNested ? null : foundschema);
              }
              return ret;
            }
            if (schemas != null && schemas.length > 0) {
              ret = [];
              for (const schema3 of schemas) {
                const _ret = search(parts2.slice(p), schema3, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts2.slice(0, p)));
                if (_ret != null) {
                  _ret.$parentSchemaDocArray = _ret.$parentSchemaDocArray || (foundschema.schema.$isSingleNested ? null : foundschema);
                  if (_ret.$parentSchemaDocArray) {
                    ret.$parentSchemaDocArray = _ret.$parentSchemaDocArray;
                  }
                  ret.push(_ret);
                }
              }
              return ret;
            } else {
              ret = search(parts2.slice(p), foundschema.schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts2.slice(0, p)));
              if (ret) {
                ret.$parentSchemaDocArray = ret.$parentSchemaDocArray || (foundschema.schema.$isSingleNested ? null : foundschema);
              }
              return ret;
            }
          } else if (p !== parts2.length && foundschema.$isMongooseArray && foundschema.casterConstructor.$isMongooseArray) {
            let type = foundschema;
            while (type.$isMongooseArray && !type.$isMongooseDocumentArray) {
              type = type.casterConstructor;
            }
            const ret = search(parts2.slice(p), type.schema, null, nestedPath.concat(parts2.slice(0, p)));
            if (ret != null) {
              return ret;
            }
            if (type.schema.discriminators) {
              const discriminatorPaths = [];
              for (const discriminatorName of Object.keys(type.schema.discriminators)) {
                const _schema = type.schema.discriminators[discriminatorName] || type.schema;
                const ret2 = search(parts2.slice(p), _schema, null, nestedPath.concat(parts2.slice(0, p)));
                if (ret2 != null) {
                  discriminatorPaths.push(ret2);
                }
              }
              if (discriminatorPaths.length > 0) {
                return discriminatorPaths;
              }
            }
          }
        } else if (foundschema.$isSchemaMap && foundschema.$__schemaType instanceof Mixed) {
          return foundschema.$__schemaType;
        }
        const fullPath = nestedPath.concat([trypath]).join(".");
        if (topLevelDoc != null && topLevelDoc.$__ && topLevelDoc.$populated(fullPath) && p < parts2.length) {
          const model2 = doc.$__.populated[fullPath].options[populateModelSymbol];
          if (model2 != null) {
            const ret = search(parts2.slice(p), model2.schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts2.slice(0, p)));
            return ret;
          }
        }
        const _val = get(topLevelDoc, trypath);
        if (_val != null) {
          const model2 = Array.isArray(_val) && _val.length > 0 ? leanPopulateMap.get(_val[0]) : leanPopulateMap.get(_val);
          const schema3 = model2 != null ? model2.schema : null;
          if (schema3 != null) {
            const ret = search(parts2.slice(p), schema3, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts2.slice(0, p)));
            if (ret != null) {
              ret.$parentSchemaDocArray = ret.$parentSchemaDocArray || (schema3.$isSingleNested ? null : schema3);
              return ret;
            }
          }
        }
        return foundschema;
      }
    }
    const parts = path.split(".");
    for (let i = 0;i < parts.length; ++i) {
      if (parts[i] === "$") {
        parts[i] = "0";
      }
    }
    return search(parts, schema, doc, []);
  };
});

// node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js
var require_getModelsMapForPopulate = __commonJS((exports, module) => {
  function _virtualPopulate(model, docs, options, _virtualRes) {
    const map = [];
    const available = {};
    const virtual = _virtualRes.virtual;
    for (const doc of docs) {
      let modelNames = null;
      const data = {};
      let localField;
      const virtualPrefix = _virtualRes.nestedSchemaPath ? _virtualRes.nestedSchemaPath + "." : "";
      if (typeof options.localField === "string") {
        localField = options.localField;
      } else if (typeof virtual.options.localField === "function") {
        localField = virtualPrefix + virtual.options.localField.call(doc, doc);
      } else if (Array.isArray(virtual.options.localField)) {
        localField = virtual.options.localField.map((field) => virtualPrefix + field);
      } else {
        localField = virtualPrefix + virtual.options.localField;
      }
      data.count = virtual.options.count;
      if (virtual.options.skip != null && !options.hasOwnProperty("skip")) {
        options.skip = virtual.options.skip;
      }
      if (virtual.options.limit != null && !options.hasOwnProperty("limit")) {
        options.limit = virtual.options.limit;
      }
      if (virtual.options.perDocumentLimit != null && !options.hasOwnProperty("perDocumentLimit")) {
        options.perDocumentLimit = virtual.options.perDocumentLimit;
      }
      let foreignField = virtual.options.foreignField;
      if (!localField || !foreignField) {
        return new MongooseError(`Cannot populate virtual \`${options.path}\` on model \`${model.modelName}\`, because options \`localField\` and / or \`foreignField\` are missing`);
      }
      if (typeof localField === "function") {
        localField = localField.call(doc, doc);
      }
      if (typeof foreignField === "function") {
        foreignField = foreignField.call(doc, doc);
      }
      data.isRefPath = false;
      let justOne = null;
      if ("justOne" in options && options.justOne !== undefined) {
        justOne = options.justOne;
      }
      modelNames = virtual._getModelNamesForPopulate(doc);
      if (virtual.options.refPath) {
        justOne = !!virtual.options.justOne;
        data.isRefPath = true;
      } else if (virtual.options.ref) {
        justOne = !!virtual.options.justOne;
      }
      data.isVirtual = true;
      data.virtual = virtual;
      data.justOne = justOne;
      const baseMatch = get(data, "virtual.options.match", null) || get(data, "virtual.options.options.match", null);
      let match = get(options, "match", null) || baseMatch;
      let hasMatchFunction = typeof match === "function";
      if (hasMatchFunction) {
        match = match.call(doc, doc, data.virtual);
      }
      if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {
        match = Object.assign({}, match);
        for (let i = 1;i < localField.length; ++i) {
          match[foreignField[i]] = convertTo_id(mpath.get(localField[i], doc, lookupLocalFields), model.schema);
          hasMatchFunction = true;
        }
        localField = localField[0];
        foreignField = foreignField[0];
      }
      data.localField = localField;
      data.foreignField = foreignField;
      data.match = match;
      data.hasMatchFunction = hasMatchFunction;
      throwOn$where(match);
      const ret = _getLocalFieldValues(doc, localField, model, options, virtual);
      try {
        addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc);
      } catch (err) {
        return err;
      }
    }
    return map;
  }
  function addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions, unpopulatedValue) {
    const connection = options.connection != null ? options.connection : model.db;
    unpopulatedValue = unpopulatedValue === undefined ? ret : unpopulatedValue;
    if (Array.isArray(unpopulatedValue)) {
      unpopulatedValue = utils.cloneArrays(unpopulatedValue);
    }
    if (modelNames == null) {
      return;
    }
    const flatModelNames = utils.array.flatten(modelNames);
    let k = flatModelNames.length;
    while (k--) {
      let modelName = flatModelNames[k];
      if (modelName == null) {
        continue;
      }
      let Model;
      if (options.model && options.model[modelSymbol]) {
        Model = options.model;
      } else if (modelName[modelSymbol]) {
        Model = modelName;
        modelName = Model.modelName;
      } else {
        try {
          Model = _getModelFromConn(connection, modelName);
        } catch (err) {
          if (ret !== undefined) {
            throw err;
          }
          Model = null;
        }
      }
      let ids = ret;
      const modelNamesForRefPath = data.modelNamesInOrder ? data.modelNamesInOrder : modelNames;
      if (data.isRefPath && Array.isArray(ret) && ret.length === modelNamesForRefPath.length) {
        ids = matchIdsToRefPaths(ret, modelNamesForRefPath, modelName);
      }
      const perDocumentLimit = options.perDocumentLimit == null ? get(options, "options.perDocumentLimit", null) : options.perDocumentLimit;
      if (!available[modelName] || perDocumentLimit != null) {
        const currentOptions = {
          model: Model
        };
        if (data.isVirtual && get(data.virtual, "options.options")) {
          currentOptions.options = clone(data.virtual.options.options);
        } else if (schemaOptions != null) {
          currentOptions.options = Object.assign({}, schemaOptions);
        }
        utils.merge(currentOptions, options);
        options[populateModelSymbol] = Model;
        currentOptions[populateModelSymbol] = Model;
        available[modelName] = {
          model: Model,
          options: currentOptions,
          match: data.hasMatchFunction ? [data.match] : data.match,
          docs: [doc],
          ids: [ids],
          allIds: [ret],
          unpopulatedValues: [unpopulatedValue],
          localField: new Set([data.localField]),
          foreignField: new Set([data.foreignField]),
          justOne: data.justOne,
          isVirtual: data.isVirtual,
          virtual: data.virtual,
          count: data.count,
          [populateModelSymbol]: Model
        };
        map.push(available[modelName]);
      } else {
        available[modelName].localField.add(data.localField);
        available[modelName].foreignField.add(data.foreignField);
        available[modelName].docs.push(doc);
        available[modelName].ids.push(ids);
        available[modelName].allIds.push(ret);
        available[modelName].unpopulatedValues.push(unpopulatedValue);
        if (data.hasMatchFunction) {
          available[modelName].match.push(data.match);
        }
      }
    }
  }
  function _getModelFromConn(conn, modelName) {
    if (conn.models[modelName] == null && conn._parent != null) {
      return _getModelFromConn(conn._parent, modelName);
    }
    return conn.model(modelName);
  }
  function matchIdsToRefPaths(ids, refPaths, refPathToFind) {
    if (!Array.isArray(refPaths)) {
      return refPaths === refPathToFind ? Array.isArray(ids) ? utils.array.flatten(ids) : [ids] : [];
    }
    if (Array.isArray(ids) && Array.isArray(refPaths)) {
      return ids.flatMap((id, index) => matchIdsToRefPaths(id, refPaths[index], refPathToFind));
    }
    return [];
  }
  function handleRefFunction(ref, doc) {
    if (typeof ref === "function" && !ref[modelSymbol]) {
      return ref.call(doc, doc);
    }
    return ref;
  }
  function _getLocalFieldValues(doc, localField, model, options, virtual, schema) {
    const localFieldPathType = model.schema._getPathType(localField);
    const localFieldPath = localFieldPathType === "real" ? model.schema.path(localField) : localFieldPathType.schema;
    const localFieldGetters = localFieldPath && localFieldPath.getters ? localFieldPath.getters : [];
    localField = localFieldPath != null && localFieldPath.instance === "Embedded" ? localField + "._id" : localField;
    const _populateOptions = get(options, "options", {});
    const getters = "getters" in _populateOptions ? _populateOptions.getters : get(virtual, "options.getters", false);
    if (localFieldGetters.length !== 0 && getters) {
      const hydratedDoc = doc.$__ != null ? doc : model.hydrate(doc);
      const localFieldValue = utils.getValue(localField, doc);
      if (Array.isArray(localFieldValue)) {
        const localFieldHydratedValue = utils.getValue(localField.split(".").slice(0, -1), hydratedDoc);
        return localFieldValue.map((localFieldArrVal, localFieldArrIndex) => localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));
      } else {
        return localFieldPath.applyGetters(localFieldValue, hydratedDoc);
      }
    } else {
      return convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);
    }
  }
  function convertTo_id(val, schema) {
    if (val != null && val.$__ != null) {
      return val._doc._id;
    }
    if (val != null && val._id != null && (schema == null || !schema.$isSchemaMap)) {
      return val._id;
    }
    if (Array.isArray(val)) {
      const rawVal = val.__array != null ? val.__array : val;
      for (let i = 0;i < rawVal.length; ++i) {
        if (rawVal[i] != null && rawVal[i].$__ != null) {
          rawVal[i] = rawVal[i]._doc._id;
        }
      }
      if (utils.isMongooseArray(val) && val.$schema()) {
        return val.$schema()._castForPopulate(val, val.$parent());
      }
      return [].concat(val);
    }
    if (getConstructorName(val) === "Object" && (schema == null || schema[schemaMixedSymbol] == null)) {
      const ret = [];
      for (const key of Object.keys(val)) {
        ret.push(val[key]);
      }
      return ret;
    }
    if (val instanceof Map) {
      return Array.from(val.values());
    }
    return val;
  }
  function _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret) {
    if (!data.isRefPath || normalizedRefPath == null) {
      return;
    }
    const pieces = normalizedRefPath.split(".");
    let cur = "";
    let modelNames = undefined;
    for (let i = 0;i < pieces.length; ++i) {
      const piece = pieces[i];
      cur = cur + (cur.length === 0 ? "" : ".") + piece;
      const schematype = modelSchema.path(cur);
      if (schematype != null && schematype.$isMongooseArray && schematype.caster.discriminators != null && Object.keys(schematype.caster.discriminators).length !== 0) {
        const subdocs = utils.getValue(cur, doc);
        const remnant = options.path.substring(cur.length + 1);
        const discriminatorKey = schematype.caster.schema.options.discriminatorKey;
        modelNames = [];
        for (const subdoc of subdocs) {
          const discriminatorName = utils.getValue(discriminatorKey, subdoc);
          const discriminator = schematype.caster.discriminators[discriminatorName];
          const discriminatorSchema = discriminator && discriminator.schema;
          if (discriminatorSchema == null) {
            continue;
          }
          const _path = discriminatorSchema.path(remnant);
          if (_path == null || _path.options.refPath == null) {
            const docValue = utils.getValue(data.localField.substring(cur.length + 1), subdoc);
            ret.forEach((v, i2) => {
              if (v === docValue) {
                ret[i2] = SkipPopulateValue(v);
              }
            });
            continue;
          }
          const modelName = utils.getValue(pieces.slice(i + 1).join("."), subdoc);
          modelNames.push(modelName);
        }
      }
    }
    return modelNames;
  }
  function throwOn$where(match) {
    if (match == null) {
      return;
    }
    if (typeof match !== "object") {
      return;
    }
    for (const key of Object.keys(match)) {
      if (key === "$where") {
        throw new MongooseError("Cannot use $where filter with populate() match");
      }
      if (match[key] != null && typeof match[key] === "object") {
        throwOn$where(match[key]);
      }
    }
  }
  var MongooseError = require_error2();
  var SkipPopulateValue = require_skipPopulateValue();
  var clone = require_clone2();
  var get = require_get2();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var getConstructorName = require_getConstructorName();
  var getSchemaTypes = require_getSchemaTypes();
  var getVirtual = require_getVirtual();
  var lookupLocalFields = require_lookupLocalFields();
  var mpath = require_mpath();
  var modelNamesFromRefPath = require_modelNamesFromRefPath();
  var utils = require_utils4();
  var modelSymbol = require_symbols().modelSymbol;
  var populateModelSymbol = require_symbols().populateModelSymbol;
  var schemaMixedSymbol = require_symbols2().schemaMixedSymbol;
  var StrictPopulate = require_strictPopulate();
  module.exports = function getModelsMapForPopulate(model, docs, options) {
    let doc;
    const len = docs.length;
    const map = [];
    const modelNameFromQuery = options.model && options.model.modelName || options.model;
    let schema;
    let refPath;
    let modelNames;
    const available = {};
    const modelSchema = model.schema;
    if (options._localModel != null && options._localModel.schema.nested[options.path]) {
      return [];
    }
    const _virtualRes = getVirtual(model.schema, options.path);
    const virtual = _virtualRes == null ? null : _virtualRes.virtual;
    if (virtual != null) {
      return _virtualPopulate(model, docs, options, _virtualRes);
    }
    let allSchemaTypes = getSchemaTypes(model, modelSchema, null, options.path);
    allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter((v) => v != null);
    const isStrictPopulateDisabled = options.strictPopulate === false || options.options?.strictPopulate === false;
    if (!isStrictPopulateDisabled && allSchemaTypes.length === 0 && options._localModel != null) {
      return new StrictPopulate(options._fullPath || options.path);
    }
    for (let i = 0;i < len; i++) {
      doc = docs[i];
      let justOne = null;
      if (doc.$__ != null && doc.populated(options.path)) {
        const forceRepopulate = options.forceRepopulate != null ? options.forceRepopulate : doc.constructor.base.options.forceRepopulate;
        if (forceRepopulate === false) {
          continue;
        }
      }
      const docSchema = doc != null && doc.$__ != null ? doc.$__schema : modelSchema;
      schema = getSchemaTypes(model, docSchema, doc, options.path);
      if (schema != null && schema.$isMongooseDocumentArray && schema.options.ref == null && schema.options.refPath == null) {
        continue;
      }
      const isUnderneathDocArray = schema && schema.$parentSchemaDocArray;
      if (isUnderneathDocArray && get(options, "options.sort") != null) {
        return new MongooseError("Cannot populate with `sort` on path " + options.path + " because it is a subproperty of a document array");
      }
      modelNames = null;
      let isRefPath = false;
      let normalizedRefPath = null;
      let schemaOptions = null;
      let modelNamesInOrder = null;
      if (schema != null && schema.instance === "Embedded") {
        if (schema.options.ref) {
          const data2 = {
            localField: options.path + "._id",
            foreignField: "_id",
            justOne: true
          };
          const res = _getModelNames(doc, schema, modelNameFromQuery, model);
          const unpopulatedValue = mpath.get(options.path, doc);
          const id2 = mpath.get("_id", unpopulatedValue);
          addModelNamesToMap(model, map, available, res.modelNames, options, data2, id2, doc, schemaOptions, unpopulatedValue);
        }
        continue;
      }
      if (Array.isArray(schema)) {
        const schemasArray = schema;
        for (const _schema of schemasArray) {
          let _modelNames;
          let res;
          try {
            res = _getModelNames(doc, _schema, modelNameFromQuery, model);
            _modelNames = res.modelNames;
            isRefPath = isRefPath || res.isRefPath;
            normalizedRefPath = normalizedRefPath || res.refPath;
            justOne = res.justOne;
          } catch (error) {
            return error;
          }
          if (isRefPath && !res.isRefPath) {
            continue;
          }
          if (!_modelNames) {
            continue;
          }
          modelNames = modelNames || [];
          for (const modelName of _modelNames) {
            if (modelNames.indexOf(modelName) === -1) {
              modelNames.push(modelName);
            }
          }
        }
      } else {
        try {
          const res = _getModelNames(doc, schema, modelNameFromQuery, model);
          modelNames = res.modelNames;
          isRefPath = res.isRefPath;
          normalizedRefPath = normalizedRefPath || res.refPath;
          justOne = res.justOne;
          schemaOptions = get(schema, "options.populate", null);
          if (isRefPath) {
            modelNamesInOrder = modelNames;
            modelNames = Array.from(new Set(modelNames));
          }
        } catch (error) {
          return error;
        }
        if (!modelNames) {
          continue;
        }
      }
      const data = {};
      const localField = options.path;
      const foreignField = "_id";
      if ("justOne" in options && options.justOne !== undefined) {
        justOne = options.justOne;
      } else if (schema && !schema[schemaMixedSymbol]) {
        if (options.path.endsWith("." + schema.path) || options.path === schema.path) {
          justOne = Array.isArray(schema) ? schema.every((schema2) => !schema2.$isMongooseArray) : !schema.$isMongooseArray;
        }
      }
      if (!modelNames) {
        continue;
      }
      data.isVirtual = false;
      data.justOne = justOne;
      data.localField = localField;
      data.foreignField = foreignField;
      const ret = _getLocalFieldValues(doc, localField, model, options, null, schema);
      const id = String(utils.getValue(foreignField, doc));
      options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;
      let match = get(options, "match", null);
      const hasMatchFunction = typeof match === "function";
      if (hasMatchFunction) {
        match = match.call(doc, doc);
      }
      throwOn$where(match);
      data.match = match;
      data.hasMatchFunction = hasMatchFunction;
      data.isRefPath = isRefPath;
      data.modelNamesInOrder = modelNamesInOrder;
      if (isRefPath) {
        const embeddedDiscriminatorModelNames = _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret);
        modelNames = embeddedDiscriminatorModelNames || modelNames;
      }
      try {
        addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions);
      } catch (err) {
        return err;
      }
    }
    return map;
    function _getModelNames(doc2, schema2, modelNameFromQuery2, model2) {
      let modelNames2;
      let isRefPath = false;
      let justOne = null;
      const originalSchema = schema2;
      if (schema2 && schema2.instance === "Array") {
        schema2 = schema2.caster;
      }
      if (schema2 && schema2.$isSchemaMap) {
        schema2 = schema2.$__schemaType;
      }
      const ref = schema2 && schema2.options && schema2.options.ref;
      refPath = schema2 && schema2.options && schema2.options.refPath;
      if (schema2 != null && schema2[schemaMixedSymbol] && !ref && !refPath && !modelNameFromQuery2) {
        return { modelNames: null };
      }
      if (modelNameFromQuery2) {
        modelNames2 = [modelNameFromQuery2];
      } else if (refPath != null) {
        if (typeof refPath === "function") {
          const subdocPath = options.path.slice(0, options.path.length - schema2.path.length - 1);
          const vals = mpath.get(subdocPath, doc2, lookupLocalFields);
          const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];
          modelNames2 = new Set;
          for (const subdoc of subdocsBeingPopulated) {
            refPath = refPath.call(subdoc, subdoc, options.path);
            modelNamesFromRefPath(refPath, doc2, options.path, modelSchema, options._queryProjection).forEach((name) => modelNames2.add(name));
          }
          modelNames2 = Array.from(modelNames2);
        } else {
          modelNames2 = modelNamesFromRefPath(refPath, doc2, options.path, modelSchema, options._queryProjection);
        }
        isRefPath = true;
      } else {
        let ref2;
        let refPath2;
        let schemaForCurrentDoc;
        let discriminatorValue;
        let modelForCurrentDoc = model2;
        const discriminatorKey = model2.schema.options.discriminatorKey;
        if (!schema2 && discriminatorKey && (discriminatorValue = utils.getValue(discriminatorKey, doc2))) {
          const discriminatorModel = getDiscriminatorByValue(model2.discriminators, discriminatorValue) || model2;
          if (discriminatorModel != null) {
            modelForCurrentDoc = discriminatorModel;
          } else {
            try {
              modelForCurrentDoc = _getModelFromConn(model2.db, discriminatorValue);
            } catch (error) {
              return error;
            }
          }
          schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);
          if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {
            schemaForCurrentDoc = schemaForCurrentDoc.caster;
          }
        } else {
          schemaForCurrentDoc = schema2;
        }
        if (originalSchema && originalSchema.path.endsWith(".$*")) {
          justOne = !originalSchema.$isMongooseArray && !originalSchema._arrayPath;
        } else if (schemaForCurrentDoc != null) {
          justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;
        }
        if ((ref2 = get(schemaForCurrentDoc, "options.ref")) != null) {
          if (schemaForCurrentDoc != null && typeof ref2 === "function" && options.path.endsWith("." + schemaForCurrentDoc.path)) {
            modelNames2 = new Set;
            const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);
            const vals = mpath.get(subdocPath, doc2, lookupLocalFields);
            const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];
            for (const subdoc of subdocsBeingPopulated) {
              modelNames2.add(handleRefFunction(ref2, subdoc));
            }
            if (subdocsBeingPopulated.length === 0) {
              modelNames2 = [handleRefFunction(ref2, doc2)];
            } else {
              modelNames2 = Array.from(modelNames2);
            }
          } else {
            ref2 = handleRefFunction(ref2, doc2);
            modelNames2 = [ref2];
          }
        } else if ((schemaForCurrentDoc = get(schema2, "options.refPath")) != null) {
          isRefPath = true;
          if (typeof refPath2 === "function") {
            const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);
            const vals = mpath.get(subdocPath, doc2, lookupLocalFields);
            const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];
            modelNames2 = new Set;
            for (const subdoc of subdocsBeingPopulated) {
              refPath2 = refPath2.call(subdoc, subdoc, options.path);
              modelNamesFromRefPath(refPath2, doc2, options.path, modelSchema, options._queryProjection).forEach((name) => modelNames2.add(name));
            }
            modelNames2 = Array.from(modelNames2);
          } else {
            modelNames2 = modelNamesFromRefPath(refPath2, doc2, options.path, modelSchema, options._queryProjection);
          }
        }
      }
      if (!modelNames2) {
        if (options._localModel == null) {
          modelNames2 = [model2.modelName];
        } else {
          return { modelNames: modelNames2, justOne, isRefPath, refPath };
        }
      }
      if (!Array.isArray(modelNames2)) {
        modelNames2 = [modelNames2];
      }
      return { modelNames: modelNames2, justOne, isRefPath, refPath };
    }
  };
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  /*!
   * ignore
   */
});

// node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js
var require_isDefaultIdIndex = __commonJS((exports, module) => {
  var get = require_get2();
  module.exports = function isDefaultIdIndex(index) {
    if (Array.isArray(index)) {
      const keys = Object.keys(index[0]);
      return keys.length === 1 && keys[0] === "_id" && index[0]._id !== "hashed";
    }
    if (typeof index !== "object") {
      return false;
    }
    const key = get(index, "key", {});
    return Object.keys(key).length === 1 && key.hasOwnProperty("_id");
  };
});

// node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js
var require_isIndexEqual = __commonJS((exports, module) => {
  var get = require_get2();
  var utils = require_utils4();
  module.exports = function isIndexEqual(schemaIndexKeysObject, options, dbIndex) {
    if (dbIndex.textIndexVersion != null) {
      delete dbIndex.key._fts;
      delete dbIndex.key._ftsx;
      const weights = { ...dbIndex.weights, ...dbIndex.key };
      if (Object.keys(weights).length !== Object.keys(schemaIndexKeysObject).length) {
        return false;
      }
      for (const prop of Object.keys(weights)) {
        if (!(prop in schemaIndexKeysObject)) {
          return false;
        }
        const weight = weights[prop];
        if (weight !== get(options, "weights." + prop) && !(weight === 1 && get(options, "weights." + prop) == null)) {
          return false;
        }
      }
      if (options["default_language"] !== dbIndex["default_language"]) {
        return dbIndex["default_language"] === "english" && options["default_language"] == null;
      }
      return true;
    }
    const optionKeys = [
      "unique",
      "partialFilterExpression",
      "sparse",
      "expireAfterSeconds",
      "collation"
    ];
    for (const key of optionKeys) {
      if (!(key in options) && !(key in dbIndex)) {
        continue;
      }
      if (key === "collation") {
        if (options[key] == null || dbIndex[key] == null) {
          return options[key] == null && dbIndex[key] == null;
        }
        const definedKeys = Object.keys(options.collation);
        const schemaCollation = options.collation;
        const dbCollation = dbIndex.collation;
        for (const opt of definedKeys) {
          if (get(schemaCollation, opt) !== get(dbCollation, opt)) {
            return false;
          }
        }
      } else if (!utils.deepEqual(options[key], dbIndex[key])) {
        return false;
      }
    }
    const schemaIndexKeys = Object.keys(schemaIndexKeysObject);
    const dbIndexKeys = Object.keys(dbIndex.key);
    if (schemaIndexKeys.length !== dbIndexKeys.length) {
      return false;
    }
    for (let i = 0;i < schemaIndexKeys.length; ++i) {
      if (schemaIndexKeys[i] !== dbIndexKeys[i]) {
        return false;
      }
      if (!utils.deepEqual(schemaIndexKeysObject[schemaIndexKeys[i]], dbIndex.key[dbIndexKeys[i]])) {
        return false;
      }
    }
    return true;
  };
});

// node_modules/mongoose/lib/helpers/indexes/isTimeseriesIndex.js
var require_isTimeseriesIndex = __commonJS((exports, module) => {
  module.exports = function isTimeseriesIndex(dbIndex, schemaOptions) {
    if (schemaOptions.timeseries == null) {
      return false;
    }
    const { timeField, metaField } = schemaOptions.timeseries;
    if (typeof timeField !== "string" || typeof metaField !== "string") {
      return false;
    }
    return Object.keys(dbIndex.key).length === 2 && dbIndex.key[timeField] === 1 && dbIndex.key[metaField] === 1;
  };
});

// node_modules/mongoose/lib/helpers/indexes/getRelatedIndexes.js
var require_getRelatedIndexes = __commonJS((exports, module) => {
  function getRelatedSchemaIndexes(model, schemaIndexes) {
    return getRelatedIndexes({
      baseModelName: model.baseModelName,
      discriminatorMapping: model.schema.discriminatorMapping,
      indexes: schemaIndexes,
      indexesType: "schema"
    });
  }
  function getRelatedDBIndexes(model, dbIndexes) {
    return getRelatedIndexes({
      baseModelName: model.baseModelName,
      discriminatorMapping: model.schema.discriminatorMapping,
      indexes: dbIndexes,
      indexesType: "db"
    });
  }
  function getRelatedIndexes({
    baseModelName,
    discriminatorMapping,
    indexes,
    indexesType
  }) {
    const discriminatorKey = discriminatorMapping && discriminatorMapping.key;
    const discriminatorValue = discriminatorMapping && discriminatorMapping.value;
    if (!discriminatorKey) {
      return indexes;
    }
    const isChildDiscriminatorModel = Boolean(baseModelName);
    if (isChildDiscriminatorModel) {
      return indexes.filter((index) => {
        const partialFilterExpression = getPartialFilterExpression(index, indexesType);
        return partialFilterExpression && partialFilterExpression[discriminatorKey] === discriminatorValue;
      });
    }
    return indexes.filter((index) => {
      const partialFilterExpression = getPartialFilterExpression(index, indexesType);
      return !partialFilterExpression || !partialFilterExpression[discriminatorKey] || hasDollarKeys(partialFilterExpression[discriminatorKey]) && !("$eq" in partialFilterExpression[discriminatorKey]);
    });
  }
  function getPartialFilterExpression(index, indexesType) {
    if (indexesType === "schema") {
      const options = index[1];
      return options && options.partialFilterExpression;
    }
    return index.partialFilterExpression;
  }
  var hasDollarKeys = require_hasDollarKeys();
  module.exports = {
    getRelatedSchemaIndexes,
    getRelatedDBIndexes
  };
});

// node_modules/mongoose/lib/helpers/parallelLimit.js
var require_parallelLimit = __commonJS((exports, module) => {
  function parallelLimit(fns, limit, callback) {
    let numInProgress = 0;
    let numFinished = 0;
    let error = null;
    if (limit <= 0) {
      throw new Error("Limit must be positive");
    }
    if (fns.length === 0) {
      return callback(null, []);
    }
    for (let i = 0;i < fns.length && i < limit; ++i) {
      _start();
    }
    function _start() {
      fns[numFinished + numInProgress](_done(numFinished + numInProgress));
      ++numInProgress;
    }
    const results = [];
    function _done(index) {
      return (err, res) => {
        --numInProgress;
        ++numFinished;
        if (error != null) {
          return;
        }
        if (err != null) {
          error = err;
          return callback(error);
        }
        results[index] = res;
        if (numFinished === fns.length) {
          return callback(null, results);
        } else if (numFinished + numInProgress < fns.length) {
          _start();
        }
      };
    }
  }
  module.exports = parallelLimit;
  /*!
   * ignore
   */
});

// node_modules/mongoose/lib/helpers/model/pushNestedArrayPaths.js
var require_pushNestedArrayPaths = __commonJS((exports, module) => {
  module.exports = function pushNestedArrayPaths(paths, nestedArray, path) {
    if (nestedArray == null) {
      return;
    }
    for (let i = 0;i < nestedArray.length; ++i) {
      if (Array.isArray(nestedArray[i])) {
        pushNestedArrayPaths(paths, nestedArray[i], path + "." + i);
      } else {
        paths.push(path + "." + i);
      }
    }
  };
});

// node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js
var require_removeDeselectedForeignField = __commonJS((exports, module) => {
  var get = require_get2();
  var mpath = require_mpath();
  var parseProjection = require_parseProjection();
  /*!
   * ignore
   */
  module.exports = function removeDeselectedForeignField(foreignFields, options, docs) {
    const projection = parseProjection(get(options, "select", null), true) || parseProjection(get(options, "options.select", null), true);
    if (projection == null) {
      return;
    }
    for (const foreignField of foreignFields) {
      if (!projection.hasOwnProperty("-" + foreignField)) {
        continue;
      }
      for (const val of docs) {
        if (val.$__ != null) {
          mpath.unset(foreignField, val._doc);
        } else {
          mpath.unset(foreignField, val);
        }
      }
    }
  };
});

// node_modules/mongoose/lib/error/bulkSaveIncompleteError.js
var require_bulkSaveIncompleteError = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var MongooseError = require_mongooseError();

  class MongooseBulkSaveIncompleteError extends MongooseError {
    constructor(modelName, documents, bulkWriteResult) {
      const matchedCount = bulkWriteResult?.matchedCount ?? 0;
      const insertedCount = bulkWriteResult?.insertedCount ?? 0;
      let preview = documents.map((doc) => doc._id).join(", ");
      if (preview.length > 100) {
        preview = preview.slice(0, 100) + "...";
      }
      const numDocumentsNotUpdated = documents.length - matchedCount - insertedCount;
      super(`${modelName}.bulkSave() was not able to update ${numDocumentsNotUpdated} of the given documents due to incorrect version or optimistic concurrency, document ids: ${preview}`);
      this.modelName = modelName;
      this.documents = documents;
      this.bulkWriteResult = bulkWriteResult;
      this.numDocumentsNotUpdated = numDocumentsNotUpdated;
    }
  }
  Object.defineProperty(MongooseBulkSaveIncompleteError.prototype, "name", {
    value: "MongooseBulkSaveIncompleteError"
  });
  /*!
   * exports
   */
  module.exports = MongooseBulkSaveIncompleteError;
});

// node_modules/mongoose/lib/model.js
var require_model = __commonJS((exports, module) => {
  function Model(doc, fields, skipId) {
    if (fields instanceof Schema) {
      throw new TypeError("2nd argument to `Model` constructor must be a POJO or string, " + "**not** a schema. Make sure you\'re calling `mongoose.model()`, not " + "`mongoose.Model()`.");
    }
    if (typeof doc === "string") {
      throw new TypeError("First argument to `Model` constructor must be an object, " + "**not** a string. Make sure you\'re calling `mongoose.model()`, not " + "`mongoose.Model()`.");
    }
    Document.call(this, doc, fields, skipId);
  }
  function _applyCustomWhere(doc, where) {
    if (doc.$where == null) {
      return;
    }
    for (const key of Object.keys(doc.$where)) {
      where[key] = doc.$where[key];
    }
  }
  function generateVersionError(doc, modifiedPaths) {
    const key = doc.$__schema.options.versionKey;
    if (!key) {
      return null;
    }
    const version = doc.$__getValue(key) || 0;
    return new VersionError(doc, version, modifiedPaths);
  }
  function _checkContext(ctx, fnName) {
    if (ctx == null || ctx === global) {
      throw new MongooseError("`Model." + fnName + "()` cannot run without a " + "model as `this`. Make sure you are calling `MyModel." + fnName + "()` " + "where `MyModel` is a Mongoose model.");
    } else if (ctx[modelSymbol] == null) {
      throw new MongooseError("`Model." + fnName + "()` cannot run without a " + "model as `this`. Make sure you are not calling " + "`new Model." + fnName + "()`");
    }
  }
  function getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop, options) {
    const toCreate = [];
    const indexOptionsToCreate = options?.indexOptionsToCreate ?? false;
    for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {
      let found = false;
      const options2 = decorateDiscriminatorIndexOptions(schema, clone(schemaIndexOptions));
      for (const index of dbIndexes) {
        if (isDefaultIdIndex(index)) {
          continue;
        }
        if (isIndexEqual(schemaIndexKeysObject, options2, index) && !toDrop.includes(index.name)) {
          found = true;
          break;
        }
      }
      if (!found) {
        if (indexOptionsToCreate) {
          toCreate.push([schemaIndexKeysObject, schemaIndexOptions]);
        } else {
          toCreate.push(schemaIndexKeysObject);
        }
      }
    }
    return toCreate;
  }
  function getIndexesToDrop(schema, schemaIndexes, dbIndexes) {
    const toDrop = [];
    for (const dbIndex of dbIndexes) {
      let found = false;
      if (isDefaultIdIndex(dbIndex)) {
        continue;
      }
      if (isTimeseriesIndex(dbIndex, schema.options)) {
        continue;
      }
      for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {
        const options = decorateDiscriminatorIndexOptions(schema, clone(schemaIndexOptions));
        applySchemaCollation(schemaIndexKeysObject, options, schema.options);
        if (isIndexEqual(schemaIndexKeysObject, options, dbIndex)) {
          found = true;
          break;
        }
      }
      if (found) {
        continue;
      }
      toDrop.push(dbIndex.name);
    }
    return toDrop;
  }
  async function _dropIndexes(toDrop, model, options) {
    if (toDrop.length === 0) {
      return [];
    }
    const collection = model.$__collection;
    if (options && options.hideIndexes) {
      await Promise.all(toDrop.map((indexName) => {
        return model.db.db.command({
          collMod: collection.collectionName,
          index: { name: indexName, hidden: true }
        });
      }));
    } else {
      await Promise.all(toDrop.map((indexName) => collection.dropIndex(indexName)));
    }
    return toDrop;
  }
  function _ensureIndexes(model, options, callback) {
    const indexes = Array.isArray(options?.toCreate) ? options.toCreate : model.schema.indexes();
    let indexError;
    options = options || {};
    const done = function(err) {
      if (err && !model.$caught) {
        model.emit("error", err);
      }
      model.emit("index", err || indexError);
      callback && callback(err || indexError);
    };
    for (const index of indexes) {
      if (isDefaultIdIndex(index)) {
        utils.warn("mongoose: Cannot specify a custom index on `_id` for " + 'model name "' + model.modelName + '", ' + "MongoDB does not allow overwriting the default `_id` index. See " + "https://bit.ly/mongodb-id-index");
      }
    }
    if (!indexes.length) {
      immediate(function() {
        done();
      });
      return;
    }
    const indexSingleDone = function(err, fields, options2, name) {
      model.emit("index-single-done", err, fields, options2, name);
    };
    const indexSingleStart = function(fields, options2) {
      model.emit("index-single-start", fields, options2);
    };
    const baseSchema = model.schema._baseSchema;
    const baseSchemaIndexes = baseSchema ? baseSchema.indexes() : [];
    immediate(function() {
      if (options._automatic && !model.collection.collection) {
        model.collection.addQueue(create, []);
      } else {
        create();
      }
    });
    function create() {
      if (options._automatic) {
        if (model.schema.options.autoIndex === false || model.schema.options.autoIndex == null && model.db.config.autoIndex === false) {
          return done();
        }
      }
      const index = indexes.shift();
      if (!index) {
        return done();
      }
      if (options._automatic && index[1]._autoIndex === false) {
        return create();
      }
      if (baseSchemaIndexes.find((i) => utils.deepEqual(i, index))) {
        return create();
      }
      const indexFields = clone(index[0]);
      const indexOptions = clone(index[1]);
      delete indexOptions._autoIndex;
      decorateDiscriminatorIndexOptions(model.schema, indexOptions);
      applyWriteConcern(model.schema, indexOptions);
      applySchemaCollation(indexFields, indexOptions, model.schema.options);
      indexSingleStart(indexFields, options);
      if ("background" in options) {
        indexOptions.background = options.background;
      }
      let promise = null;
      try {
        promise = model.collection.createIndex(indexFields, indexOptions);
      } catch (err) {
        if (!indexError) {
          indexError = err;
        }
        if (!model.$caught) {
          model.emit("error", err);
        }
        indexSingleDone(err, indexFields, indexOptions);
        create();
        return;
      }
      promise.then((name) => {
        indexSingleDone(null, indexFields, indexOptions, name);
        create();
      }, (err) => {
        if (!indexError) {
          indexError = err;
        }
        if (!model.$caught) {
          model.emit("error", err);
        }
        indexSingleDone(err, indexFields, indexOptions);
        create();
      });
    }
  }
  function _setIsNew(doc, val) {
    doc.$isNew = val;
    doc.$emit("isNew", val);
    doc.constructor.emit("isNew", val);
    const subdocs = doc.$getAllSubdocs({ useCache: true });
    for (const subdoc of subdocs) {
      subdoc.$isNew = val;
      subdoc.$emit("isNew", val);
    }
  }
  function buildPreSavePromise(document2, options) {
    return new Promise((resolve, reject) => {
      document2.schema.s.hooks.execPre("save", document2, [options], (err) => {
        if (err) {
          reject(err);
          return;
        }
        resolve();
      });
    });
  }
  function handleSuccessfulWrite(document2) {
    return new Promise((resolve, reject) => {
      if (document2.$isNew) {
        _setIsNew(document2, false);
      }
      document2.$__reset();
      document2.schema.s.hooks.execPost("save", document2, [document2], {}, (err) => {
        if (err) {
          reject(err);
          return;
        }
        resolve();
      });
    });
  }
  function _update(model, op, conditions, doc, options) {
    const mq = new model.Query({}, {}, model, model.collection);
    if (conditions instanceof Document) {
      conditions = conditions.toObject();
    } else {
      conditions = clone(conditions);
    }
    options = typeof options === "function" ? options : clone(options);
    const versionKey = model && model.schema && model.schema.options && model.schema.options.versionKey || null;
    decorateUpdateWithVersionKey(doc, options, versionKey);
    return mq[op](conditions, doc, options);
  }
  async function _populatePath(model, docs, populateOptions) {
    if (populateOptions.strictPopulate == null) {
      if (populateOptions._localModel != null && populateOptions._localModel.schema._userProvidedOptions.strictPopulate != null) {
        populateOptions.strictPopulate = populateOptions._localModel.schema._userProvidedOptions.strictPopulate;
      } else if (populateOptions._localModel != null && model.base.options.strictPopulate != null) {
        populateOptions.strictPopulate = model.base.options.strictPopulate;
      } else if (model.base.options.strictPopulate != null) {
        populateOptions.strictPopulate = model.base.options.strictPopulate;
      }
    }
    if (!Array.isArray(docs)) {
      docs = [docs];
    }
    if (docs.length === 0 || docs.every(utils.isNullOrUndefined)) {
      return;
    }
    const modelsMap = getModelsMapForPopulate(model, docs, populateOptions);
    if (modelsMap instanceof MongooseError) {
      throw modelsMap;
    }
    const len = modelsMap.length;
    let vals = [];
    function flatten(item) {
      return item !== undefined;
    }
    let hasOne = false;
    const params = [];
    for (let i = 0;i < len; ++i) {
      const mod = modelsMap[i];
      let select = mod.options.select;
      let ids = utils.array.flatten(mod.ids, flatten);
      ids = utils.array.unique(ids);
      const assignmentOpts = {};
      assignmentOpts.sort = mod && mod.options && mod.options.options && mod.options.options.sort || undefined;
      assignmentOpts.excludeId = excludeIdReg.test(select) || select && select._id === 0;
      if (mod.options && mod.options.options && mod.options.options.lean && mod.options.options.lean.transform) {
        mod.options.options._leanTransform = mod.options.options.lean.transform;
        mod.options.options.lean = true;
      }
      if (ids.length === 0 || ids.every(utils.isNullOrUndefined)) {
        _assign(model, [], mod, assignmentOpts);
        continue;
      }
      hasOne = true;
      if (typeof populateOptions.foreignField === "string") {
        mod.foreignField.clear();
        mod.foreignField.add(populateOptions.foreignField);
      }
      const match = createPopulateQueryFilter(ids, mod.match, mod.foreignField, mod.model, mod.options.skipInvalidIds);
      if (assignmentOpts.excludeId) {
        if (typeof select === "string") {
          select = select.replace(excludeIdRegGlobal, " ");
        } else if (Array.isArray(select)) {
          select = select.filter((field) => field !== "-_id");
        } else {
          select = { ...select };
          delete select._id;
        }
      }
      if (mod.options.options && mod.options.options.limit != null) {
        assignmentOpts.originalLimit = mod.options.options.limit;
      } else if (mod.options.limit != null) {
        assignmentOpts.originalLimit = mod.options.limit;
      }
      params.push([mod, match, select, assignmentOpts]);
    }
    if (!hasOne) {
      if (modelsMap.length !== 0) {
        return;
      }
      if (populateOptions.populate != null) {
        const opts = utils.populate(populateOptions.populate).map((pop) => Object.assign({}, pop, {
          path: populateOptions.path + "." + pop.path
        }));
        return model.populate(docs, opts);
      }
      return;
    }
    const promises = [];
    for (const arr of params) {
      promises.push(_execPopulateQuery.apply(null, arr).then((valsFromDb) => {
        vals = vals.concat(valsFromDb);
      }));
    }
    await Promise.all(promises);
    for (const arr of params) {
      const mod = arr[0];
      const assignmentOpts = arr[3];
      for (const val of vals) {
        mod.options._childDocs.push(val);
      }
      _assign(model, vals, mod, assignmentOpts);
    }
    for (const arr of params) {
      removeDeselectedForeignField(arr[0].foreignField, arr[0].options, vals);
    }
    for (const arr of params) {
      const mod = arr[0];
      if (mod.options && mod.options.options && mod.options.options._leanTransform) {
        for (const doc of vals) {
          mod.options.options._leanTransform(doc);
        }
      }
    }
  }
  function _execPopulateQuery(mod, match, select) {
    let subPopulate = clone(mod.options.populate);
    const queryOptions = Object.assign({
      skip: mod.options.skip,
      limit: mod.options.limit,
      perDocumentLimit: mod.options.perDocumentLimit
    }, mod.options.options);
    if (mod.count) {
      delete queryOptions.skip;
    }
    if (queryOptions.perDocumentLimit != null) {
      queryOptions.limit = queryOptions.perDocumentLimit;
      delete queryOptions.perDocumentLimit;
    } else if (queryOptions.limit != null) {
      queryOptions.limit = queryOptions.limit * mod.ids.length;
    }
    const query = mod.model.find(match, select, queryOptions);
    for (const foreignField of mod.foreignField) {
      if (foreignField !== "_id" && query.selectedInclusively() && !isPathSelectedInclusive(query._fields, foreignField)) {
        query.select(foreignField);
      }
    }
    if (mod.count) {
      for (const foreignField of mod.foreignField) {
        query.select(foreignField);
      }
    }
    if (subPopulate) {
      if (mod.model.baseModelName != null) {
        if (Array.isArray(subPopulate)) {
          subPopulate.forEach((pop) => {
            pop.strictPopulate = false;
          });
        } else if (typeof subPopulate === "string") {
          subPopulate = { path: subPopulate, strictPopulate: false };
        } else {
          subPopulate.strictPopulate = false;
        }
      }
      const basePath = mod.options._fullPath || mod.options.path;
      if (Array.isArray(subPopulate)) {
        for (const pop of subPopulate) {
          pop._fullPath = basePath + "." + pop.path;
        }
      } else if (typeof subPopulate === "object") {
        subPopulate._fullPath = basePath + "." + subPopulate.path;
      }
      query.populate(subPopulate);
    }
    return query.exec().then((docs) => {
      for (const val of docs) {
        leanPopulateMap.set(val, mod.model);
      }
      return docs;
    });
  }
  function _assign(model, vals, mod, assignmentOpts) {
    const options = mod.options;
    const isVirtual = mod.isVirtual;
    const justOne = mod.justOne;
    let _val;
    const lean = options && options.options && options.options.lean || false;
    const len = vals.length;
    const rawOrder = {};
    const rawDocs = {};
    let key;
    let val;
    const allIds = clone(mod.allIds);
    for (let i = 0;i < len; i++) {
      val = vals[i];
      if (val == null) {
        continue;
      }
      for (const foreignField of mod.foreignField) {
        _val = utils.getValue(foreignField, val);
        if (Array.isArray(_val)) {
          _val = utils.array.unique(utils.array.flatten(_val));
          for (let __val of _val) {
            if (__val instanceof Document) {
              __val = __val._doc._id;
            }
            key = String(__val);
            if (rawDocs[key]) {
              if (Array.isArray(rawDocs[key])) {
                rawDocs[key].push(val);
                rawOrder[key].push(i);
              } else {
                rawDocs[key] = [rawDocs[key], val];
                rawOrder[key] = [rawOrder[key], i];
              }
            } else {
              if (isVirtual && !justOne) {
                rawDocs[key] = [val];
                rawOrder[key] = [i];
              } else {
                rawDocs[key] = val;
                rawOrder[key] = i;
              }
            }
          }
        } else {
          if (_val instanceof Document) {
            _val = _val._doc._id;
          }
          key = String(_val);
          if (rawDocs[key]) {
            if (Array.isArray(rawDocs[key])) {
              rawDocs[key].push(val);
              rawOrder[key].push(i);
            } else if (isVirtual || rawDocs[key].constructor !== val.constructor || (rawDocs[key] instanceof Document ? String(rawDocs[key]._doc._id) : String(rawDocs[key]._id)) !== (val instanceof Document ? String(val._doc._id) : String(val._id))) {
              rawDocs[key] = [rawDocs[key], val];
              rawOrder[key] = [rawOrder[key], i];
            }
          } else {
            rawDocs[key] = val;
            rawOrder[key] = i;
          }
        }
        if (!lean) {
          val.$__.wasPopulated = val.$__.wasPopulated || { value: _val };
        }
      }
    }
    assignVals({
      originalModel: model,
      rawIds: mod.isVirtual ? allIds : mod.allIds,
      allIds,
      unpopulatedValues: mod.unpopulatedValues,
      foreignField: mod.foreignField,
      rawDocs,
      rawOrder,
      docs: mod.docs,
      path: options.path,
      options: assignmentOpts,
      justOne: mod.justOne,
      isVirtual: mod.isVirtual,
      allOptions: mod,
      populatedModel: mod.model,
      lean,
      virtual: mod.virtual,
      count: mod.count,
      match: mod.match
    });
  }
  function applyQueryMethods(model, methods) {
    for (const i in methods) {
      model.Query.prototype[i] = methods[i];
    }
  }
  function _getContexts(hook) {
    const ret = {};
    if (hook.hasOwnProperty("query")) {
      ret.query = hook.query;
    }
    if (hook.hasOwnProperty("document")) {
      ret.document = hook.document;
    }
    return ret;
  }
  /*!
   * Module dependencies.
   */
  var Aggregate = require_aggregate2();
  var ChangeStream = require_changeStream();
  var Document = require_document2();
  var DocumentNotFoundError = require_notFound();
  var EventEmitter = import.meta.require("events").EventEmitter;
  var Kareem = require_kareem();
  var { MongoBulkWriteError } = require_lib3();
  var MongooseBulkWriteError = require_bulkWriteError();
  var MongooseError = require_error2();
  var ObjectParameterError = require_objectParameter();
  var OverwriteModelError = require_overwriteModel();
  var Query = require_query();
  var SaveOptions = require_saveOptions();
  var Schema = require_schema2();
  var ValidationError = require_validation();
  var VersionError = require_version();
  var ParallelSaveError = require_parallelSave();
  var applyDefaultsHelper = require_applyDefaults();
  var applyDefaultsToPOJO = require_applyDefaultsToPOJO();
  var applyEmbeddedDiscriminators = require_applyEmbeddedDiscriminators();
  var applyHooks = require_applyHooks();
  var applyMethods = require_applyMethods();
  var applyProjection = require_applyProjection();
  var applyReadConcern = require_applyReadConcern();
  var applySchemaCollation = require_applySchemaCollation();
  var applyStaticHooks = require_applyStaticHooks();
  var applyStatics = require_applyStatics();
  var applyTimestampsHelper = require_applyTimestamps();
  var applyWriteConcern = require_applyWriteConcern();
  var applyVirtualsHelper = require_applyVirtuals();
  var assignVals = require_assignVals();
  var castBulkWrite = require_castBulkWrite();
  var clone = require_clone2();
  var createPopulateQueryFilter = require_createPopulateQueryFilter();
  var decorateUpdateWithVersionKey = require_decorateUpdateWithVersionKey();
  var getDefaultBulkwriteResult = require_getDefaultBulkwriteResult();
  var getSchemaDiscriminatorByValue = require_getSchemaDiscriminatorByValue();
  var discriminator = require_discriminator();
  var each = require_each();
  var get = require_get2();
  var getConstructorName = require_getConstructorName();
  var getDiscriminatorByValue = require_getDiscriminatorByValue();
  var getModelsMapForPopulate = require_getModelsMapForPopulate();
  var immediate = require_immediate();
  var internalToObjectOptions = require_options().internalToObjectOptions;
  var isDefaultIdIndex = require_isDefaultIdIndex();
  var isIndexEqual = require_isIndexEqual();
  var isTimeseriesIndex = require_isTimeseriesIndex();
  var {
    getRelatedDBIndexes,
    getRelatedSchemaIndexes
  } = require_getRelatedIndexes();
  var decorateDiscriminatorIndexOptions = require_decorateDiscriminatorIndexOptions();
  var isPathSelectedInclusive = require_isPathSelectedInclusive();
  var leanPopulateMap = require_leanPopulateMap();
  var parallelLimit = require_parallelLimit();
  var prepareDiscriminatorPipeline = require_prepareDiscriminatorPipeline();
  var pushNestedArrayPaths = require_pushNestedArrayPaths();
  var removeDeselectedForeignField = require_removeDeselectedForeignField();
  var setDottedPath = require_setDottedPath();
  var util = import.meta.require("util");
  var utils = require_utils4();
  var minimize = require_minimize();
  var MongooseBulkSaveIncompleteError = require_bulkSaveIncompleteError();
  var ObjectExpectedError = require_objectExpected();
  var modelCollectionSymbol = Symbol("mongoose#Model#collection");
  var modelDbSymbol = Symbol("mongoose#Model#db");
  var modelSymbol = require_symbols().modelSymbol;
  var subclassedSymbol = Symbol("mongoose#Model#subclassed");
  var { VERSION_INC, VERSION_WHERE, VERSION_ALL } = Document;
  var saveToObjectOptions = Object.assign({}, internalToObjectOptions, {
    bson: true
  });
  Object.setPrototypeOf(Model.prototype, Document.prototype);
  Model.prototype.$isMongooseModelPrototype = true;
  Model.prototype.db;
  Model.useConnection = function useConnection(connection) {
    if (!connection) {
      throw new Error("Please provide a connection.");
    }
    if (this.db) {
      delete this.db.models[this.modelName];
      delete this.prototype.db;
      delete this.prototype[modelDbSymbol];
      delete this.prototype.collection;
      delete this.prototype.$collection;
      delete this.prototype[modelCollectionSymbol];
    }
    this.db = connection;
    const collection = connection.collection(this.modelName, connection.options);
    this.prototype.collection = collection;
    this.prototype.$collection = collection;
    this.prototype[modelCollectionSymbol] = collection;
    this.prototype.db = connection;
    this.prototype[modelDbSymbol] = connection;
    this.collection = collection;
    this.$__collection = collection;
    connection.models[this.modelName] = this;
    return this;
  };
  Model.prototype.collection;
  Model.prototype.$__collection;
  Model.prototype.modelName;
  Model.prototype.$where;
  Model.prototype.baseModelName;
  Model.events;
  Model._middleware;
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  Model.prototype.$__handleSave = function(options, callback) {
    const saveOptions = {};
    applyWriteConcern(this.$__schema, options);
    if (typeof options.writeConcern !== "undefined") {
      saveOptions.writeConcern = {};
      if ("w" in options.writeConcern) {
        saveOptions.writeConcern.w = options.writeConcern.w;
      }
      if ("j" in options.writeConcern) {
        saveOptions.writeConcern.j = options.writeConcern.j;
      }
      if ("wtimeout" in options.writeConcern) {
        saveOptions.writeConcern.wtimeout = options.writeConcern.wtimeout;
      }
    } else {
      if ("w" in options) {
        saveOptions.w = options.w;
      }
      if ("j" in options) {
        saveOptions.j = options.j;
      }
      if ("wtimeout" in options) {
        saveOptions.wtimeout = options.wtimeout;
      }
    }
    if ("checkKeys" in options) {
      saveOptions.checkKeys = options.checkKeys;
    }
    const session = this.$session();
    const asyncLocalStorage = this[modelDbSymbol].base.transactionAsyncLocalStorage?.getStore();
    if (session != null) {
      saveOptions.session = session;
    } else if (!options.hasOwnProperty("session") && asyncLocalStorage?.session != null) {
      saveOptions.session = asyncLocalStorage.session;
    }
    if (this.$isNew) {
      const obj = this.toObject(saveToObjectOptions);
      if ((obj || {})._id === undefined) {
        immediate(function() {
          callback(new MongooseError("document must have an _id before saving"));
        });
        return;
      }
      this.$__version(true, obj);
      this[modelCollectionSymbol].insertOne(obj, saveOptions).then((ret) => callback(null, ret), (err) => {
        _setIsNew(this, true);
        callback(err, null);
      });
      this.$__reset();
      _setIsNew(this, false);
      this.$__.inserting = true;
      return;
    }
    this.$__.inserting = false;
    const delta = this.$__delta();
    if (options.pathsToSave) {
      for (const key in delta[1]["$set"]) {
        if (options.pathsToSave.includes(key)) {
          continue;
        } else if (options.pathsToSave.some((pathToSave) => key.slice(0, pathToSave.length) === pathToSave && key.charAt(pathToSave.length) === ".")) {
          continue;
        } else {
          delete delta[1]["$set"][key];
        }
      }
    }
    if (delta) {
      if (delta instanceof MongooseError) {
        callback(delta);
        return;
      }
      const where = this.$__where(delta[0]);
      if (where instanceof MongooseError) {
        callback(where);
        return;
      }
      _applyCustomWhere(this, where);
      const update = delta[1];
      if (this.$__schema.options.minimize) {
        for (const updateOp of Object.values(update)) {
          if (updateOp == null) {
            continue;
          }
          for (const key of Object.keys(updateOp)) {
            if (updateOp[key] == null || typeof updateOp[key] !== "object") {
              continue;
            }
            if (!utils.isPOJO(updateOp[key])) {
              continue;
            }
            minimize(updateOp[key]);
            if (Object.keys(updateOp[key]).length === 0) {
              delete updateOp[key];
              update.$unset = update.$unset || {};
              update.$unset[key] = 1;
            }
          }
        }
      }
      this[modelCollectionSymbol].updateOne(where, update, saveOptions).then((ret) => {
        if (ret == null) {
          ret = { $where: where };
        } else {
          ret.$where = where;
        }
        callback(null, ret);
      }, (err) => {
        this.$__undoReset();
        callback(err);
      });
    } else {
      handleEmptyUpdate.call(this);
      return;
    }
    this.$__.modifiedPaths = this.modifiedPaths();
    this.$__reset();
    _setIsNew(this, false);
    function handleEmptyUpdate() {
      const optionsWithCustomValues = Object.assign({}, options, saveOptions);
      const where = this.$__where();
      const optimisticConcurrency = this.$__schema.options.optimisticConcurrency;
      if (optimisticConcurrency && !Array.isArray(optimisticConcurrency)) {
        const key = this.$__schema.options.versionKey;
        const val = this.$__getValue(key);
        if (val != null) {
          where[key] = val;
        }
      }
      applyReadConcern(this.$__schema, optionsWithCustomValues);
      this.constructor.collection.findOne(where, optionsWithCustomValues).then((documentExists) => {
        const matchedCount = !documentExists ? 0 : 1;
        callback(null, { $where: where, matchedCount });
      }).catch(callback);
    }
  };
  /*!
   * ignore
   */
  Model.prototype.$__save = function(options, callback) {
    this.$__handleSave(options, (error, result) => {
      if (error) {
        error = this.$__schema._transformDuplicateKeyError(error);
        const hooks = this.$__schema.s.hooks;
        return hooks.execPost("save:error", this, [this], { error }, (error2) => {
          callback(error2, this);
        });
      }
      let numAffected = 0;
      const writeConcern = options != null ? options.writeConcern != null ? options.writeConcern.w : options.w : 0;
      if (writeConcern !== 0) {
        if (result != null) {
          if (Array.isArray(result)) {
            numAffected = result.length;
          } else if (result.matchedCount != null) {
            numAffected = result.matchedCount;
          } else {
            numAffected = result;
          }
        }
        const versionBump = this.$__.version;
        if (versionBump && !this.$__.inserting) {
          const doIncrement = VERSION_INC === (VERSION_INC & this.$__.version);
          this.$__.version = undefined;
          const key = this.$__schema.options.versionKey;
          const version = this.$__getValue(key) || 0;
          if (numAffected <= 0) {
            this.$__undoReset();
            const err = this.$__.$versionError || new VersionError(this, version, this.$__.modifiedPaths);
            return callback(err);
          }
          if (doIncrement) {
            this.$__setValue(key, version + 1);
          }
        }
        if (result != null && numAffected <= 0) {
          this.$__undoReset();
          error = new DocumentNotFoundError(result.$where, this.constructor.modelName, numAffected, result);
          const hooks = this.$__schema.s.hooks;
          return hooks.execPost("save:error", this, [this], { error }, (error2) => {
            callback(error2, this);
          });
        }
      }
      this.$__.saving = undefined;
      this.$__.savedState = {};
      this.$emit("save", this, numAffected);
      this.constructor.emit("save", this, numAffected);
      callback(null, this);
    });
  };
  /*!
   * ignore
   */
  Model.prototype.save = async function save(options) {
    if (typeof options === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.prototype.save() no longer accepts a callback");
    }
    let parallelSave;
    this.$op = "save";
    if (this.$__.saving) {
      parallelSave = new ParallelSaveError(this);
    } else {
      this.$__.saving = new ParallelSaveError(this);
    }
    options = new SaveOptions(options);
    if (options.hasOwnProperty("session")) {
      this.$session(options.session);
    }
    if (this.$__.timestamps != null) {
      options.timestamps = this.$__.timestamps;
    }
    this.$__.$versionError = generateVersionError(this, this.modifiedPaths());
    if (parallelSave) {
      this.$__handleReject(parallelSave);
      throw parallelSave;
    }
    this.$__.saveOptions = options;
    await new Promise((resolve, reject) => {
      this.$__save(options, (error) => {
        this.$__.saving = null;
        this.$__.saveOptions = null;
        this.$__.$versionError = null;
        this.$op = null;
        if (error != null) {
          this.$__handleReject(error);
          return reject(error);
        }
        resolve();
      });
    });
    return this;
  };
  Model.prototype.$save = Model.prototype.save;
  Model.prototype.$__version = function(where, delta) {
    const key = this.$__schema.options.versionKey;
    if (where === true) {
      if (key) {
        setDottedPath(delta, key, 0);
        this.$__setValue(key, 0);
      }
      return;
    }
    if (key === false) {
      return;
    }
    if (!this.$__isSelected(key)) {
      return;
    }
    if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {
      const value = this.$__getValue(key);
      if (value != null)
        where[key] = value;
    }
    if (VERSION_INC === (VERSION_INC & this.$__.version)) {
      if (get(delta.$set, key, null) != null) {
        ++delta.$set[key];
      } else {
        delta.$inc = delta.$inc || {};
        delta.$inc[key] = 1;
      }
    }
  };
  Model.prototype.increment = function increment() {
    this.$__.version = VERSION_ALL;
    return this;
  };
  Model.prototype.$__where = function _where(where) {
    where || (where = {});
    if (!where._id) {
      where._id = this._doc._id;
    }
    if (this._doc._id === undefined) {
      return new MongooseError("No _id found on document!");
    }
    return where;
  };
  Model.prototype.deleteOne = function deleteOne(options) {
    if (typeof options === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.prototype.deleteOne() no longer accepts a callback");
    }
    if (!options) {
      options = {};
    }
    if (options.hasOwnProperty("session")) {
      this.$session(options.session);
    }
    const self2 = this;
    const where = this.$__where();
    if (where instanceof Error) {
      throw where;
    }
    const query = self2.constructor.deleteOne(where, options);
    if (this.$session() != null) {
      if (!("session" in query.options)) {
        query.options.session = this.$session();
      }
    }
    query.pre(function queryPreDeleteOne(cb) {
      self2.constructor._middleware.execPre("deleteOne", self2, [self2], cb);
    });
    query.pre(function callSubdocPreHooks(cb) {
      each(self2.$getAllSubdocs(), (subdoc, cb2) => {
        subdoc.constructor._middleware.execPre("deleteOne", subdoc, [subdoc], cb2);
      }, cb);
    });
    query.pre(function skipIfAlreadyDeleted(cb) {
      if (self2.$__.isDeleted) {
        return cb(Kareem.skipWrappedFunction());
      }
      return cb();
    });
    query.post(function callSubdocPostHooks(cb) {
      each(self2.$getAllSubdocs(), (subdoc, cb2) => {
        subdoc.constructor._middleware.execPost("deleteOne", subdoc, [subdoc], {}, cb2);
      }, cb);
    });
    query.post(function queryPostDeleteOne(cb) {
      self2.constructor._middleware.execPost("deleteOne", self2, [self2], {}, cb);
    });
    return query;
  };
  Model.prototype.$model = function $model(name) {
    if (arguments.length === 0) {
      return this.constructor;
    }
    return this[modelDbSymbol].model(name);
  };
  Model.prototype.model = Model.prototype.$model;
  Model.exists = function exists(filter, options) {
    _checkContext(this, "exists");
    if (typeof arguments[2] === "function") {
      throw new MongooseError("Model.exists() no longer accepts a callback");
    }
    const query = this.findOne(filter).select({ _id: 1 }).lean().setOptions(options);
    return query;
  };
  Model.discriminator = function(name, schema, options) {
    let model;
    if (typeof name === "function") {
      model = name;
      name = utils.getFunctionName(model);
      if (!(model.prototype instanceof Model)) {
        throw new MongooseError("The provided class " + name + " must extend Model");
      }
    }
    options = options || {};
    const value = utils.isPOJO(options) ? options.value : options;
    const clone2 = typeof options.clone === "boolean" ? options.clone : true;
    const mergePlugins = typeof options.mergePlugins === "boolean" ? options.mergePlugins : true;
    const overwriteModels = typeof options.overwriteModels === "boolean" ? options.overwriteModels : false;
    _checkContext(this, "discriminator");
    if (utils.isObject(schema) && !schema.instanceOfSchema) {
      schema = new Schema(schema);
    }
    if (schema instanceof Schema && clone2) {
      schema = schema.clone();
    }
    schema = discriminator(this, name, schema, value, mergePlugins, options.mergeHooks, overwriteModels);
    if (this.db.models[name] && !schema.options.overwriteModels && !overwriteModels) {
      throw new OverwriteModelError(name);
    }
    schema.$isRootDiscriminator = true;
    schema.$globalPluginsApplied = true;
    model = this.db.model(model || name, schema, this.$__collection.name);
    this.discriminators[name] = model;
    const d = this.discriminators[name];
    Object.setPrototypeOf(d.prototype, this.prototype);
    Object.defineProperty(d, "baseModelName", {
      value: this.modelName,
      configurable: true,
      writable: false
    });
    applyMethods(d, schema);
    applyStatics(d, schema);
    if (this[subclassedSymbol] != null) {
      for (const submodel of this[subclassedSymbol]) {
        submodel.discriminators = submodel.discriminators || {};
        submodel.discriminators[name] = model.__subclass(model.db, schema, submodel.collection.name);
      }
    }
    return d;
  };
  /*!
   * Give the constructor the ability to emit events.
   */
  for (const i in EventEmitter.prototype) {
    Model[i] = EventEmitter.prototype[i];
  }
  Model.init = function init() {
    _checkContext(this, "init");
    if (typeof arguments[0] === "function") {
      throw new MongooseError("Model.init() no longer accepts a callback");
    }
    this.schema.emit("init", this);
    if (this.$init != null) {
      return this.$init;
    }
    const conn = this.db;
    const _ensureIndexes2 = async () => {
      const autoIndex = utils.getOption("autoIndex", this.schema.options, conn.config, conn.base.options);
      if (!autoIndex) {
        return;
      }
      return await this.ensureIndexes({ _automatic: true });
    };
    const _createSearchIndexes = async () => {
      const autoSearchIndex = utils.getOption("autoSearchIndex", this.schema.options, conn.config, conn.base.options);
      if (!autoSearchIndex) {
        return;
      }
      const results = [];
      for (const searchIndex of this.schema._searchIndexes) {
        results.push(await this.createSearchIndex(searchIndex));
      }
      return results;
    };
    const _createCollection = async () => {
      let autoCreate = utils.getOption("autoCreate", this.schema.options, conn.config);
      if (autoCreate == null) {
        await conn._waitForConnect(true);
        autoCreate = utils.getOption("autoCreate", this.schema.options, conn.config, conn.base.options);
      }
      if (!autoCreate) {
        return;
      }
      return await this.createCollection();
    };
    this.$init = _createCollection().then(() => _ensureIndexes2()).then(() => _createSearchIndexes());
    const _catch = this.$init.catch;
    const _this = this;
    this.$init.catch = function() {
      _this.$caught = true;
      return _catch.apply(_this.$init, arguments);
    };
    return this.$init;
  };
  Model.createCollection = async function createCollection(options) {
    _checkContext(this, "createCollection");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.createCollection() no longer accepts a callback");
    }
    const shouldSkip = await new Promise((resolve, reject) => {
      this.hooks.execPre("createCollection", this, [options], (err) => {
        if (err != null) {
          if (err instanceof Kareem.skipWrappedFunction) {
            return resolve(true);
          }
          return reject(err);
        }
        resolve();
      });
    });
    const collectionOptions = this && this.schema && this.schema.options && this.schema.options.collectionOptions;
    if (collectionOptions != null) {
      options = Object.assign({}, collectionOptions, options);
    }
    const schemaCollation = this && this.schema && this.schema.options && this.schema.options.collation;
    if (schemaCollation != null) {
      options = Object.assign({ collation: schemaCollation }, options);
    }
    const capped = this && this.schema && this.schema.options && this.schema.options.capped;
    if (capped != null) {
      if (typeof capped === "number") {
        options = Object.assign({ capped: true, size: capped }, options);
      } else if (typeof capped === "object") {
        options = Object.assign({ capped: true }, capped, options);
      }
    }
    const timeseries = this && this.schema && this.schema.options && this.schema.options.timeseries;
    if (timeseries != null) {
      options = Object.assign({ timeseries }, options);
      if (options.expireAfterSeconds != null) {
      } else if (options.expires != null) {
        utils.expires(options);
      } else if (this.schema.options.expireAfterSeconds != null) {
        options.expireAfterSeconds = this.schema.options.expireAfterSeconds;
      } else if (this.schema.options.expires != null) {
        options.expires = this.schema.options.expires;
        utils.expires(options);
      }
    }
    const clusteredIndex = this && this.schema && this.schema.options && this.schema.options.clusteredIndex;
    if (clusteredIndex != null) {
      options = Object.assign({ clusteredIndex: { ...clusteredIndex, unique: true } }, options);
    }
    try {
      if (!shouldSkip) {
        await this.db.createCollection(this.$__collection.collectionName, options);
      }
    } catch (err) {
      if (err != null && (err.name !== "MongoServerError" || err.code !== 48)) {
        await new Promise((resolve, reject) => {
          const _opts = { error: err };
          this.hooks.execPost("createCollection", this, [null], _opts, (err2) => {
            if (err2 != null) {
              return reject(err2);
            }
            resolve();
          });
        });
      }
    }
    await new Promise((resolve, reject) => {
      this.hooks.execPost("createCollection", this, [this.$__collection], (err) => {
        if (err != null) {
          return reject(err);
        }
        resolve();
      });
    });
    return this.$__collection;
  };
  Model.syncIndexes = async function syncIndexes(options) {
    _checkContext(this, "syncIndexes");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.syncIndexes() no longer accepts a callback");
    }
    const autoCreate = options?.autoCreate ?? this.schema.options?.autoCreate ?? this.db.config.autoCreate ?? true;
    if (autoCreate) {
      try {
        await this.createCollection();
      } catch (err) {
        if (err != null && (err.name !== "MongoServerError" || err.code !== 48)) {
          throw err;
        }
      }
    }
    const diffIndexesResult = await this.diffIndexes({ indexOptionsToCreate: true });
    const dropped = await this.cleanIndexes({ ...options, toDrop: diffIndexesResult.toDrop });
    await this.createIndexes({ ...options, toCreate: diffIndexesResult.toCreate });
    return dropped;
  };
  Model.createSearchIndex = async function createSearchIndex(description) {
    _checkContext(this, "createSearchIndex");
    return await this.$__collection.createSearchIndex(description);
  };
  Model.updateSearchIndex = async function updateSearchIndex(name, definition) {
    _checkContext(this, "updateSearchIndex");
    return await this.$__collection.updateSearchIndex(name, definition);
  };
  Model.dropSearchIndex = async function dropSearchIndex(name) {
    _checkContext(this, "dropSearchIndex");
    return await this.$__collection.dropSearchIndex(name);
  };
  Model.listSearchIndexes = async function listSearchIndexes(options) {
    _checkContext(this, "listSearchIndexes");
    const cursor = await this.$__collection.listSearchIndexes(options);
    return await cursor.toArray();
  };
  Model.diffIndexes = async function diffIndexes(options) {
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.syncIndexes() no longer accepts a callback");
    }
    const model = this;
    let dbIndexes = await model.listIndexes().catch((err) => {
      if (err.codeName == "NamespaceNotFound") {
        return;
      }
      throw err;
    });
    if (dbIndexes === undefined) {
      dbIndexes = [];
    }
    dbIndexes = getRelatedDBIndexes(model, dbIndexes);
    const schema = model.schema;
    const schemaIndexes = getRelatedSchemaIndexes(model, schema.indexes());
    const toDrop = getIndexesToDrop(schema, schemaIndexes, dbIndexes);
    const toCreate = getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop, options);
    return { toDrop, toCreate };
  };
  Model.cleanIndexes = async function cleanIndexes(options) {
    _checkContext(this, "cleanIndexes");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.cleanIndexes() no longer accepts a callback");
    }
    const model = this;
    if (Array.isArray(options && options.toDrop)) {
      const res2 = await _dropIndexes(options.toDrop, model, options);
      return res2;
    }
    const res = await model.diffIndexes();
    return await _dropIndexes(res.toDrop, model, options);
  };
  Model.listIndexes = async function listIndexes() {
    _checkContext(this, "listIndexes");
    if (typeof arguments[0] === "function") {
      throw new MongooseError("Model.listIndexes() no longer accepts a callback");
    }
    if (this.$__collection.buffer) {
      await new Promise((resolve) => {
        this.$__collection.addQueue(resolve);
      });
    }
    return this.$__collection.listIndexes().toArray();
  };
  Model.ensureIndexes = async function ensureIndexes(options) {
    _checkContext(this, "ensureIndexes");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.ensureIndexes() no longer accepts a callback");
    }
    await new Promise((resolve, reject) => {
      _ensureIndexes(this, options, (err) => {
        if (err != null) {
          return reject(err);
        }
        resolve();
      });
    });
  };
  Model.createIndexes = async function createIndexes(options) {
    _checkContext(this, "createIndexes");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function") {
      throw new MongooseError("Model.createIndexes() no longer accepts a callback");
    }
    return this.ensureIndexes(options);
  };
  /*!
   * ignore
   */
  Model.schema;
  Model.db;
  Model.collection;
  Model.$__collection;
  Model.base;
  Model.discriminators;
  Model.translateAliases = function translateAliases(fields, errorOnDuplicates) {
    _checkContext(this, "translateAliases");
    const translate = (key, value) => {
      let alias;
      const translated = [];
      const fieldKeys = key.split(".");
      let currentSchema = this.schema;
      for (const i in fieldKeys) {
        const name = fieldKeys[i];
        if (currentSchema && currentSchema.aliases[name]) {
          alias = currentSchema.aliases[name];
          if (errorOnDuplicates && alias in fields) {
            throw new MongooseError(`Provided object has both field "${name}" and its alias "${alias}"`);
          }
          translated.push(alias);
        } else {
          alias = name;
          translated.push(name);
        }
        if (currentSchema && currentSchema.paths[alias]) {
          currentSchema = currentSchema.paths[alias].schema;
        } else
          currentSchema = null;
      }
      const translatedKey = translated.join(".");
      if (fields instanceof Map)
        fields.set(translatedKey, value);
      else
        fields[translatedKey] = value;
      if (translatedKey !== key) {
        if (fields instanceof Map) {
          fields.delete(key);
        } else {
          delete fields[key];
        }
      }
      return fields;
    };
    if (typeof fields === "object") {
      if (fields instanceof Map) {
        for (const field of new Map(fields)) {
          fields = translate(field[0], field[1]);
        }
      } else {
        for (const key of Object.keys(fields)) {
          fields = translate(key, fields[key]);
          if (key[0] === "$") {
            if (Array.isArray(fields[key])) {
              for (const i in fields[key]) {
                fields[key][i] = this.translateAliases(fields[key][i]);
              }
            } else {
              this.translateAliases(fields[key]);
            }
          }
        }
      }
      return fields;
    } else {
      return fields;
    }
  };
  Model.deleteOne = function deleteOne(conditions, options) {
    _checkContext(this, "deleteOne");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.prototype.deleteOne() no longer accepts a callback");
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.setOptions(options);
    return mq.deleteOne(conditions);
  };
  Model.deleteMany = function deleteMany(conditions, options) {
    _checkContext(this, "deleteMany");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.deleteMany() no longer accepts a callback");
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.setOptions(options);
    return mq.deleteMany(conditions);
  };
  Model.find = function find(conditions, projection, options) {
    _checkContext(this, "find");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function" || typeof arguments[3] === "function") {
      throw new MongooseError("Model.find() no longer accepts a callback");
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.select(projection);
    mq.setOptions(options);
    return mq.find(conditions);
  };
  Model.findById = function findById(id, projection, options) {
    _checkContext(this, "findById");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.findById() no longer accepts a callback");
    }
    if (typeof id === "undefined") {
      id = null;
    }
    return this.findOne({ _id: id }, projection, options);
  };
  Model.findOne = function findOne(conditions, projection, options) {
    _checkContext(this, "findOne");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.findOne() no longer accepts a callback");
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.select(projection);
    mq.setOptions(options);
    return mq.findOne(conditions);
  };
  Model.estimatedDocumentCount = function estimatedDocumentCount(options) {
    _checkContext(this, "estimatedDocumentCount");
    const mq = new this.Query({}, {}, this, this.$__collection);
    return mq.estimatedDocumentCount(options);
  };
  Model.countDocuments = function countDocuments(conditions, options) {
    _checkContext(this, "countDocuments");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.countDocuments() no longer accepts a callback");
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    if (options != null) {
      mq.setOptions(options);
    }
    return mq.countDocuments(conditions);
  };
  Model.distinct = function distinct(field, conditions, options) {
    _checkContext(this, "distinct");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.distinct() no longer accepts a callback");
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    if (options != null) {
      mq.setOptions(options);
    }
    return mq.distinct(field, conditions);
  };
  Model.where = function where(path, val) {
    _checkContext(this, "where");
    const mq = new this.Query({}, {}, this, this.$__collection).find({});
    return mq.where.apply(mq, arguments);
  };
  Model.$where = function $where() {
    _checkContext(this, "$where");
    const mq = new this.Query({}, {}, this, this.$__collection).find({});
    return mq.$where.apply(mq, arguments);
  };
  Model.findOneAndUpdate = function(conditions, update, options) {
    _checkContext(this, "findOneAndUpdate");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function" || typeof arguments[3] === "function") {
      throw new MongooseError("Model.findOneAndUpdate() no longer accepts a callback");
    }
    if (arguments.length === 1) {
      update = conditions;
      conditions = null;
      options = null;
    }
    let fields;
    if (options) {
      fields = options.fields || options.projection;
    }
    update = clone(update, {
      depopulate: true,
      _isNested: true
    });
    decorateUpdateWithVersionKey(update, options, this.schema.options.versionKey);
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.select(fields);
    return mq.findOneAndUpdate(conditions, update, options);
  };
  Model.findByIdAndUpdate = function(id, update, options) {
    _checkContext(this, "findByIdAndUpdate");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function" || typeof arguments[3] === "function") {
      throw new MongooseError("Model.findByIdAndUpdate() no longer accepts a callback");
    }
    if (id instanceof Document) {
      id = id._doc._id;
    }
    return this.findOneAndUpdate.call(this, { _id: id }, update, options);
  };
  Model.findOneAndDelete = function(conditions, options) {
    _checkContext(this, "findOneAndDelete");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.findOneAndDelete() no longer accepts a callback");
    }
    let fields;
    if (options) {
      fields = options.select;
      options.select = undefined;
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.select(fields);
    return mq.findOneAndDelete(conditions, options);
  };
  Model.findByIdAndDelete = function(id, options) {
    _checkContext(this, "findByIdAndDelete");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.findByIdAndDelete() no longer accepts a callback");
    }
    return this.findOneAndDelete({ _id: id }, options);
  };
  Model.findOneAndReplace = function(filter, replacement, options) {
    _checkContext(this, "findOneAndReplace");
    if (typeof arguments[0] === "function" || typeof arguments[1] === "function" || typeof arguments[2] === "function" || typeof arguments[3] === "function") {
      throw new MongooseError("Model.findOneAndReplace() no longer accepts a callback");
    }
    let fields;
    if (options) {
      fields = options.select;
      options.select = undefined;
    }
    const mq = new this.Query({}, {}, this, this.$__collection);
    mq.select(fields);
    return mq.findOneAndReplace(filter, replacement, options);
  };
  Model.create = async function create(doc, options) {
    if (typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.create() no longer accepts a callback");
    }
    _checkContext(this, "create");
    let args;
    const discriminatorKey = this.schema.options.discriminatorKey;
    if (Array.isArray(doc)) {
      args = doc;
      options = options != null && typeof options === "object" ? options : {};
    } else {
      const last = arguments[arguments.length - 1];
      options = {};
      const hasCallback = typeof last === "function" || typeof options === "function" || typeof arguments[2] === "function";
      if (hasCallback) {
        throw new MongooseError("Model.create() no longer accepts a callback");
      } else {
        args = [...arguments];
        if (args.length > 1 && !last) {
          args.pop();
        }
      }
      if (args.length === 2 && args[0] != null && args[1] != null && args[0].session == null && last && getConstructorName(last.session) === "ClientSession" && !this.schema.path("session")) {
        utils.warn("WARNING: to pass a `session` to `Model.create()` in " + "Mongoose, you **must** pass an array as the first argument. See: " + "https://mongoosejs.com/docs/api/model.html#Model.create()");
      }
    }
    if (args.length === 0) {
      return Array.isArray(doc) ? [] : null;
    }
    let res = [];
    const immediateError = typeof options.aggregateErrors === "boolean" ? !options.aggregateErrors : true;
    delete options.aggregateErrors;
    if (options.session && !options.ordered && args.length > 1) {
      throw new MongooseError("Cannot call `create()` with a session and multiple documents unless `ordered: true` is set");
    }
    if (options.ordered) {
      for (let i = 0;i < args.length; i++) {
        try {
          const doc2 = args[i];
          const Model2 = this.discriminators && doc2[discriminatorKey] != null ? this.discriminators[doc2[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc2[discriminatorKey]) : this;
          if (Model2 == null) {
            throw new MongooseError(`Discriminator "${doc2[discriminatorKey]}" not ` + `found for model "${this.modelName}"`);
          }
          let toSave = doc2;
          if (!(toSave instanceof Model2)) {
            toSave = new Model2(toSave);
          }
          await toSave.$save(options);
          res.push(toSave);
        } catch (err) {
          if (!immediateError) {
            res.push(err);
          } else {
            throw err;
          }
        }
      }
      return res;
    } else if (!immediateError) {
      res = await Promise.allSettled(args.map(async (doc2) => {
        const Model2 = this.discriminators && doc2[discriminatorKey] != null ? this.discriminators[doc2[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc2[discriminatorKey]) : this;
        if (Model2 == null) {
          throw new MongooseError(`Discriminator "${doc2[discriminatorKey]}" not ` + `found for model "${this.modelName}"`);
        }
        let toSave = doc2;
        if (!(toSave instanceof Model2)) {
          toSave = new Model2(toSave);
        }
        await toSave.$save(options);
        return toSave;
      }));
      res = res.map((result) => result.status === "fulfilled" ? result.value : result.reason);
    } else {
      let firstError = null;
      res = await Promise.all(args.map(async (doc2) => {
        const Model2 = this.discriminators && doc2[discriminatorKey] != null ? this.discriminators[doc2[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc2[discriminatorKey]) : this;
        if (Model2 == null) {
          throw new MongooseError(`Discriminator "${doc2[discriminatorKey]}" not ` + `found for model "${this.modelName}"`);
        }
        try {
          let toSave = doc2;
          if (!(toSave instanceof Model2)) {
            toSave = new Model2(toSave);
          }
          await toSave.$save(options);
          return toSave;
        } catch (err) {
          if (!firstError) {
            firstError = err;
          }
        }
      }));
      if (firstError) {
        throw firstError;
      }
    }
    if (!Array.isArray(doc) && args.length === 1) {
      return res[0];
    }
    return res;
  };
  Model.insertOne = async function insertOne(doc, options) {
    _checkContext(this, "insertOne");
    const discriminatorKey = this.schema.options.discriminatorKey;
    const Model2 = this.discriminators && doc[discriminatorKey] != null ? this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) : this;
    if (Model2 == null) {
      throw new MongooseError(`Discriminator "${doc[discriminatorKey]}" not found for model "${this.modelName}"`);
    }
    if (!(doc instanceof Model2)) {
      doc = new Model2(doc);
    }
    return await doc.$save(options);
  };
  Model.watch = function(pipeline, options) {
    _checkContext(this, "watch");
    const changeStreamThunk = (cb) => {
      pipeline = pipeline || [];
      prepareDiscriminatorPipeline(pipeline, this.schema, "fullDocument");
      if (this.$__collection.buffer) {
        this.$__collection.addQueue(() => {
          if (this.closed) {
            return;
          }
          const driverChangeStream = this.$__collection.watch(pipeline, options);
          cb(null, driverChangeStream);
        });
      } else {
        const driverChangeStream = this.$__collection.watch(pipeline, options);
        cb(null, driverChangeStream);
      }
    };
    options = options || {};
    options.model = this;
    return new ChangeStream(changeStreamThunk, pipeline, options);
  };
  Model.startSession = function() {
    _checkContext(this, "startSession");
    return this.db.startSession.apply(this.db, arguments);
  };
  Model.insertMany = async function insertMany(arr, options) {
    _checkContext(this, "insertMany");
    if (typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.insertMany() no longer accepts a callback");
    }
    return new Promise((resolve, reject) => {
      this.$__insertMany(arr, options, (err, res) => {
        if (err != null) {
          return reject(err);
        }
        resolve(res);
      });
    });
  };
  Model.$__insertMany = function(arr, options, callback) {
    const _this = this;
    if (typeof options === "function") {
      callback = options;
      options = null;
    }
    callback = callback || utils.noop;
    options = options || {};
    const limit = options.limit || 1000;
    const rawResult = !!options.rawResult;
    const ordered = typeof options.ordered === "boolean" ? options.ordered : true;
    const throwOnValidationError = typeof options.throwOnValidationError === "boolean" ? options.throwOnValidationError : false;
    const lean = !!options.lean;
    const asyncLocalStorage = this.db.base.transactionAsyncLocalStorage?.getStore();
    if ((!options || !options.hasOwnProperty("session")) && asyncLocalStorage?.session != null) {
      options = { ...options, session: asyncLocalStorage.session };
    }
    if (!Array.isArray(arr)) {
      arr = [arr];
    }
    const validationErrors = [];
    const validationErrorsToOriginalOrder = new Map;
    const results = ordered ? null : new Array(arr.length);
    const toExecute = arr.map((doc, index) => (callback2) => {
      if (lean) {
        return immediate(() => callback2(null, doc));
      }
      let createdNewDoc = false;
      if (!(doc instanceof _this)) {
        if (doc != null && typeof doc !== "object") {
          return callback2(new ObjectParameterError(doc, "arr." + index, "insertMany"));
        }
        try {
          doc = new _this(doc);
          createdNewDoc = true;
        } catch (err) {
          return callback2(err);
        }
      }
      if (options.session != null) {
        doc.$session(options.session);
      }
      if (lean) {
        return immediate(() => callback2(null, doc));
      }
      doc.$validate(createdNewDoc ? { _skipParallelValidateCheck: true } : null).then(() => {
        callback2(null, doc);
      }, (error) => {
        if (ordered === false) {
          validationErrors.push(error);
          validationErrorsToOriginalOrder.set(error, index);
          results[index] = error;
          return callback2(null, null);
        }
        callback2(error);
      });
    });
    parallelLimit(toExecute, limit, function(error, docs) {
      if (error) {
        callback(error, null);
        return;
      }
      const originalDocIndex = new Map;
      const validDocIndexToOriginalIndex = new Map;
      for (let i = 0;i < docs.length; ++i) {
        originalDocIndex.set(docs[i], i);
      }
      const docAttributes = docs.filter(function(doc) {
        return doc != null;
      });
      for (let i = 0;i < docAttributes.length; ++i) {
        validDocIndexToOriginalIndex.set(i, originalDocIndex.get(docAttributes[i]));
      }
      if (validationErrors.length > 0) {
        validationErrors.sort((err1, err2) => {
          return validationErrorsToOriginalOrder.get(err1) - validationErrorsToOriginalOrder.get(err2);
        });
      }
      if (docAttributes.length === 0) {
        if (throwOnValidationError) {
          return callback(new MongooseBulkWriteError(validationErrors, results, null, "insertMany"));
        }
        if (rawResult) {
          const res = {
            acknowledged: true,
            insertedCount: 0,
            insertedIds: {},
            mongoose: {
              validationErrors
            }
          };
          return callback(null, res);
        }
        callback(null, []);
        return;
      }
      const docObjects = lean ? docAttributes : docAttributes.map(function(doc) {
        if (doc.$__schema.options.versionKey) {
          doc[doc.$__schema.options.versionKey] = 0;
        }
        const shouldSetTimestamps = (!options || options.timestamps !== false) && doc.initializeTimestamps && (!doc.$__ || doc.$__.timestamps !== false);
        if (shouldSetTimestamps) {
          doc.initializeTimestamps();
        }
        if (doc.$__hasOnlyPrimitiveValues()) {
          return doc.$__toObjectShallow();
        }
        return doc.toObject(internalToObjectOptions);
      });
      _this.$__collection.insertMany(docObjects, options).then((res) => {
        if (!lean) {
          for (const attribute of docAttributes) {
            attribute.$__reset();
            _setIsNew(attribute, false);
          }
        }
        if (ordered === false && throwOnValidationError && validationErrors.length > 0) {
          for (let i = 0;i < results.length; ++i) {
            if (results[i] === undefined) {
              results[i] = docs[i];
            }
          }
          return callback(new MongooseBulkWriteError(validationErrors, results, res, "insertMany"));
        }
        if (rawResult) {
          if (ordered === false) {
            for (let i = 0;i < results.length; ++i) {
              if (results[i] === undefined) {
                results[i] = docs[i];
              }
            }
            res.mongoose = {
              validationErrors,
              results
            };
          }
          return callback(null, res);
        }
        if (options.populate != null) {
          return _this.populate(docAttributes, options.populate).then((docs2) => {
            callback(null, docs2);
          }, (err) => {
            if (err != null) {
              err.insertedDocs = docAttributes;
            }
            throw err;
          });
        }
        callback(null, docAttributes);
      }, (error2) => {
        if (error2.writeErrors == null && (error2.result && error2.result.result && error2.result.result.writeErrors) != null) {
          error2.writeErrors = error2.result.result.writeErrors;
        }
        const hasWriteErrors = error2 && error2.writeErrors;
        const erroredIndexes = new Set((error2 && error2.writeErrors || []).map((err) => err.index));
        if (error2.writeErrors != null) {
          for (let i = 0;i < error2.writeErrors.length; ++i) {
            const originalIndex = validDocIndexToOriginalIndex.get(error2.writeErrors[i].index);
            error2.writeErrors[i] = {
              ...error2.writeErrors[i],
              index: originalIndex
            };
            if (!ordered) {
              results[originalIndex] = error2.writeErrors[i];
            }
          }
        }
        if (!ordered) {
          for (let i = 0;i < results.length; ++i) {
            if (results[i] === undefined) {
              results[i] = docs[i];
            }
          }
          error2.results = results;
        }
        let firstErroredIndex = -1;
        error2.insertedDocs = docAttributes.filter((doc, i) => {
          const isErrored = !hasWriteErrors || erroredIndexes.has(i);
          if (ordered) {
            if (firstErroredIndex > -1) {
              return i < firstErroredIndex;
            }
            if (isErrored) {
              firstErroredIndex = i;
            }
          }
          return !isErrored;
        }).map(function setIsNewForInsertedDoc(doc) {
          if (lean) {
            return doc;
          }
          doc.$__reset();
          _setIsNew(doc, false);
          return doc;
        });
        if (rawResult && ordered === false) {
          error2.mongoose = {
            validationErrors,
            results
          };
        }
        callback(error2, null);
      });
    });
  };
  /*!
   * ignore
   */
  Model.bulkWrite = async function bulkWrite(ops, options) {
    _checkContext(this, "bulkWrite");
    if (typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.bulkWrite() no longer accepts a callback");
    }
    options = options || {};
    const shouldSkip = await new Promise((resolve, reject) => {
      this.hooks.execPre("bulkWrite", this, [ops, options], (err) => {
        if (err != null) {
          if (err instanceof Kareem.skipWrappedFunction) {
            return resolve(err);
          }
          return reject(err);
        }
        resolve();
      });
    });
    if (shouldSkip) {
      return shouldSkip.args[0];
    }
    const ordered = options.ordered == null ? true : options.ordered;
    if (ops.length === 0) {
      return getDefaultBulkwriteResult();
    }
    const validations = ops.map((op) => castBulkWrite(this, op, options));
    const asyncLocalStorage = this.db.base.transactionAsyncLocalStorage?.getStore();
    if ((!options || !options.hasOwnProperty("session")) && asyncLocalStorage?.session != null) {
      options = { ...options, session: asyncLocalStorage.session };
    }
    let res = null;
    if (ordered) {
      await new Promise((resolve, reject) => {
        each(validations, (fn, cb) => fn(cb), (error) => {
          if (error) {
            return reject(error);
          }
          resolve();
        });
      });
      try {
        res = await this.$__collection.bulkWrite(ops, options);
      } catch (error) {
        await new Promise((resolve, reject) => {
          const _opts = { error };
          this.hooks.execPost("bulkWrite", this, [null], _opts, (err) => {
            if (err != null) {
              return reject(err);
            }
            resolve();
          });
        });
      }
    } else {
      let remaining = validations.length;
      let validOps = [];
      let validationErrors = [];
      const results = [];
      await new Promise((resolve) => {
        for (let i = 0;i < validations.length; ++i) {
          validations[i]((err) => {
            if (err == null) {
              validOps.push(i);
            } else {
              validationErrors.push({ index: i, error: err });
              results[i] = err;
            }
            if (--remaining <= 0) {
              resolve();
            }
          });
        }
      });
      validationErrors = validationErrors.sort((v1, v2) => v1.index - v2.index).map((v) => v.error);
      const validOpIndexes = validOps;
      validOps = validOps.sort().map((index) => ops[index]);
      if (validOps.length === 0) {
        if (options.throwOnValidationError && validationErrors.length) {
          throw new MongooseBulkWriteError(validationErrors, results, res, "bulkWrite");
        }
        return getDefaultBulkwriteResult();
      }
      let error;
      [res, error] = await this.$__collection.bulkWrite(validOps, options).then((res2) => [res2, null]).catch((error2) => [null, error2]);
      if (error) {
        if (validationErrors.length > 0) {
          error.mongoose = error.mongoose || {};
          error.mongoose.validationErrors = validationErrors;
        }
        await new Promise((resolve, reject) => {
          const _opts = { error };
          this.hooks.execPost("bulkWrite", this, [null], _opts, (err) => {
            if (err != null) {
              return reject(err);
            }
            resolve();
          });
        });
      }
      for (let i = 0;i < validOpIndexes.length; ++i) {
        results[validOpIndexes[i]] = null;
      }
      if (validationErrors.length > 0) {
        if (options.throwOnValidationError) {
          throw new MongooseBulkWriteError(validationErrors, results, res, "bulkWrite");
        } else {
          res.mongoose = res.mongoose || {};
          res.mongoose.validationErrors = validationErrors;
          res.mongoose.results = results;
        }
      }
    }
    await new Promise((resolve, reject) => {
      this.hooks.execPost("bulkWrite", this, [res], (err) => {
        if (err != null) {
          return reject(err);
        }
        resolve();
      });
    });
    return res;
  };
  Model.bulkSave = async function bulkSave(documents, options) {
    options = options || {};
    if (options.timestamps != null) {
      for (const document2 of documents) {
        document2.$__.saveOptions = document2.$__.saveOptions || {};
        document2.$__.saveOptions.timestamps = options.timestamps;
      }
    } else {
      for (const document2 of documents) {
        if (document2.$__.timestamps != null) {
          document2.$__.saveOptions = document2.$__.saveOptions || {};
          document2.$__.saveOptions.timestamps = document2.$__.timestamps;
        }
      }
    }
    await Promise.all(documents.map((doc) => buildPreSavePromise(doc, options)));
    const writeOperations = this.buildBulkWriteOperations(documents, { skipValidation: true, timestamps: options.timestamps });
    const { bulkWriteResult, bulkWriteError } = await this.bulkWrite(writeOperations, { skipValidation: true, ...options }).then((res) => ({ bulkWriteResult: res, bulkWriteError: null }), (err) => ({ bulkWriteResult: null, bulkWriteError: err }));
    if (bulkWriteError != null && !(bulkWriteError instanceof MongoBulkWriteError)) {
      throw bulkWriteError;
    }
    const matchedCount = bulkWriteResult?.matchedCount ?? 0;
    const insertedCount = bulkWriteResult?.insertedCount ?? 0;
    if (writeOperations.length > 0 && matchedCount + insertedCount < writeOperations.length && !bulkWriteError) {
      throw new MongooseBulkSaveIncompleteError(this.modelName, documents, bulkWriteResult);
    }
    const successfulDocuments = [];
    for (let i = 0;i < documents.length; i++) {
      const document2 = documents[i];
      const documentError = bulkWriteError && bulkWriteError.writeErrors.find((writeError) => {
        const writeErrorDocumentId = writeError.err.op._id || writeError.err.op.q._id;
        return writeErrorDocumentId.toString() === document2._doc._id.toString();
      });
      if (documentError == null) {
        successfulDocuments.push(document2);
      }
    }
    await Promise.all(successfulDocuments.map((document2) => handleSuccessfulWrite(document2)));
    if (bulkWriteError && bulkWriteError.writeErrors && bulkWriteError.writeErrors.length) {
      throw bulkWriteError;
    }
    return bulkWriteResult;
  };
  Model.applyDefaults = function applyDefaults(doc) {
    if (doc == null) {
      return doc;
    }
    if (doc.$__ != null) {
      applyDefaultsHelper(doc, doc.$__.fields, doc.$__.exclude);
      for (const subdoc of doc.$getAllSubdocs()) {
        applyDefaults(subdoc, subdoc.$__.fields, subdoc.$__.exclude);
      }
      return doc;
    }
    applyDefaultsToPOJO(doc, this.schema);
    return doc;
  };
  Model.applyVirtuals = function applyVirtuals(obj, virtualsToApply) {
    if (obj == null) {
      return obj;
    }
    if (obj.$__ != null) {
      return obj;
    }
    applyVirtualsHelper(this.schema, obj, virtualsToApply);
    return obj;
  };
  Model.applyTimestamps = function applyTimestamps(obj, options) {
    if (obj == null) {
      return obj;
    }
    if (obj.$__ != null) {
      return obj;
    }
    applyTimestampsHelper(this.schema, obj, options);
    return obj;
  };
  Model.castObject = function castObject(obj, options) {
    options = options || {};
    const ret = {};
    let schema = this.schema;
    const discriminatorKey = schema.options.discriminatorKey;
    if (schema.discriminators != null && obj != null && obj[discriminatorKey] != null) {
      schema = getSchemaDiscriminatorByValue(schema, obj[discriminatorKey]) || schema;
    }
    const paths = Object.keys(schema.paths);
    for (const path of paths) {
      const schemaType = schema.path(path);
      if (!schemaType || !schemaType.$isMongooseArray) {
        continue;
      }
      const val = get(obj, path);
      pushNestedArrayPaths(paths, val, path);
    }
    let error = null;
    for (const path of paths) {
      const schemaType = schema.path(path);
      if (schemaType == null) {
        continue;
      }
      let val = get(obj, path, undefined);
      if (val == null) {
        continue;
      }
      const pieces = path.indexOf(".") === -1 ? [path] : path.split(".");
      let cur = ret;
      for (let i = 0;i < pieces.length - 1; ++i) {
        if (cur[pieces[i]] == null) {
          cur[pieces[i]] = isNaN(pieces[i + 1]) ? {} : [];
        }
        cur = cur[pieces[i]];
      }
      if (schemaType.$isMongooseDocumentArray) {
        const castNonArraysOption = schemaType.options?.castNonArrays ?? schemaType.constructor.options.castNonArrays;
        if (!Array.isArray(val)) {
          if (!castNonArraysOption) {
            if (!options.ignoreCastErrors) {
              error = error || new ValidationError;
              error.addError(path, new ObjectExpectedError(path, val));
            }
          } else {
            cur[pieces[pieces.length - 1]] = [
              Model.castObject.call(schemaType.caster, val)
            ];
          }
          continue;
        }
      }
      if (schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) {
        try {
          val = Model.castObject.call(schemaType.caster, val);
        } catch (err) {
          if (!options.ignoreCastErrors) {
            error = error || new ValidationError;
            error.addError(path, err);
          }
          continue;
        }
        cur[pieces[pieces.length - 1]] = val;
        continue;
      }
      try {
        val = schemaType.cast(val);
        cur[pieces[pieces.length - 1]] = val;
      } catch (err) {
        if (!options.ignoreCastErrors) {
          error = error || new ValidationError;
          error.addError(path, err);
        }
        continue;
      }
    }
    if (error != null) {
      throw error;
    }
    return ret;
  };
  Model.buildBulkWriteOperations = function buildBulkWriteOperations(documents, options) {
    if (!Array.isArray(documents)) {
      throw new Error(`bulkSave expects an array of documents to be passed, received \`${documents}\` instead`);
    }
    setDefaultOptions();
    const discriminatorKey = this.schema.options.discriminatorKey;
    const writeOperations = documents.reduce((accumulator, document2, i) => {
      if (!options.skipValidation) {
        if (!(document2 instanceof Document)) {
          throw new Error(`documents.${i} was not a mongoose document, documents must be an array of mongoose documents (instanceof mongoose.Document).`);
        }
        const validationError = document2.validateSync();
        if (validationError) {
          throw validationError;
        }
      }
      const isANewDocument = document2.isNew;
      if (isANewDocument) {
        const writeOperation = { insertOne: { document: document2 } };
        utils.injectTimestampsOption(writeOperation.insertOne, options.timestamps);
        accumulator.push(writeOperation);
        return accumulator;
      }
      const delta = document2.$__delta();
      const isDocumentWithChanges = delta != null && !utils.isEmptyObject(delta[0]);
      if (isDocumentWithChanges) {
        const where = document2.$__where(delta[0]);
        const changes = delta[1];
        _applyCustomWhere(document2, where);
        const shardKey = this.schema.options.shardKey;
        if (shardKey) {
          const paths = Object.keys(shardKey);
          const len = paths.length;
          for (let i2 = 0;i2 < len; ++i2) {
            where[paths[i2]] = document2[paths[i2]];
          }
        }
        if (document2[discriminatorKey] != null && !(discriminatorKey in where)) {
          where[discriminatorKey] = document2[discriminatorKey];
        }
        document2.$__version(where, delta);
        const writeOperation = { updateOne: { filter: where, update: changes } };
        utils.injectTimestampsOption(writeOperation.updateOne, options.timestamps);
        accumulator.push(writeOperation);
        return accumulator;
      }
      return accumulator;
    }, []);
    return writeOperations;
    function setDefaultOptions() {
      options = options || {};
      if (options.skipValidation == null) {
        options.skipValidation = false;
      }
    }
  };
  Model.hydrate = function(obj, projection, options) {
    _checkContext(this, "hydrate");
    if (projection != null) {
      if (obj != null && obj.$__ != null) {
        obj = obj.toObject(internalToObjectOptions);
      }
      obj = applyProjection(obj, projection);
    }
    const document2 = require_queryHelpers().createModel(this, obj, projection);
    document2.$init(obj, options);
    return document2;
  };
  Model.updateMany = function updateMany(conditions, update, options) {
    _checkContext(this, "updateMany");
    if (update == null) {
      throw new MongooseError("updateMany `update` parameter cannot be nullish");
    }
    return _update(this, "updateMany", conditions, update, options);
  };
  Model.updateOne = function updateOne(conditions, doc, options) {
    _checkContext(this, "updateOne");
    return _update(this, "updateOne", conditions, doc, options);
  };
  Model.replaceOne = function replaceOne(conditions, doc, options) {
    _checkContext(this, "replaceOne");
    const versionKey = this && this.schema && this.schema.options && this.schema.options.versionKey || null;
    if (versionKey && !doc[versionKey]) {
      doc[versionKey] = 0;
    }
    return _update(this, "replaceOne", conditions, doc, options);
  };
  Model.aggregate = function aggregate(pipeline, options) {
    _checkContext(this, "aggregate");
    if (typeof options === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.aggregate() no longer accepts a callback");
    }
    const aggregate = new Aggregate(pipeline || []);
    aggregate.model(this);
    if (options != null) {
      aggregate.option(options);
    }
    return aggregate;
  };
  Model.validate = async function validate(obj, pathsOrOptions, context) {
    if (arguments.length < 3 || arguments.length === 3 && typeof arguments[2] === "function") {
      context = obj;
    }
    if (typeof context === "function" || typeof arguments[3] === "function") {
      throw new MongooseError("Model.validate() no longer accepts a callback");
    }
    let schema = this.schema;
    const discriminatorKey = schema.options.discriminatorKey;
    if (schema.discriminators != null && obj != null && obj[discriminatorKey] != null) {
      schema = getSchemaDiscriminatorByValue(schema, obj[discriminatorKey]) || schema;
    }
    let paths = Object.keys(schema.paths);
    if (pathsOrOptions != null) {
      const _pathsToValidate = typeof pathsOrOptions === "string" ? new Set(pathsOrOptions.split(" ")) : Array.isArray(pathsOrOptions) ? new Set(pathsOrOptions) : new Set(paths);
      paths = paths.filter((p) => {
        if (pathsOrOptions.pathsToSkip) {
          if (Array.isArray(pathsOrOptions.pathsToSkip)) {
            if (pathsOrOptions.pathsToSkip.find((x) => x == p)) {
              return false;
            }
          } else if (typeof pathsOrOptions.pathsToSkip == "string") {
            if (pathsOrOptions.pathsToSkip.includes(p)) {
              return false;
            }
          }
        }
        const pieces = p.split(".");
        let cur = pieces[0];
        for (const piece of pieces) {
          if (_pathsToValidate.has(cur)) {
            return true;
          }
          cur += "." + piece;
        }
        return _pathsToValidate.has(p);
      });
    }
    for (const path of paths) {
      const schemaType = schema.path(path);
      if (!schemaType || !schemaType.$isMongooseArray || schemaType.$isMongooseDocumentArray) {
        continue;
      }
      const val = get(obj, path);
      pushNestedArrayPaths(paths, val, path);
    }
    let error = null;
    paths = new Set(paths);
    try {
      obj = this.castObject(obj);
    } catch (err) {
      error = err;
      for (const key of Object.keys(error.errors || {})) {
        paths.delete(key);
      }
    }
    let remaining = paths.size;
    return new Promise((resolve, reject) => {
      for (const path of paths) {
        const schemaType = schema.path(path);
        if (schemaType == null) {
          _checkDone();
          continue;
        }
        const pieces = path.indexOf(".") === -1 ? [path] : path.split(".");
        let cur = obj;
        for (let i = 0;i < pieces.length - 1; ++i) {
          cur = cur[pieces[i]];
        }
        const val = get(obj, path, undefined);
        schemaType.doValidate(val, (err) => {
          if (err) {
            error = error || new ValidationError;
            error.addError(path, err);
          }
          _checkDone();
        }, context, { path });
      }
      function _checkDone() {
        if (--remaining <= 0) {
          if (error) {
            reject(error);
          } else {
            resolve(obj);
          }
        }
      }
    });
  };
  Model.populate = async function populate(docs, paths) {
    _checkContext(this, "populate");
    if (typeof paths === "function" || typeof arguments[2] === "function") {
      throw new MongooseError("Model.populate() no longer accepts a callback");
    }
    paths = utils.populate(paths);
    if (paths.length === 0) {
      return docs;
    }
    const promises = [];
    for (const path of paths) {
      promises.push(_populatePath(this, docs, path));
    }
    await Promise.all(promises);
    return docs;
  };
  /*!
   * Populates `docs` for a single `populateOptions` instance.
   */
  var excludeIdReg = /\s?-_id\s?/;
  var excludeIdRegGlobal = /\s?-_id\s?/g;
  /*!
   * ignore
   */
  /*!
   * ignore
   */
  Model.compile = function compile(name, schema, collectionName, connection, base) {
    const versioningEnabled = schema.options.versionKey !== false;
    if (versioningEnabled && !schema.paths[schema.options.versionKey]) {
      const o = {};
      o[schema.options.versionKey] = Number;
      schema.add(o);
    }
    let model;
    if (typeof name === "function" && name.prototype instanceof Model) {
      model = name;
      name = model.name;
      schema.loadClass(model, false);
      model.prototype.$isMongooseModelPrototype = true;
    } else {
      model = function model(doc, fields, skipId) {
        model.hooks.execPreSync("createModel", doc);
        if (!(this instanceof model)) {
          return new model(doc, fields, skipId);
        }
        const discriminatorKey = model.schema.options.discriminatorKey;
        if (model.discriminators == null || doc == null || doc[discriminatorKey] == null) {
          Model.call(this, doc, fields, skipId);
          return;
        }
        const Discriminator = model.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);
        if (Discriminator != null) {
          return new Discriminator(doc, fields, skipId);
        }
        Model.call(this, doc, fields, skipId);
      };
    }
    model.hooks = schema.s.hooks.clone();
    model.base = base;
    model.modelName = name;
    if (!(model.prototype instanceof Model)) {
      Object.setPrototypeOf(model, Model);
      Object.setPrototypeOf(model.prototype, Model.prototype);
    }
    model.model = function model(name2) {
      return this.db.model(name2);
    };
    model.db = connection;
    model.prototype.db = connection;
    model.prototype[modelDbSymbol] = connection;
    model.discriminators = model.prototype.discriminators = undefined;
    model[modelSymbol] = true;
    model.events = new EventEmitter;
    schema._preCompile();
    const _userProvidedOptions = schema._userProvidedOptions || {};
    const collectionOptions = {
      schemaUserProvidedOptions: _userProvidedOptions,
      capped: schema.options.capped,
      Promise: model.base.Promise,
      modelName: name
    };
    if (schema.options.autoCreate !== undefined) {
      collectionOptions.autoCreate = schema.options.autoCreate;
    }
    const collection = connection.collection(collectionName, collectionOptions);
    model.prototype.collection = collection;
    model.prototype.$collection = collection;
    model.prototype[modelCollectionSymbol] = collection;
    model.prototype.$__setSchema(schema);
    applyMethods(model, schema);
    applyStatics(model, schema);
    applyHooks(model, schema);
    applyStaticHooks(model, schema.s.hooks, schema.statics);
    model.schema = model.prototype.$__schema;
    model.collection = collection;
    model.$__collection = collection;
    model.Query = function() {
      Query.apply(this, arguments);
    };
    Object.setPrototypeOf(model.Query.prototype, Query.prototype);
    model.Query.base = Query.base;
    model.Query.prototype.constructor = Query;
    model._applyQueryMiddleware();
    applyQueryMethods(model, schema.query);
    return model;
  };
  Model.$__updateConnection = function $__updateConnection(newConnection) {
    this.db = newConnection;
    this.prototype.db = newConnection;
    this.prototype[modelDbSymbol] = newConnection;
    const collection = newConnection.collection(this.collection.collectionName, this.collection.opts);
    this.prototype.collection = collection;
    this.prototype.$collection = collection;
    this.prototype[modelCollectionSymbol] = collection;
    this.collection = collection;
    this.$__collection = collection;
  };
  Model.__subclass = function subclass(conn, schema, collection) {
    const _this = this;
    const Model2 = function Model(doc, fields, skipId) {
      if (!(this instanceof Model)) {
        return new Model(doc, fields, skipId);
      }
      _this.call(this, doc, fields, skipId);
    };
    Object.setPrototypeOf(Model2, _this);
    Object.setPrototypeOf(Model2.prototype, _this.prototype);
    Model2.db = conn;
    Model2.prototype.db = conn;
    Model2.prototype[modelDbSymbol] = conn;
    _this[subclassedSymbol] = _this[subclassedSymbol] || [];
    _this[subclassedSymbol].push(Model2);
    if (_this.discriminators != null) {
      Model2.discriminators = {};
      for (const key of Object.keys(_this.discriminators)) {
        Model2.discriminators[key] = _this.discriminators[key].__subclass(_this.db, _this.discriminators[key].schema, collection);
      }
    }
    const s = schema && typeof schema !== "string" ? schema : _this.prototype.$__schema;
    const options = s.options || {};
    const _userProvidedOptions = s._userProvidedOptions || {};
    if (!collection) {
      collection = _this.prototype.$__schema.get("collection") || utils.toCollectionName(_this.modelName, this.base.pluralize());
    }
    const collectionOptions = {
      schemaUserProvidedOptions: _userProvidedOptions,
      capped: s && options.capped
    };
    Model2.prototype.collection = conn.collection(collection, collectionOptions);
    Model2.prototype.$collection = Model2.prototype.collection;
    Model2.prototype[modelCollectionSymbol] = Model2.prototype.collection;
    Model2.collection = Model2.prototype.collection;
    Model2.$__collection = Model2.collection;
    Model2.init().catch(() => {
    });
    return Model2;
  };
  Model.recompileSchema = function recompileSchema() {
    this.prototype.$__setSchema(this.schema);
    if (this.schema._applyDiscriminators != null) {
      for (const disc of this.schema._applyDiscriminators.keys()) {
        this.discriminator(disc, this.schema._applyDiscriminators.get(disc));
      }
    }
    delete this.schema._defaultToObjectOptionsMap;
    applyEmbeddedDiscriminators(this.schema, new WeakSet, true);
  };
  Model.inspect = function() {
    return `Model { ${this.modelName} }`;
  };
  Model.namespace = function namespace() {
    return this.db.name + "." + this.collection.collectionName;
  };
  if (util.inspect.custom) {
    Model[util.inspect.custom] = Model.inspect;
  }
  /*!
   * Applies query middleware from this model's schema to this model's
   * Query constructor.
   */
  Model._applyQueryMiddleware = function _applyQueryMiddleware() {
    const Query2 = this.Query;
    const queryMiddleware = this.schema.s.hooks.filter((hook) => {
      const contexts = _getContexts(hook);
      if (hook.name === "validate") {
        return !!contexts.query;
      }
      if (hook.name === "deleteOne" || hook.name === "updateOne") {
        return !!contexts.query || Object.keys(contexts).length === 0;
      }
      if (hook.query != null || hook.document != null) {
        return !!hook.query;
      }
      return true;
    });
    Query2.prototype._queryMiddleware = queryMiddleware;
  };
  /*!
   * Module exports.
   */
  module.exports = exports = Model;
});

// node_modules/mongoose/lib/helpers/pluralize.js
var require_pluralize = __commonJS((exports, module) => {
  function pluralize(str) {
    let found;
    str = str.toLowerCase();
    if (!~uncountables.indexOf(str)) {
      found = rules.filter(function(rule) {
        return str.match(rule[0]);
      });
      if (found[0]) {
        return str.replace(found[0][0], found[0][1]);
      }
    }
    return str;
  }
  module.exports = pluralize;
  exports.pluralization = [
    [/human$/gi, "humans"],
    [/(m)an$/gi, "$1en"],
    [/(pe)rson$/gi, "$1ople"],
    [/(child)$/gi, "$1ren"],
    [/^(ox)$/gi, "$1en"],
    [/(ax|test)is$/gi, "$1es"],
    [/(octop|vir)us$/gi, "$1i"],
    [/(alias|status)$/gi, "$1es"],
    [/(bu)s$/gi, "$1ses"],
    [/(buffal|tomat|potat)o$/gi, "$1oes"],
    [/([ti])um$/gi, "$1a"],
    [/sis$/gi, "ses"],
    [/(?:([^f])fe|([lr])f)$/gi, "$1$2ves"],
    [/(hive)$/gi, "$1s"],
    [/([^aeiouy]|qu)y$/gi, "$1ies"],
    [/(x|ch|ss|sh)$/gi, "$1es"],
    [/(matr|vert|ind)ix|ex$/gi, "$1ices"],
    [/([m|l])ouse$/gi, "$1ice"],
    [/(kn|w|l)ife$/gi, "$1ives"],
    [/(quiz)$/gi, "$1zes"],
    [/^goose$/i, "geese"],
    [/s$/gi, "s"],
    [/([^a-z])$/, "$1"],
    [/$/gi, "s"]
  ];
  var rules = exports.pluralization;
  exports.uncountables = [
    "advice",
    "energy",
    "excretion",
    "digestion",
    "cooperation",
    "health",
    "justice",
    "labour",
    "machinery",
    "equipment",
    "information",
    "pollution",
    "sewage",
    "paper",
    "money",
    "species",
    "series",
    "rain",
    "rice",
    "fish",
    "sheep",
    "moose",
    "deer",
    "news",
    "expertise",
    "status",
    "media"
  ];
  var uncountables = exports.uncountables;
});

// node_modules/mongoose/lib/error/setOptionError.js
var require_setOptionError = __commonJS((exports, module) => {
  /*!
   * Module requirements
   */
  var MongooseError = require_mongooseError();
  var util = import.meta.require("util");
  var combinePathErrors = require_combinePathErrors();

  class SetOptionError extends MongooseError {
    constructor() {
      super("");
      this.errors = {};
    }
    toString() {
      return combinePathErrors(this);
    }
    inspect() {
      return Object.assign(new Error(this.message), this);
    }
    addError(key, error) {
      if (error instanceof SetOptionError) {
        const { errors } = error;
        for (const optionKey of Object.keys(errors)) {
          this.addError(optionKey, errors[optionKey]);
        }
        return;
      }
      this.errors[key] = error;
      this.message = combinePathErrors(this);
    }
  }
  if (util.inspect.custom) {
    SetOptionError.prototype[util.inspect.custom] = SetOptionError.prototype.inspect;
  }
  Object.defineProperty(SetOptionError.prototype, "toJSON", {
    enumerable: false,
    writable: false,
    configurable: true,
    value: function() {
      return Object.assign({}, this, { name: this.name, message: this.message });
    }
  });
  Object.defineProperty(SetOptionError.prototype, "name", {
    value: "SetOptionError"
  });

  class SetOptionInnerError extends MongooseError {
    constructor(key) {
      super(`"${key}" is not a valid option to set`);
    }
  }
  SetOptionError.SetOptionInnerError = SetOptionInnerError;
  /*!
   * Module exports
   */
  module.exports = SetOptionError;
});

// node_modules/mongoose/lib/helpers/printJestWarning.js
var require_printJestWarning = __commonJS(() => {
  var utils = require_utils4();
  if (typeof jest !== "undefined" && !process.env.SUPPRESS_JEST_WARNINGS) {
    if (typeof window !== "undefined") {
      utils.warn("Mongoose: looks like you\'re trying to test a Mongoose app " + "with Jest\'s default jsdom test environment. Please make sure you read " + "Mongoose\'s docs on configuring Jest to test Node.js apps: " + "https://mongoosejs.com/docs/jest.html. Set the SUPPRESS_JEST_WARNINGS to true " + "to hide this warning.");
    }
    if (setTimeout.clock != null && typeof setTimeout.clock.Date === "function") {
      utils.warn("Mongoose: looks like you\'re trying to test a Mongoose app " + "with Jest\'s mock timers enabled. Please make sure you read " + "Mongoose\'s docs on configuring Jest to test Node.js apps: " + "https://mongoosejs.com/docs/jest.html. Set the SUPPRESS_JEST_WARNINGS to true " + "to hide this warning.");
    }
  }
});

// node_modules/mongoose/lib/browserDocument.js
var require_browserDocument = __commonJS((exports, module) => {
  function Document(obj, schema, fields, skipId, skipInit) {
    if (!(this instanceof Document)) {
      return new Document(obj, schema, fields, skipId, skipInit);
    }
    if (isObject(schema) && !schema.instanceOfSchema) {
      schema = new Schema(schema);
    }
    schema = this.schema || schema;
    if (!this.schema && schema.options._id) {
      obj = obj || {};
      if (obj._id === undefined) {
        obj._id = new ObjectId2;
      }
    }
    if (!schema) {
      throw new MongooseError.MissingSchemaError;
    }
    this.$__setSchema(schema);
    NodeJSDocument.call(this, obj, fields, skipId, skipInit);
    applyHooks(this, schema, { decorateDoc: true });
    for (const m in schema.methods) {
      this[m] = schema.methods[m];
    }
    for (const s in schema.statics) {
      this[s] = schema.statics[s];
    }
  }
  /*!
   * Module dependencies.
   */
  var NodeJSDocument = require_document2();
  var EventEmitter = import.meta.require("events").EventEmitter;
  var MongooseError = require_error2();
  var Schema = require_schema2();
  var ObjectId2 = require_objectid();
  var ValidationError = MongooseError.ValidationError;
  var applyHooks = require_applyHooks();
  var isObject = require_isObject2();
  /*!
   * Inherit from the NodeJS document
   */
  Document.prototype = Object.create(NodeJSDocument.prototype);
  Document.prototype.constructor = Document;
  /*!
   * ignore
   */
  Document.events = new EventEmitter;
  /*!
   * Browser doc exposes the event emitter API
   */
  Document.$emitter = new EventEmitter;
  [
    "on",
    "once",
    "emit",
    "listeners",
    "removeListener",
    "setMaxListeners",
    "removeAllListeners",
    "addListener"
  ].forEach(function(emitterFn) {
    Document[emitterFn] = function() {
      return Document.$emitter[emitterFn].apply(Document.$emitter, arguments);
    };
  });
  /*!
   * Module exports.
   */
  Document.ValidationError = ValidationError;
  module.exports = exports = Document;
});

// node_modules/mongoose/lib/documentProvider.js
var require_documentProvider = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var Document = require_document2();
  var BrowserDocument = require_browserDocument();
  var isBrowser = false;
  module.exports = function documentProvider() {
    if (isBrowser) {
      return BrowserDocument;
    }
    return Document;
  };
  /*!
   * ignore
   */
  module.exports.setBrowser = function(flag) {
    isBrowser = flag;
  };
});

// node_modules/mongoose/lib/mongoose.js
var require_mongoose = __commonJS((exports, module) => {
  function Mongoose(options) {
    this.connections = [];
    this.nextConnectionId = 0;
    this.models = {};
    this.events = new EventEmitter;
    this.__driver = driver.get();
    this.options = Object.assign({
      pluralization: true,
      autoIndex: true,
      autoCreate: true,
      autoSearchIndex: false
    }, options);
    const createInitialConnection = utils.getOption("createInitialConnection", this.options) ?? true;
    if (createInitialConnection && this.__driver != null) {
      _createDefaultConnection(this);
    }
    if (this.options.pluralization) {
      this._pluralize = legacyPluralize;
    }
    if (!options || !options[defaultMongooseSymbol]) {
      const _this = this;
      this.Schema = function() {
        this.base = _this;
        return Schema.apply(this, arguments);
      };
      this.Schema.prototype = Object.create(Schema.prototype);
      Object.assign(this.Schema, Schema);
      this.Schema.base = this;
      this.Schema.Types = Object.assign({}, Schema.Types);
    } else {
      for (const key of ["Schema", "model"]) {
        this[key] = Mongoose.prototype[key];
      }
    }
    this.Schema.prototype.base = this;
    if (options?.transactionAsyncLocalStorage) {
      this.transactionAsyncLocalStorage = new AsyncLocalStorage;
    }
    Object.defineProperty(this, "plugins", {
      configurable: false,
      enumerable: true,
      writable: false,
      value: Object.values(builtinPlugins).map((plugin) => [plugin, { deduplicate: true }])
    });
  }
  function _createDefaultConnection(mongoose2) {
    if (mongoose2.connection) {
      return;
    }
    const conn = mongoose2.createConnection();
    conn[defaultConnectionSymbol] = true;
    conn.models = mongoose2.models;
  }
  /*!
   * Module dependencies.
   */
  var Document = require_document2();
  var EventEmitter = import.meta.require("events").EventEmitter;
  var Kareem = require_kareem();
  var Schema = require_schema2();
  var SchemaType = require_schemaType();
  var SchemaTypes = require_schema();
  var VirtualType = require_virtualType();
  var STATES = require_connectionState();
  var VALID_OPTIONS = require_validOptions();
  var Types = require_types();
  var Query = require_query();
  var Model = require_model();
  var applyPlugins = require_applyPlugins();
  var builtinPlugins = require_plugins();
  var driver = require_driver();
  var legacyPluralize = require_pluralize();
  var utils = require_utils4();
  var pkg = require_package3();
  var cast = require_cast2();
  var Aggregate = require_aggregate2();
  var trusted = require_trusted().trusted;
  var sanitizeFilter = require_sanitizeFilter();
  var isBsonType = require_isBsonType();
  var MongooseError = require_mongooseError();
  var SetOptionError = require_setOptionError();
  var applyEmbeddedDiscriminators = require_applyEmbeddedDiscriminators();
  var defaultMongooseSymbol = Symbol.for("mongoose:default");
  var defaultConnectionSymbol = Symbol("mongoose:defaultConnection");
  require_printJestWarning();
  var objectIdHexRegexp = /^[0-9A-Fa-f]{24}$/;
  var { AsyncLocalStorage } = import.meta.require("async_hooks");
  Mongoose.prototype.cast = cast;
  Mongoose.prototype.STATES = STATES;
  Mongoose.prototype.ConnectionStates = STATES;
  Mongoose.prototype.driver = driver;
  Mongoose.prototype.setDriver = function setDriver(driver2) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    if (_mongoose.__driver === driver2) {
      return _mongoose;
    }
    const openConnection = _mongoose.connections && _mongoose.connections.find((conn) => conn.readyState !== STATES.disconnected);
    if (openConnection) {
      const msg = "Cannot modify Mongoose driver if a connection is already open. " + "Call `mongoose.disconnect()` before modifying the driver";
      throw new MongooseError(msg);
    }
    _mongoose.__driver = driver2;
    if (Array.isArray(driver2.plugins)) {
      for (const plugin of driver2.plugins) {
        if (typeof plugin === "function") {
          _mongoose.plugin(plugin);
        }
      }
    }
    const Connection = driver2.Connection;
    const oldDefaultConnection = _mongoose.connections[0];
    _mongoose.connections = [new Connection(_mongoose)];
    _mongoose.connections[0].models = _mongoose.models;
    if (oldDefaultConnection == null) {
      return _mongoose;
    }
    for (const model of Object.values(_mongoose.models)) {
      if (model.db !== oldDefaultConnection) {
        continue;
      }
      model.$__updateConnection(_mongoose.connections[0]);
    }
    return _mongoose;
  };
  Mongoose.prototype.set = function getsetOptions(key, value) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    if (arguments.length === 1 && typeof key !== "object") {
      if (VALID_OPTIONS.indexOf(key) === -1) {
        const error2 = new SetOptionError;
        error2.addError(key, new SetOptionError.SetOptionInnerError(key));
        throw error2;
      }
      return _mongoose.options[key];
    }
    let options = {};
    if (arguments.length === 2) {
      options = { [key]: value };
    }
    if (arguments.length === 1 && typeof key === "object") {
      options = key;
    }
    let error = undefined;
    for (const [optionKey, optionValue] of Object.entries(options)) {
      if (VALID_OPTIONS.indexOf(optionKey) === -1) {
        if (!error) {
          error = new SetOptionError;
        }
        error.addError(optionKey, new SetOptionError.SetOptionInnerError(optionKey));
        continue;
      }
      _mongoose.options[optionKey] = optionValue;
      if (optionKey === "objectIdGetter") {
        if (optionValue) {
          Object.defineProperty(_mongoose.Types.ObjectId.prototype, "_id", {
            enumerable: false,
            configurable: true,
            get: function() {
              return this;
            }
          });
        } else {
          delete _mongoose.Types.ObjectId.prototype._id;
        }
      } else if (optionKey === "transactionAsyncLocalStorage") {
        if (optionValue && !_mongoose.transactionAsyncLocalStorage) {
          _mongoose.transactionAsyncLocalStorage = new AsyncLocalStorage;
        } else if (!optionValue && _mongoose.transactionAsyncLocalStorage) {
          delete _mongoose.transactionAsyncLocalStorage;
        }
      } else if (optionKey === "createInitialConnection") {
        if (optionValue && !_mongoose.connection) {
          _createDefaultConnection(_mongoose);
        } else if (optionValue === false && _mongoose.connection && _mongoose.connection[defaultConnectionSymbol]) {
          if (_mongoose.connection.readyState === STATES.disconnected && Object.keys(_mongoose.connection.models).length === 0) {
            _mongoose.connections.shift();
          }
        }
      }
    }
    if (error) {
      throw error;
    }
    return _mongoose;
  };
  Mongoose.prototype.get = Mongoose.prototype.set;
  Mongoose.prototype.createConnection = function createConnection(uri, options) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    const Connection = _mongoose.__driver.Connection;
    const conn = new Connection(_mongoose);
    _mongoose.connections.push(conn);
    _mongoose.nextConnectionId++;
    _mongoose.events.emit("createConnection", conn);
    if (arguments.length > 0) {
      conn.openUri(uri, { ...options, _fireAndForget: true });
    }
    return conn;
  };
  Mongoose.prototype.connect = async function connect(uri, options) {
    if (typeof options === "function" || arguments.length >= 3 && typeof arguments[2] === "function") {
      throw new MongooseError("Mongoose.prototype.connect() no longer accepts a callback");
    }
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    if (_mongoose.connection == null) {
      _createDefaultConnection(_mongoose);
    }
    const conn = _mongoose.connection;
    return conn.openUri(uri, options).then(() => _mongoose);
  };
  Mongoose.prototype.disconnect = async function disconnect() {
    if (arguments.length >= 1 && typeof arguments[0] === "function") {
      throw new MongooseError("Mongoose.prototype.disconnect() no longer accepts a callback");
    }
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    const remaining = _mongoose.connections.length;
    if (remaining <= 0) {
      return;
    }
    await Promise.all(_mongoose.connections.map((conn) => conn.close()));
  };
  Mongoose.prototype.startSession = function startSession() {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    return _mongoose.connection.startSession.apply(_mongoose.connection, arguments);
  };
  Mongoose.prototype.pluralize = function pluralize(fn) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    if (arguments.length > 0) {
      _mongoose._pluralize = fn;
    }
    return _mongoose._pluralize;
  };
  Mongoose.prototype.model = function model(name, schema, collection, options) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    if (typeof schema === "string") {
      collection = schema;
      schema = false;
    }
    if (arguments.length === 1) {
      const model2 = _mongoose.models[name];
      if (!model2) {
        throw new _mongoose.Error.MissingSchemaError(name);
      }
      return model2;
    }
    if (utils.isObject(schema) && !(schema instanceof Schema)) {
      schema = new Schema(schema);
    }
    if (schema && !(schema instanceof Schema)) {
      throw new _mongoose.Error("The 2nd parameter to `mongoose.model()` should be a " + "schema or a POJO");
    }
    options = options || {};
    const originalSchema = schema;
    if (schema) {
      if (_mongoose.get("cloneSchemas")) {
        schema = schema.clone();
      }
      _mongoose._applyPlugins(schema);
    }
    const overwriteModels = _mongoose.options.hasOwnProperty("overwriteModels") ? _mongoose.options.overwriteModels : options.overwriteModels;
    if (_mongoose.models.hasOwnProperty(name) && options.cache !== false && overwriteModels !== true) {
      if (originalSchema && originalSchema.instanceOfSchema && originalSchema !== _mongoose.models[name].schema) {
        throw new _mongoose.Error.OverwriteModelError(name);
      }
      if (collection && collection !== _mongoose.models[name].collection.name) {
        const model2 = _mongoose.models[name];
        schema = model2.prototype.schema;
        const sub = model2.__subclass(_mongoose.connection, schema, collection);
        return sub;
      }
      return _mongoose.models[name];
    }
    if (schema == null) {
      throw new _mongoose.Error.MissingSchemaError(name);
    }
    const model = _mongoose._model(name, schema, collection, options);
    _mongoose.connection.models[name] = model;
    _mongoose.models[name] = model;
    return model;
  };
  /*!
   * ignore
   */
  Mongoose.prototype._model = function _model(name, schema, collection, options) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    let model;
    if (typeof name === "function") {
      model = name;
      name = model.name;
      if (!(model.prototype instanceof Model)) {
        throw new _mongoose.Error("The provided class " + name + " must extend Model");
      }
    }
    if (schema) {
      if (_mongoose.get("cloneSchemas")) {
        schema = schema.clone();
      }
      _mongoose._applyPlugins(schema);
    }
    if (schema == null || !("pluralization" in schema.options)) {
      schema.options.pluralization = _mongoose.options.pluralization;
    }
    if (!collection) {
      collection = schema.get("collection") || utils.toCollectionName(name, _mongoose.pluralize());
    }
    applyEmbeddedDiscriminators(schema);
    const connection = options.connection || _mongoose.connection;
    model = _mongoose.Model.compile(model || name, schema, collection, connection, _mongoose);
    model.init().catch(function $modelInitNoop() {
    });
    connection.emit("model", model);
    if (schema._applyDiscriminators != null) {
      for (const disc of schema._applyDiscriminators.keys()) {
        const {
          schema: discriminatorSchema,
          options: options2
        } = schema._applyDiscriminators.get(disc);
        model.discriminator(disc, discriminatorSchema, options2);
      }
    }
    return model;
  };
  Mongoose.prototype.deleteModel = function deleteModel(name) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    _mongoose.connection.deleteModel(name);
    delete _mongoose.models[name];
    return _mongoose;
  };
  Mongoose.prototype.modelNames = function modelNames() {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    const names = Object.keys(_mongoose.models);
    return names;
  };
  Mongoose.prototype._applyPlugins = function _applyPlugins(schema, options) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    options = options || {};
    options.applyPluginsToDiscriminators = _mongoose.options && _mongoose.options.applyPluginsToDiscriminators || false;
    options.applyPluginsToChildSchemas = typeof (_mongoose.options && _mongoose.options.applyPluginsToChildSchemas) === "boolean" ? _mongoose.options.applyPluginsToChildSchemas : true;
    applyPlugins(schema, _mongoose.plugins, options, "$globalPluginsApplied");
  };
  Mongoose.prototype.plugin = function plugin(fn, opts) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    _mongoose.plugins.push([fn, opts]);
    return _mongoose;
  };
  Mongoose.prototype.__defineGetter__("connection", function() {
    return this.connections[0];
  });
  Mongoose.prototype.__defineSetter__("connection", function(v) {
    if (v instanceof this.__driver.Connection) {
      this.connections[0] = v;
      this.models = v.models;
    }
  });
  Mongoose.prototype.connections;
  Mongoose.prototype.nextConnectionId;
  Mongoose.prototype.Aggregate = Aggregate;
  Object.defineProperty(Mongoose.prototype, "Collection", {
    get: function() {
      return this.__driver.Collection;
    },
    set: function(Collection) {
      this.__driver.Collection = Collection;
    }
  });
  Object.defineProperty(Mongoose.prototype, "Connection", {
    get: function() {
      return this.__driver.Connection;
    },
    set: function(Connection) {
      if (Connection === this.__driver.Connection) {
        return;
      }
      this.__driver.Connection = Connection;
    }
  });
  Mongoose.prototype.version = pkg.version;
  Mongoose.prototype.Mongoose = Mongoose;
  Mongoose.prototype.Schema = Schema;
  Mongoose.prototype.SchemaType = SchemaType;
  Mongoose.prototype.SchemaTypes = Schema.Types;
  Mongoose.prototype.VirtualType = VirtualType;
  Mongoose.prototype.Types = Types;
  Mongoose.prototype.Query = Query;
  Mongoose.prototype.Model = Model;
  Mongoose.prototype.Document = Document;
  Mongoose.prototype.DocumentProvider = require_documentProvider();
  Mongoose.prototype.ObjectId = SchemaTypes.ObjectId;
  Mongoose.prototype.isValidObjectId = function isValidObjectId(v) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    return _mongoose.Types.ObjectId.isValid(v);
  };
  Mongoose.prototype.isObjectIdOrHexString = function isObjectIdOrHexString(v) {
    return isBsonType(v, "ObjectId") || typeof v === "string" && objectIdHexRegexp.test(v);
  };
  Mongoose.prototype.syncIndexes = function syncIndexes(options) {
    const _mongoose = this instanceof Mongoose ? this : mongoose;
    return _mongoose.connection.syncIndexes(options);
  };
  Mongoose.prototype.Decimal128 = SchemaTypes.Decimal128;
  Mongoose.prototype.Mixed = SchemaTypes.Mixed;
  Mongoose.prototype.Date = SchemaTypes.Date;
  Mongoose.prototype.Number = SchemaTypes.Number;
  Mongoose.prototype.Error = MongooseError;
  Mongoose.prototype.MongooseError = MongooseError;
  Mongoose.prototype.now = function now() {
    return new Date;
  };
  Mongoose.prototype.CastError = MongooseError.CastError;
  Mongoose.prototype.SchemaTypeOptions = require_schemaTypeOptions();
  Mongoose.prototype.mquery = require_mquery();
  Mongoose.prototype.sanitizeFilter = sanitizeFilter;
  Mongoose.prototype.trusted = trusted;
  Mongoose.prototype.skipMiddlewareFunction = Kareem.skipWrappedFunction;
  Mongoose.prototype.overwriteMiddlewareResult = Kareem.overwriteResult;
  Mongoose.prototype.omitUndefined = require_omitUndefined();
  /*!
   * Create a new default connection (`mongoose.connection`) for a Mongoose instance.
   * No-op if there is already a default connection.
   */
  var mongoose = module.exports = exports = new Mongoose({
    [defaultMongooseSymbol]: true
  });
});

// node_modules/mongoose/lib/index.js
var require_lib6 = __commonJS((exports, module) => {
  /*!
   * Module dependencies.
   */
  var mongodbDriver = require_node_mongodb_native();
  require_driver().set(mongodbDriver);
  var mongoose = require_mongoose();
  mongoose.setDriver(mongodbDriver);
  mongoose.Mongoose.prototype.mongo = require_lib3();
  module.exports = mongoose;
});

// node_modules/mongoose/index.js
var require_mongoose2 = __commonJS((exports, module) => {
  var mongoose = require_lib6();
  module.exports = mongoose;
  module.exports.default = mongoose;
  module.exports.mongoose = mongoose;
  module.exports.cast = mongoose.cast;
  module.exports.STATES = mongoose.STATES;
  module.exports.setDriver = mongoose.setDriver;
  module.exports.set = mongoose.set;
  module.exports.get = mongoose.get;
  module.exports.createConnection = mongoose.createConnection;
  module.exports.connect = mongoose.connect;
  module.exports.disconnect = mongoose.disconnect;
  module.exports.startSession = mongoose.startSession;
  module.exports.pluralize = mongoose.pluralize;
  module.exports.model = mongoose.model;
  module.exports.deleteModel = mongoose.deleteModel;
  module.exports.modelNames = mongoose.modelNames;
  module.exports.plugin = mongoose.plugin;
  module.exports.connections = mongoose.connections;
  module.exports.version = mongoose.version;
  module.exports.Aggregate = mongoose.Aggregate;
  module.exports.Mongoose = mongoose.Mongoose;
  module.exports.Schema = mongoose.Schema;
  module.exports.SchemaType = mongoose.SchemaType;
  module.exports.SchemaTypes = mongoose.SchemaTypes;
  module.exports.VirtualType = mongoose.VirtualType;
  module.exports.Types = mongoose.Types;
  module.exports.Query = mongoose.Query;
  module.exports.Model = mongoose.Model;
  module.exports.Document = mongoose.Document;
  module.exports.ObjectId = mongoose.ObjectId;
  module.exports.isValidObjectId = mongoose.isValidObjectId;
  module.exports.isObjectIdOrHexString = mongoose.isObjectIdOrHexString;
  module.exports.syncIndexes = mongoose.syncIndexes;
  module.exports.Decimal128 = mongoose.Decimal128;
  module.exports.Mixed = mongoose.Mixed;
  module.exports.Date = mongoose.Date;
  module.exports.Number = mongoose.Number;
  module.exports.Error = mongoose.Error;
  module.exports.MongooseError = mongoose.MongooseError;
  module.exports.now = mongoose.now;
  module.exports.CastError = mongoose.CastError;
  module.exports.SchemaTypeOptions = mongoose.SchemaTypeOptions;
  module.exports.mongo = mongoose.mongo;
  module.exports.mquery = mongoose.mquery;
  module.exports.sanitizeFilter = mongoose.sanitizeFilter;
  module.exports.trusted = mongoose.trusted;
  module.exports.skipMiddlewareFunction = mongoose.skipMiddlewareFunction;
  module.exports.overwriteMiddlewareResult = mongoose.overwriteMiddlewareResult;
});

// node_modules/is-base64/is-base64.js
var require_is_base64 = __commonJS((exports, module) => {
  (function(root) {
    function isBase64(v, opts) {
      if (v instanceof Boolean || typeof v === "boolean") {
        return false;
      }
      if (!(opts instanceof Object)) {
        opts = {};
      }
      if (opts.allowEmpty === false && v === "") {
        return false;
      }
      var regex = "(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+/]{3}=)?";
      var mimeRegex = "(data:\\w+\\/[a-zA-Z\\+\\-\\.]+;base64,)";
      if (opts.mimeRequired === true) {
        regex = mimeRegex + regex;
      } else if (opts.allowMime === true) {
        regex = mimeRegex + "?" + regex;
      }
      if (opts.paddingRequired === false) {
        regex = "(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?";
      }
      return new RegExp("^" + regex + "$", "gi").test(v);
    }
    if (typeof exports !== "undefined") {
      if (typeof module !== "undefined" && module.exports) {
        exports = module.exports = isBase64;
      }
      exports.isBase64 = isBase64;
    } else if (typeof define === "function" && define.amd) {
      define([], function() {
        return isBase64;
      });
    } else {
      root.isBase64 = isBase64;
    }
  })(exports);
});

// node_modules/nodemailer/lib/fetch/cookies.js
var require_cookies = __commonJS((exports, module) => {
  var urllib = import.meta.require("url");
  var SESSION_TIMEOUT = 1800;

  class Cookies {
    constructor(options) {
      this.options = options || {};
      this.cookies = [];
    }
    set(cookieStr, url) {
      let urlparts = urllib.parse(url || "");
      let cookie = this.parse(cookieStr);
      let domain;
      if (cookie.domain) {
        domain = cookie.domain.replace(/^\./, "");
        if (urlparts.hostname.length < domain.length || ("." + urlparts.hostname).substr(-domain.length + 1) !== "." + domain) {
          cookie.domain = urlparts.hostname;
        }
      } else {
        cookie.domain = urlparts.hostname;
      }
      if (!cookie.path) {
        cookie.path = this.getPath(urlparts.pathname);
      }
      if (!cookie.expires) {
        cookie.expires = new Date(Date.now() + (Number(this.options.sessionTimeout || SESSION_TIMEOUT) || SESSION_TIMEOUT) * 1000);
      }
      return this.add(cookie);
    }
    get(url) {
      return this.list(url).map((cookie) => cookie.name + "=" + cookie.value).join("; ");
    }
    list(url) {
      let result = [];
      let i;
      let cookie;
      for (i = this.cookies.length - 1;i >= 0; i--) {
        cookie = this.cookies[i];
        if (this.isExpired(cookie)) {
          this.cookies.splice(i, i);
          continue;
        }
        if (this.match(cookie, url)) {
          result.unshift(cookie);
        }
      }
      return result;
    }
    parse(cookieStr) {
      let cookie = {};
      (cookieStr || "").toString().split(";").forEach((cookiePart) => {
        let valueParts = cookiePart.split("=");
        let key = valueParts.shift().trim().toLowerCase();
        let value = valueParts.join("=").trim();
        let domain;
        if (!key) {
          return;
        }
        switch (key) {
          case "expires":
            value = new Date(value);
            if (value.toString() !== "Invalid Date") {
              cookie.expires = value;
            }
            break;
          case "path":
            cookie.path = value;
            break;
          case "domain":
            domain = value.toLowerCase();
            if (domain.length && domain.charAt(0) !== ".") {
              domain = "." + domain;
            }
            cookie.domain = domain;
            break;
          case "max-age":
            cookie.expires = new Date(Date.now() + (Number(value) || 0) * 1000);
            break;
          case "secure":
            cookie.secure = true;
            break;
          case "httponly":
            cookie.httponly = true;
            break;
          default:
            if (!cookie.name) {
              cookie.name = key;
              cookie.value = value;
            }
        }
      });
      return cookie;
    }
    match(cookie, url) {
      let urlparts = urllib.parse(url || "");
      if (urlparts.hostname !== cookie.domain && (cookie.domain.charAt(0) !== "." || ("." + urlparts.hostname).substr(-cookie.domain.length) !== cookie.domain)) {
        return false;
      }
      let path = this.getPath(urlparts.pathname);
      if (path.substr(0, cookie.path.length) !== cookie.path) {
        return false;
      }
      if (cookie.secure && urlparts.protocol !== "https:") {
        return false;
      }
      return true;
    }
    add(cookie) {
      let i;
      let len;
      if (!cookie || !cookie.name) {
        return false;
      }
      for (i = 0, len = this.cookies.length;i < len; i++) {
        if (this.compare(this.cookies[i], cookie)) {
          if (this.isExpired(cookie)) {
            this.cookies.splice(i, 1);
            return false;
          }
          this.cookies[i] = cookie;
          return true;
        }
      }
      if (!this.isExpired(cookie)) {
        this.cookies.push(cookie);
      }
      return true;
    }
    compare(a, b) {
      return a.name === b.name && a.path === b.path && a.domain === b.domain && a.secure === b.secure && a.httponly === a.httponly;
    }
    isExpired(cookie) {
      return cookie.expires && cookie.expires < new Date || !cookie.value;
    }
    getPath(pathname) {
      let path = (pathname || "/").split("/");
      path.pop();
      path = path.join("/").trim();
      if (path.charAt(0) !== "/") {
        path = "/" + path;
      }
      if (path.substr(-1) !== "/") {
        path += "/";
      }
      return path;
    }
  }
  module.exports = Cookies;
});

// node_modules/nodemailer/package.json
var require_package4 = __commonJS((exports, module) => {
  module.exports = {
    name: "nodemailer",
    version: "6.10.0",
    description: "Easy as cake e-mail sending from your Node.js applications",
    main: "lib/nodemailer.js",
    scripts: {
      test: "node --test --test-concurrency=1 test/**/*.test.js test/**/*-test.js",
      "test:coverage": "c8 node --test --test-concurrency=1 test/**/*.test.js test/**/*-test.js",
      lint: "eslint .",
      update: "rm -rf node_modules/ package-lock.json && ncu -u && npm install"
    },
    repository: {
      type: "git",
      url: "https://github.com/nodemailer/nodemailer.git"
    },
    keywords: [
      "Nodemailer"
    ],
    author: "Andris Reinman",
    license: "MIT-0",
    bugs: {
      url: "https://github.com/nodemailer/nodemailer/issues"
    },
    homepage: "https://nodemailer.com/",
    devDependencies: {
      "@aws-sdk/client-ses": "3.731.1",
      bunyan: "1.8.15",
      c8: "10.1.3",
      eslint: "8.57.0",
      "eslint-config-nodemailer": "1.2.0",
      "eslint-config-prettier": "9.1.0",
      libbase64: "1.3.0",
      libmime: "5.3.6",
      libqp: "2.1.1",
      "nodemailer-ntlm-auth": "1.0.4",
      proxy: "1.0.2",
      "proxy-test-server": "1.0.0",
      "smtp-server": "3.13.6"
    },
    engines: {
      node: ">=6.0.0"
    }
  };
});

// node_modules/nodemailer/lib/fetch/index.js
var require_fetch = __commonJS((exports, module) => {
  function nmfetch(url, options) {
    options = options || {};
    options.fetchRes = options.fetchRes || new PassThrough;
    options.cookies = options.cookies || new Cookies;
    options.redirects = options.redirects || 0;
    options.maxRedirects = isNaN(options.maxRedirects) ? MAX_REDIRECTS : options.maxRedirects;
    if (options.cookie) {
      [].concat(options.cookie || []).forEach((cookie) => {
        options.cookies.set(cookie, url);
      });
      options.cookie = false;
    }
    let fetchRes = options.fetchRes;
    let parsed = urllib.parse(url);
    let method = (options.method || "").toString().trim().toUpperCase() || "GET";
    let finished = false;
    let cookies;
    let body;
    let handler = parsed.protocol === "https:" ? https : http;
    let headers = {
      "accept-encoding": "gzip,deflate",
      "user-agent": "nodemailer/" + packageData.version
    };
    Object.keys(options.headers || {}).forEach((key) => {
      headers[key.toLowerCase().trim()] = options.headers[key];
    });
    if (options.userAgent) {
      headers["user-agent"] = options.userAgent;
    }
    if (parsed.auth) {
      headers.Authorization = "Basic " + Buffer.from(parsed.auth).toString("base64");
    }
    if (cookies = options.cookies.get(url)) {
      headers.cookie = cookies;
    }
    if (options.body) {
      if (options.contentType !== false) {
        headers["Content-Type"] = options.contentType || "application/x-www-form-urlencoded";
      }
      if (typeof options.body.pipe === "function") {
        headers["Transfer-Encoding"] = "chunked";
        body = options.body;
        body.on("error", (err) => {
          if (finished) {
            return;
          }
          finished = true;
          err.type = "FETCH";
          err.sourceUrl = url;
          fetchRes.emit("error", err);
        });
      } else {
        if (options.body instanceof Buffer) {
          body = options.body;
        } else if (typeof options.body === "object") {
          try {
            body = Buffer.from(Object.keys(options.body).map((key) => {
              let value = options.body[key].toString().trim();
              return encodeURIComponent(key) + "=" + encodeURIComponent(value);
            }).join("&"));
          } catch (E) {
            if (finished) {
              return;
            }
            finished = true;
            E.type = "FETCH";
            E.sourceUrl = url;
            fetchRes.emit("error", E);
            return;
          }
        } else {
          body = Buffer.from(options.body.toString().trim());
        }
        headers["Content-Type"] = options.contentType || "application/x-www-form-urlencoded";
        headers["Content-Length"] = body.length;
      }
      method = (options.method || "").toString().trim().toUpperCase() || "POST";
    }
    let req;
    let reqOptions = {
      method,
      host: parsed.hostname,
      path: parsed.path,
      port: parsed.port ? parsed.port : parsed.protocol === "https:" ? 443 : 80,
      headers,
      rejectUnauthorized: false,
      agent: false
    };
    if (options.tls) {
      Object.keys(options.tls).forEach((key) => {
        reqOptions[key] = options.tls[key];
      });
    }
    if (parsed.protocol === "https:" && parsed.hostname && parsed.hostname !== reqOptions.host && !net.isIP(parsed.hostname) && !reqOptions.servername) {
      reqOptions.servername = parsed.hostname;
    }
    try {
      req = handler.request(reqOptions);
    } catch (E) {
      finished = true;
      setImmediate(() => {
        E.type = "FETCH";
        E.sourceUrl = url;
        fetchRes.emit("error", E);
      });
      return fetchRes;
    }
    if (options.timeout) {
      req.setTimeout(options.timeout, () => {
        if (finished) {
          return;
        }
        finished = true;
        req.abort();
        let err = new Error("Request Timeout");
        err.type = "FETCH";
        err.sourceUrl = url;
        fetchRes.emit("error", err);
      });
    }
    req.on("error", (err) => {
      if (finished) {
        return;
      }
      finished = true;
      err.type = "FETCH";
      err.sourceUrl = url;
      fetchRes.emit("error", err);
    });
    req.on("response", (res) => {
      let inflate;
      if (finished) {
        return;
      }
      switch (res.headers["content-encoding"]) {
        case "gzip":
        case "deflate":
          inflate = zlib.createUnzip();
          break;
      }
      if (res.headers["set-cookie"]) {
        [].concat(res.headers["set-cookie"] || []).forEach((cookie) => {
          options.cookies.set(cookie, url);
        });
      }
      if ([301, 302, 303, 307, 308].includes(res.statusCode) && res.headers.location) {
        options.redirects++;
        if (options.redirects > options.maxRedirects) {
          finished = true;
          let err = new Error("Maximum redirect count exceeded");
          err.type = "FETCH";
          err.sourceUrl = url;
          fetchRes.emit("error", err);
          req.abort();
          return;
        }
        options.method = "GET";
        options.body = false;
        return nmfetch(urllib.resolve(url, res.headers.location), options);
      }
      fetchRes.statusCode = res.statusCode;
      fetchRes.headers = res.headers;
      if (res.statusCode >= 300 && !options.allowErrorResponse) {
        finished = true;
        let err = new Error("Invalid status code " + res.statusCode);
        err.type = "FETCH";
        err.sourceUrl = url;
        fetchRes.emit("error", err);
        req.abort();
        return;
      }
      res.on("error", (err) => {
        if (finished) {
          return;
        }
        finished = true;
        err.type = "FETCH";
        err.sourceUrl = url;
        fetchRes.emit("error", err);
        req.abort();
      });
      if (inflate) {
        res.pipe(inflate).pipe(fetchRes);
        inflate.on("error", (err) => {
          if (finished) {
            return;
          }
          finished = true;
          err.type = "FETCH";
          err.sourceUrl = url;
          fetchRes.emit("error", err);
          req.abort();
        });
      } else {
        res.pipe(fetchRes);
      }
    });
    setImmediate(() => {
      if (body) {
        try {
          if (typeof body.pipe === "function") {
            return body.pipe(req);
          } else {
            req.write(body);
          }
        } catch (err) {
          finished = true;
          err.type = "FETCH";
          err.sourceUrl = url;
          fetchRes.emit("error", err);
          return;
        }
      }
      req.end();
    });
    return fetchRes;
  }
  var http = import.meta.require("http");
  var https = import.meta.require("https");
  var urllib = import.meta.require("url");
  var zlib = import.meta.require("zlib");
  var PassThrough = import.meta.require("stream").PassThrough;
  var Cookies = require_cookies();
  var packageData = require_package4();
  var net = import.meta.require("net");
  var MAX_REDIRECTS = 5;
  module.exports = function(url, options) {
    return nmfetch(url, options);
  };
  module.exports.Cookies = Cookies;
});

// node_modules/nodemailer/lib/shared/index.js
var require_shared2 = __commonJS((exports, module) => {
  function resolveStream(stream, callback) {
    let responded = false;
    let chunks = [];
    let chunklen = 0;
    stream.on("error", (err) => {
      if (responded) {
        return;
      }
      responded = true;
      callback(err);
    });
    stream.on("readable", () => {
      let chunk;
      while ((chunk = stream.read()) !== null) {
        chunks.push(chunk);
        chunklen += chunk.length;
      }
    });
    stream.on("end", () => {
      if (responded) {
        return;
      }
      responded = true;
      let value;
      try {
        value = Buffer.concat(chunks, chunklen);
      } catch (E) {
        return callback(E);
      }
      callback(null, value);
    });
  }
  function createDefaultLogger(levels) {
    let levelMaxLen = 0;
    let levelNames = new Map;
    levels.forEach((level) => {
      if (level.length > levelMaxLen) {
        levelMaxLen = level.length;
      }
    });
    levels.forEach((level) => {
      let levelName = level.toUpperCase();
      if (levelName.length < levelMaxLen) {
        levelName += " ".repeat(levelMaxLen - levelName.length);
      }
      levelNames.set(level, levelName);
    });
    let print = (level, entry, message, ...args) => {
      let prefix = "";
      if (entry) {
        if (entry.tnx === "server") {
          prefix = "S: ";
        } else if (entry.tnx === "client") {
          prefix = "C: ";
        }
        if (entry.sid) {
          prefix = "[" + entry.sid + "] " + prefix;
        }
        if (entry.cid) {
          prefix = "[#" + entry.cid + "] " + prefix;
        }
      }
      message = util.format(message, ...args);
      message.split(/\r?\n/).forEach((line) => {
        console.log("[%s] %s %s", new Date().toISOString().substr(0, 19).replace(/T/, " "), levelNames.get(level), prefix + line);
      });
    };
    let logger2 = {};
    levels.forEach((level) => {
      logger2[level] = print.bind(null, level);
    });
    return logger2;
  }
  var urllib = import.meta.require("url");
  var util = import.meta.require("util");
  var fs = import.meta.require("fs");
  var nmfetch = require_fetch();
  var dns = import.meta.require("dns");
  var net = import.meta.require("net");
  var os = import.meta.require("os");
  var DNS_TTL = 5 * 60 * 1000;
  var networkInterfaces;
  try {
    networkInterfaces = os.networkInterfaces();
  } catch (err) {
  }
  exports.networkInterfaces = networkInterfaces;
  var isFamilySupported = (family, allowInternal) => {
    let networkInterfaces2 = exports.networkInterfaces;
    if (!networkInterfaces2) {
      return true;
    }
    const familySupported = Object.keys(networkInterfaces2).map((key) => networkInterfaces2[key]).reduce((acc, val) => acc.concat(val), []).filter((i) => !i.internal || allowInternal).filter((i) => i.family === "IPv" + family || i.family === family).length > 0;
    return familySupported;
  };
  var resolver = (family, hostname, options, callback) => {
    options = options || {};
    const familySupported = isFamilySupported(family, options.allowInternalNetworkInterfaces);
    if (!familySupported) {
      return callback(null, []);
    }
    const resolver2 = dns.Resolver ? new dns.Resolver(options) : dns;
    resolver2["resolve" + family](hostname, (err, addresses) => {
      if (err) {
        switch (err.code) {
          case dns.NODATA:
          case dns.NOTFOUND:
          case dns.NOTIMP:
          case dns.SERVFAIL:
          case dns.CONNREFUSED:
          case dns.REFUSED:
          case "EAI_AGAIN":
            return callback(null, []);
        }
        return callback(err);
      }
      return callback(null, Array.isArray(addresses) ? addresses : [].concat(addresses || []));
    });
  };
  var dnsCache = exports.dnsCache = new Map;
  var formatDNSValue = (value, extra) => {
    if (!value) {
      return Object.assign({}, extra || {});
    }
    return Object.assign({
      servername: value.servername,
      host: !value.addresses || !value.addresses.length ? null : value.addresses.length === 1 ? value.addresses[0] : value.addresses[Math.floor(Math.random() * value.addresses.length)]
    }, extra || {});
  };
  exports.resolveHostname = (options, callback) => {
    options = options || {};
    if (!options.host && options.servername) {
      options.host = options.servername;
    }
    if (!options.host || net.isIP(options.host)) {
      let value = {
        addresses: [options.host],
        servername: options.servername || false
      };
      return callback(null, formatDNSValue(value, {
        cached: false
      }));
    }
    let cached;
    if (dnsCache.has(options.host)) {
      cached = dnsCache.get(options.host);
      if (!cached.expires || cached.expires >= Date.now()) {
        return callback(null, formatDNSValue(cached.value, {
          cached: true
        }));
      }
    }
    resolver(4, options.host, options, (err, addresses) => {
      if (err) {
        if (cached) {
          return callback(null, formatDNSValue(cached.value, {
            cached: true,
            error: err
          }));
        }
        return callback(err);
      }
      if (addresses && addresses.length) {
        let value = {
          addresses,
          servername: options.servername || options.host
        };
        dnsCache.set(options.host, {
          value,
          expires: Date.now() + (options.dnsTtl || DNS_TTL)
        });
        return callback(null, formatDNSValue(value, {
          cached: false
        }));
      }
      resolver(6, options.host, options, (err2, addresses2) => {
        if (err2) {
          if (cached) {
            return callback(null, formatDNSValue(cached.value, {
              cached: true,
              error: err2
            }));
          }
          return callback(err2);
        }
        if (addresses2 && addresses2.length) {
          let value = {
            addresses: addresses2,
            servername: options.servername || options.host
          };
          dnsCache.set(options.host, {
            value,
            expires: Date.now() + (options.dnsTtl || DNS_TTL)
          });
          return callback(null, formatDNSValue(value, {
            cached: false
          }));
        }
        try {
          dns.lookup(options.host, { all: true }, (err3, addresses3) => {
            if (err3) {
              if (cached) {
                return callback(null, formatDNSValue(cached.value, {
                  cached: true,
                  error: err3
                }));
              }
              return callback(err3);
            }
            let address = addresses3 ? addresses3.filter((addr) => isFamilySupported(addr.family)).map((addr) => addr.address).shift() : false;
            if (addresses3 && addresses3.length && !address) {
              console.warn(`Failed to resolve IPv${addresses3[0].family} addresses with current network`);
            }
            if (!address && cached) {
              return callback(null, formatDNSValue(cached.value, {
                cached: true
              }));
            }
            let value = {
              addresses: address ? [address] : [options.host],
              servername: options.servername || options.host
            };
            dnsCache.set(options.host, {
              value,
              expires: Date.now() + (options.dnsTtl || DNS_TTL)
            });
            return callback(null, formatDNSValue(value, {
              cached: false
            }));
          });
        } catch (err3) {
          if (cached) {
            return callback(null, formatDNSValue(cached.value, {
              cached: true,
              error: err3
            }));
          }
          return callback(err3);
        }
      });
    });
  };
  exports.parseConnectionUrl = (str) => {
    str = str || "";
    let options = {};
    [urllib.parse(str, true)].forEach((url) => {
      let auth;
      switch (url.protocol) {
        case "smtp:":
          options.secure = false;
          break;
        case "smtps:":
          options.secure = true;
          break;
        case "direct:":
          options.direct = true;
          break;
      }
      if (!isNaN(url.port) && Number(url.port)) {
        options.port = Number(url.port);
      }
      if (url.hostname) {
        options.host = url.hostname;
      }
      if (url.auth) {
        auth = url.auth.split(":");
        if (!options.auth) {
          options.auth = {};
        }
        options.auth.user = auth.shift();
        options.auth.pass = auth.join(":");
      }
      Object.keys(url.query || {}).forEach((key) => {
        let obj = options;
        let lKey = key;
        let value = url.query[key];
        if (!isNaN(value)) {
          value = Number(value);
        }
        switch (value) {
          case "true":
            value = true;
            break;
          case "false":
            value = false;
            break;
        }
        if (key.indexOf("tls.") === 0) {
          lKey = key.substr(4);
          if (!options.tls) {
            options.tls = {};
          }
          obj = options.tls;
        } else if (key.indexOf(".") >= 0) {
          return;
        }
        if (!(lKey in obj)) {
          obj[lKey] = value;
        }
      });
    });
    return options;
  };
  exports._logFunc = (logger2, level, defaults, data, message, ...args) => {
    let entry = {};
    Object.keys(defaults || {}).forEach((key) => {
      if (key !== "level") {
        entry[key] = defaults[key];
      }
    });
    Object.keys(data || {}).forEach((key) => {
      if (key !== "level") {
        entry[key] = data[key];
      }
    });
    logger2[level](entry, message, ...args);
  };
  exports.getLogger = (options, defaults) => {
    options = options || {};
    let response = {};
    let levels = ["trace", "debug", "info", "warn", "error", "fatal"];
    if (!options.logger) {
      levels.forEach((level) => {
        response[level] = () => false;
      });
      return response;
    }
    let logger2 = options.logger;
    if (options.logger === true) {
      logger2 = createDefaultLogger(levels);
    }
    levels.forEach((level) => {
      response[level] = (data, message, ...args) => {
        exports._logFunc(logger2, level, defaults, data, message, ...args);
      };
    });
    return response;
  };
  exports.callbackPromise = (resolve, reject) => function() {
    let args = Array.from(arguments);
    let err = args.shift();
    if (err) {
      reject(err);
    } else {
      resolve(...args);
    }
  };
  exports.parseDataURI = (uri) => {
    let input = uri;
    let commaPos = input.indexOf(",");
    if (!commaPos) {
      return uri;
    }
    let data = input.substring(commaPos + 1);
    let metaStr = input.substring("data:".length, commaPos);
    let encoding;
    let metaEntries = metaStr.split(";");
    let lastMetaEntry = metaEntries.length > 1 ? metaEntries[metaEntries.length - 1] : false;
    if (lastMetaEntry && lastMetaEntry.indexOf("=") < 0) {
      encoding = lastMetaEntry.toLowerCase();
      metaEntries.pop();
    }
    let contentType = metaEntries.shift() || "application/octet-stream";
    let params = {};
    for (let entry of metaEntries) {
      let sep = entry.indexOf("=");
      if (sep >= 0) {
        let key = entry.substring(0, sep);
        let value = entry.substring(sep + 1);
        params[key] = value;
      }
    }
    switch (encoding) {
      case "base64":
        data = Buffer.from(data, "base64");
        break;
      case "utf8":
        data = Buffer.from(data);
        break;
      default:
        try {
          data = Buffer.from(decodeURIComponent(data));
        } catch (err) {
          data = Buffer.from(data);
        }
        data = Buffer.from(data);
    }
    return { data, encoding, contentType, params };
  };
  exports.resolveContent = (data, key, callback) => {
    let promise;
    if (!callback) {
      promise = new Promise((resolve, reject) => {
        callback = exports.callbackPromise(resolve, reject);
      });
    }
    let content = data && data[key] && data[key].content || data[key];
    let contentStream;
    let encoding = (typeof data[key] === "object" && data[key].encoding || "utf8").toString().toLowerCase().replace(/[-_\s]/g, "");
    if (!content) {
      return callback(null, content);
    }
    if (typeof content === "object") {
      if (typeof content.pipe === "function") {
        return resolveStream(content, (err, value) => {
          if (err) {
            return callback(err);
          }
          if (data[key].content) {
            data[key].content = value;
          } else {
            data[key] = value;
          }
          callback(null, value);
        });
      } else if (/^https?:\/\//i.test(content.path || content.href)) {
        contentStream = nmfetch(content.path || content.href);
        return resolveStream(contentStream, callback);
      } else if (/^data:/i.test(content.path || content.href)) {
        let parsedDataUri = exports.parseDataURI(content.path || content.href);
        if (!parsedDataUri || !parsedDataUri.data) {
          return callback(null, Buffer.from(0));
        }
        return callback(null, parsedDataUri.data);
      } else if (content.path) {
        return resolveStream(fs.createReadStream(content.path), callback);
      }
    }
    if (typeof data[key].content === "string" && !["utf8", "usascii", "ascii"].includes(encoding)) {
      content = Buffer.from(data[key].content, encoding);
    }
    setImmediate(() => callback(null, content));
    return promise;
  };
  exports.assign = function() {
    let args = Array.from(arguments);
    let target = args.shift() || {};
    args.forEach((source) => {
      Object.keys(source || {}).forEach((key) => {
        if (["tls", "auth"].includes(key) && source[key] && typeof source[key] === "object") {
          if (!target[key]) {
            target[key] = {};
          }
          Object.keys(source[key]).forEach((subKey) => {
            target[key][subKey] = source[key][subKey];
          });
        } else {
          target[key] = source[key];
        }
      });
    });
    return target;
  };
  exports.encodeXText = (str) => {
    if (!/[^\x21-\x2A\x2C-\x3C\x3E-\x7E]/.test(str)) {
      return str;
    }
    let buf = Buffer.from(str);
    let result = "";
    for (let i = 0, len = buf.length;i < len; i++) {
      let c = buf[i];
      if (c < 33 || c > 126 || c === 43 || c === 61) {
        result += "+" + (c < 16 ? "0" : "") + c.toString(16).toUpperCase();
      } else {
        result += String.fromCharCode(c);
      }
    }
    return result;
  };
});

// node_modules/nodemailer/lib/mime-funcs/mime-types.js
var require_mime_types = __commonJS((exports, module) => {
  var path = import.meta.require("path");
  var defaultMimeType = "application/octet-stream";
  var defaultExtension = "bin";
  var mimeTypes = new Map([
    ["application/acad", "dwg"],
    ["application/applixware", "aw"],
    ["application/arj", "arj"],
    ["application/atom+xml", "xml"],
    ["application/atomcat+xml", "atomcat"],
    ["application/atomsvc+xml", "atomsvc"],
    ["application/base64", ["mm", "mme"]],
    ["application/binhex", "hqx"],
    ["application/binhex4", "hqx"],
    ["application/book", ["book", "boo"]],
    ["application/ccxml+xml,", "ccxml"],
    ["application/cdf", "cdf"],
    ["application/cdmi-capability", "cdmia"],
    ["application/cdmi-container", "cdmic"],
    ["application/cdmi-domain", "cdmid"],
    ["application/cdmi-object", "cdmio"],
    ["application/cdmi-queue", "cdmiq"],
    ["application/clariscad", "ccad"],
    ["application/commonground", "dp"],
    ["application/cu-seeme", "cu"],
    ["application/davmount+xml", "davmount"],
    ["application/drafting", "drw"],
    ["application/dsptype", "tsp"],
    ["application/dssc+der", "dssc"],
    ["application/dssc+xml", "xdssc"],
    ["application/dxf", "dxf"],
    ["application/ecmascript", ["js", "es"]],
    ["application/emma+xml", "emma"],
    ["application/envoy", "evy"],
    ["application/epub+zip", "epub"],
    ["application/excel", ["xls", "xl", "xla", "xlb", "xlc", "xld", "xlk", "xll", "xlm", "xlt", "xlv", "xlw"]],
    ["application/exi", "exi"],
    ["application/font-tdpfr", "pfr"],
    ["application/fractals", "fif"],
    ["application/freeloader", "frl"],
    ["application/futuresplash", "spl"],
    ["application/geo+json", "geojson"],
    ["application/gnutar", "tgz"],
    ["application/groupwise", "vew"],
    ["application/hlp", "hlp"],
    ["application/hta", "hta"],
    ["application/hyperstudio", "stk"],
    ["application/i-deas", "unv"],
    ["application/iges", ["iges", "igs"]],
    ["application/inf", "inf"],
    ["application/internet-property-stream", "acx"],
    ["application/ipfix", "ipfix"],
    ["application/java", "class"],
    ["application/java-archive", "jar"],
    ["application/java-byte-code", "class"],
    ["application/java-serialized-object", "ser"],
    ["application/java-vm", "class"],
    ["application/javascript", "js"],
    ["application/json", "json"],
    ["application/lha", "lha"],
    ["application/lzx", "lzx"],
    ["application/mac-binary", "bin"],
    ["application/mac-binhex", "hqx"],
    ["application/mac-binhex40", "hqx"],
    ["application/mac-compactpro", "cpt"],
    ["application/macbinary", "bin"],
    ["application/mads+xml", "mads"],
    ["application/marc", "mrc"],
    ["application/marcxml+xml", "mrcx"],
    ["application/mathematica", "ma"],
    ["application/mathml+xml", "mathml"],
    ["application/mbedlet", "mbd"],
    ["application/mbox", "mbox"],
    ["application/mcad", "mcd"],
    ["application/mediaservercontrol+xml", "mscml"],
    ["application/metalink4+xml", "meta4"],
    ["application/mets+xml", "mets"],
    ["application/mime", "aps"],
    ["application/mods+xml", "mods"],
    ["application/mp21", "m21"],
    ["application/mp4", "mp4"],
    ["application/mspowerpoint", ["ppt", "pot", "pps", "ppz"]],
    ["application/msword", ["doc", "dot", "w6w", "wiz", "word"]],
    ["application/mswrite", "wri"],
    ["application/mxf", "mxf"],
    ["application/netmc", "mcp"],
    ["application/octet-stream", ["*"]],
    ["application/oda", "oda"],
    ["application/oebps-package+xml", "opf"],
    ["application/ogg", "ogx"],
    ["application/olescript", "axs"],
    ["application/onenote", "onetoc"],
    ["application/patch-ops-error+xml", "xer"],
    ["application/pdf", "pdf"],
    ["application/pgp-encrypted", "asc"],
    ["application/pgp-signature", "pgp"],
    ["application/pics-rules", "prf"],
    ["application/pkcs-12", "p12"],
    ["application/pkcs-crl", "crl"],
    ["application/pkcs10", "p10"],
    ["application/pkcs7-mime", ["p7c", "p7m"]],
    ["application/pkcs7-signature", "p7s"],
    ["application/pkcs8", "p8"],
    ["application/pkix-attr-cert", "ac"],
    ["application/pkix-cert", ["cer", "crt"]],
    ["application/pkix-crl", "crl"],
    ["application/pkix-pkipath", "pkipath"],
    ["application/pkixcmp", "pki"],
    ["application/plain", "text"],
    ["application/pls+xml", "pls"],
    ["application/postscript", ["ps", "ai", "eps"]],
    ["application/powerpoint", "ppt"],
    ["application/pro_eng", ["part", "prt"]],
    ["application/prs.cww", "cww"],
    ["application/pskc+xml", "pskcxml"],
    ["application/rdf+xml", "rdf"],
    ["application/reginfo+xml", "rif"],
    ["application/relax-ng-compact-syntax", "rnc"],
    ["application/resource-lists+xml", "rl"],
    ["application/resource-lists-diff+xml", "rld"],
    ["application/ringing-tones", "rng"],
    ["application/rls-services+xml", "rs"],
    ["application/rsd+xml", "rsd"],
    ["application/rss+xml", "xml"],
    ["application/rtf", ["rtf", "rtx"]],
    ["application/sbml+xml", "sbml"],
    ["application/scvp-cv-request", "scq"],
    ["application/scvp-cv-response", "scs"],
    ["application/scvp-vp-request", "spq"],
    ["application/scvp-vp-response", "spp"],
    ["application/sdp", "sdp"],
    ["application/sea", "sea"],
    ["application/set", "set"],
    ["application/set-payment-initiation", "setpay"],
    ["application/set-registration-initiation", "setreg"],
    ["application/shf+xml", "shf"],
    ["application/sla", "stl"],
    ["application/smil", ["smi", "smil"]],
    ["application/smil+xml", "smi"],
    ["application/solids", "sol"],
    ["application/sounder", "sdr"],
    ["application/sparql-query", "rq"],
    ["application/sparql-results+xml", "srx"],
    ["application/srgs", "gram"],
    ["application/srgs+xml", "grxml"],
    ["application/sru+xml", "sru"],
    ["application/ssml+xml", "ssml"],
    ["application/step", ["step", "stp"]],
    ["application/streamingmedia", "ssm"],
    ["application/tei+xml", "tei"],
    ["application/thraud+xml", "tfi"],
    ["application/timestamped-data", "tsd"],
    ["application/toolbook", "tbk"],
    ["application/vda", "vda"],
    ["application/vnd.3gpp.pic-bw-large", "plb"],
    ["application/vnd.3gpp.pic-bw-small", "psb"],
    ["application/vnd.3gpp.pic-bw-var", "pvb"],
    ["application/vnd.3gpp2.tcap", "tcap"],
    ["application/vnd.3m.post-it-notes", "pwn"],
    ["application/vnd.accpac.simply.aso", "aso"],
    ["application/vnd.accpac.simply.imp", "imp"],
    ["application/vnd.acucobol", "acu"],
    ["application/vnd.acucorp", "atc"],
    ["application/vnd.adobe.air-application-installer-package+zip", "air"],
    ["application/vnd.adobe.fxp", "fxp"],
    ["application/vnd.adobe.xdp+xml", "xdp"],
    ["application/vnd.adobe.xfdf", "xfdf"],
    ["application/vnd.ahead.space", "ahead"],
    ["application/vnd.airzip.filesecure.azf", "azf"],
    ["application/vnd.airzip.filesecure.azs", "azs"],
    ["application/vnd.amazon.ebook", "azw"],
    ["application/vnd.americandynamics.acc", "acc"],
    ["application/vnd.amiga.ami", "ami"],
    ["application/vnd.android.package-archive", "apk"],
    ["application/vnd.anser-web-certificate-issue-initiation", "cii"],
    ["application/vnd.anser-web-funds-transfer-initiation", "fti"],
    ["application/vnd.antix.game-component", "atx"],
    ["application/vnd.apple.installer+xml", "mpkg"],
    ["application/vnd.apple.mpegurl", "m3u8"],
    ["application/vnd.aristanetworks.swi", "swi"],
    ["application/vnd.audiograph", "aep"],
    ["application/vnd.blueice.multipass", "mpm"],
    ["application/vnd.bmi", "bmi"],
    ["application/vnd.businessobjects", "rep"],
    ["application/vnd.chemdraw+xml", "cdxml"],
    ["application/vnd.chipnuts.karaoke-mmd", "mmd"],
    ["application/vnd.cinderella", "cdy"],
    ["application/vnd.claymore", "cla"],
    ["application/vnd.cloanto.rp9", "rp9"],
    ["application/vnd.clonk.c4group", "c4g"],
    ["application/vnd.cluetrust.cartomobile-config", "c11amc"],
    ["application/vnd.cluetrust.cartomobile-config-pkg", "c11amz"],
    ["application/vnd.commonspace", "csp"],
    ["application/vnd.contact.cmsg", "cdbcmsg"],
    ["application/vnd.cosmocaller", "cmc"],
    ["application/vnd.crick.clicker", "clkx"],
    ["application/vnd.crick.clicker.keyboard", "clkk"],
    ["application/vnd.crick.clicker.palette", "clkp"],
    ["application/vnd.crick.clicker.template", "clkt"],
    ["application/vnd.crick.clicker.wordbank", "clkw"],
    ["application/vnd.criticaltools.wbs+xml", "wbs"],
    ["application/vnd.ctc-posml", "pml"],
    ["application/vnd.cups-ppd", "ppd"],
    ["application/vnd.curl.car", "car"],
    ["application/vnd.curl.pcurl", "pcurl"],
    ["application/vnd.data-vision.rdz", "rdz"],
    ["application/vnd.denovo.fcselayout-link", "fe_launch"],
    ["application/vnd.dna", "dna"],
    ["application/vnd.dolby.mlp", "mlp"],
    ["application/vnd.dpgraph", "dpg"],
    ["application/vnd.dreamfactory", "dfac"],
    ["application/vnd.dvb.ait", "ait"],
    ["application/vnd.dvb.service", "svc"],
    ["application/vnd.dynageo", "geo"],
    ["application/vnd.ecowin.chart", "mag"],
    ["application/vnd.enliven", "nml"],
    ["application/vnd.epson.esf", "esf"],
    ["application/vnd.epson.msf", "msf"],
    ["application/vnd.epson.quickanime", "qam"],
    ["application/vnd.epson.salt", "slt"],
    ["application/vnd.epson.ssf", "ssf"],
    ["application/vnd.eszigno3+xml", "es3"],
    ["application/vnd.ezpix-album", "ez2"],
    ["application/vnd.ezpix-package", "ez3"],
    ["application/vnd.fdf", "fdf"],
    ["application/vnd.fdsn.seed", "seed"],
    ["application/vnd.flographit", "gph"],
    ["application/vnd.fluxtime.clip", "ftc"],
    ["application/vnd.framemaker", "fm"],
    ["application/vnd.frogans.fnc", "fnc"],
    ["application/vnd.frogans.ltf", "ltf"],
    ["application/vnd.fsc.weblaunch", "fsc"],
    ["application/vnd.fujitsu.oasys", "oas"],
    ["application/vnd.fujitsu.oasys2", "oa2"],
    ["application/vnd.fujitsu.oasys3", "oa3"],
    ["application/vnd.fujitsu.oasysgp", "fg5"],
    ["application/vnd.fujitsu.oasysprs", "bh2"],
    ["application/vnd.fujixerox.ddd", "ddd"],
    ["application/vnd.fujixerox.docuworks", "xdw"],
    ["application/vnd.fujixerox.docuworks.binder", "xbd"],
    ["application/vnd.fuzzysheet", "fzs"],
    ["application/vnd.genomatix.tuxedo", "txd"],
    ["application/vnd.geogebra.file", "ggb"],
    ["application/vnd.geogebra.tool", "ggt"],
    ["application/vnd.geometry-explorer", "gex"],
    ["application/vnd.geonext", "gxt"],
    ["application/vnd.geoplan", "g2w"],
    ["application/vnd.geospace", "g3w"],
    ["application/vnd.gmx", "gmx"],
    ["application/vnd.google-earth.kml+xml", "kml"],
    ["application/vnd.google-earth.kmz", "kmz"],
    ["application/vnd.grafeq", "gqf"],
    ["application/vnd.groove-account", "gac"],
    ["application/vnd.groove-help", "ghf"],
    ["application/vnd.groove-identity-message", "gim"],
    ["application/vnd.groove-injector", "grv"],
    ["application/vnd.groove-tool-message", "gtm"],
    ["application/vnd.groove-tool-template", "tpl"],
    ["application/vnd.groove-vcard", "vcg"],
    ["application/vnd.hal+xml", "hal"],
    ["application/vnd.handheld-entertainment+xml", "zmm"],
    ["application/vnd.hbci", "hbci"],
    ["application/vnd.hhe.lesson-player", "les"],
    ["application/vnd.hp-hpgl", ["hgl", "hpg", "hpgl"]],
    ["application/vnd.hp-hpid", "hpid"],
    ["application/vnd.hp-hps", "hps"],
    ["application/vnd.hp-jlyt", "jlt"],
    ["application/vnd.hp-pcl", "pcl"],
    ["application/vnd.hp-pclxl", "pclxl"],
    ["application/vnd.hydrostatix.sof-data", "sfd-hdstx"],
    ["application/vnd.hzn-3d-crossword", "x3d"],
    ["application/vnd.ibm.minipay", "mpy"],
    ["application/vnd.ibm.modcap", "afp"],
    ["application/vnd.ibm.rights-management", "irm"],
    ["application/vnd.ibm.secure-container", "sc"],
    ["application/vnd.iccprofile", "icc"],
    ["application/vnd.igloader", "igl"],
    ["application/vnd.immervision-ivp", "ivp"],
    ["application/vnd.immervision-ivu", "ivu"],
    ["application/vnd.insors.igm", "igm"],
    ["application/vnd.intercon.formnet", "xpw"],
    ["application/vnd.intergeo", "i2g"],
    ["application/vnd.intu.qbo", "qbo"],
    ["application/vnd.intu.qfx", "qfx"],
    ["application/vnd.ipunplugged.rcprofile", "rcprofile"],
    ["application/vnd.irepository.package+xml", "irp"],
    ["application/vnd.is-xpr", "xpr"],
    ["application/vnd.isac.fcs", "fcs"],
    ["application/vnd.jam", "jam"],
    ["application/vnd.jcp.javame.midlet-rms", "rms"],
    ["application/vnd.jisp", "jisp"],
    ["application/vnd.joost.joda-archive", "joda"],
    ["application/vnd.kahootz", "ktz"],
    ["application/vnd.kde.karbon", "karbon"],
    ["application/vnd.kde.kchart", "chrt"],
    ["application/vnd.kde.kformula", "kfo"],
    ["application/vnd.kde.kivio", "flw"],
    ["application/vnd.kde.kontour", "kon"],
    ["application/vnd.kde.kpresenter", "kpr"],
    ["application/vnd.kde.kspread", "ksp"],
    ["application/vnd.kde.kword", "kwd"],
    ["application/vnd.kenameaapp", "htke"],
    ["application/vnd.kidspiration", "kia"],
    ["application/vnd.kinar", "kne"],
    ["application/vnd.koan", "skp"],
    ["application/vnd.kodak-descriptor", "sse"],
    ["application/vnd.las.las+xml", "lasxml"],
    ["application/vnd.llamagraphics.life-balance.desktop", "lbd"],
    ["application/vnd.llamagraphics.life-balance.exchange+xml", "lbe"],
    ["application/vnd.lotus-1-2-3", "123"],
    ["application/vnd.lotus-approach", "apr"],
    ["application/vnd.lotus-freelance", "pre"],
    ["application/vnd.lotus-notes", "nsf"],
    ["application/vnd.lotus-organizer", "org"],
    ["application/vnd.lotus-screencam", "scm"],
    ["application/vnd.lotus-wordpro", "lwp"],
    ["application/vnd.macports.portpkg", "portpkg"],
    ["application/vnd.mcd", "mcd"],
    ["application/vnd.medcalcdata", "mc1"],
    ["application/vnd.mediastation.cdkey", "cdkey"],
    ["application/vnd.mfer", "mwf"],
    ["application/vnd.mfmp", "mfm"],
    ["application/vnd.micrografx.flo", "flo"],
    ["application/vnd.micrografx.igx", "igx"],
    ["application/vnd.mif", "mif"],
    ["application/vnd.mobius.daf", "daf"],
    ["application/vnd.mobius.dis", "dis"],
    ["application/vnd.mobius.mbk", "mbk"],
    ["application/vnd.mobius.mqy", "mqy"],
    ["application/vnd.mobius.msl", "msl"],
    ["application/vnd.mobius.plc", "plc"],
    ["application/vnd.mobius.txf", "txf"],
    ["application/vnd.mophun.application", "mpn"],
    ["application/vnd.mophun.certificate", "mpc"],
    ["application/vnd.mozilla.xul+xml", "xul"],
    ["application/vnd.ms-artgalry", "cil"],
    ["application/vnd.ms-cab-compressed", "cab"],
    ["application/vnd.ms-excel", ["xls", "xla", "xlc", "xlm", "xlt", "xlw", "xlb", "xll"]],
    ["application/vnd.ms-excel.addin.macroenabled.12", "xlam"],
    ["application/vnd.ms-excel.sheet.binary.macroenabled.12", "xlsb"],
    ["application/vnd.ms-excel.sheet.macroenabled.12", "xlsm"],
    ["application/vnd.ms-excel.template.macroenabled.12", "xltm"],
    ["application/vnd.ms-fontobject", "eot"],
    ["application/vnd.ms-htmlhelp", "chm"],
    ["application/vnd.ms-ims", "ims"],
    ["application/vnd.ms-lrm", "lrm"],
    ["application/vnd.ms-officetheme", "thmx"],
    ["application/vnd.ms-outlook", "msg"],
    ["application/vnd.ms-pki.certstore", "sst"],
    ["application/vnd.ms-pki.pko", "pko"],
    ["application/vnd.ms-pki.seccat", "cat"],
    ["application/vnd.ms-pki.stl", "stl"],
    ["application/vnd.ms-pkicertstore", "sst"],
    ["application/vnd.ms-pkiseccat", "cat"],
    ["application/vnd.ms-pkistl", "stl"],
    ["application/vnd.ms-powerpoint", ["ppt", "pot", "pps", "ppa", "pwz"]],
    ["application/vnd.ms-powerpoint.addin.macroenabled.12", "ppam"],
    ["application/vnd.ms-powerpoint.presentation.macroenabled.12", "pptm"],
    ["application/vnd.ms-powerpoint.slide.macroenabled.12", "sldm"],
    ["application/vnd.ms-powerpoint.slideshow.macroenabled.12", "ppsm"],
    ["application/vnd.ms-powerpoint.template.macroenabled.12", "potm"],
    ["application/vnd.ms-project", "mpp"],
    ["application/vnd.ms-word.document.macroenabled.12", "docm"],
    ["application/vnd.ms-word.template.macroenabled.12", "dotm"],
    ["application/vnd.ms-works", ["wks", "wcm", "wdb", "wps"]],
    ["application/vnd.ms-wpl", "wpl"],
    ["application/vnd.ms-xpsdocument", "xps"],
    ["application/vnd.mseq", "mseq"],
    ["application/vnd.musician", "mus"],
    ["application/vnd.muvee.style", "msty"],
    ["application/vnd.neurolanguage.nlu", "nlu"],
    ["application/vnd.noblenet-directory", "nnd"],
    ["application/vnd.noblenet-sealer", "nns"],
    ["application/vnd.noblenet-web", "nnw"],
    ["application/vnd.nokia.configuration-message", "ncm"],
    ["application/vnd.nokia.n-gage.data", "ngdat"],
    ["application/vnd.nokia.n-gage.symbian.install", "n-gage"],
    ["application/vnd.nokia.radio-preset", "rpst"],
    ["application/vnd.nokia.radio-presets", "rpss"],
    ["application/vnd.nokia.ringing-tone", "rng"],
    ["application/vnd.novadigm.edm", "edm"],
    ["application/vnd.novadigm.edx", "edx"],
    ["application/vnd.novadigm.ext", "ext"],
    ["application/vnd.oasis.opendocument.chart", "odc"],
    ["application/vnd.oasis.opendocument.chart-template", "otc"],
    ["application/vnd.oasis.opendocument.database", "odb"],
    ["application/vnd.oasis.opendocument.formula", "odf"],
    ["application/vnd.oasis.opendocument.formula-template", "odft"],
    ["application/vnd.oasis.opendocument.graphics", "odg"],
    ["application/vnd.oasis.opendocument.graphics-template", "otg"],
    ["application/vnd.oasis.opendocument.image", "odi"],
    ["application/vnd.oasis.opendocument.image-template", "oti"],
    ["application/vnd.oasis.opendocument.presentation", "odp"],
    ["application/vnd.oasis.opendocument.presentation-template", "otp"],
    ["application/vnd.oasis.opendocument.spreadsheet", "ods"],
    ["application/vnd.oasis.opendocument.spreadsheet-template", "ots"],
    ["application/vnd.oasis.opendocument.text", "odt"],
    ["application/vnd.oasis.opendocument.text-master", "odm"],
    ["application/vnd.oasis.opendocument.text-template", "ott"],
    ["application/vnd.oasis.opendocument.text-web", "oth"],
    ["application/vnd.olpc-sugar", "xo"],
    ["application/vnd.oma.dd2+xml", "dd2"],
    ["application/vnd.openofficeorg.extension", "oxt"],
    ["application/vnd.openxmlformats-officedocument.presentationml.presentation", "pptx"],
    ["application/vnd.openxmlformats-officedocument.presentationml.slide", "sldx"],
    ["application/vnd.openxmlformats-officedocument.presentationml.slideshow", "ppsx"],
    ["application/vnd.openxmlformats-officedocument.presentationml.template", "potx"],
    ["application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "xlsx"],
    ["application/vnd.openxmlformats-officedocument.spreadsheetml.template", "xltx"],
    ["application/vnd.openxmlformats-officedocument.wordprocessingml.document", "docx"],
    ["application/vnd.openxmlformats-officedocument.wordprocessingml.template", "dotx"],
    ["application/vnd.osgeo.mapguide.package", "mgp"],
    ["application/vnd.osgi.dp", "dp"],
    ["application/vnd.palm", "pdb"],
    ["application/vnd.pawaafile", "paw"],
    ["application/vnd.pg.format", "str"],
    ["application/vnd.pg.osasli", "ei6"],
    ["application/vnd.picsel", "efif"],
    ["application/vnd.pmi.widget", "wg"],
    ["application/vnd.pocketlearn", "plf"],
    ["application/vnd.powerbuilder6", "pbd"],
    ["application/vnd.previewsystems.box", "box"],
    ["application/vnd.proteus.magazine", "mgz"],
    ["application/vnd.publishare-delta-tree", "qps"],
    ["application/vnd.pvi.ptid1", "ptid"],
    ["application/vnd.quark.quarkxpress", "qxd"],
    ["application/vnd.realvnc.bed", "bed"],
    ["application/vnd.recordare.musicxml", "mxl"],
    ["application/vnd.recordare.musicxml+xml", "musicxml"],
    ["application/vnd.rig.cryptonote", "cryptonote"],
    ["application/vnd.rim.cod", "cod"],
    ["application/vnd.rn-realmedia", "rm"],
    ["application/vnd.rn-realplayer", "rnx"],
    ["application/vnd.route66.link66+xml", "link66"],
    ["application/vnd.sailingtracker.track", "st"],
    ["application/vnd.seemail", "see"],
    ["application/vnd.sema", "sema"],
    ["application/vnd.semd", "semd"],
    ["application/vnd.semf", "semf"],
    ["application/vnd.shana.informed.formdata", "ifm"],
    ["application/vnd.shana.informed.formtemplate", "itp"],
    ["application/vnd.shana.informed.interchange", "iif"],
    ["application/vnd.shana.informed.package", "ipk"],
    ["application/vnd.simtech-mindmapper", "twd"],
    ["application/vnd.smaf", "mmf"],
    ["application/vnd.smart.teacher", "teacher"],
    ["application/vnd.solent.sdkm+xml", "sdkm"],
    ["application/vnd.spotfire.dxp", "dxp"],
    ["application/vnd.spotfire.sfs", "sfs"],
    ["application/vnd.stardivision.calc", "sdc"],
    ["application/vnd.stardivision.draw", "sda"],
    ["application/vnd.stardivision.impress", "sdd"],
    ["application/vnd.stardivision.math", "smf"],
    ["application/vnd.stardivision.writer", "sdw"],
    ["application/vnd.stardivision.writer-global", "sgl"],
    ["application/vnd.stepmania.stepchart", "sm"],
    ["application/vnd.sun.xml.calc", "sxc"],
    ["application/vnd.sun.xml.calc.template", "stc"],
    ["application/vnd.sun.xml.draw", "sxd"],
    ["application/vnd.sun.xml.draw.template", "std"],
    ["application/vnd.sun.xml.impress", "sxi"],
    ["application/vnd.sun.xml.impress.template", "sti"],
    ["application/vnd.sun.xml.math", "sxm"],
    ["application/vnd.sun.xml.writer", "sxw"],
    ["application/vnd.sun.xml.writer.global", "sxg"],
    ["application/vnd.sun.xml.writer.template", "stw"],
    ["application/vnd.sus-calendar", "sus"],
    ["application/vnd.svd", "svd"],
    ["application/vnd.symbian.install", "sis"],
    ["application/vnd.syncml+xml", "xsm"],
    ["application/vnd.syncml.dm+wbxml", "bdm"],
    ["application/vnd.syncml.dm+xml", "xdm"],
    ["application/vnd.tao.intent-module-archive", "tao"],
    ["application/vnd.tmobile-livetv", "tmo"],
    ["application/vnd.trid.tpt", "tpt"],
    ["application/vnd.triscape.mxs", "mxs"],
    ["application/vnd.trueapp", "tra"],
    ["application/vnd.ufdl", "ufd"],
    ["application/vnd.uiq.theme", "utz"],
    ["application/vnd.umajin", "umj"],
    ["application/vnd.unity", "unityweb"],
    ["application/vnd.uoml+xml", "uoml"],
    ["application/vnd.vcx", "vcx"],
    ["application/vnd.visio", "vsd"],
    ["application/vnd.visionary", "vis"],
    ["application/vnd.vsf", "vsf"],
    ["application/vnd.wap.wbxml", "wbxml"],
    ["application/vnd.wap.wmlc", "wmlc"],
    ["application/vnd.wap.wmlscriptc", "wmlsc"],
    ["application/vnd.webturbo", "wtb"],
    ["application/vnd.wolfram.player", "nbp"],
    ["application/vnd.wordperfect", "wpd"],
    ["application/vnd.wqd", "wqd"],
    ["application/vnd.wt.stf", "stf"],
    ["application/vnd.xara", ["web", "xar"]],
    ["application/vnd.xfdl", "xfdl"],
    ["application/vnd.yamaha.hv-dic", "hvd"],
    ["application/vnd.yamaha.hv-script", "hvs"],
    ["application/vnd.yamaha.hv-voice", "hvp"],
    ["application/vnd.yamaha.openscoreformat", "osf"],
    ["application/vnd.yamaha.openscoreformat.osfpvg+xml", "osfpvg"],
    ["application/vnd.yamaha.smaf-audio", "saf"],
    ["application/vnd.yamaha.smaf-phrase", "spf"],
    ["application/vnd.yellowriver-custom-menu", "cmp"],
    ["application/vnd.zul", "zir"],
    ["application/vnd.zzazz.deck+xml", "zaz"],
    ["application/vocaltec-media-desc", "vmd"],
    ["application/vocaltec-media-file", "vmf"],
    ["application/voicexml+xml", "vxml"],
    ["application/widget", "wgt"],
    ["application/winhlp", "hlp"],
    ["application/wordperfect", ["wp", "wp5", "wp6", "wpd"]],
    ["application/wordperfect6.0", ["w60", "wp5"]],
    ["application/wordperfect6.1", "w61"],
    ["application/wsdl+xml", "wsdl"],
    ["application/wspolicy+xml", "wspolicy"],
    ["application/x-123", "wk1"],
    ["application/x-7z-compressed", "7z"],
    ["application/x-abiword", "abw"],
    ["application/x-ace-compressed", "ace"],
    ["application/x-aim", "aim"],
    ["application/x-authorware-bin", "aab"],
    ["application/x-authorware-map", "aam"],
    ["application/x-authorware-seg", "aas"],
    ["application/x-bcpio", "bcpio"],
    ["application/x-binary", "bin"],
    ["application/x-binhex40", "hqx"],
    ["application/x-bittorrent", "torrent"],
    ["application/x-bsh", ["bsh", "sh", "shar"]],
    ["application/x-bytecode.elisp", "elc"],
    ["application/x-bytecode.python", "pyc"],
    ["application/x-bzip", "bz"],
    ["application/x-bzip2", ["boz", "bz2"]],
    ["application/x-cdf", "cdf"],
    ["application/x-cdlink", "vcd"],
    ["application/x-chat", ["cha", "chat"]],
    ["application/x-chess-pgn", "pgn"],
    ["application/x-cmu-raster", "ras"],
    ["application/x-cocoa", "cco"],
    ["application/x-compactpro", "cpt"],
    ["application/x-compress", "z"],
    ["application/x-compressed", ["tgz", "gz", "z", "zip"]],
    ["application/x-conference", "nsc"],
    ["application/x-cpio", "cpio"],
    ["application/x-cpt", "cpt"],
    ["application/x-csh", "csh"],
    ["application/x-debian-package", "deb"],
    ["application/x-deepv", "deepv"],
    ["application/x-director", ["dir", "dcr", "dxr"]],
    ["application/x-doom", "wad"],
    ["application/x-dtbncx+xml", "ncx"],
    ["application/x-dtbook+xml", "dtb"],
    ["application/x-dtbresource+xml", "res"],
    ["application/x-dvi", "dvi"],
    ["application/x-elc", "elc"],
    ["application/x-envoy", ["env", "evy"]],
    ["application/x-esrehber", "es"],
    ["application/x-excel", ["xls", "xla", "xlb", "xlc", "xld", "xlk", "xll", "xlm", "xlt", "xlv", "xlw"]],
    ["application/x-font-bdf", "bdf"],
    ["application/x-font-ghostscript", "gsf"],
    ["application/x-font-linux-psf", "psf"],
    ["application/x-font-otf", "otf"],
    ["application/x-font-pcf", "pcf"],
    ["application/x-font-snf", "snf"],
    ["application/x-font-ttf", "ttf"],
    ["application/x-font-type1", "pfa"],
    ["application/x-font-woff", "woff"],
    ["application/x-frame", "mif"],
    ["application/x-freelance", "pre"],
    ["application/x-futuresplash", "spl"],
    ["application/x-gnumeric", "gnumeric"],
    ["application/x-gsp", "gsp"],
    ["application/x-gss", "gss"],
    ["application/x-gtar", "gtar"],
    ["application/x-gzip", ["gz", "gzip"]],
    ["application/x-hdf", "hdf"],
    ["application/x-helpfile", ["help", "hlp"]],
    ["application/x-httpd-imap", "imap"],
    ["application/x-ima", "ima"],
    ["application/x-internet-signup", ["ins", "isp"]],
    ["application/x-internett-signup", "ins"],
    ["application/x-inventor", "iv"],
    ["application/x-ip2", "ip"],
    ["application/x-iphone", "iii"],
    ["application/x-java-class", "class"],
    ["application/x-java-commerce", "jcm"],
    ["application/x-java-jnlp-file", "jnlp"],
    ["application/x-javascript", "js"],
    ["application/x-koan", ["skd", "skm", "skp", "skt"]],
    ["application/x-ksh", "ksh"],
    ["application/x-latex", ["latex", "ltx"]],
    ["application/x-lha", "lha"],
    ["application/x-lisp", "lsp"],
    ["application/x-livescreen", "ivy"],
    ["application/x-lotus", "wq1"],
    ["application/x-lotusscreencam", "scm"],
    ["application/x-lzh", "lzh"],
    ["application/x-lzx", "lzx"],
    ["application/x-mac-binhex40", "hqx"],
    ["application/x-macbinary", "bin"],
    ["application/x-magic-cap-package-1.0", "mc$"],
    ["application/x-mathcad", "mcd"],
    ["application/x-meme", "mm"],
    ["application/x-midi", ["mid", "midi"]],
    ["application/x-mif", "mif"],
    ["application/x-mix-transfer", "nix"],
    ["application/x-mobipocket-ebook", "prc"],
    ["application/x-mplayer2", "asx"],
    ["application/x-ms-application", "application"],
    ["application/x-ms-wmd", "wmd"],
    ["application/x-ms-wmz", "wmz"],
    ["application/x-ms-xbap", "xbap"],
    ["application/x-msaccess", "mdb"],
    ["application/x-msbinder", "obd"],
    ["application/x-mscardfile", "crd"],
    ["application/x-msclip", "clp"],
    ["application/x-msdownload", ["exe", "dll"]],
    ["application/x-msexcel", ["xls", "xla", "xlw"]],
    ["application/x-msmediaview", ["mvb", "m13", "m14"]],
    ["application/x-msmetafile", "wmf"],
    ["application/x-msmoney", "mny"],
    ["application/x-mspowerpoint", "ppt"],
    ["application/x-mspublisher", "pub"],
    ["application/x-msschedule", "scd"],
    ["application/x-msterminal", "trm"],
    ["application/x-mswrite", "wri"],
    ["application/x-navi-animation", "ani"],
    ["application/x-navidoc", "nvd"],
    ["application/x-navimap", "map"],
    ["application/x-navistyle", "stl"],
    ["application/x-netcdf", ["cdf", "nc"]],
    ["application/x-newton-compatible-pkg", "pkg"],
    ["application/x-nokia-9000-communicator-add-on-software", "aos"],
    ["application/x-omc", "omc"],
    ["application/x-omcdatamaker", "omcd"],
    ["application/x-omcregerator", "omcr"],
    ["application/x-pagemaker", ["pm4", "pm5"]],
    ["application/x-pcl", "pcl"],
    ["application/x-perfmon", ["pma", "pmc", "pml", "pmr", "pmw"]],
    ["application/x-pixclscript", "plx"],
    ["application/x-pkcs10", "p10"],
    ["application/x-pkcs12", ["p12", "pfx"]],
    ["application/x-pkcs7-certificates", ["p7b", "spc"]],
    ["application/x-pkcs7-certreqresp", "p7r"],
    ["application/x-pkcs7-mime", ["p7m", "p7c"]],
    ["application/x-pkcs7-signature", ["p7s", "p7a"]],
    ["application/x-pointplus", "css"],
    ["application/x-portable-anymap", "pnm"],
    ["application/x-project", ["mpc", "mpt", "mpv", "mpx"]],
    ["application/x-qpro", "wb1"],
    ["application/x-rar-compressed", "rar"],
    ["application/x-rtf", "rtf"],
    ["application/x-sdp", "sdp"],
    ["application/x-sea", "sea"],
    ["application/x-seelogo", "sl"],
    ["application/x-sh", "sh"],
    ["application/x-shar", ["shar", "sh"]],
    ["application/x-shockwave-flash", "swf"],
    ["application/x-silverlight-app", "xap"],
    ["application/x-sit", "sit"],
    ["application/x-sprite", ["spr", "sprite"]],
    ["application/x-stuffit", "sit"],
    ["application/x-stuffitx", "sitx"],
    ["application/x-sv4cpio", "sv4cpio"],
    ["application/x-sv4crc", "sv4crc"],
    ["application/x-tar", "tar"],
    ["application/x-tbook", ["sbk", "tbk"]],
    ["application/x-tcl", "tcl"],
    ["application/x-tex", "tex"],
    ["application/x-tex-tfm", "tfm"],
    ["application/x-texinfo", ["texi", "texinfo"]],
    ["application/x-troff", ["roff", "t", "tr"]],
    ["application/x-troff-man", "man"],
    ["application/x-troff-me", "me"],
    ["application/x-troff-ms", "ms"],
    ["application/x-troff-msvideo", "avi"],
    ["application/x-ustar", "ustar"],
    ["application/x-visio", ["vsd", "vst", "vsw"]],
    ["application/x-vnd.audioexplosion.mzz", "mzz"],
    ["application/x-vnd.ls-xpix", "xpix"],
    ["application/x-vrml", "vrml"],
    ["application/x-wais-source", ["src", "wsrc"]],
    ["application/x-winhelp", "hlp"],
    ["application/x-wintalk", "wtk"],
    ["application/x-world", ["wrl", "svr"]],
    ["application/x-wpwin", "wpd"],
    ["application/x-wri", "wri"],
    ["application/x-x509-ca-cert", ["cer", "crt", "der"]],
    ["application/x-x509-user-cert", "crt"],
    ["application/x-xfig", "fig"],
    ["application/x-xpinstall", "xpi"],
    ["application/x-zip-compressed", "zip"],
    ["application/xcap-diff+xml", "xdf"],
    ["application/xenc+xml", "xenc"],
    ["application/xhtml+xml", "xhtml"],
    ["application/xml", "xml"],
    ["application/xml-dtd", "dtd"],
    ["application/xop+xml", "xop"],
    ["application/xslt+xml", "xslt"],
    ["application/xspf+xml", "xspf"],
    ["application/xv+xml", "mxml"],
    ["application/yang", "yang"],
    ["application/yin+xml", "yin"],
    ["application/ynd.ms-pkipko", "pko"],
    ["application/zip", "zip"],
    ["audio/adpcm", "adp"],
    ["audio/aiff", ["aiff", "aif", "aifc"]],
    ["audio/basic", ["snd", "au"]],
    ["audio/it", "it"],
    ["audio/make", ["funk", "my", "pfunk"]],
    ["audio/make.my.funk", "pfunk"],
    ["audio/mid", ["mid", "rmi"]],
    ["audio/midi", ["midi", "kar", "mid"]],
    ["audio/mod", "mod"],
    ["audio/mp4", "mp4a"],
    ["audio/mpeg", ["mpga", "mp3", "m2a", "mp2", "mpa", "mpg"]],
    ["audio/mpeg3", "mp3"],
    ["audio/nspaudio", ["la", "lma"]],
    ["audio/ogg", "oga"],
    ["audio/s3m", "s3m"],
    ["audio/tsp-audio", "tsi"],
    ["audio/tsplayer", "tsp"],
    ["audio/vnd.dece.audio", "uva"],
    ["audio/vnd.digital-winds", "eol"],
    ["audio/vnd.dra", "dra"],
    ["audio/vnd.dts", "dts"],
    ["audio/vnd.dts.hd", "dtshd"],
    ["audio/vnd.lucent.voice", "lvp"],
    ["audio/vnd.ms-playready.media.pya", "pya"],
    ["audio/vnd.nuera.ecelp4800", "ecelp4800"],
    ["audio/vnd.nuera.ecelp7470", "ecelp7470"],
    ["audio/vnd.nuera.ecelp9600", "ecelp9600"],
    ["audio/vnd.qcelp", "qcp"],
    ["audio/vnd.rip", "rip"],
    ["audio/voc", "voc"],
    ["audio/voxware", "vox"],
    ["audio/wav", "wav"],
    ["audio/webm", "weba"],
    ["audio/x-aac", "aac"],
    ["audio/x-adpcm", "snd"],
    ["audio/x-aiff", ["aiff", "aif", "aifc"]],
    ["audio/x-au", "au"],
    ["audio/x-gsm", ["gsd", "gsm"]],
    ["audio/x-jam", "jam"],
    ["audio/x-liveaudio", "lam"],
    ["audio/x-mid", ["mid", "midi"]],
    ["audio/x-midi", ["midi", "mid"]],
    ["audio/x-mod", "mod"],
    ["audio/x-mpeg", "mp2"],
    ["audio/x-mpeg-3", "mp3"],
    ["audio/x-mpegurl", "m3u"],
    ["audio/x-mpequrl", "m3u"],
    ["audio/x-ms-wax", "wax"],
    ["audio/x-ms-wma", "wma"],
    ["audio/x-nspaudio", ["la", "lma"]],
    ["audio/x-pn-realaudio", ["ra", "ram", "rm", "rmm", "rmp"]],
    ["audio/x-pn-realaudio-plugin", ["ra", "rmp", "rpm"]],
    ["audio/x-psid", "sid"],
    ["audio/x-realaudio", "ra"],
    ["audio/x-twinvq", "vqf"],
    ["audio/x-twinvq-plugin", ["vqe", "vql"]],
    ["audio/x-vnd.audioexplosion.mjuicemediafile", "mjf"],
    ["audio/x-voc", "voc"],
    ["audio/x-wav", "wav"],
    ["audio/xm", "xm"],
    ["chemical/x-cdx", "cdx"],
    ["chemical/x-cif", "cif"],
    ["chemical/x-cmdf", "cmdf"],
    ["chemical/x-cml", "cml"],
    ["chemical/x-csml", "csml"],
    ["chemical/x-pdb", ["pdb", "xyz"]],
    ["chemical/x-xyz", "xyz"],
    ["drawing/x-dwf", "dwf"],
    ["i-world/i-vrml", "ivr"],
    ["image/bmp", ["bmp", "bm"]],
    ["image/cgm", "cgm"],
    ["image/cis-cod", "cod"],
    ["image/cmu-raster", ["ras", "rast"]],
    ["image/fif", "fif"],
    ["image/florian", ["flo", "turbot"]],
    ["image/g3fax", "g3"],
    ["image/gif", "gif"],
    ["image/ief", ["ief", "iefs"]],
    ["image/jpeg", ["jpeg", "jpe", "jpg", "jfif", "jfif-tbnl"]],
    ["image/jutvision", "jut"],
    ["image/ktx", "ktx"],
    ["image/naplps", ["nap", "naplps"]],
    ["image/pict", ["pic", "pict"]],
    ["image/pipeg", "jfif"],
    ["image/pjpeg", ["jfif", "jpe", "jpeg", "jpg"]],
    ["image/png", ["png", "x-png"]],
    ["image/prs.btif", "btif"],
    ["image/svg+xml", "svg"],
    ["image/tiff", ["tif", "tiff"]],
    ["image/vasa", "mcf"],
    ["image/vnd.adobe.photoshop", "psd"],
    ["image/vnd.dece.graphic", "uvi"],
    ["image/vnd.djvu", "djvu"],
    ["image/vnd.dvb.subtitle", "sub"],
    ["image/vnd.dwg", ["dwg", "dxf", "svf"]],
    ["image/vnd.dxf", "dxf"],
    ["image/vnd.fastbidsheet", "fbs"],
    ["image/vnd.fpx", "fpx"],
    ["image/vnd.fst", "fst"],
    ["image/vnd.fujixerox.edmics-mmr", "mmr"],
    ["image/vnd.fujixerox.edmics-rlc", "rlc"],
    ["image/vnd.ms-modi", "mdi"],
    ["image/vnd.net-fpx", ["fpx", "npx"]],
    ["image/vnd.rn-realflash", "rf"],
    ["image/vnd.rn-realpix", "rp"],
    ["image/vnd.wap.wbmp", "wbmp"],
    ["image/vnd.xiff", "xif"],
    ["image/webp", "webp"],
    ["image/x-cmu-raster", "ras"],
    ["image/x-cmx", "cmx"],
    ["image/x-dwg", ["dwg", "dxf", "svf"]],
    ["image/x-freehand", "fh"],
    ["image/x-icon", "ico"],
    ["image/x-jg", "art"],
    ["image/x-jps", "jps"],
    ["image/x-niff", ["niff", "nif"]],
    ["image/x-pcx", "pcx"],
    ["image/x-pict", ["pct", "pic"]],
    ["image/x-portable-anymap", "pnm"],
    ["image/x-portable-bitmap", "pbm"],
    ["image/x-portable-graymap", "pgm"],
    ["image/x-portable-greymap", "pgm"],
    ["image/x-portable-pixmap", "ppm"],
    ["image/x-quicktime", ["qif", "qti", "qtif"]],
    ["image/x-rgb", "rgb"],
    ["image/x-tiff", ["tif", "tiff"]],
    ["image/x-windows-bmp", "bmp"],
    ["image/x-xbitmap", "xbm"],
    ["image/x-xbm", "xbm"],
    ["image/x-xpixmap", ["xpm", "pm"]],
    ["image/x-xwd", "xwd"],
    ["image/x-xwindowdump", "xwd"],
    ["image/xbm", "xbm"],
    ["image/xpm", "xpm"],
    ["message/rfc822", ["eml", "mht", "mhtml", "nws", "mime"]],
    ["model/iges", ["iges", "igs"]],
    ["model/mesh", "msh"],
    ["model/vnd.collada+xml", "dae"],
    ["model/vnd.dwf", "dwf"],
    ["model/vnd.gdl", "gdl"],
    ["model/vnd.gtw", "gtw"],
    ["model/vnd.mts", "mts"],
    ["model/vnd.vtu", "vtu"],
    ["model/vrml", ["vrml", "wrl", "wrz"]],
    ["model/x-pov", "pov"],
    ["multipart/x-gzip", "gzip"],
    ["multipart/x-ustar", "ustar"],
    ["multipart/x-zip", "zip"],
    ["music/crescendo", ["mid", "midi"]],
    ["music/x-karaoke", "kar"],
    ["paleovu/x-pv", "pvu"],
    ["text/asp", "asp"],
    ["text/calendar", "ics"],
    ["text/css", "css"],
    ["text/csv", "csv"],
    ["text/ecmascript", "js"],
    ["text/h323", "323"],
    ["text/html", ["html", "htm", "stm", "acgi", "htmls", "htx", "shtml"]],
    ["text/iuls", "uls"],
    ["text/javascript", "js"],
    ["text/mcf", "mcf"],
    ["text/n3", "n3"],
    ["text/pascal", "pas"],
    [
      "text/plain",
      [
        "txt",
        "bas",
        "c",
        "h",
        "c++",
        "cc",
        "com",
        "conf",
        "cxx",
        "def",
        "f",
        "f90",
        "for",
        "g",
        "hh",
        "idc",
        "jav",
        "java",
        "list",
        "log",
        "lst",
        "m",
        "mar",
        "pl",
        "sdml",
        "text"
      ]
    ],
    ["text/plain-bas", "par"],
    ["text/prs.lines.tag", "dsc"],
    ["text/richtext", ["rtx", "rt", "rtf"]],
    ["text/scriplet", "wsc"],
    ["text/scriptlet", "sct"],
    ["text/sgml", ["sgm", "sgml"]],
    ["text/tab-separated-values", "tsv"],
    ["text/troff", "t"],
    ["text/turtle", "ttl"],
    ["text/uri-list", ["uni", "unis", "uri", "uris"]],
    ["text/vnd.abc", "abc"],
    ["text/vnd.curl", "curl"],
    ["text/vnd.curl.dcurl", "dcurl"],
    ["text/vnd.curl.mcurl", "mcurl"],
    ["text/vnd.curl.scurl", "scurl"],
    ["text/vnd.fly", "fly"],
    ["text/vnd.fmi.flexstor", "flx"],
    ["text/vnd.graphviz", "gv"],
    ["text/vnd.in3d.3dml", "3dml"],
    ["text/vnd.in3d.spot", "spot"],
    ["text/vnd.rn-realtext", "rt"],
    ["text/vnd.sun.j2me.app-descriptor", "jad"],
    ["text/vnd.wap.wml", "wml"],
    ["text/vnd.wap.wmlscript", "wmls"],
    ["text/webviewhtml", "htt"],
    ["text/x-asm", ["asm", "s"]],
    ["text/x-audiosoft-intra", "aip"],
    ["text/x-c", ["c", "cc", "cpp"]],
    ["text/x-component", "htc"],
    ["text/x-fortran", ["for", "f", "f77", "f90"]],
    ["text/x-h", ["h", "hh"]],
    ["text/x-java-source", ["java", "jav"]],
    ["text/x-java-source,java", "java"],
    ["text/x-la-asf", "lsx"],
    ["text/x-m", "m"],
    ["text/x-pascal", "p"],
    ["text/x-script", "hlb"],
    ["text/x-script.csh", "csh"],
    ["text/x-script.elisp", "el"],
    ["text/x-script.guile", "scm"],
    ["text/x-script.ksh", "ksh"],
    ["text/x-script.lisp", "lsp"],
    ["text/x-script.perl", "pl"],
    ["text/x-script.perl-module", "pm"],
    ["text/x-script.phyton", "py"],
    ["text/x-script.rexx", "rexx"],
    ["text/x-script.scheme", "scm"],
    ["text/x-script.sh", "sh"],
    ["text/x-script.tcl", "tcl"],
    ["text/x-script.tcsh", "tcsh"],
    ["text/x-script.zsh", "zsh"],
    ["text/x-server-parsed-html", ["shtml", "ssi"]],
    ["text/x-setext", "etx"],
    ["text/x-sgml", ["sgm", "sgml"]],
    ["text/x-speech", ["spc", "talk"]],
    ["text/x-uil", "uil"],
    ["text/x-uuencode", ["uu", "uue"]],
    ["text/x-vcalendar", "vcs"],
    ["text/x-vcard", "vcf"],
    ["text/xml", "xml"],
    ["video/3gpp", "3gp"],
    ["video/3gpp2", "3g2"],
    ["video/animaflex", "afl"],
    ["video/avi", "avi"],
    ["video/avs-video", "avs"],
    ["video/dl", "dl"],
    ["video/fli", "fli"],
    ["video/gl", "gl"],
    ["video/h261", "h261"],
    ["video/h263", "h263"],
    ["video/h264", "h264"],
    ["video/jpeg", "jpgv"],
    ["video/jpm", "jpm"],
    ["video/mj2", "mj2"],
    ["video/mp4", "mp4"],
    ["video/mpeg", ["mpeg", "mp2", "mpa", "mpe", "mpg", "mpv2", "m1v", "m2v", "mp3"]],
    ["video/msvideo", "avi"],
    ["video/ogg", "ogv"],
    ["video/quicktime", ["mov", "qt", "moov"]],
    ["video/vdo", "vdo"],
    ["video/vivo", ["viv", "vivo"]],
    ["video/vnd.dece.hd", "uvh"],
    ["video/vnd.dece.mobile", "uvm"],
    ["video/vnd.dece.pd", "uvp"],
    ["video/vnd.dece.sd", "uvs"],
    ["video/vnd.dece.video", "uvv"],
    ["video/vnd.fvt", "fvt"],
    ["video/vnd.mpegurl", "mxu"],
    ["video/vnd.ms-playready.media.pyv", "pyv"],
    ["video/vnd.rn-realvideo", "rv"],
    ["video/vnd.uvvu.mp4", "uvu"],
    ["video/vnd.vivo", ["viv", "vivo"]],
    ["video/vosaic", "vos"],
    ["video/webm", "webm"],
    ["video/x-amt-demorun", "xdr"],
    ["video/x-amt-showrun", "xsr"],
    ["video/x-atomic3d-feature", "fmf"],
    ["video/x-dl", "dl"],
    ["video/x-dv", ["dif", "dv"]],
    ["video/x-f4v", "f4v"],
    ["video/x-fli", "fli"],
    ["video/x-flv", "flv"],
    ["video/x-gl", "gl"],
    ["video/x-isvideo", "isu"],
    ["video/x-la-asf", ["lsf", "lsx"]],
    ["video/x-m4v", "m4v"],
    ["video/x-motion-jpeg", "mjpg"],
    ["video/x-mpeg", ["mp3", "mp2"]],
    ["video/x-mpeq2a", "mp2"],
    ["video/x-ms-asf", ["asf", "asr", "asx"]],
    ["video/x-ms-asf-plugin", "asx"],
    ["video/x-ms-wm", "wm"],
    ["video/x-ms-wmv", "wmv"],
    ["video/x-ms-wmx", "wmx"],
    ["video/x-ms-wvx", "wvx"],
    ["video/x-msvideo", "avi"],
    ["video/x-qtc", "qtc"],
    ["video/x-scm", "scm"],
    ["video/x-sgi-movie", ["movie", "mv"]],
    ["windows/metafile", "wmf"],
    ["www/mime", "mime"],
    ["x-conference/x-cooltalk", "ice"],
    ["x-music/x-midi", ["mid", "midi"]],
    ["x-world/x-3dmf", ["3dm", "3dmf", "qd3", "qd3d"]],
    ["x-world/x-svr", "svr"],
    ["x-world/x-vrml", ["flr", "vrml", "wrl", "wrz", "xaf", "xof"]],
    ["x-world/x-vrt", "vrt"],
    ["xgl/drawing", "xgz"],
    ["xgl/movie", "xmz"]
  ]);
  var extensions = new Map([
    ["123", "application/vnd.lotus-1-2-3"],
    ["323", "text/h323"],
    ["*", "application/octet-stream"],
    ["3dm", "x-world/x-3dmf"],
    ["3dmf", "x-world/x-3dmf"],
    ["3dml", "text/vnd.in3d.3dml"],
    ["3g2", "video/3gpp2"],
    ["3gp", "video/3gpp"],
    ["7z", "application/x-7z-compressed"],
    ["a", "application/octet-stream"],
    ["aab", "application/x-authorware-bin"],
    ["aac", "audio/x-aac"],
    ["aam", "application/x-authorware-map"],
    ["aas", "application/x-authorware-seg"],
    ["abc", "text/vnd.abc"],
    ["abw", "application/x-abiword"],
    ["ac", "application/pkix-attr-cert"],
    ["acc", "application/vnd.americandynamics.acc"],
    ["ace", "application/x-ace-compressed"],
    ["acgi", "text/html"],
    ["acu", "application/vnd.acucobol"],
    ["acx", "application/internet-property-stream"],
    ["adp", "audio/adpcm"],
    ["aep", "application/vnd.audiograph"],
    ["afl", "video/animaflex"],
    ["afp", "application/vnd.ibm.modcap"],
    ["ahead", "application/vnd.ahead.space"],
    ["ai", "application/postscript"],
    ["aif", ["audio/aiff", "audio/x-aiff"]],
    ["aifc", ["audio/aiff", "audio/x-aiff"]],
    ["aiff", ["audio/aiff", "audio/x-aiff"]],
    ["aim", "application/x-aim"],
    ["aip", "text/x-audiosoft-intra"],
    ["air", "application/vnd.adobe.air-application-installer-package+zip"],
    ["ait", "application/vnd.dvb.ait"],
    ["ami", "application/vnd.amiga.ami"],
    ["ani", "application/x-navi-animation"],
    ["aos", "application/x-nokia-9000-communicator-add-on-software"],
    ["apk", "application/vnd.android.package-archive"],
    ["application", "application/x-ms-application"],
    ["apr", "application/vnd.lotus-approach"],
    ["aps", "application/mime"],
    ["arc", "application/octet-stream"],
    ["arj", ["application/arj", "application/octet-stream"]],
    ["art", "image/x-jg"],
    ["asf", "video/x-ms-asf"],
    ["asm", "text/x-asm"],
    ["aso", "application/vnd.accpac.simply.aso"],
    ["asp", "text/asp"],
    ["asr", "video/x-ms-asf"],
    ["asx", ["video/x-ms-asf", "application/x-mplayer2", "video/x-ms-asf-plugin"]],
    ["atc", "application/vnd.acucorp"],
    ["atomcat", "application/atomcat+xml"],
    ["atomsvc", "application/atomsvc+xml"],
    ["atx", "application/vnd.antix.game-component"],
    ["au", ["audio/basic", "audio/x-au"]],
    ["avi", ["video/avi", "video/msvideo", "application/x-troff-msvideo", "video/x-msvideo"]],
    ["avs", "video/avs-video"],
    ["aw", "application/applixware"],
    ["axs", "application/olescript"],
    ["azf", "application/vnd.airzip.filesecure.azf"],
    ["azs", "application/vnd.airzip.filesecure.azs"],
    ["azw", "application/vnd.amazon.ebook"],
    ["bas", "text/plain"],
    ["bcpio", "application/x-bcpio"],
    ["bdf", "application/x-font-bdf"],
    ["bdm", "application/vnd.syncml.dm+wbxml"],
    ["bed", "application/vnd.realvnc.bed"],
    ["bh2", "application/vnd.fujitsu.oasysprs"],
    ["bin", ["application/octet-stream", "application/mac-binary", "application/macbinary", "application/x-macbinary", "application/x-binary"]],
    ["bm", "image/bmp"],
    ["bmi", "application/vnd.bmi"],
    ["bmp", ["image/bmp", "image/x-windows-bmp"]],
    ["boo", "application/book"],
    ["book", "application/book"],
    ["box", "application/vnd.previewsystems.box"],
    ["boz", "application/x-bzip2"],
    ["bsh", "application/x-bsh"],
    ["btif", "image/prs.btif"],
    ["bz", "application/x-bzip"],
    ["bz2", "application/x-bzip2"],
    ["c", ["text/plain", "text/x-c"]],
    ["c++", "text/plain"],
    ["c11amc", "application/vnd.cluetrust.cartomobile-config"],
    ["c11amz", "application/vnd.cluetrust.cartomobile-config-pkg"],
    ["c4g", "application/vnd.clonk.c4group"],
    ["cab", "application/vnd.ms-cab-compressed"],
    ["car", "application/vnd.curl.car"],
    ["cat", ["application/vnd.ms-pkiseccat", "application/vnd.ms-pki.seccat"]],
    ["cc", ["text/plain", "text/x-c"]],
    ["ccad", "application/clariscad"],
    ["cco", "application/x-cocoa"],
    ["ccxml", "application/ccxml+xml,"],
    ["cdbcmsg", "application/vnd.contact.cmsg"],
    ["cdf", ["application/cdf", "application/x-cdf", "application/x-netcdf"]],
    ["cdkey", "application/vnd.mediastation.cdkey"],
    ["cdmia", "application/cdmi-capability"],
    ["cdmic", "application/cdmi-container"],
    ["cdmid", "application/cdmi-domain"],
    ["cdmio", "application/cdmi-object"],
    ["cdmiq", "application/cdmi-queue"],
    ["cdx", "chemical/x-cdx"],
    ["cdxml", "application/vnd.chemdraw+xml"],
    ["cdy", "application/vnd.cinderella"],
    ["cer", ["application/pkix-cert", "application/x-x509-ca-cert"]],
    ["cgm", "image/cgm"],
    ["cha", "application/x-chat"],
    ["chat", "application/x-chat"],
    ["chm", "application/vnd.ms-htmlhelp"],
    ["chrt", "application/vnd.kde.kchart"],
    ["cif", "chemical/x-cif"],
    ["cii", "application/vnd.anser-web-certificate-issue-initiation"],
    ["cil", "application/vnd.ms-artgalry"],
    ["cla", "application/vnd.claymore"],
    ["class", ["application/octet-stream", "application/java", "application/java-byte-code", "application/java-vm", "application/x-java-class"]],
    ["clkk", "application/vnd.crick.clicker.keyboard"],
    ["clkp", "application/vnd.crick.clicker.palette"],
    ["clkt", "application/vnd.crick.clicker.template"],
    ["clkw", "application/vnd.crick.clicker.wordbank"],
    ["clkx", "application/vnd.crick.clicker"],
    ["clp", "application/x-msclip"],
    ["cmc", "application/vnd.cosmocaller"],
    ["cmdf", "chemical/x-cmdf"],
    ["cml", "chemical/x-cml"],
    ["cmp", "application/vnd.yellowriver-custom-menu"],
    ["cmx", "image/x-cmx"],
    ["cod", ["image/cis-cod", "application/vnd.rim.cod"]],
    ["com", ["application/octet-stream", "text/plain"]],
    ["conf", "text/plain"],
    ["cpio", "application/x-cpio"],
    ["cpp", "text/x-c"],
    ["cpt", ["application/mac-compactpro", "application/x-compactpro", "application/x-cpt"]],
    ["crd", "application/x-mscardfile"],
    ["crl", ["application/pkix-crl", "application/pkcs-crl"]],
    ["crt", ["application/pkix-cert", "application/x-x509-user-cert", "application/x-x509-ca-cert"]],
    ["cryptonote", "application/vnd.rig.cryptonote"],
    ["csh", ["text/x-script.csh", "application/x-csh"]],
    ["csml", "chemical/x-csml"],
    ["csp", "application/vnd.commonspace"],
    ["css", ["text/css", "application/x-pointplus"]],
    ["csv", "text/csv"],
    ["cu", "application/cu-seeme"],
    ["curl", "text/vnd.curl"],
    ["cww", "application/prs.cww"],
    ["cxx", "text/plain"],
    ["dae", "model/vnd.collada+xml"],
    ["daf", "application/vnd.mobius.daf"],
    ["davmount", "application/davmount+xml"],
    ["dcr", "application/x-director"],
    ["dcurl", "text/vnd.curl.dcurl"],
    ["dd2", "application/vnd.oma.dd2+xml"],
    ["ddd", "application/vnd.fujixerox.ddd"],
    ["deb", "application/x-debian-package"],
    ["deepv", "application/x-deepv"],
    ["def", "text/plain"],
    ["der", "application/x-x509-ca-cert"],
    ["dfac", "application/vnd.dreamfactory"],
    ["dif", "video/x-dv"],
    ["dir", "application/x-director"],
    ["dis", "application/vnd.mobius.dis"],
    ["djvu", "image/vnd.djvu"],
    ["dl", ["video/dl", "video/x-dl"]],
    ["dll", "application/x-msdownload"],
    ["dms", "application/octet-stream"],
    ["dna", "application/vnd.dna"],
    ["doc", "application/msword"],
    ["docm", "application/vnd.ms-word.document.macroenabled.12"],
    ["docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
    ["dot", "application/msword"],
    ["dotm", "application/vnd.ms-word.template.macroenabled.12"],
    ["dotx", "application/vnd.openxmlformats-officedocument.wordprocessingml.template"],
    ["dp", ["application/commonground", "application/vnd.osgi.dp"]],
    ["dpg", "application/vnd.dpgraph"],
    ["dra", "audio/vnd.dra"],
    ["drw", "application/drafting"],
    ["dsc", "text/prs.lines.tag"],
    ["dssc", "application/dssc+der"],
    ["dtb", "application/x-dtbook+xml"],
    ["dtd", "application/xml-dtd"],
    ["dts", "audio/vnd.dts"],
    ["dtshd", "audio/vnd.dts.hd"],
    ["dump", "application/octet-stream"],
    ["dv", "video/x-dv"],
    ["dvi", "application/x-dvi"],
    ["dwf", ["model/vnd.dwf", "drawing/x-dwf"]],
    ["dwg", ["application/acad", "image/vnd.dwg", "image/x-dwg"]],
    ["dxf", ["application/dxf", "image/vnd.dwg", "image/vnd.dxf", "image/x-dwg"]],
    ["dxp", "application/vnd.spotfire.dxp"],
    ["dxr", "application/x-director"],
    ["ecelp4800", "audio/vnd.nuera.ecelp4800"],
    ["ecelp7470", "audio/vnd.nuera.ecelp7470"],
    ["ecelp9600", "audio/vnd.nuera.ecelp9600"],
    ["edm", "application/vnd.novadigm.edm"],
    ["edx", "application/vnd.novadigm.edx"],
    ["efif", "application/vnd.picsel"],
    ["ei6", "application/vnd.pg.osasli"],
    ["el", "text/x-script.elisp"],
    ["elc", ["application/x-elc", "application/x-bytecode.elisp"]],
    ["eml", "message/rfc822"],
    ["emma", "application/emma+xml"],
    ["env", "application/x-envoy"],
    ["eol", "audio/vnd.digital-winds"],
    ["eot", "application/vnd.ms-fontobject"],
    ["eps", "application/postscript"],
    ["epub", "application/epub+zip"],
    ["es", ["application/ecmascript", "application/x-esrehber"]],
    ["es3", "application/vnd.eszigno3+xml"],
    ["esf", "application/vnd.epson.esf"],
    ["etx", "text/x-setext"],
    ["evy", ["application/envoy", "application/x-envoy"]],
    ["exe", ["application/octet-stream", "application/x-msdownload"]],
    ["exi", "application/exi"],
    ["ext", "application/vnd.novadigm.ext"],
    ["ez2", "application/vnd.ezpix-album"],
    ["ez3", "application/vnd.ezpix-package"],
    ["f", ["text/plain", "text/x-fortran"]],
    ["f4v", "video/x-f4v"],
    ["f77", "text/x-fortran"],
    ["f90", ["text/plain", "text/x-fortran"]],
    ["fbs", "image/vnd.fastbidsheet"],
    ["fcs", "application/vnd.isac.fcs"],
    ["fdf", "application/vnd.fdf"],
    ["fe_launch", "application/vnd.denovo.fcselayout-link"],
    ["fg5", "application/vnd.fujitsu.oasysgp"],
    ["fh", "image/x-freehand"],
    ["fif", ["application/fractals", "image/fif"]],
    ["fig", "application/x-xfig"],
    ["fli", ["video/fli", "video/x-fli"]],
    ["flo", ["image/florian", "application/vnd.micrografx.flo"]],
    ["flr", "x-world/x-vrml"],
    ["flv", "video/x-flv"],
    ["flw", "application/vnd.kde.kivio"],
    ["flx", "text/vnd.fmi.flexstor"],
    ["fly", "text/vnd.fly"],
    ["fm", "application/vnd.framemaker"],
    ["fmf", "video/x-atomic3d-feature"],
    ["fnc", "application/vnd.frogans.fnc"],
    ["for", ["text/plain", "text/x-fortran"]],
    ["fpx", ["image/vnd.fpx", "image/vnd.net-fpx"]],
    ["frl", "application/freeloader"],
    ["fsc", "application/vnd.fsc.weblaunch"],
    ["fst", "image/vnd.fst"],
    ["ftc", "application/vnd.fluxtime.clip"],
    ["fti", "application/vnd.anser-web-funds-transfer-initiation"],
    ["funk", "audio/make"],
    ["fvt", "video/vnd.fvt"],
    ["fxp", "application/vnd.adobe.fxp"],
    ["fzs", "application/vnd.fuzzysheet"],
    ["g", "text/plain"],
    ["g2w", "application/vnd.geoplan"],
    ["g3", "image/g3fax"],
    ["g3w", "application/vnd.geospace"],
    ["gac", "application/vnd.groove-account"],
    ["gdl", "model/vnd.gdl"],
    ["geo", "application/vnd.dynageo"],
    ["geojson", "application/geo+json"],
    ["gex", "application/vnd.geometry-explorer"],
    ["ggb", "application/vnd.geogebra.file"],
    ["ggt", "application/vnd.geogebra.tool"],
    ["ghf", "application/vnd.groove-help"],
    ["gif", "image/gif"],
    ["gim", "application/vnd.groove-identity-message"],
    ["gl", ["video/gl", "video/x-gl"]],
    ["gmx", "application/vnd.gmx"],
    ["gnumeric", "application/x-gnumeric"],
    ["gph", "application/vnd.flographit"],
    ["gqf", "application/vnd.grafeq"],
    ["gram", "application/srgs"],
    ["grv", "application/vnd.groove-injector"],
    ["grxml", "application/srgs+xml"],
    ["gsd", "audio/x-gsm"],
    ["gsf", "application/x-font-ghostscript"],
    ["gsm", "audio/x-gsm"],
    ["gsp", "application/x-gsp"],
    ["gss", "application/x-gss"],
    ["gtar", "application/x-gtar"],
    ["gtm", "application/vnd.groove-tool-message"],
    ["gtw", "model/vnd.gtw"],
    ["gv", "text/vnd.graphviz"],
    ["gxt", "application/vnd.geonext"],
    ["gz", ["application/x-gzip", "application/x-compressed"]],
    ["gzip", ["multipart/x-gzip", "application/x-gzip"]],
    ["h", ["text/plain", "text/x-h"]],
    ["h261", "video/h261"],
    ["h263", "video/h263"],
    ["h264", "video/h264"],
    ["hal", "application/vnd.hal+xml"],
    ["hbci", "application/vnd.hbci"],
    ["hdf", "application/x-hdf"],
    ["help", "application/x-helpfile"],
    ["hgl", "application/vnd.hp-hpgl"],
    ["hh", ["text/plain", "text/x-h"]],
    ["hlb", "text/x-script"],
    ["hlp", ["application/winhlp", "application/hlp", "application/x-helpfile", "application/x-winhelp"]],
    ["hpg", "application/vnd.hp-hpgl"],
    ["hpgl", "application/vnd.hp-hpgl"],
    ["hpid", "application/vnd.hp-hpid"],
    ["hps", "application/vnd.hp-hps"],
    [
      "hqx",
      [
        "application/mac-binhex40",
        "application/binhex",
        "application/binhex4",
        "application/mac-binhex",
        "application/x-binhex40",
        "application/x-mac-binhex40"
      ]
    ],
    ["hta", "application/hta"],
    ["htc", "text/x-component"],
    ["htke", "application/vnd.kenameaapp"],
    ["htm", "text/html"],
    ["html", "text/html"],
    ["htmls", "text/html"],
    ["htt", "text/webviewhtml"],
    ["htx", "text/html"],
    ["hvd", "application/vnd.yamaha.hv-dic"],
    ["hvp", "application/vnd.yamaha.hv-voice"],
    ["hvs", "application/vnd.yamaha.hv-script"],
    ["i2g", "application/vnd.intergeo"],
    ["icc", "application/vnd.iccprofile"],
    ["ice", "x-conference/x-cooltalk"],
    ["ico", "image/x-icon"],
    ["ics", "text/calendar"],
    ["idc", "text/plain"],
    ["ief", "image/ief"],
    ["iefs", "image/ief"],
    ["ifm", "application/vnd.shana.informed.formdata"],
    ["iges", ["application/iges", "model/iges"]],
    ["igl", "application/vnd.igloader"],
    ["igm", "application/vnd.insors.igm"],
    ["igs", ["application/iges", "model/iges"]],
    ["igx", "application/vnd.micrografx.igx"],
    ["iif", "application/vnd.shana.informed.interchange"],
    ["iii", "application/x-iphone"],
    ["ima", "application/x-ima"],
    ["imap", "application/x-httpd-imap"],
    ["imp", "application/vnd.accpac.simply.imp"],
    ["ims", "application/vnd.ms-ims"],
    ["inf", "application/inf"],
    ["ins", ["application/x-internet-signup", "application/x-internett-signup"]],
    ["ip", "application/x-ip2"],
    ["ipfix", "application/ipfix"],
    ["ipk", "application/vnd.shana.informed.package"],
    ["irm", "application/vnd.ibm.rights-management"],
    ["irp", "application/vnd.irepository.package+xml"],
    ["isp", "application/x-internet-signup"],
    ["isu", "video/x-isvideo"],
    ["it", "audio/it"],
    ["itp", "application/vnd.shana.informed.formtemplate"],
    ["iv", "application/x-inventor"],
    ["ivp", "application/vnd.immervision-ivp"],
    ["ivr", "i-world/i-vrml"],
    ["ivu", "application/vnd.immervision-ivu"],
    ["ivy", "application/x-livescreen"],
    ["jad", "text/vnd.sun.j2me.app-descriptor"],
    ["jam", ["application/vnd.jam", "audio/x-jam"]],
    ["jar", "application/java-archive"],
    ["jav", ["text/plain", "text/x-java-source"]],
    ["java", ["text/plain", "text/x-java-source,java", "text/x-java-source"]],
    ["jcm", "application/x-java-commerce"],
    ["jfif", ["image/pipeg", "image/jpeg", "image/pjpeg"]],
    ["jfif-tbnl", "image/jpeg"],
    ["jisp", "application/vnd.jisp"],
    ["jlt", "application/vnd.hp-jlyt"],
    ["jnlp", "application/x-java-jnlp-file"],
    ["joda", "application/vnd.joost.joda-archive"],
    ["jpe", ["image/jpeg", "image/pjpeg"]],
    ["jpeg", ["image/jpeg", "image/pjpeg"]],
    ["jpg", ["image/jpeg", "image/pjpeg"]],
    ["jpgv", "video/jpeg"],
    ["jpm", "video/jpm"],
    ["jps", "image/x-jps"],
    ["js", ["application/javascript", "application/ecmascript", "text/javascript", "text/ecmascript", "application/x-javascript"]],
    ["json", "application/json"],
    ["jut", "image/jutvision"],
    ["kar", ["audio/midi", "music/x-karaoke"]],
    ["karbon", "application/vnd.kde.karbon"],
    ["kfo", "application/vnd.kde.kformula"],
    ["kia", "application/vnd.kidspiration"],
    ["kml", "application/vnd.google-earth.kml+xml"],
    ["kmz", "application/vnd.google-earth.kmz"],
    ["kne", "application/vnd.kinar"],
    ["kon", "application/vnd.kde.kontour"],
    ["kpr", "application/vnd.kde.kpresenter"],
    ["ksh", ["application/x-ksh", "text/x-script.ksh"]],
    ["ksp", "application/vnd.kde.kspread"],
    ["ktx", "image/ktx"],
    ["ktz", "application/vnd.kahootz"],
    ["kwd", "application/vnd.kde.kword"],
    ["la", ["audio/nspaudio", "audio/x-nspaudio"]],
    ["lam", "audio/x-liveaudio"],
    ["lasxml", "application/vnd.las.las+xml"],
    ["latex", "application/x-latex"],
    ["lbd", "application/vnd.llamagraphics.life-balance.desktop"],
    ["lbe", "application/vnd.llamagraphics.life-balance.exchange+xml"],
    ["les", "application/vnd.hhe.lesson-player"],
    ["lha", ["application/octet-stream", "application/lha", "application/x-lha"]],
    ["lhx", "application/octet-stream"],
    ["link66", "application/vnd.route66.link66+xml"],
    ["list", "text/plain"],
    ["lma", ["audio/nspaudio", "audio/x-nspaudio"]],
    ["log", "text/plain"],
    ["lrm", "application/vnd.ms-lrm"],
    ["lsf", "video/x-la-asf"],
    ["lsp", ["application/x-lisp", "text/x-script.lisp"]],
    ["lst", "text/plain"],
    ["lsx", ["video/x-la-asf", "text/x-la-asf"]],
    ["ltf", "application/vnd.frogans.ltf"],
    ["ltx", "application/x-latex"],
    ["lvp", "audio/vnd.lucent.voice"],
    ["lwp", "application/vnd.lotus-wordpro"],
    ["lzh", ["application/octet-stream", "application/x-lzh"]],
    ["lzx", ["application/lzx", "application/octet-stream", "application/x-lzx"]],
    ["m", ["text/plain", "text/x-m"]],
    ["m13", "application/x-msmediaview"],
    ["m14", "application/x-msmediaview"],
    ["m1v", "video/mpeg"],
    ["m21", "application/mp21"],
    ["m2a", "audio/mpeg"],
    ["m2v", "video/mpeg"],
    ["m3u", ["audio/x-mpegurl", "audio/x-mpequrl"]],
    ["m3u8", "application/vnd.apple.mpegurl"],
    ["m4v", "video/x-m4v"],
    ["ma", "application/mathematica"],
    ["mads", "application/mads+xml"],
    ["mag", "application/vnd.ecowin.chart"],
    ["man", "application/x-troff-man"],
    ["map", "application/x-navimap"],
    ["mar", "text/plain"],
    ["mathml", "application/mathml+xml"],
    ["mbd", "application/mbedlet"],
    ["mbk", "application/vnd.mobius.mbk"],
    ["mbox", "application/mbox"],
    ["mc$", "application/x-magic-cap-package-1.0"],
    ["mc1", "application/vnd.medcalcdata"],
    ["mcd", ["application/mcad", "application/vnd.mcd", "application/x-mathcad"]],
    ["mcf", ["image/vasa", "text/mcf"]],
    ["mcp", "application/netmc"],
    ["mcurl", "text/vnd.curl.mcurl"],
    ["mdb", "application/x-msaccess"],
    ["mdi", "image/vnd.ms-modi"],
    ["me", "application/x-troff-me"],
    ["meta4", "application/metalink4+xml"],
    ["mets", "application/mets+xml"],
    ["mfm", "application/vnd.mfmp"],
    ["mgp", "application/vnd.osgeo.mapguide.package"],
    ["mgz", "application/vnd.proteus.magazine"],
    ["mht", "message/rfc822"],
    ["mhtml", "message/rfc822"],
    ["mid", ["audio/mid", "audio/midi", "music/crescendo", "x-music/x-midi", "audio/x-midi", "application/x-midi", "audio/x-mid"]],
    ["midi", ["audio/midi", "music/crescendo", "x-music/x-midi", "audio/x-midi", "application/x-midi", "audio/x-mid"]],
    ["mif", ["application/vnd.mif", "application/x-mif", "application/x-frame"]],
    ["mime", ["message/rfc822", "www/mime"]],
    ["mj2", "video/mj2"],
    ["mjf", "audio/x-vnd.audioexplosion.mjuicemediafile"],
    ["mjpg", "video/x-motion-jpeg"],
    ["mlp", "application/vnd.dolby.mlp"],
    ["mm", ["application/base64", "application/x-meme"]],
    ["mmd", "application/vnd.chipnuts.karaoke-mmd"],
    ["mme", "application/base64"],
    ["mmf", "application/vnd.smaf"],
    ["mmr", "image/vnd.fujixerox.edmics-mmr"],
    ["mny", "application/x-msmoney"],
    ["mod", ["audio/mod", "audio/x-mod"]],
    ["mods", "application/mods+xml"],
    ["moov", "video/quicktime"],
    ["mov", "video/quicktime"],
    ["movie", "video/x-sgi-movie"],
    ["mp2", ["video/mpeg", "audio/mpeg", "video/x-mpeg", "audio/x-mpeg", "video/x-mpeq2a"]],
    ["mp3", ["audio/mpeg", "audio/mpeg3", "video/mpeg", "audio/x-mpeg-3", "video/x-mpeg"]],
    ["mp4", ["video/mp4", "application/mp4"]],
    ["mp4a", "audio/mp4"],
    ["mpa", ["video/mpeg", "audio/mpeg"]],
    ["mpc", ["application/vnd.mophun.certificate", "application/x-project"]],
    ["mpe", "video/mpeg"],
    ["mpeg", "video/mpeg"],
    ["mpg", ["video/mpeg", "audio/mpeg"]],
    ["mpga", "audio/mpeg"],
    ["mpkg", "application/vnd.apple.installer+xml"],
    ["mpm", "application/vnd.blueice.multipass"],
    ["mpn", "application/vnd.mophun.application"],
    ["mpp", "application/vnd.ms-project"],
    ["mpt", "application/x-project"],
    ["mpv", "application/x-project"],
    ["mpv2", "video/mpeg"],
    ["mpx", "application/x-project"],
    ["mpy", "application/vnd.ibm.minipay"],
    ["mqy", "application/vnd.mobius.mqy"],
    ["mrc", "application/marc"],
    ["mrcx", "application/marcxml+xml"],
    ["ms", "application/x-troff-ms"],
    ["mscml", "application/mediaservercontrol+xml"],
    ["mseq", "application/vnd.mseq"],
    ["msf", "application/vnd.epson.msf"],
    ["msg", "application/vnd.ms-outlook"],
    ["msh", "model/mesh"],
    ["msl", "application/vnd.mobius.msl"],
    ["msty", "application/vnd.muvee.style"],
    ["mts", "model/vnd.mts"],
    ["mus", "application/vnd.musician"],
    ["musicxml", "application/vnd.recordare.musicxml+xml"],
    ["mv", "video/x-sgi-movie"],
    ["mvb", "application/x-msmediaview"],
    ["mwf", "application/vnd.mfer"],
    ["mxf", "application/mxf"],
    ["mxl", "application/vnd.recordare.musicxml"],
    ["mxml", "application/xv+xml"],
    ["mxs", "application/vnd.triscape.mxs"],
    ["mxu", "video/vnd.mpegurl"],
    ["my", "audio/make"],
    ["mzz", "application/x-vnd.audioexplosion.mzz"],
    ["n-gage", "application/vnd.nokia.n-gage.symbian.install"],
    ["n3", "text/n3"],
    ["nap", "image/naplps"],
    ["naplps", "image/naplps"],
    ["nbp", "application/vnd.wolfram.player"],
    ["nc", "application/x-netcdf"],
    ["ncm", "application/vnd.nokia.configuration-message"],
    ["ncx", "application/x-dtbncx+xml"],
    ["ngdat", "application/vnd.nokia.n-gage.data"],
    ["nif", "image/x-niff"],
    ["niff", "image/x-niff"],
    ["nix", "application/x-mix-transfer"],
    ["nlu", "application/vnd.neurolanguage.nlu"],
    ["nml", "application/vnd.enliven"],
    ["nnd", "application/vnd.noblenet-directory"],
    ["nns", "application/vnd.noblenet-sealer"],
    ["nnw", "application/vnd.noblenet-web"],
    ["npx", "image/vnd.net-fpx"],
    ["nsc", "application/x-conference"],
    ["nsf", "application/vnd.lotus-notes"],
    ["nvd", "application/x-navidoc"],
    ["nws", "message/rfc822"],
    ["o", "application/octet-stream"],
    ["oa2", "application/vnd.fujitsu.oasys2"],
    ["oa3", "application/vnd.fujitsu.oasys3"],
    ["oas", "application/vnd.fujitsu.oasys"],
    ["obd", "application/x-msbinder"],
    ["oda", "application/oda"],
    ["odb", "application/vnd.oasis.opendocument.database"],
    ["odc", "application/vnd.oasis.opendocument.chart"],
    ["odf", "application/vnd.oasis.opendocument.formula"],
    ["odft", "application/vnd.oasis.opendocument.formula-template"],
    ["odg", "application/vnd.oasis.opendocument.graphics"],
    ["odi", "application/vnd.oasis.opendocument.image"],
    ["odm", "application/vnd.oasis.opendocument.text-master"],
    ["odp", "application/vnd.oasis.opendocument.presentation"],
    ["ods", "application/vnd.oasis.opendocument.spreadsheet"],
    ["odt", "application/vnd.oasis.opendocument.text"],
    ["oga", "audio/ogg"],
    ["ogv", "video/ogg"],
    ["ogx", "application/ogg"],
    ["omc", "application/x-omc"],
    ["omcd", "application/x-omcdatamaker"],
    ["omcr", "application/x-omcregerator"],
    ["onetoc", "application/onenote"],
    ["opf", "application/oebps-package+xml"],
    ["org", "application/vnd.lotus-organizer"],
    ["osf", "application/vnd.yamaha.openscoreformat"],
    ["osfpvg", "application/vnd.yamaha.openscoreformat.osfpvg+xml"],
    ["otc", "application/vnd.oasis.opendocument.chart-template"],
    ["otf", "application/x-font-otf"],
    ["otg", "application/vnd.oasis.opendocument.graphics-template"],
    ["oth", "application/vnd.oasis.opendocument.text-web"],
    ["oti", "application/vnd.oasis.opendocument.image-template"],
    ["otp", "application/vnd.oasis.opendocument.presentation-template"],
    ["ots", "application/vnd.oasis.opendocument.spreadsheet-template"],
    ["ott", "application/vnd.oasis.opendocument.text-template"],
    ["oxt", "application/vnd.openofficeorg.extension"],
    ["p", "text/x-pascal"],
    ["p10", ["application/pkcs10", "application/x-pkcs10"]],
    ["p12", ["application/pkcs-12", "application/x-pkcs12"]],
    ["p7a", "application/x-pkcs7-signature"],
    ["p7b", "application/x-pkcs7-certificates"],
    ["p7c", ["application/pkcs7-mime", "application/x-pkcs7-mime"]],
    ["p7m", ["application/pkcs7-mime", "application/x-pkcs7-mime"]],
    ["p7r", "application/x-pkcs7-certreqresp"],
    ["p7s", ["application/pkcs7-signature", "application/x-pkcs7-signature"]],
    ["p8", "application/pkcs8"],
    ["par", "text/plain-bas"],
    ["part", "application/pro_eng"],
    ["pas", "text/pascal"],
    ["paw", "application/vnd.pawaafile"],
    ["pbd", "application/vnd.powerbuilder6"],
    ["pbm", "image/x-portable-bitmap"],
    ["pcf", "application/x-font-pcf"],
    ["pcl", ["application/vnd.hp-pcl", "application/x-pcl"]],
    ["pclxl", "application/vnd.hp-pclxl"],
    ["pct", "image/x-pict"],
    ["pcurl", "application/vnd.curl.pcurl"],
    ["pcx", "image/x-pcx"],
    ["pdb", ["application/vnd.palm", "chemical/x-pdb"]],
    ["pdf", "application/pdf"],
    ["pfa", "application/x-font-type1"],
    ["pfr", "application/font-tdpfr"],
    ["pfunk", ["audio/make", "audio/make.my.funk"]],
    ["pfx", "application/x-pkcs12"],
    ["pgm", ["image/x-portable-graymap", "image/x-portable-greymap"]],
    ["pgn", "application/x-chess-pgn"],
    ["pgp", "application/pgp-signature"],
    ["pic", ["image/pict", "image/x-pict"]],
    ["pict", "image/pict"],
    ["pkg", "application/x-newton-compatible-pkg"],
    ["pki", "application/pkixcmp"],
    ["pkipath", "application/pkix-pkipath"],
    ["pko", ["application/ynd.ms-pkipko", "application/vnd.ms-pki.pko"]],
    ["pl", ["text/plain", "text/x-script.perl"]],
    ["plb", "application/vnd.3gpp.pic-bw-large"],
    ["plc", "application/vnd.mobius.plc"],
    ["plf", "application/vnd.pocketlearn"],
    ["pls", "application/pls+xml"],
    ["plx", "application/x-pixclscript"],
    ["pm", ["text/x-script.perl-module", "image/x-xpixmap"]],
    ["pm4", "application/x-pagemaker"],
    ["pm5", "application/x-pagemaker"],
    ["pma", "application/x-perfmon"],
    ["pmc", "application/x-perfmon"],
    ["pml", ["application/vnd.ctc-posml", "application/x-perfmon"]],
    ["pmr", "application/x-perfmon"],
    ["pmw", "application/x-perfmon"],
    ["png", "image/png"],
    ["pnm", ["application/x-portable-anymap", "image/x-portable-anymap"]],
    ["portpkg", "application/vnd.macports.portpkg"],
    ["pot", ["application/vnd.ms-powerpoint", "application/mspowerpoint"]],
    ["potm", "application/vnd.ms-powerpoint.template.macroenabled.12"],
    ["potx", "application/vnd.openxmlformats-officedocument.presentationml.template"],
    ["pov", "model/x-pov"],
    ["ppa", "application/vnd.ms-powerpoint"],
    ["ppam", "application/vnd.ms-powerpoint.addin.macroenabled.12"],
    ["ppd", "application/vnd.cups-ppd"],
    ["ppm", "image/x-portable-pixmap"],
    ["pps", ["application/vnd.ms-powerpoint", "application/mspowerpoint"]],
    ["ppsm", "application/vnd.ms-powerpoint.slideshow.macroenabled.12"],
    ["ppsx", "application/vnd.openxmlformats-officedocument.presentationml.slideshow"],
    ["ppt", ["application/vnd.ms-powerpoint", "application/mspowerpoint", "application/powerpoint", "application/x-mspowerpoint"]],
    ["pptm", "application/vnd.ms-powerpoint.presentation.macroenabled.12"],
    ["pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation"],
    ["ppz", "application/mspowerpoint"],
    ["prc", "application/x-mobipocket-ebook"],
    ["pre", ["application/vnd.lotus-freelance", "application/x-freelance"]],
    ["prf", "application/pics-rules"],
    ["prt", "application/pro_eng"],
    ["ps", "application/postscript"],
    ["psb", "application/vnd.3gpp.pic-bw-small"],
    ["psd", ["application/octet-stream", "image/vnd.adobe.photoshop"]],
    ["psf", "application/x-font-linux-psf"],
    ["pskcxml", "application/pskc+xml"],
    ["ptid", "application/vnd.pvi.ptid1"],
    ["pub", "application/x-mspublisher"],
    ["pvb", "application/vnd.3gpp.pic-bw-var"],
    ["pvu", "paleovu/x-pv"],
    ["pwn", "application/vnd.3m.post-it-notes"],
    ["pwz", "application/vnd.ms-powerpoint"],
    ["py", "text/x-script.phyton"],
    ["pya", "audio/vnd.ms-playready.media.pya"],
    ["pyc", "application/x-bytecode.python"],
    ["pyv", "video/vnd.ms-playready.media.pyv"],
    ["qam", "application/vnd.epson.quickanime"],
    ["qbo", "application/vnd.intu.qbo"],
    ["qcp", "audio/vnd.qcelp"],
    ["qd3", "x-world/x-3dmf"],
    ["qd3d", "x-world/x-3dmf"],
    ["qfx", "application/vnd.intu.qfx"],
    ["qif", "image/x-quicktime"],
    ["qps", "application/vnd.publishare-delta-tree"],
    ["qt", "video/quicktime"],
    ["qtc", "video/x-qtc"],
    ["qti", "image/x-quicktime"],
    ["qtif", "image/x-quicktime"],
    ["qxd", "application/vnd.quark.quarkxpress"],
    ["ra", ["audio/x-realaudio", "audio/x-pn-realaudio", "audio/x-pn-realaudio-plugin"]],
    ["ram", "audio/x-pn-realaudio"],
    ["rar", "application/x-rar-compressed"],
    ["ras", ["image/cmu-raster", "application/x-cmu-raster", "image/x-cmu-raster"]],
    ["rast", "image/cmu-raster"],
    ["rcprofile", "application/vnd.ipunplugged.rcprofile"],
    ["rdf", "application/rdf+xml"],
    ["rdz", "application/vnd.data-vision.rdz"],
    ["rep", "application/vnd.businessobjects"],
    ["res", "application/x-dtbresource+xml"],
    ["rexx", "text/x-script.rexx"],
    ["rf", "image/vnd.rn-realflash"],
    ["rgb", "image/x-rgb"],
    ["rif", "application/reginfo+xml"],
    ["rip", "audio/vnd.rip"],
    ["rl", "application/resource-lists+xml"],
    ["rlc", "image/vnd.fujixerox.edmics-rlc"],
    ["rld", "application/resource-lists-diff+xml"],
    ["rm", ["application/vnd.rn-realmedia", "audio/x-pn-realaudio"]],
    ["rmi", "audio/mid"],
    ["rmm", "audio/x-pn-realaudio"],
    ["rmp", ["audio/x-pn-realaudio-plugin", "audio/x-pn-realaudio"]],
    ["rms", "application/vnd.jcp.javame.midlet-rms"],
    ["rnc", "application/relax-ng-compact-syntax"],
    ["rng", ["application/ringing-tones", "application/vnd.nokia.ringing-tone"]],
    ["rnx", "application/vnd.rn-realplayer"],
    ["roff", "application/x-troff"],
    ["rp", "image/vnd.rn-realpix"],
    ["rp9", "application/vnd.cloanto.rp9"],
    ["rpm", "audio/x-pn-realaudio-plugin"],
    ["rpss", "application/vnd.nokia.radio-presets"],
    ["rpst", "application/vnd.nokia.radio-preset"],
    ["rq", "application/sparql-query"],
    ["rs", "application/rls-services+xml"],
    ["rsd", "application/rsd+xml"],
    ["rt", ["text/richtext", "text/vnd.rn-realtext"]],
    ["rtf", ["application/rtf", "text/richtext", "application/x-rtf"]],
    ["rtx", ["text/richtext", "application/rtf"]],
    ["rv", "video/vnd.rn-realvideo"],
    ["s", "text/x-asm"],
    ["s3m", "audio/s3m"],
    ["saf", "application/vnd.yamaha.smaf-audio"],
    ["saveme", "application/octet-stream"],
    ["sbk", "application/x-tbook"],
    ["sbml", "application/sbml+xml"],
    ["sc", "application/vnd.ibm.secure-container"],
    ["scd", "application/x-msschedule"],
    ["scm", ["application/vnd.lotus-screencam", "video/x-scm", "text/x-script.guile", "application/x-lotusscreencam", "text/x-script.scheme"]],
    ["scq", "application/scvp-cv-request"],
    ["scs", "application/scvp-cv-response"],
    ["sct", "text/scriptlet"],
    ["scurl", "text/vnd.curl.scurl"],
    ["sda", "application/vnd.stardivision.draw"],
    ["sdc", "application/vnd.stardivision.calc"],
    ["sdd", "application/vnd.stardivision.impress"],
    ["sdkm", "application/vnd.solent.sdkm+xml"],
    ["sdml", "text/plain"],
    ["sdp", ["application/sdp", "application/x-sdp"]],
    ["sdr", "application/sounder"],
    ["sdw", "application/vnd.stardivision.writer"],
    ["sea", ["application/sea", "application/x-sea"]],
    ["see", "application/vnd.seemail"],
    ["seed", "application/vnd.fdsn.seed"],
    ["sema", "application/vnd.sema"],
    ["semd", "application/vnd.semd"],
    ["semf", "application/vnd.semf"],
    ["ser", "application/java-serialized-object"],
    ["set", "application/set"],
    ["setpay", "application/set-payment-initiation"],
    ["setreg", "application/set-registration-initiation"],
    ["sfd-hdstx", "application/vnd.hydrostatix.sof-data"],
    ["sfs", "application/vnd.spotfire.sfs"],
    ["sgl", "application/vnd.stardivision.writer-global"],
    ["sgm", ["text/sgml", "text/x-sgml"]],
    ["sgml", ["text/sgml", "text/x-sgml"]],
    ["sh", ["application/x-shar", "application/x-bsh", "application/x-sh", "text/x-script.sh"]],
    ["shar", ["application/x-bsh", "application/x-shar"]],
    ["shf", "application/shf+xml"],
    ["shtml", ["text/html", "text/x-server-parsed-html"]],
    ["sid", "audio/x-psid"],
    ["sis", "application/vnd.symbian.install"],
    ["sit", ["application/x-stuffit", "application/x-sit"]],
    ["sitx", "application/x-stuffitx"],
    ["skd", "application/x-koan"],
    ["skm", "application/x-koan"],
    ["skp", ["application/vnd.koan", "application/x-koan"]],
    ["skt", "application/x-koan"],
    ["sl", "application/x-seelogo"],
    ["sldm", "application/vnd.ms-powerpoint.slide.macroenabled.12"],
    ["sldx", "application/vnd.openxmlformats-officedocument.presentationml.slide"],
    ["slt", "application/vnd.epson.salt"],
    ["sm", "application/vnd.stepmania.stepchart"],
    ["smf", "application/vnd.stardivision.math"],
    ["smi", ["application/smil", "application/smil+xml"]],
    ["smil", "application/smil"],
    ["snd", ["audio/basic", "audio/x-adpcm"]],
    ["snf", "application/x-font-snf"],
    ["sol", "application/solids"],
    ["spc", ["text/x-speech", "application/x-pkcs7-certificates"]],
    ["spf", "application/vnd.yamaha.smaf-phrase"],
    ["spl", ["application/futuresplash", "application/x-futuresplash"]],
    ["spot", "text/vnd.in3d.spot"],
    ["spp", "application/scvp-vp-response"],
    ["spq", "application/scvp-vp-request"],
    ["spr", "application/x-sprite"],
    ["sprite", "application/x-sprite"],
    ["src", "application/x-wais-source"],
    ["sru", "application/sru+xml"],
    ["srx", "application/sparql-results+xml"],
    ["sse", "application/vnd.kodak-descriptor"],
    ["ssf", "application/vnd.epson.ssf"],
    ["ssi", "text/x-server-parsed-html"],
    ["ssm", "application/streamingmedia"],
    ["ssml", "application/ssml+xml"],
    ["sst", ["application/vnd.ms-pkicertstore", "application/vnd.ms-pki.certstore"]],
    ["st", "application/vnd.sailingtracker.track"],
    ["stc", "application/vnd.sun.xml.calc.template"],
    ["std", "application/vnd.sun.xml.draw.template"],
    ["step", "application/step"],
    ["stf", "application/vnd.wt.stf"],
    ["sti", "application/vnd.sun.xml.impress.template"],
    ["stk", "application/hyperstudio"],
    ["stl", ["application/vnd.ms-pkistl", "application/sla", "application/vnd.ms-pki.stl", "application/x-navistyle"]],
    ["stm", "text/html"],
    ["stp", "application/step"],
    ["str", "application/vnd.pg.format"],
    ["stw", "application/vnd.sun.xml.writer.template"],
    ["sub", "image/vnd.dvb.subtitle"],
    ["sus", "application/vnd.sus-calendar"],
    ["sv4cpio", "application/x-sv4cpio"],
    ["sv4crc", "application/x-sv4crc"],
    ["svc", "application/vnd.dvb.service"],
    ["svd", "application/vnd.svd"],
    ["svf", ["image/vnd.dwg", "image/x-dwg"]],
    ["svg", "image/svg+xml"],
    ["svr", ["x-world/x-svr", "application/x-world"]],
    ["swf", "application/x-shockwave-flash"],
    ["swi", "application/vnd.aristanetworks.swi"],
    ["sxc", "application/vnd.sun.xml.calc"],
    ["sxd", "application/vnd.sun.xml.draw"],
    ["sxg", "application/vnd.sun.xml.writer.global"],
    ["sxi", "application/vnd.sun.xml.impress"],
    ["sxm", "application/vnd.sun.xml.math"],
    ["sxw", "application/vnd.sun.xml.writer"],
    ["t", ["text/troff", "application/x-troff"]],
    ["talk", "text/x-speech"],
    ["tao", "application/vnd.tao.intent-module-archive"],
    ["tar", "application/x-tar"],
    ["tbk", ["application/toolbook", "application/x-tbook"]],
    ["tcap", "application/vnd.3gpp2.tcap"],
    ["tcl", ["text/x-script.tcl", "application/x-tcl"]],
    ["tcsh", "text/x-script.tcsh"],
    ["teacher", "application/vnd.smart.teacher"],
    ["tei", "application/tei+xml"],
    ["tex", "application/x-tex"],
    ["texi", "application/x-texinfo"],
    ["texinfo", "application/x-texinfo"],
    ["text", ["application/plain", "text/plain"]],
    ["tfi", "application/thraud+xml"],
    ["tfm", "application/x-tex-tfm"],
    ["tgz", ["application/gnutar", "application/x-compressed"]],
    ["thmx", "application/vnd.ms-officetheme"],
    ["tif", ["image/tiff", "image/x-tiff"]],
    ["tiff", ["image/tiff", "image/x-tiff"]],
    ["tmo", "application/vnd.tmobile-livetv"],
    ["torrent", "application/x-bittorrent"],
    ["tpl", "application/vnd.groove-tool-template"],
    ["tpt", "application/vnd.trid.tpt"],
    ["tr", "application/x-troff"],
    ["tra", "application/vnd.trueapp"],
    ["trm", "application/x-msterminal"],
    ["tsd", "application/timestamped-data"],
    ["tsi", "audio/tsp-audio"],
    ["tsp", ["application/dsptype", "audio/tsplayer"]],
    ["tsv", "text/tab-separated-values"],
    ["ttf", "application/x-font-ttf"],
    ["ttl", "text/turtle"],
    ["turbot", "image/florian"],
    ["twd", "application/vnd.simtech-mindmapper"],
    ["txd", "application/vnd.genomatix.tuxedo"],
    ["txf", "application/vnd.mobius.txf"],
    ["txt", "text/plain"],
    ["ufd", "application/vnd.ufdl"],
    ["uil", "text/x-uil"],
    ["uls", "text/iuls"],
    ["umj", "application/vnd.umajin"],
    ["uni", "text/uri-list"],
    ["unis", "text/uri-list"],
    ["unityweb", "application/vnd.unity"],
    ["unv", "application/i-deas"],
    ["uoml", "application/vnd.uoml+xml"],
    ["uri", "text/uri-list"],
    ["uris", "text/uri-list"],
    ["ustar", ["application/x-ustar", "multipart/x-ustar"]],
    ["utz", "application/vnd.uiq.theme"],
    ["uu", ["application/octet-stream", "text/x-uuencode"]],
    ["uue", "text/x-uuencode"],
    ["uva", "audio/vnd.dece.audio"],
    ["uvh", "video/vnd.dece.hd"],
    ["uvi", "image/vnd.dece.graphic"],
    ["uvm", "video/vnd.dece.mobile"],
    ["uvp", "video/vnd.dece.pd"],
    ["uvs", "video/vnd.dece.sd"],
    ["uvu", "video/vnd.uvvu.mp4"],
    ["uvv", "video/vnd.dece.video"],
    ["vcd", "application/x-cdlink"],
    ["vcf", "text/x-vcard"],
    ["vcg", "application/vnd.groove-vcard"],
    ["vcs", "text/x-vcalendar"],
    ["vcx", "application/vnd.vcx"],
    ["vda", "application/vda"],
    ["vdo", "video/vdo"],
    ["vew", "application/groupwise"],
    ["vis", "application/vnd.visionary"],
    ["viv", ["video/vivo", "video/vnd.vivo"]],
    ["vivo", ["video/vivo", "video/vnd.vivo"]],
    ["vmd", "application/vocaltec-media-desc"],
    ["vmf", "application/vocaltec-media-file"],
    ["voc", ["audio/voc", "audio/x-voc"]],
    ["vos", "video/vosaic"],
    ["vox", "audio/voxware"],
    ["vqe", "audio/x-twinvq-plugin"],
    ["vqf", "audio/x-twinvq"],
    ["vql", "audio/x-twinvq-plugin"],
    ["vrml", ["model/vrml", "x-world/x-vrml", "application/x-vrml"]],
    ["vrt", "x-world/x-vrt"],
    ["vsd", ["application/vnd.visio", "application/x-visio"]],
    ["vsf", "application/vnd.vsf"],
    ["vst", "application/x-visio"],
    ["vsw", "application/x-visio"],
    ["vtu", "model/vnd.vtu"],
    ["vxml", "application/voicexml+xml"],
    ["w60", "application/wordperfect6.0"],
    ["w61", "application/wordperfect6.1"],
    ["w6w", "application/msword"],
    ["wad", "application/x-doom"],
    ["wav", ["audio/wav", "audio/x-wav"]],
    ["wax", "audio/x-ms-wax"],
    ["wb1", "application/x-qpro"],
    ["wbmp", "image/vnd.wap.wbmp"],
    ["wbs", "application/vnd.criticaltools.wbs+xml"],
    ["wbxml", "application/vnd.wap.wbxml"],
    ["wcm", "application/vnd.ms-works"],
    ["wdb", "application/vnd.ms-works"],
    ["web", "application/vnd.xara"],
    ["weba", "audio/webm"],
    ["webm", "video/webm"],
    ["webp", "image/webp"],
    ["wg", "application/vnd.pmi.widget"],
    ["wgt", "application/widget"],
    ["wiz", "application/msword"],
    ["wk1", "application/x-123"],
    ["wks", "application/vnd.ms-works"],
    ["wm", "video/x-ms-wm"],
    ["wma", "audio/x-ms-wma"],
    ["wmd", "application/x-ms-wmd"],
    ["wmf", ["windows/metafile", "application/x-msmetafile"]],
    ["wml", "text/vnd.wap.wml"],
    ["wmlc", "application/vnd.wap.wmlc"],
    ["wmls", "text/vnd.wap.wmlscript"],
    ["wmlsc", "application/vnd.wap.wmlscriptc"],
    ["wmv", "video/x-ms-wmv"],
    ["wmx", "video/x-ms-wmx"],
    ["wmz", "application/x-ms-wmz"],
    ["woff", "application/x-font-woff"],
    ["word", "application/msword"],
    ["wp", "application/wordperfect"],
    ["wp5", ["application/wordperfect", "application/wordperfect6.0"]],
    ["wp6", "application/wordperfect"],
    ["wpd", ["application/wordperfect", "application/vnd.wordperfect", "application/x-wpwin"]],
    ["wpl", "application/vnd.ms-wpl"],
    ["wps", "application/vnd.ms-works"],
    ["wq1", "application/x-lotus"],
    ["wqd", "application/vnd.wqd"],
    ["wri", ["application/mswrite", "application/x-wri", "application/x-mswrite"]],
    ["wrl", ["model/vrml", "x-world/x-vrml", "application/x-world"]],
    ["wrz", ["model/vrml", "x-world/x-vrml"]],
    ["wsc", "text/scriplet"],
    ["wsdl", "application/wsdl+xml"],
    ["wspolicy", "application/wspolicy+xml"],
    ["wsrc", "application/x-wais-source"],
    ["wtb", "application/vnd.webturbo"],
    ["wtk", "application/x-wintalk"],
    ["wvx", "video/x-ms-wvx"],
    ["x-png", "image/png"],
    ["x3d", "application/vnd.hzn-3d-crossword"],
    ["xaf", "x-world/x-vrml"],
    ["xap", "application/x-silverlight-app"],
    ["xar", "application/vnd.xara"],
    ["xbap", "application/x-ms-xbap"],
    ["xbd", "application/vnd.fujixerox.docuworks.binder"],
    ["xbm", ["image/xbm", "image/x-xbm", "image/x-xbitmap"]],
    ["xdf", "application/xcap-diff+xml"],
    ["xdm", "application/vnd.syncml.dm+xml"],
    ["xdp", "application/vnd.adobe.xdp+xml"],
    ["xdr", "video/x-amt-demorun"],
    ["xdssc", "application/dssc+xml"],
    ["xdw", "application/vnd.fujixerox.docuworks"],
    ["xenc", "application/xenc+xml"],
    ["xer", "application/patch-ops-error+xml"],
    ["xfdf", "application/vnd.adobe.xfdf"],
    ["xfdl", "application/vnd.xfdl"],
    ["xgz", "xgl/drawing"],
    ["xhtml", "application/xhtml+xml"],
    ["xif", "image/vnd.xiff"],
    ["xl", "application/excel"],
    ["xla", ["application/vnd.ms-excel", "application/excel", "application/x-msexcel", "application/x-excel"]],
    ["xlam", "application/vnd.ms-excel.addin.macroenabled.12"],
    ["xlb", ["application/excel", "application/vnd.ms-excel", "application/x-excel"]],
    ["xlc", ["application/vnd.ms-excel", "application/excel", "application/x-excel"]],
    ["xld", ["application/excel", "application/x-excel"]],
    ["xlk", ["application/excel", "application/x-excel"]],
    ["xll", ["application/excel", "application/vnd.ms-excel", "application/x-excel"]],
    ["xlm", ["application/vnd.ms-excel", "application/excel", "application/x-excel"]],
    ["xls", ["application/vnd.ms-excel", "application/excel", "application/x-msexcel", "application/x-excel"]],
    ["xlsb", "application/vnd.ms-excel.sheet.binary.macroenabled.12"],
    ["xlsm", "application/vnd.ms-excel.sheet.macroenabled.12"],
    ["xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],
    ["xlt", ["application/vnd.ms-excel", "application/excel", "application/x-excel"]],
    ["xltm", "application/vnd.ms-excel.template.macroenabled.12"],
    ["xltx", "application/vnd.openxmlformats-officedocument.spreadsheetml.template"],
    ["xlv", ["application/excel", "application/x-excel"]],
    ["xlw", ["application/vnd.ms-excel", "application/excel", "application/x-msexcel", "application/x-excel"]],
    ["xm", "audio/xm"],
    ["xml", ["application/xml", "text/xml", "application/atom+xml", "application/rss+xml"]],
    ["xmz", "xgl/movie"],
    ["xo", "application/vnd.olpc-sugar"],
    ["xof", "x-world/x-vrml"],
    ["xop", "application/xop+xml"],
    ["xpi", "application/x-xpinstall"],
    ["xpix", "application/x-vnd.ls-xpix"],
    ["xpm", ["image/xpm", "image/x-xpixmap"]],
    ["xpr", "application/vnd.is-xpr"],
    ["xps", "application/vnd.ms-xpsdocument"],
    ["xpw", "application/vnd.intercon.formnet"],
    ["xslt", "application/xslt+xml"],
    ["xsm", "application/vnd.syncml+xml"],
    ["xspf", "application/xspf+xml"],
    ["xsr", "video/x-amt-showrun"],
    ["xul", "application/vnd.mozilla.xul+xml"],
    ["xwd", ["image/x-xwd", "image/x-xwindowdump"]],
    ["xyz", ["chemical/x-xyz", "chemical/x-pdb"]],
    ["yang", "application/yang"],
    ["yin", "application/yin+xml"],
    ["z", ["application/x-compressed", "application/x-compress"]],
    ["zaz", "application/vnd.zzazz.deck+xml"],
    ["zip", ["application/zip", "multipart/x-zip", "application/x-zip-compressed", "application/x-compressed"]],
    ["zir", "application/vnd.zul"],
    ["zmm", "application/vnd.handheld-entertainment+xml"],
    ["zoo", "application/octet-stream"],
    ["zsh", "text/x-script.zsh"]
  ]);
  module.exports = {
    detectMimeType(filename) {
      if (!filename) {
        return defaultMimeType;
      }
      let parsed = path.parse(filename);
      let extension = (parsed.ext.substr(1) || parsed.name || "").split("?").shift().trim().toLowerCase();
      let value = defaultMimeType;
      if (extensions.has(extension)) {
        value = extensions.get(extension);
      }
      if (Array.isArray(value)) {
        return value[0];
      }
      return value;
    },
    detectExtension(mimeType) {
      if (!mimeType) {
        return defaultExtension;
      }
      let parts = (mimeType || "").toLowerCase().trim().split("/");
      let rootType = parts.shift().trim();
      let subType = parts.join("/").trim();
      if (mimeTypes.has(rootType + "/" + subType)) {
        let value = mimeTypes.get(rootType + "/" + subType);
        if (Array.isArray(value)) {
          return value[0];
        }
        return value;
      }
      switch (rootType) {
        case "text":
          return "txt";
        default:
          return "bin";
      }
    }
  };
});

// node_modules/nodemailer/lib/punycode/index.js
var require_punycode2 = __commonJS((exports, module) => {
  function error(type) {
    throw new RangeError(errors[type]);
  }
  function map(array, callback) {
    const result = [];
    let length = array.length;
    while (length--) {
      result[length] = callback(array[length]);
    }
    return result;
  }
  function mapDomain(domain, callback) {
    const parts = domain.split("@");
    let result = "";
    if (parts.length > 1) {
      result = parts[0] + "@";
      domain = parts[1];
    }
    domain = domain.replace(regexSeparators, ".");
    const labels = domain.split(".");
    const encoded = map(labels, callback).join(".");
    return result + encoded;
  }
  function ucs2decode(string) {
    const output = [];
    let counter = 0;
    const length = string.length;
    while (counter < length) {
      const value = string.charCodeAt(counter++);
      if (value >= 55296 && value <= 56319 && counter < length) {
        const extra = string.charCodeAt(counter++);
        if ((extra & 64512) == 56320) {
          output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  }
  var maxInt = 2147483647;
  var base = 36;
  var tMin = 1;
  var tMax = 26;
  var skew = 38;
  var damp = 700;
  var initialBias = 72;
  var initialN = 128;
  var delimiter = "-";
  var regexPunycode = /^xn--/;
  var regexNonASCII = /[^\0-\x7F]/;
  var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
  var errors = {
    overflow: "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
  };
  var baseMinusTMin = base - tMin;
  var floor = Math.floor;
  var stringFromCharCode = String.fromCharCode;
  var ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
  var basicToDigit = function(codePoint) {
    if (codePoint >= 48 && codePoint < 58) {
      return 26 + (codePoint - 48);
    }
    if (codePoint >= 65 && codePoint < 91) {
      return codePoint - 65;
    }
    if (codePoint >= 97 && codePoint < 123) {
      return codePoint - 97;
    }
    return base;
  };
  var digitToBasic = function(digit, flag) {
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  };
  var adapt = function(delta, numPoints, firstTime) {
    let k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    for (;delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }
    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  };
  var decode = function(input) {
    const output = [];
    const inputLength = input.length;
    let i = 0;
    let n = initialN;
    let bias = initialBias;
    let basic = input.lastIndexOf(delimiter);
    if (basic < 0) {
      basic = 0;
    }
    for (let j = 0;j < basic; ++j) {
      if (input.charCodeAt(j) >= 128) {
        error("not-basic");
      }
      output.push(input.charCodeAt(j));
    }
    for (let index = basic > 0 ? basic + 1 : 0;index < inputLength; ) {
      const oldi = i;
      for (let w = 1, k = base;; k += base) {
        if (index >= inputLength) {
          error("invalid-input");
        }
        const digit = basicToDigit(input.charCodeAt(index++));
        if (digit >= base) {
          error("invalid-input");
        }
        if (digit > floor((maxInt - i) / w)) {
          error("overflow");
        }
        i += digit * w;
        const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
        if (digit < t) {
          break;
        }
        const baseMinusT = base - t;
        if (w > floor(maxInt / baseMinusT)) {
          error("overflow");
        }
        w *= baseMinusT;
      }
      const out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0);
      if (floor(i / out) > maxInt - n) {
        error("overflow");
      }
      n += floor(i / out);
      i %= out;
      output.splice(i++, 0, n);
    }
    return String.fromCodePoint(...output);
  };
  var encode = function(input) {
    const output = [];
    input = ucs2decode(input);
    const inputLength = input.length;
    let n = initialN;
    let delta = 0;
    let bias = initialBias;
    for (const currentValue of input) {
      if (currentValue < 128) {
        output.push(stringFromCharCode(currentValue));
      }
    }
    const basicLength = output.length;
    let handledCPCount = basicLength;
    if (basicLength) {
      output.push(delimiter);
    }
    while (handledCPCount < inputLength) {
      let m = maxInt;
      for (const currentValue of input) {
        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      }
      const handledCPCountPlusOne = handledCPCount + 1;
      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error("overflow");
      }
      delta += (m - n) * handledCPCountPlusOne;
      n = m;
      for (const currentValue of input) {
        if (currentValue < n && ++delta > maxInt) {
          error("overflow");
        }
        if (currentValue === n) {
          let q = delta;
          for (let k = base;; k += base) {
            const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (q < t) {
              break;
            }
            const qMinusT = q - t;
            const baseMinusT = base - t;
            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
            q = floor(qMinusT / baseMinusT);
          }
          output.push(stringFromCharCode(digitToBasic(q, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }
      ++delta;
      ++n;
    }
    return output.join("");
  };
  var toUnicode = function(input) {
    return mapDomain(input, function(string) {
      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
  };
  var toASCII = function(input) {
    return mapDomain(input, function(string) {
      return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
    });
  };
  var punycode = {
    version: "2.3.1",
    ucs2: {
      decode: ucs2decode,
      encode: ucs2encode
    },
    decode,
    encode,
    toASCII,
    toUnicode
  };
  module.exports = punycode;
});

// node_modules/nodemailer/lib/base64/index.js
var require_base64 = __commonJS((exports, module) => {
  function encode(buffer) {
    if (typeof buffer === "string") {
      buffer = Buffer.from(buffer, "utf-8");
    }
    return buffer.toString("base64");
  }
  function wrap(str, lineLength) {
    str = (str || "").toString();
    lineLength = lineLength || 76;
    if (str.length <= lineLength) {
      return str;
    }
    let result = [];
    let pos = 0;
    let chunkLength = lineLength * 1024;
    while (pos < str.length) {
      let wrappedLines = str.substr(pos, chunkLength).replace(new RegExp(".{" + lineLength + "}", "g"), "$&\r\n").trim();
      result.push(wrappedLines);
      pos += chunkLength;
    }
    return result.join("\r\n").trim();
  }
  var Transform = import.meta.require("stream").Transform;

  class Encoder extends Transform {
    constructor(options) {
      super();
      this.options = options || {};
      if (this.options.lineLength !== false) {
        this.options.lineLength = this.options.lineLength || 76;
      }
      this._curLine = "";
      this._remainingBytes = false;
      this.inputBytes = 0;
      this.outputBytes = 0;
    }
    _transform(chunk, encoding, done) {
      if (encoding !== "buffer") {
        chunk = Buffer.from(chunk, encoding);
      }
      if (!chunk || !chunk.length) {
        return setImmediate(done);
      }
      this.inputBytes += chunk.length;
      if (this._remainingBytes && this._remainingBytes.length) {
        chunk = Buffer.concat([this._remainingBytes, chunk], this._remainingBytes.length + chunk.length);
        this._remainingBytes = false;
      }
      if (chunk.length % 3) {
        this._remainingBytes = chunk.slice(chunk.length - chunk.length % 3);
        chunk = chunk.slice(0, chunk.length - chunk.length % 3);
      } else {
        this._remainingBytes = false;
      }
      let b64 = this._curLine + encode(chunk);
      if (this.options.lineLength) {
        b64 = wrap(b64, this.options.lineLength);
        let lastLF = b64.lastIndexOf("\n");
        if (lastLF < 0) {
          this._curLine = b64;
          b64 = "";
        } else if (lastLF === b64.length - 1) {
          this._curLine = "";
        } else {
          this._curLine = b64.substr(lastLF + 1);
          b64 = b64.substr(0, lastLF + 1);
        }
      }
      if (b64) {
        this.outputBytes += b64.length;
        this.push(Buffer.from(b64, "ascii"));
      }
      setImmediate(done);
    }
    _flush(done) {
      if (this._remainingBytes && this._remainingBytes.length) {
        this._curLine += encode(this._remainingBytes);
      }
      if (this._curLine) {
        this._curLine = wrap(this._curLine, this.options.lineLength);
        this.outputBytes += this._curLine.length;
        this.push(this._curLine, "ascii");
        this._curLine = "";
      }
      done();
    }
  }
  module.exports = {
    encode,
    wrap,
    Encoder
  };
});

// node_modules/nodemailer/lib/qp/index.js
var require_qp = __commonJS((exports, module) => {
  function encode(buffer) {
    if (typeof buffer === "string") {
      buffer = Buffer.from(buffer, "utf-8");
    }
    let ranges = [
      [9],
      [10],
      [13],
      [32, 60],
      [62, 126]
    ];
    let result = "";
    let ord;
    for (let i = 0, len = buffer.length;i < len; i++) {
      ord = buffer[i];
      if (checkRanges(ord, ranges) && !((ord === 32 || ord === 9) && (i === len - 1 || buffer[i + 1] === 10 || buffer[i + 1] === 13))) {
        result += String.fromCharCode(ord);
        continue;
      }
      result += "=" + (ord < 16 ? "0" : "") + ord.toString(16).toUpperCase();
    }
    return result;
  }
  function wrap(str, lineLength) {
    str = (str || "").toString();
    lineLength = lineLength || 76;
    if (str.length <= lineLength) {
      return str;
    }
    let pos = 0;
    let len = str.length;
    let match, code, line;
    let lineMargin = Math.floor(lineLength / 3);
    let result = "";
    while (pos < len) {
      line = str.substr(pos, lineLength);
      if (match = line.match(/\r\n/)) {
        line = line.substr(0, match.index + match[0].length);
        result += line;
        pos += line.length;
        continue;
      }
      if (line.substr(-1) === "\n") {
        result += line;
        pos += line.length;
        continue;
      } else if (match = line.substr(-lineMargin).match(/\n.*?$/)) {
        line = line.substr(0, line.length - (match[0].length - 1));
        result += line;
        pos += line.length;
        continue;
      } else if (line.length > lineLength - lineMargin && (match = line.substr(-lineMargin).match(/[ \t.,!?][^ \t.,!?]*$/))) {
        line = line.substr(0, line.length - (match[0].length - 1));
      } else if (line.match(/[=][\da-f]{0,2}$/i)) {
        if (match = line.match(/[=][\da-f]{0,1}$/i)) {
          line = line.substr(0, line.length - match[0].length);
        }
        while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\da-f]{2}){1,4}$/i) && (match = line.match(/[=][\da-f]{2}$/gi))) {
          code = parseInt(match[0].substr(1, 2), 16);
          if (code < 128) {
            break;
          }
          line = line.substr(0, line.length - 3);
          if (code >= 192) {
            break;
          }
        }
      }
      if (pos + line.length < len && line.substr(-1) !== "\n") {
        if (line.length === lineLength && line.match(/[=][\da-f]{2}$/i)) {
          line = line.substr(0, line.length - 3);
        } else if (line.length === lineLength) {
          line = line.substr(0, line.length - 1);
        }
        pos += line.length;
        line += "=\r\n";
      } else {
        pos += line.length;
      }
      result += line;
    }
    return result;
  }
  function checkRanges(nr, ranges) {
    for (let i = ranges.length - 1;i >= 0; i--) {
      if (!ranges[i].length) {
        continue;
      }
      if (ranges[i].length === 1 && nr === ranges[i][0]) {
        return true;
      }
      if (ranges[i].length === 2 && nr >= ranges[i][0] && nr <= ranges[i][1]) {
        return true;
      }
    }
    return false;
  }
  var Transform = import.meta.require("stream").Transform;

  class Encoder extends Transform {
    constructor(options) {
      super();
      this.options = options || {};
      if (this.options.lineLength !== false) {
        this.options.lineLength = this.options.lineLength || 76;
      }
      this._curLine = "";
      this.inputBytes = 0;
      this.outputBytes = 0;
    }
    _transform(chunk, encoding, done) {
      let qp;
      if (encoding !== "buffer") {
        chunk = Buffer.from(chunk, encoding);
      }
      if (!chunk || !chunk.length) {
        return done();
      }
      this.inputBytes += chunk.length;
      if (this.options.lineLength) {
        qp = this._curLine + encode(chunk);
        qp = wrap(qp, this.options.lineLength);
        qp = qp.replace(/(^|\n)([^\n]*)$/, (match, lineBreak, lastLine) => {
          this._curLine = lastLine;
          return lineBreak;
        });
        if (qp) {
          this.outputBytes += qp.length;
          this.push(qp);
        }
      } else {
        qp = encode(chunk);
        this.outputBytes += qp.length;
        this.push(qp, "ascii");
      }
      done();
    }
    _flush(done) {
      if (this._curLine) {
        this.outputBytes += this._curLine.length;
        this.push(this._curLine, "ascii");
      }
      done();
    }
  }
  module.exports = {
    encode,
    wrap,
    Encoder
  };
});

// node_modules/nodemailer/lib/mime-funcs/index.js
var require_mime_funcs = __commonJS((exports, module) => {
  var base64 = require_base64();
  var qp = require_qp();
  var mimeTypes = require_mime_types();
  module.exports = {
    isPlainText(value, isParam) {
      const re = isParam ? /[\x00-\x08\x0b\x0c\x0e-\x1f"\u0080-\uFFFF]/ : /[\x00-\x08\x0b\x0c\x0e-\x1f\u0080-\uFFFF]/;
      if (typeof value !== "string" || re.test(value)) {
        return false;
      } else {
        return true;
      }
    },
    hasLongerLines(str, lineLength) {
      if (str.length > 128 * 1024) {
        return true;
      }
      return new RegExp("^.{" + (lineLength + 1) + ",}", "m").test(str);
    },
    encodeWord(data, mimeWordEncoding, maxLength) {
      mimeWordEncoding = (mimeWordEncoding || "Q").toString().toUpperCase().trim().charAt(0);
      maxLength = maxLength || 0;
      let encodedStr;
      let toCharset = "UTF-8";
      if (maxLength && maxLength > 7 + toCharset.length) {
        maxLength -= 7 + toCharset.length;
      }
      if (mimeWordEncoding === "Q") {
        encodedStr = qp.encode(data).replace(/[^a-z0-9!*+\-/=]/gi, (chr) => {
          let ord = chr.charCodeAt(0).toString(16).toUpperCase();
          if (chr === " ") {
            return "_";
          } else {
            return "=" + (ord.length === 1 ? "0" + ord : ord);
          }
        });
      } else if (mimeWordEncoding === "B") {
        encodedStr = typeof data === "string" ? data : base64.encode(data);
        maxLength = maxLength ? Math.max(3, (maxLength - maxLength % 4) / 4 * 3) : 0;
      }
      if (maxLength && (mimeWordEncoding !== "B" ? encodedStr : base64.encode(data)).length > maxLength) {
        if (mimeWordEncoding === "Q") {
          encodedStr = this.splitMimeEncodedString(encodedStr, maxLength).join("?= =?" + toCharset + "?" + mimeWordEncoding + "?");
        } else {
          let parts = [];
          let lpart = "";
          for (let i = 0, len = encodedStr.length;i < len; i++) {
            let chr = encodedStr.charAt(i);
            if (/[\ud83c\ud83d\ud83e]/.test(chr) && i < len - 1) {
              chr += encodedStr.charAt(++i);
            }
            if (Buffer.byteLength(lpart + chr) <= maxLength || i === 0) {
              lpart += chr;
            } else {
              parts.push(base64.encode(lpart));
              lpart = chr;
            }
          }
          if (lpart) {
            parts.push(base64.encode(lpart));
          }
          if (parts.length > 1) {
            encodedStr = parts.join("?= =?" + toCharset + "?" + mimeWordEncoding + "?");
          } else {
            encodedStr = parts.join("");
          }
        }
      } else if (mimeWordEncoding === "B") {
        encodedStr = base64.encode(data);
      }
      return "=?" + toCharset + "?" + mimeWordEncoding + "?" + encodedStr + (encodedStr.substr(-2) === "?=" ? "" : "?=");
    },
    encodeWords(value, mimeWordEncoding, maxLength, encodeAll) {
      maxLength = maxLength || 0;
      let encodedValue;
      let firstMatch = value.match(/(?:^|\s)([^\s]*["\u0080-\uFFFF])/);
      if (!firstMatch) {
        return value;
      }
      if (encodeAll) {
        return this.encodeWord(value, mimeWordEncoding, maxLength);
      }
      let lastMatch = value.match(/(["\u0080-\uFFFF][^\s]*)[^"\u0080-\uFFFF]*$/);
      if (!lastMatch) {
        return value;
      }
      let startIndex = firstMatch.index + (firstMatch[0].match(/[^\s]/) || {
        index: 0
      }).index;
      let endIndex = lastMatch.index + (lastMatch[1] || "").length;
      encodedValue = (startIndex ? value.substr(0, startIndex) : "") + this.encodeWord(value.substring(startIndex, endIndex), mimeWordEncoding || "Q", maxLength) + (endIndex < value.length ? value.substr(endIndex) : "");
      return encodedValue;
    },
    buildHeaderValue(structured) {
      let paramsArray = [];
      Object.keys(structured.params || {}).forEach((param) => {
        let value = structured.params[param];
        if (!this.isPlainText(value, true) || value.length >= 75) {
          this.buildHeaderParam(param, value, 50).forEach((encodedParam) => {
            if (!/[\s"\\;:/=(),<>@[\]?]|^[-']|'$/.test(encodedParam.value) || encodedParam.key.substr(-1) === "*") {
              paramsArray.push(encodedParam.key + "=" + encodedParam.value);
            } else {
              paramsArray.push(encodedParam.key + "=" + JSON.stringify(encodedParam.value));
            }
          });
        } else if (/[\s'"\\;:/=(),<>@[\]?]|^-/.test(value)) {
          paramsArray.push(param + "=" + JSON.stringify(value));
        } else {
          paramsArray.push(param + "=" + value);
        }
      });
      return structured.value + (paramsArray.length ? "; " + paramsArray.join("; ") : "");
    },
    buildHeaderParam(key, data, maxLength) {
      let list = [];
      let encodedStr = typeof data === "string" ? data : (data || "").toString();
      let encodedStrArr;
      let chr, ord;
      let line;
      let startPos = 0;
      let i, len;
      maxLength = maxLength || 50;
      if (this.isPlainText(data, true)) {
        if (encodedStr.length <= maxLength) {
          return [
            {
              key,
              value: encodedStr
            }
          ];
        }
        encodedStr = encodedStr.replace(new RegExp(".{" + maxLength + "}", "g"), (str) => {
          list.push({
            line: str
          });
          return "";
        });
        if (encodedStr) {
          list.push({
            line: encodedStr
          });
        }
      } else {
        if (/[\uD800-\uDBFF]/.test(encodedStr)) {
          encodedStrArr = [];
          for (i = 0, len = encodedStr.length;i < len; i++) {
            chr = encodedStr.charAt(i);
            ord = chr.charCodeAt(0);
            if (ord >= 55296 && ord <= 56319 && i < len - 1) {
              chr += encodedStr.charAt(i + 1);
              encodedStrArr.push(chr);
              i++;
            } else {
              encodedStrArr.push(chr);
            }
          }
          encodedStr = encodedStrArr;
        }
        line = "utf-8''";
        let encoded = true;
        startPos = 0;
        for (i = 0, len = encodedStr.length;i < len; i++) {
          chr = encodedStr[i];
          if (encoded) {
            chr = this.safeEncodeURIComponent(chr);
          } else {
            chr = chr === " " ? chr : this.safeEncodeURIComponent(chr);
            if (chr !== encodedStr[i]) {
              if ((this.safeEncodeURIComponent(line) + chr).length >= maxLength) {
                list.push({
                  line,
                  encoded
                });
                line = "";
                startPos = i - 1;
              } else {
                encoded = true;
                i = startPos;
                line = "";
                continue;
              }
            }
          }
          if ((line + chr).length >= maxLength) {
            list.push({
              line,
              encoded
            });
            line = chr = encodedStr[i] === " " ? " " : this.safeEncodeURIComponent(encodedStr[i]);
            if (chr === encodedStr[i]) {
              encoded = false;
              startPos = i - 1;
            } else {
              encoded = true;
            }
          } else {
            line += chr;
          }
        }
        if (line) {
          list.push({
            line,
            encoded
          });
        }
      }
      return list.map((item, i2) => ({
        key: key + "*" + i2 + (item.encoded ? "*" : ""),
        value: item.line
      }));
    },
    parseHeaderValue(str) {
      let response = {
        value: false,
        params: {}
      };
      let key = false;
      let value = "";
      let type = "value";
      let quote = false;
      let escaped = false;
      let chr;
      for (let i = 0, len = str.length;i < len; i++) {
        chr = str.charAt(i);
        if (type === "key") {
          if (chr === "=") {
            key = value.trim().toLowerCase();
            type = "value";
            value = "";
            continue;
          }
          value += chr;
        } else {
          if (escaped) {
            value += chr;
          } else if (chr === "\\") {
            escaped = true;
            continue;
          } else if (quote && chr === quote) {
            quote = false;
          } else if (!quote && chr === '"') {
            quote = chr;
          } else if (!quote && chr === ";") {
            if (key === false) {
              response.value = value.trim();
            } else {
              response.params[key] = value.trim();
            }
            type = "key";
            value = "";
          } else {
            value += chr;
          }
          escaped = false;
        }
      }
      if (type === "value") {
        if (key === false) {
          response.value = value.trim();
        } else {
          response.params[key] = value.trim();
        }
      } else if (value.trim()) {
        response.params[value.trim().toLowerCase()] = "";
      }
      Object.keys(response.params).forEach((key2) => {
        let actualKey, nr, match, value2;
        if (match = key2.match(/(\*(\d+)|\*(\d+)\*|\*)$/)) {
          actualKey = key2.substr(0, match.index);
          nr = Number(match[2] || match[3]) || 0;
          if (!response.params[actualKey] || typeof response.params[actualKey] !== "object") {
            response.params[actualKey] = {
              charset: false,
              values: []
            };
          }
          value2 = response.params[key2];
          if (nr === 0 && match[0].substr(-1) === "*" && (match = value2.match(/^([^']*)'[^']*'(.*)$/))) {
            response.params[actualKey].charset = match[1] || "iso-8859-1";
            value2 = match[2];
          }
          response.params[actualKey].values[nr] = value2;
          delete response.params[key2];
        }
      });
      Object.keys(response.params).forEach((key2) => {
        let value2;
        if (response.params[key2] && Array.isArray(response.params[key2].values)) {
          value2 = response.params[key2].values.map((val) => val || "").join("");
          if (response.params[key2].charset) {
            response.params[key2] = "=?" + response.params[key2].charset + "?Q?" + value2.replace(/[=?_\s]/g, (s) => {
              let c = s.charCodeAt(0).toString(16);
              if (s === " ") {
                return "_";
              } else {
                return "%" + (c.length < 2 ? "0" : "") + c;
              }
            }).replace(/%/g, "=") + "?=";
          } else {
            response.params[key2] = value2;
          }
        }
      });
      return response;
    },
    detectExtension: (mimeType) => mimeTypes.detectExtension(mimeType),
    detectMimeType: (extension) => mimeTypes.detectMimeType(extension),
    foldLines(str, lineLength, afterSpace) {
      str = (str || "").toString();
      lineLength = lineLength || 76;
      let pos = 0, len = str.length, result = "", line, match;
      while (pos < len) {
        line = str.substr(pos, lineLength);
        if (line.length < lineLength) {
          result += line;
          break;
        }
        if (match = line.match(/^[^\n\r]*(\r?\n|\r)/)) {
          line = match[0];
          result += line;
          pos += line.length;
          continue;
        } else if ((match = line.match(/(\s+)[^\s]*$/)) && match[0].length - (afterSpace ? (match[1] || "").length : 0) < line.length) {
          line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || "").length : 0)));
        } else if (match = str.substr(pos + line.length).match(/^[^\s]+(\s*)/)) {
          line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || "").length : 0));
        }
        result += line;
        pos += line.length;
        if (pos < len) {
          result += "\r\n";
        }
      }
      return result;
    },
    splitMimeEncodedString: (str, maxlen) => {
      let curLine, match, chr, done, lines = [];
      maxlen = Math.max(maxlen || 0, 12);
      while (str.length) {
        curLine = str.substr(0, maxlen);
        if (match = curLine.match(/[=][0-9A-F]?$/i)) {
          curLine = curLine.substr(0, match.index);
        }
        done = false;
        while (!done) {
          done = true;
          if (match = str.substr(curLine.length).match(/^[=]([0-9A-F]{2})/i)) {
            chr = parseInt(match[1], 16);
            if (chr < 194 && chr > 127) {
              curLine = curLine.substr(0, curLine.length - 3);
              done = false;
            }
          }
        }
        if (curLine.length) {
          lines.push(curLine);
        }
        str = str.substr(curLine.length);
      }
      return lines;
    },
    encodeURICharComponent: (chr) => {
      let res = "";
      let ord = chr.charCodeAt(0).toString(16).toUpperCase();
      if (ord.length % 2) {
        ord = "0" + ord;
      }
      if (ord.length > 2) {
        for (let i = 0, len = ord.length / 2;i < len; i++) {
          res += "%" + ord.substr(i, 2);
        }
      } else {
        res += "%" + ord;
      }
      return res;
    },
    safeEncodeURIComponent(str) {
      str = (str || "").toString();
      try {
        str = encodeURIComponent(str);
      } catch (E) {
        return str.replace(/[^\x00-\x1F *'()<>@,;:\\"[\]?=\u007F-\uFFFF]+/g, "");
      }
      return str.replace(/[\x00-\x1F *'()<>@,;:\\"[\]?=\u007F-\uFFFF]/g, (chr) => this.encodeURICharComponent(chr));
    }
  };
});

// node_modules/nodemailer/lib/addressparser/index.js
var require_addressparser = __commonJS((exports, module) => {
  function _handleAddress(tokens) {
    let isGroup = false;
    let state = "text";
    let address;
    let addresses = [];
    let data = {
      address: [],
      comment: [],
      group: [],
      text: []
    };
    let i;
    let len;
    for (i = 0, len = tokens.length;i < len; i++) {
      let token = tokens[i];
      let prevToken = i ? tokens[i - 1] : null;
      if (token.type === "operator") {
        switch (token.value) {
          case "<":
            state = "address";
            break;
          case "(":
            state = "comment";
            break;
          case ":":
            state = "group";
            isGroup = true;
            break;
          default:
            state = "text";
            break;
        }
      } else if (token.value) {
        if (state === "address") {
          token.value = token.value.replace(/^[^<]*<\s*/, "");
        }
        if (prevToken && prevToken.noBreak && data[state].length) {
          data[state][data[state].length - 1] += token.value;
        } else {
          data[state].push(token.value);
        }
      }
    }
    if (!data.text.length && data.comment.length) {
      data.text = data.comment;
      data.comment = [];
    }
    if (isGroup) {
      data.text = data.text.join(" ");
      addresses.push({
        name: data.text || address && address.name,
        group: data.group.length ? addressparser(data.group.join(",")) : []
      });
    } else {
      if (!data.address.length && data.text.length) {
        for (i = data.text.length - 1;i >= 0; i--) {
          if (data.text[i].match(/^[^@\s]+@[^@\s]+$/)) {
            data.address = data.text.splice(i, 1);
            break;
          }
        }
        let _regexHandler = function(address2) {
          if (!data.address.length) {
            data.address = [address2.trim()];
            return " ";
          } else {
            return address2;
          }
        };
        if (!data.address.length) {
          for (i = data.text.length - 1;i >= 0; i--) {
            data.text[i] = data.text[i].replace(/\s*\b[^@\s]+@[^\s]+\b\s*/, _regexHandler).trim();
            if (data.address.length) {
              break;
            }
          }
        }
      }
      if (!data.text.length && data.comment.length) {
        data.text = data.comment;
        data.comment = [];
      }
      if (data.address.length > 1) {
        data.text = data.text.concat(data.address.splice(1));
      }
      data.text = data.text.join(" ");
      data.address = data.address.join(" ");
      if (!data.address && isGroup) {
        return [];
      } else {
        address = {
          address: data.address || data.text || "",
          name: data.text || data.address || ""
        };
        if (address.address === address.name) {
          if ((address.address || "").match(/@/)) {
            address.name = "";
          } else {
            address.address = "";
          }
        }
        addresses.push(address);
      }
    }
    return addresses;
  }
  function addressparser(str, options) {
    options = options || {};
    let tokenizer = new Tokenizer(str);
    let tokens = tokenizer.tokenize();
    let addresses = [];
    let address = [];
    let parsedAddresses = [];
    tokens.forEach((token) => {
      if (token.type === "operator" && (token.value === "," || token.value === ";")) {
        if (address.length) {
          addresses.push(address);
        }
        address = [];
      } else {
        address.push(token);
      }
    });
    if (address.length) {
      addresses.push(address);
    }
    addresses.forEach((address2) => {
      address2 = _handleAddress(address2);
      if (address2.length) {
        parsedAddresses = parsedAddresses.concat(address2);
      }
    });
    if (options.flatten) {
      let addresses2 = [];
      let walkAddressList = (list) => {
        list.forEach((address2) => {
          if (address2.group) {
            return walkAddressList(address2.group);
          } else {
            addresses2.push(address2);
          }
        });
      };
      walkAddressList(parsedAddresses);
      return addresses2;
    }
    return parsedAddresses;
  }

  class Tokenizer {
    constructor(str) {
      this.str = (str || "").toString();
      this.operatorCurrent = "";
      this.operatorExpecting = "";
      this.node = null;
      this.escaped = false;
      this.list = [];
      this.operators = {
        '"': '"',
        "(": ")",
        "<": ">",
        ",": "",
        ":": ";",
        ";": ""
      };
    }
    tokenize() {
      let list = [];
      for (let i = 0, len = this.str.length;i < len; i++) {
        let chr = this.str.charAt(i);
        let nextChr = i < len - 1 ? this.str.charAt(i + 1) : null;
        this.checkChar(chr, nextChr);
      }
      this.list.forEach((node) => {
        node.value = (node.value || "").toString().trim();
        if (node.value) {
          list.push(node);
        }
      });
      return list;
    }
    checkChar(chr, nextChr) {
      if (this.escaped) {
      } else if (chr === this.operatorExpecting) {
        this.node = {
          type: "operator",
          value: chr
        };
        if (nextChr && ![" ", "\t", "\r", "\n", ",", ";"].includes(nextChr)) {
          this.node.noBreak = true;
        }
        this.list.push(this.node);
        this.node = null;
        this.operatorExpecting = "";
        this.escaped = false;
        return;
      } else if (!this.operatorExpecting && chr in this.operators) {
        this.node = {
          type: "operator",
          value: chr
        };
        this.list.push(this.node);
        this.node = null;
        this.operatorExpecting = this.operators[chr];
        this.escaped = false;
        return;
      } else if (['"', "'"].includes(this.operatorExpecting) && chr === "\\") {
        this.escaped = true;
        return;
      }
      if (!this.node) {
        this.node = {
          type: "text",
          value: ""
        };
        this.list.push(this.node);
      }
      if (chr === "\n") {
        chr = " ";
      }
      if (chr.charCodeAt(0) >= 33 || [" ", "\t"].includes(chr)) {
        this.node.value += chr;
      }
      this.escaped = false;
    }
  }
  module.exports = addressparser;
});

// node_modules/nodemailer/lib/mime-node/last-newline.js
var require_last_newline = __commonJS((exports, module) => {
  var Transform = import.meta.require("stream").Transform;

  class LastNewline extends Transform {
    constructor() {
      super();
      this.lastByte = false;
    }
    _transform(chunk, encoding, done) {
      if (chunk.length) {
        this.lastByte = chunk[chunk.length - 1];
      }
      this.push(chunk);
      done();
    }
    _flush(done) {
      if (this.lastByte === 10) {
        return done();
      }
      if (this.lastByte === 13) {
        this.push(Buffer.from("\n"));
        return done();
      }
      this.push(Buffer.from("\r\n"));
      return done();
    }
  }
  module.exports = LastNewline;
});

// node_modules/nodemailer/lib/mime-node/le-windows.js
var require_le_windows = __commonJS((exports, module) => {
  var stream = import.meta.require("stream");
  var Transform = stream.Transform;

  class LeWindows extends Transform {
    constructor(options) {
      super(options);
      this.options = options || {};
      this.lastByte = false;
    }
    _transform(chunk, encoding, done) {
      let buf;
      let lastPos = 0;
      for (let i = 0, len = chunk.length;i < len; i++) {
        if (chunk[i] === 10) {
          if (i && chunk[i - 1] !== 13 || !i && this.lastByte !== 13) {
            if (i > lastPos) {
              buf = chunk.slice(lastPos, i);
              this.push(buf);
            }
            this.push(Buffer.from("\r\n"));
            lastPos = i + 1;
          }
        }
      }
      if (lastPos && lastPos < chunk.length) {
        buf = chunk.slice(lastPos);
        this.push(buf);
      } else if (!lastPos) {
        this.push(chunk);
      }
      this.lastByte = chunk[chunk.length - 1];
      done();
    }
  }
  module.exports = LeWindows;
});

// node_modules/nodemailer/lib/mime-node/le-unix.js
var require_le_unix = __commonJS((exports, module) => {
  var stream = import.meta.require("stream");
  var Transform = stream.Transform;

  class LeWindows extends Transform {
    constructor(options) {
      super(options);
      this.options = options || {};
    }
    _transform(chunk, encoding, done) {
      let buf;
      let lastPos = 0;
      for (let i = 0, len = chunk.length;i < len; i++) {
        if (chunk[i] === 13) {
          buf = chunk.slice(lastPos, i);
          lastPos = i + 1;
          this.push(buf);
        }
      }
      if (lastPos && lastPos < chunk.length) {
        buf = chunk.slice(lastPos);
        this.push(buf);
      } else if (!lastPos) {
        this.push(chunk);
      }
      done();
    }
  }
  module.exports = LeWindows;
});

// node_modules/nodemailer/lib/mime-node/index.js
var require_mime_node = __commonJS((exports, module) => {
  var crypto3 = import.meta.require("crypto");
  var fs = import.meta.require("fs");
  var punycode = require_punycode2();
  var PassThrough = import.meta.require("stream").PassThrough;
  var shared = require_shared2();
  var mimeFuncs = require_mime_funcs();
  var qp = require_qp();
  var base64 = require_base64();
  var addressparser = require_addressparser();
  var nmfetch = require_fetch();
  var LastNewline = require_last_newline();
  var LeWindows = require_le_windows();
  var LeUnix = require_le_unix();

  class MimeNode {
    constructor(contentType, options) {
      this.nodeCounter = 0;
      options = options || {};
      this.baseBoundary = options.baseBoundary || crypto3.randomBytes(8).toString("hex");
      this.boundaryPrefix = options.boundaryPrefix || "--_NmP";
      this.disableFileAccess = !!options.disableFileAccess;
      this.disableUrlAccess = !!options.disableUrlAccess;
      this.normalizeHeaderKey = options.normalizeHeaderKey;
      this.date = new Date;
      this.rootNode = options.rootNode || this;
      this.keepBcc = !!options.keepBcc;
      if (options.filename) {
        this.filename = options.filename;
        if (!contentType) {
          contentType = mimeFuncs.detectMimeType(this.filename.split(".").pop());
        }
      }
      this.textEncoding = (options.textEncoding || "").toString().trim().charAt(0).toUpperCase();
      this.parentNode = options.parentNode;
      this.hostname = options.hostname;
      this.newline = options.newline;
      this.childNodes = [];
      this._nodeId = ++this.rootNode.nodeCounter;
      this._headers = [];
      this._isPlainText = false;
      this._hasLongLines = false;
      this._envelope = false;
      this._raw = false;
      this._transforms = [];
      this._processFuncs = [];
      if (contentType) {
        this.setHeader("Content-Type", contentType);
      }
    }
    createChild(contentType, options) {
      if (!options && typeof contentType === "object") {
        options = contentType;
        contentType = undefined;
      }
      let node = new MimeNode(contentType, options);
      this.appendChild(node);
      return node;
    }
    appendChild(childNode) {
      if (childNode.rootNode !== this.rootNode) {
        childNode.rootNode = this.rootNode;
        childNode._nodeId = ++this.rootNode.nodeCounter;
      }
      childNode.parentNode = this;
      this.childNodes.push(childNode);
      return childNode;
    }
    replace(node) {
      if (node === this) {
        return this;
      }
      this.parentNode.childNodes.forEach((childNode, i) => {
        if (childNode === this) {
          node.rootNode = this.rootNode;
          node.parentNode = this.parentNode;
          node._nodeId = this._nodeId;
          this.rootNode = this;
          this.parentNode = undefined;
          node.parentNode.childNodes[i] = node;
        }
      });
      return node;
    }
    remove() {
      if (!this.parentNode) {
        return this;
      }
      for (let i = this.parentNode.childNodes.length - 1;i >= 0; i--) {
        if (this.parentNode.childNodes[i] === this) {
          this.parentNode.childNodes.splice(i, 1);
          this.parentNode = undefined;
          this.rootNode = this;
          return this;
        }
      }
    }
    setHeader(key, value) {
      let added = false, headerValue;
      if (!value && key && typeof key === "object") {
        if (key.key && "value" in key) {
          this.setHeader(key.key, key.value);
        } else if (Array.isArray(key)) {
          key.forEach((i) => {
            this.setHeader(i.key, i.value);
          });
        } else {
          Object.keys(key).forEach((i) => {
            this.setHeader(i, key[i]);
          });
        }
        return this;
      }
      key = this._normalizeHeaderKey(key);
      headerValue = {
        key,
        value
      };
      for (let i = 0, len = this._headers.length;i < len; i++) {
        if (this._headers[i].key === key) {
          if (!added) {
            this._headers[i] = headerValue;
            added = true;
          } else {
            this._headers.splice(i, 1);
            i--;
            len--;
          }
        }
      }
      if (!added) {
        this._headers.push(headerValue);
      }
      return this;
    }
    addHeader(key, value) {
      if (!value && key && typeof key === "object") {
        if (key.key && key.value) {
          this.addHeader(key.key, key.value);
        } else if (Array.isArray(key)) {
          key.forEach((i) => {
            this.addHeader(i.key, i.value);
          });
        } else {
          Object.keys(key).forEach((i) => {
            this.addHeader(i, key[i]);
          });
        }
        return this;
      } else if (Array.isArray(value)) {
        value.forEach((val) => {
          this.addHeader(key, val);
        });
        return this;
      }
      this._headers.push({
        key: this._normalizeHeaderKey(key),
        value
      });
      return this;
    }
    getHeader(key) {
      key = this._normalizeHeaderKey(key);
      for (let i = 0, len = this._headers.length;i < len; i++) {
        if (this._headers[i].key === key) {
          return this._headers[i].value;
        }
      }
    }
    setContent(content) {
      this.content = content;
      if (typeof this.content.pipe === "function") {
        this._contentErrorHandler = (err) => {
          this.content.removeListener("error", this._contentErrorHandler);
          this.content = err;
        };
        this.content.once("error", this._contentErrorHandler);
      } else if (typeof this.content === "string") {
        this._isPlainText = mimeFuncs.isPlainText(this.content);
        if (this._isPlainText && mimeFuncs.hasLongerLines(this.content, 76)) {
          this._hasLongLines = true;
        }
      }
      return this;
    }
    build(callback) {
      let promise;
      if (!callback) {
        promise = new Promise((resolve, reject) => {
          callback = shared.callbackPromise(resolve, reject);
        });
      }
      let stream = this.createReadStream();
      let buf = [];
      let buflen = 0;
      let returned = false;
      stream.on("readable", () => {
        let chunk;
        while ((chunk = stream.read()) !== null) {
          buf.push(chunk);
          buflen += chunk.length;
        }
      });
      stream.once("error", (err) => {
        if (returned) {
          return;
        }
        returned = true;
        return callback(err);
      });
      stream.once("end", (chunk) => {
        if (returned) {
          return;
        }
        returned = true;
        if (chunk && chunk.length) {
          buf.push(chunk);
          buflen += chunk.length;
        }
        return callback(null, Buffer.concat(buf, buflen));
      });
      return promise;
    }
    getTransferEncoding() {
      let transferEncoding = false;
      let contentType = (this.getHeader("Content-Type") || "").toString().toLowerCase().trim();
      if (this.content) {
        transferEncoding = (this.getHeader("Content-Transfer-Encoding") || "").toString().toLowerCase().trim();
        if (!transferEncoding || !["base64", "quoted-printable"].includes(transferEncoding)) {
          if (/^text\//i.test(contentType)) {
            if (this._isPlainText && !this._hasLongLines) {
              transferEncoding = "7bit";
            } else if (typeof this.content === "string" || this.content instanceof Buffer) {
              transferEncoding = this._getTextEncoding(this.content) === "Q" ? "quoted-printable" : "base64";
            } else {
              transferEncoding = this.textEncoding === "B" ? "base64" : "quoted-printable";
            }
          } else if (!/^(multipart|message)\//i.test(contentType)) {
            transferEncoding = transferEncoding || "base64";
          }
        }
      }
      return transferEncoding;
    }
    buildHeaders() {
      let transferEncoding = this.getTransferEncoding();
      let headers = [];
      if (transferEncoding) {
        this.setHeader("Content-Transfer-Encoding", transferEncoding);
      }
      if (this.filename && !this.getHeader("Content-Disposition")) {
        this.setHeader("Content-Disposition", "attachment");
      }
      if (this.rootNode === this) {
        if (!this.getHeader("Date")) {
          this.setHeader("Date", this.date.toUTCString().replace(/GMT/, "+0000"));
        }
        this.messageId();
        if (!this.getHeader("MIME-Version")) {
          this.setHeader("MIME-Version", "1.0");
        }
        for (let i = this._headers.length - 2;i >= 0; i--) {
          let header = this._headers[i];
          if (header.key === "Content-Type") {
            this._headers.splice(i, 1);
            this._headers.push(header);
          }
        }
      }
      this._headers.forEach((header) => {
        let key = header.key;
        let value = header.value;
        let structured;
        let param;
        let options = {};
        let formattedHeaders = ["From", "Sender", "To", "Cc", "Bcc", "Reply-To", "Date", "References"];
        if (value && typeof value === "object" && !formattedHeaders.includes(key)) {
          Object.keys(value).forEach((key2) => {
            if (key2 !== "value") {
              options[key2] = value[key2];
            }
          });
          value = (value.value || "").toString();
          if (!value.trim()) {
            return;
          }
        }
        if (options.prepared) {
          if (options.foldLines) {
            headers.push(mimeFuncs.foldLines(key + ": " + value));
          } else {
            headers.push(key + ": " + value);
          }
          return;
        }
        switch (header.key) {
          case "Content-Disposition":
            structured = mimeFuncs.parseHeaderValue(value);
            if (this.filename) {
              structured.params.filename = this.filename;
            }
            value = mimeFuncs.buildHeaderValue(structured);
            break;
          case "Content-Type":
            structured = mimeFuncs.parseHeaderValue(value);
            this._handleContentType(structured);
            if (structured.value.match(/^text\/plain\b/) && typeof this.content === "string" && /[\u0080-\uFFFF]/.test(this.content)) {
              structured.params.charset = "utf-8";
            }
            value = mimeFuncs.buildHeaderValue(structured);
            if (this.filename) {
              param = this._encodeWords(this.filename);
              if (param !== this.filename || /[\s'"\\;:/=(),<>@[\]?]|^-/.test(param)) {
                param = '"' + param + '"';
              }
              value += "; name=" + param;
            }
            break;
          case "Bcc":
            if (!this.keepBcc) {
              return;
            }
            break;
        }
        value = this._encodeHeaderValue(key, value);
        if (!(value || "").toString().trim()) {
          return;
        }
        if (typeof this.normalizeHeaderKey === "function") {
          let normalized = this.normalizeHeaderKey(key, value);
          if (normalized && typeof normalized === "string" && normalized.length) {
            key = normalized;
          }
        }
        headers.push(mimeFuncs.foldLines(key + ": " + value, 76));
      });
      return headers.join("\r\n");
    }
    createReadStream(options) {
      options = options || {};
      let stream = new PassThrough(options);
      let outputStream = stream;
      let transform;
      this.stream(stream, options, (err) => {
        if (err) {
          outputStream.emit("error", err);
          return;
        }
        stream.end();
      });
      for (let i = 0, len = this._transforms.length;i < len; i++) {
        transform = typeof this._transforms[i] === "function" ? this._transforms[i]() : this._transforms[i];
        outputStream.once("error", (err) => {
          transform.emit("error", err);
        });
        outputStream = outputStream.pipe(transform);
      }
      transform = new LastNewline;
      outputStream.once("error", (err) => {
        transform.emit("error", err);
      });
      outputStream = outputStream.pipe(transform);
      for (let i = 0, len = this._processFuncs.length;i < len; i++) {
        transform = this._processFuncs[i];
        outputStream = transform(outputStream);
      }
      if (this.newline) {
        const winbreak = ["win", "windows", "dos", "\r\n"].includes(this.newline.toString().toLowerCase());
        const newlineTransform = winbreak ? new LeWindows : new LeUnix;
        const stream2 = outputStream.pipe(newlineTransform);
        outputStream.on("error", (err) => stream2.emit("error", err));
        return stream2;
      }
      return outputStream;
    }
    transform(transform) {
      this._transforms.push(transform);
    }
    processFunc(processFunc) {
      this._processFuncs.push(processFunc);
    }
    stream(outputStream, options, done) {
      let transferEncoding = this.getTransferEncoding();
      let contentStream;
      let localStream;
      let returned = false;
      let callback = (err) => {
        if (returned) {
          return;
        }
        returned = true;
        done(err);
      };
      let finalize = () => {
        let childId = 0;
        let processChildNode = () => {
          if (childId >= this.childNodes.length) {
            outputStream.write("\r\n--" + this.boundary + "--\r\n");
            return callback();
          }
          let child = this.childNodes[childId++];
          outputStream.write((childId > 1 ? "\r\n" : "") + "--" + this.boundary + "\r\n");
          child.stream(outputStream, options, (err) => {
            if (err) {
              return callback(err);
            }
            setImmediate(processChildNode);
          });
        };
        if (this.multipart) {
          setImmediate(processChildNode);
        } else {
          return callback();
        }
      };
      let sendContent = () => {
        if (this.content) {
          if (Object.prototype.toString.call(this.content) === "[object Error]") {
            return callback(this.content);
          }
          if (typeof this.content.pipe === "function") {
            this.content.removeListener("error", this._contentErrorHandler);
            this._contentErrorHandler = (err) => callback(err);
            this.content.once("error", this._contentErrorHandler);
          }
          let createStream = () => {
            if (["quoted-printable", "base64"].includes(transferEncoding)) {
              contentStream = new (transferEncoding === "base64" ? base64 : qp).Encoder(options);
              contentStream.pipe(outputStream, {
                end: false
              });
              contentStream.once("end", finalize);
              contentStream.once("error", (err) => callback(err));
              localStream = this._getStream(this.content);
              localStream.pipe(contentStream);
            } else {
              localStream = this._getStream(this.content);
              localStream.pipe(outputStream, {
                end: false
              });
              localStream.once("end", finalize);
            }
            localStream.once("error", (err) => callback(err));
          };
          if (this.content._resolve) {
            let chunks = [];
            let chunklen = 0;
            let returned2 = false;
            let sourceStream = this._getStream(this.content);
            sourceStream.on("error", (err) => {
              if (returned2) {
                return;
              }
              returned2 = true;
              callback(err);
            });
            sourceStream.on("readable", () => {
              let chunk;
              while ((chunk = sourceStream.read()) !== null) {
                chunks.push(chunk);
                chunklen += chunk.length;
              }
            });
            sourceStream.on("end", () => {
              if (returned2) {
                return;
              }
              returned2 = true;
              this.content._resolve = false;
              this.content._resolvedValue = Buffer.concat(chunks, chunklen);
              setImmediate(createStream);
            });
          } else {
            setImmediate(createStream);
          }
          return;
        } else {
          return setImmediate(finalize);
        }
      };
      if (this._raw) {
        setImmediate(() => {
          if (Object.prototype.toString.call(this._raw) === "[object Error]") {
            return callback(this._raw);
          }
          if (typeof this._raw.pipe === "function") {
            this._raw.removeListener("error", this._contentErrorHandler);
          }
          let raw2 = this._getStream(this._raw);
          raw2.pipe(outputStream, {
            end: false
          });
          raw2.on("error", (err) => outputStream.emit("error", err));
          raw2.on("end", finalize);
        });
      } else {
        outputStream.write(this.buildHeaders() + "\r\n\r\n");
        setImmediate(sendContent);
      }
    }
    setEnvelope(envelope) {
      let list;
      this._envelope = {
        from: false,
        to: []
      };
      if (envelope.from) {
        list = [];
        this._convertAddresses(this._parseAddresses(envelope.from), list);
        list = list.filter((address) => address && address.address);
        if (list.length && list[0]) {
          this._envelope.from = list[0].address;
        }
      }
      ["to", "cc", "bcc"].forEach((key) => {
        if (envelope[key]) {
          this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);
        }
      });
      this._envelope.to = this._envelope.to.map((to) => to.address).filter((address) => address);
      let standardFields = ["to", "cc", "bcc", "from"];
      Object.keys(envelope).forEach((key) => {
        if (!standardFields.includes(key)) {
          this._envelope[key] = envelope[key];
        }
      });
      return this;
    }
    getAddresses() {
      let addresses = {};
      this._headers.forEach((header) => {
        let key = header.key.toLowerCase();
        if (["from", "sender", "reply-to", "to", "cc", "bcc"].includes(key)) {
          if (!Array.isArray(addresses[key])) {
            addresses[key] = [];
          }
          this._convertAddresses(this._parseAddresses(header.value), addresses[key]);
        }
      });
      return addresses;
    }
    getEnvelope() {
      if (this._envelope) {
        return this._envelope;
      }
      let envelope = {
        from: false,
        to: []
      };
      this._headers.forEach((header) => {
        let list = [];
        if (header.key === "From" || !envelope.from && ["Reply-To", "Sender"].includes(header.key)) {
          this._convertAddresses(this._parseAddresses(header.value), list);
          if (list.length && list[0]) {
            envelope.from = list[0].address;
          }
        } else if (["To", "Cc", "Bcc"].includes(header.key)) {
          this._convertAddresses(this._parseAddresses(header.value), envelope.to);
        }
      });
      envelope.to = envelope.to.map((to) => to.address);
      return envelope;
    }
    messageId() {
      let messageId = this.getHeader("Message-ID");
      if (!messageId) {
        messageId = this._generateMessageId();
        this.setHeader("Message-ID", messageId);
      }
      return messageId;
    }
    setRaw(raw2) {
      this._raw = raw2;
      if (this._raw && typeof this._raw.pipe === "function") {
        this._contentErrorHandler = (err) => {
          this._raw.removeListener("error", this._contentErrorHandler);
          this._raw = err;
        };
        this._raw.once("error", this._contentErrorHandler);
      }
      return this;
    }
    _getStream(content) {
      let contentStream;
      if (content._resolvedValue) {
        contentStream = new PassThrough;
        setImmediate(() => {
          try {
            contentStream.end(content._resolvedValue);
          } catch (err) {
            contentStream.emit("error", err);
          }
        });
        return contentStream;
      } else if (typeof content.pipe === "function") {
        return content;
      } else if (content && typeof content.path === "string" && !content.href) {
        if (this.disableFileAccess) {
          contentStream = new PassThrough;
          setImmediate(() => contentStream.emit("error", new Error("File access rejected for " + content.path)));
          return contentStream;
        }
        return fs.createReadStream(content.path);
      } else if (content && typeof content.href === "string") {
        if (this.disableUrlAccess) {
          contentStream = new PassThrough;
          setImmediate(() => contentStream.emit("error", new Error("Url access rejected for " + content.href)));
          return contentStream;
        }
        return nmfetch(content.href, { headers: content.httpHeaders });
      } else {
        contentStream = new PassThrough;
        setImmediate(() => {
          try {
            contentStream.end(content || "");
          } catch (err) {
            contentStream.emit("error", err);
          }
        });
        return contentStream;
      }
    }
    _parseAddresses(addresses) {
      return [].concat.apply([], [].concat(addresses).map((address) => {
        if (address && address.address) {
          address.address = this._normalizeAddress(address.address);
          address.name = address.name || "";
          return [address];
        }
        return addressparser(address);
      }));
    }
    _normalizeHeaderKey(key) {
      key = (key || "").toString().replace(/\r?\n|\r/g, " ").trim().toLowerCase().replace(/^X-SMTPAPI$|^(MIME|DKIM|ARC|BIMI)\b|^[a-z]|-(SPF|FBL|ID|MD5)$|-[a-z]/gi, (c) => c.toUpperCase()).replace(/^Content-Features$/i, "Content-features");
      return key;
    }
    _handleContentType(structured) {
      this.contentType = structured.value.trim().toLowerCase();
      this.multipart = /^multipart\//i.test(this.contentType) ? this.contentType.substr(this.contentType.indexOf("/") + 1) : false;
      if (this.multipart) {
        this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();
      } else {
        this.boundary = false;
      }
    }
    _generateBoundary() {
      return this.rootNode.boundaryPrefix + "-" + this.rootNode.baseBoundary + "-Part_" + this._nodeId;
    }
    _encodeHeaderValue(key, value) {
      key = this._normalizeHeaderKey(key);
      switch (key) {
        case "From":
        case "Sender":
        case "To":
        case "Cc":
        case "Bcc":
        case "Reply-To":
          return this._convertAddresses(this._parseAddresses(value));
        case "Message-ID":
        case "In-Reply-To":
        case "Content-Id":
          value = (value || "").toString().replace(/\r?\n|\r/g, " ");
          if (value.charAt(0) !== "<") {
            value = "<" + value;
          }
          if (value.charAt(value.length - 1) !== ">") {
            value = value + ">";
          }
          return value;
        case "References":
          value = [].concat.apply([], [].concat(value || "").map((elm) => {
            elm = (elm || "").toString().replace(/\r?\n|\r/g, " ").trim();
            return elm.replace(/<[^>]*>/g, (str) => str.replace(/\s/g, "")).split(/\s+/);
          })).map((elm) => {
            if (elm.charAt(0) !== "<") {
              elm = "<" + elm;
            }
            if (elm.charAt(elm.length - 1) !== ">") {
              elm = elm + ">";
            }
            return elm;
          });
          return value.join(" ").trim();
        case "Date":
          if (Object.prototype.toString.call(value) === "[object Date]") {
            return value.toUTCString().replace(/GMT/, "+0000");
          }
          value = (value || "").toString().replace(/\r?\n|\r/g, " ");
          return this._encodeWords(value);
        case "Content-Type":
        case "Content-Disposition":
          return (value || "").toString().replace(/\r?\n|\r/g, " ");
        default:
          value = (value || "").toString().replace(/\r?\n|\r/g, " ");
          return this._encodeWords(value);
      }
    }
    _convertAddresses(addresses, uniqueList) {
      let values = [];
      uniqueList = uniqueList || [];
      [].concat(addresses || []).forEach((address) => {
        if (address.address) {
          address.address = this._normalizeAddress(address.address);
          if (!address.name) {
            values.push(address.address.indexOf(" ") >= 0 ? `<${address.address}>` : `${address.address}`);
          } else if (address.name) {
            values.push(`${this._encodeAddressName(address.name)} <${address.address}>`);
          }
          if (address.address) {
            if (!uniqueList.filter((a) => a.address === address.address).length) {
              uniqueList.push(address);
            }
          }
        } else if (address.group) {
          let groupListAddresses = (address.group.length ? this._convertAddresses(address.group, uniqueList) : "").trim();
          values.push(`${this._encodeAddressName(address.name)}:${groupListAddresses};`);
        }
      });
      return values.join(", ");
    }
    _normalizeAddress(address) {
      address = (address || "").toString().replace(/[\x00-\x1F<>]+/g, " ").trim();
      let lastAt = address.lastIndexOf("@");
      if (lastAt < 0) {
        return address;
      }
      let user = address.substr(0, lastAt);
      let domain = address.substr(lastAt + 1);
      let encodedDomain;
      try {
        encodedDomain = punycode.toASCII(domain.toLowerCase());
      } catch (err) {
      }
      if (user.indexOf(" ") >= 0) {
        if (user.charAt(0) !== '"') {
          user = '"' + user;
        }
        if (user.substr(-1) !== '"') {
          user = user + '"';
        }
      }
      return `${user}@${encodedDomain}`;
    }
    _encodeAddressName(name) {
      if (!/^[\w ]*$/.test(name)) {
        if (/^[\x20-\x7e]*$/.test(name)) {
          return '"' + name.replace(/([\\"])/g, "\\$1") + '"';
        } else {
          return mimeFuncs.encodeWord(name, this._getTextEncoding(name), 52);
        }
      }
      return name;
    }
    _encodeWords(value) {
      return mimeFuncs.encodeWords(value, this._getTextEncoding(value), 52, true);
    }
    _getTextEncoding(value) {
      value = (value || "").toString();
      let encoding = this.textEncoding;
      let latinLen;
      let nonLatinLen;
      if (!encoding) {
        nonLatinLen = (value.match(/[\x00-\x08\x0B\x0C\x0E-\x1F\u0080-\uFFFF]/g) || []).length;
        latinLen = (value.match(/[a-z]/gi) || []).length;
        encoding = nonLatinLen < latinLen ? "Q" : "B";
      }
      return encoding;
    }
    _generateMessageId() {
      return "<" + [2, 2, 2, 6].reduce((prev, len) => prev + "-" + crypto3.randomBytes(len).toString("hex"), crypto3.randomBytes(4).toString("hex")) + "@" + (this.getEnvelope().from || this.hostname || "localhost").split("@").pop() + ">";
    }
  }
  module.exports = MimeNode;
});

// node_modules/nodemailer/lib/mail-composer/index.js
var require_mail_composer = __commonJS((exports, module) => {
  var MimeNode = require_mime_node();
  var mimeFuncs = require_mime_funcs();
  var parseDataURI = require_shared2().parseDataURI;

  class MailComposer {
    constructor(mail) {
      this.mail = mail || {};
      this.message = false;
    }
    compile() {
      this._alternatives = this.getAlternatives();
      this._htmlNode = this._alternatives.filter((alternative) => /^text\/html\b/i.test(alternative.contentType)).pop();
      this._attachments = this.getAttachments(!!this._htmlNode);
      this._useRelated = !!(this._htmlNode && this._attachments.related.length);
      this._useAlternative = this._alternatives.length > 1;
      this._useMixed = this._attachments.attached.length > 1 || this._alternatives.length && this._attachments.attached.length === 1;
      if (this.mail.raw) {
        this.message = new MimeNode("message/rfc822", { newline: this.mail.newline }).setRaw(this.mail.raw);
      } else if (this._useMixed) {
        this.message = this._createMixed();
      } else if (this._useAlternative) {
        this.message = this._createAlternative();
      } else if (this._useRelated) {
        this.message = this._createRelated();
      } else {
        this.message = this._createContentNode(false, [].concat(this._alternatives || []).concat(this._attachments.attached || []).shift() || {
          contentType: "text/plain",
          content: ""
        });
      }
      if (this.mail.headers) {
        this.message.addHeader(this.mail.headers);
      }
      ["from", "sender", "to", "cc", "bcc", "reply-to", "in-reply-to", "references", "subject", "message-id", "date"].forEach((header) => {
        let key = header.replace(/-(\w)/g, (o, c) => c.toUpperCase());
        if (this.mail[key]) {
          this.message.setHeader(header, this.mail[key]);
        }
      });
      if (this.mail.envelope) {
        this.message.setEnvelope(this.mail.envelope);
      }
      this.message.messageId();
      return this.message;
    }
    getAttachments(findRelated) {
      let icalEvent, eventObject;
      let attachments = [].concat(this.mail.attachments || []).map((attachment, i) => {
        let data;
        let isMessageNode = /^message\//i.test(attachment.contentType);
        if (/^data:/i.test(attachment.path || attachment.href)) {
          attachment = this._processDataUrl(attachment);
        }
        let contentType = attachment.contentType || mimeFuncs.detectMimeType(attachment.filename || attachment.path || attachment.href || "bin");
        let isImage = /^image\//i.test(contentType);
        let contentDisposition = attachment.contentDisposition || (isMessageNode || isImage && attachment.cid ? "inline" : "attachment");
        data = {
          contentType,
          contentDisposition,
          contentTransferEncoding: "contentTransferEncoding" in attachment ? attachment.contentTransferEncoding : "base64"
        };
        if (attachment.filename) {
          data.filename = attachment.filename;
        } else if (!isMessageNode && attachment.filename !== false) {
          data.filename = (attachment.path || attachment.href || "").split("/").pop().split("?").shift() || "attachment-" + (i + 1);
          if (data.filename.indexOf(".") < 0) {
            data.filename += "." + mimeFuncs.detectExtension(data.contentType);
          }
        }
        if (/^https?:\/\//i.test(attachment.path)) {
          attachment.href = attachment.path;
          attachment.path = undefined;
        }
        if (attachment.cid) {
          data.cid = attachment.cid;
        }
        if (attachment.raw) {
          data.raw = attachment.raw;
        } else if (attachment.path) {
          data.content = {
            path: attachment.path
          };
        } else if (attachment.href) {
          data.content = {
            href: attachment.href,
            httpHeaders: attachment.httpHeaders
          };
        } else {
          data.content = attachment.content || "";
        }
        if (attachment.encoding) {
          data.encoding = attachment.encoding;
        }
        if (attachment.headers) {
          data.headers = attachment.headers;
        }
        return data;
      });
      if (this.mail.icalEvent) {
        if (typeof this.mail.icalEvent === "object" && (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)) {
          icalEvent = this.mail.icalEvent;
        } else {
          icalEvent = {
            content: this.mail.icalEvent
          };
        }
        eventObject = {};
        Object.keys(icalEvent).forEach((key) => {
          eventObject[key] = icalEvent[key];
        });
        eventObject.contentType = "application/ics";
        if (!eventObject.headers) {
          eventObject.headers = {};
        }
        eventObject.filename = eventObject.filename || "invite.ics";
        eventObject.headers["Content-Disposition"] = "attachment";
        eventObject.headers["Content-Transfer-Encoding"] = "base64";
      }
      if (!findRelated) {
        return {
          attached: attachments.concat(eventObject || []),
          related: []
        };
      } else {
        return {
          attached: attachments.filter((attachment) => !attachment.cid).concat(eventObject || []),
          related: attachments.filter((attachment) => !!attachment.cid)
        };
      }
    }
    getAlternatives() {
      let alternatives = [], text, html, watchHtml, amp, icalEvent, eventObject;
      if (this.mail.text) {
        if (typeof this.mail.text === "object" && (this.mail.text.content || this.mail.text.path || this.mail.text.href || this.mail.text.raw)) {
          text = this.mail.text;
        } else {
          text = {
            content: this.mail.text
          };
        }
        text.contentType = "text/plain; charset=utf-8";
      }
      if (this.mail.watchHtml) {
        if (typeof this.mail.watchHtml === "object" && (this.mail.watchHtml.content || this.mail.watchHtml.path || this.mail.watchHtml.href || this.mail.watchHtml.raw)) {
          watchHtml = this.mail.watchHtml;
        } else {
          watchHtml = {
            content: this.mail.watchHtml
          };
        }
        watchHtml.contentType = "text/watch-html; charset=utf-8";
      }
      if (this.mail.amp) {
        if (typeof this.mail.amp === "object" && (this.mail.amp.content || this.mail.amp.path || this.mail.amp.href || this.mail.amp.raw)) {
          amp = this.mail.amp;
        } else {
          amp = {
            content: this.mail.amp
          };
        }
        amp.contentType = "text/x-amp-html; charset=utf-8";
      }
      if (this.mail.icalEvent) {
        if (typeof this.mail.icalEvent === "object" && (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)) {
          icalEvent = this.mail.icalEvent;
        } else {
          icalEvent = {
            content: this.mail.icalEvent
          };
        }
        eventObject = {};
        Object.keys(icalEvent).forEach((key) => {
          eventObject[key] = icalEvent[key];
        });
        if (eventObject.content && typeof eventObject.content === "object") {
          eventObject.content._resolve = true;
        }
        eventObject.filename = false;
        eventObject.contentType = "text/calendar; charset=utf-8; method=" + (eventObject.method || "PUBLISH").toString().trim().toUpperCase();
        if (!eventObject.headers) {
          eventObject.headers = {};
        }
      }
      if (this.mail.html) {
        if (typeof this.mail.html === "object" && (this.mail.html.content || this.mail.html.path || this.mail.html.href || this.mail.html.raw)) {
          html = this.mail.html;
        } else {
          html = {
            content: this.mail.html
          };
        }
        html.contentType = "text/html; charset=utf-8";
      }
      [].concat(text || []).concat(watchHtml || []).concat(amp || []).concat(html || []).concat(eventObject || []).concat(this.mail.alternatives || []).forEach((alternative) => {
        let data;
        if (/^data:/i.test(alternative.path || alternative.href)) {
          alternative = this._processDataUrl(alternative);
        }
        data = {
          contentType: alternative.contentType || mimeFuncs.detectMimeType(alternative.filename || alternative.path || alternative.href || "txt"),
          contentTransferEncoding: alternative.contentTransferEncoding
        };
        if (alternative.filename) {
          data.filename = alternative.filename;
        }
        if (/^https?:\/\//i.test(alternative.path)) {
          alternative.href = alternative.path;
          alternative.path = undefined;
        }
        if (alternative.raw) {
          data.raw = alternative.raw;
        } else if (alternative.path) {
          data.content = {
            path: alternative.path
          };
        } else if (alternative.href) {
          data.content = {
            href: alternative.href
          };
        } else {
          data.content = alternative.content || "";
        }
        if (alternative.encoding) {
          data.encoding = alternative.encoding;
        }
        if (alternative.headers) {
          data.headers = alternative.headers;
        }
        alternatives.push(data);
      });
      return alternatives;
    }
    _createMixed(parentNode) {
      let node;
      if (!parentNode) {
        node = new MimeNode("multipart/mixed", {
          baseBoundary: this.mail.baseBoundary,
          textEncoding: this.mail.textEncoding,
          boundaryPrefix: this.mail.boundaryPrefix,
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      } else {
        node = parentNode.createChild("multipart/mixed", {
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      }
      if (this._useAlternative) {
        this._createAlternative(node);
      } else if (this._useRelated) {
        this._createRelated(node);
      }
      [].concat(!this._useAlternative && this._alternatives || []).concat(this._attachments.attached || []).forEach((element) => {
        if (!this._useRelated || element !== this._htmlNode) {
          this._createContentNode(node, element);
        }
      });
      return node;
    }
    _createAlternative(parentNode) {
      let node;
      if (!parentNode) {
        node = new MimeNode("multipart/alternative", {
          baseBoundary: this.mail.baseBoundary,
          textEncoding: this.mail.textEncoding,
          boundaryPrefix: this.mail.boundaryPrefix,
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      } else {
        node = parentNode.createChild("multipart/alternative", {
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      }
      this._alternatives.forEach((alternative) => {
        if (this._useRelated && this._htmlNode === alternative) {
          this._createRelated(node);
        } else {
          this._createContentNode(node, alternative);
        }
      });
      return node;
    }
    _createRelated(parentNode) {
      let node;
      if (!parentNode) {
        node = new MimeNode('multipart/related; type="text/html"', {
          baseBoundary: this.mail.baseBoundary,
          textEncoding: this.mail.textEncoding,
          boundaryPrefix: this.mail.boundaryPrefix,
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      } else {
        node = parentNode.createChild('multipart/related; type="text/html"', {
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      }
      this._createContentNode(node, this._htmlNode);
      this._attachments.related.forEach((alternative) => this._createContentNode(node, alternative));
      return node;
    }
    _createContentNode(parentNode, element) {
      element = element || {};
      element.content = element.content || "";
      let node;
      let encoding = (element.encoding || "utf8").toString().toLowerCase().replace(/[-_\s]/g, "");
      if (!parentNode) {
        node = new MimeNode(element.contentType, {
          filename: element.filename,
          baseBoundary: this.mail.baseBoundary,
          textEncoding: this.mail.textEncoding,
          boundaryPrefix: this.mail.boundaryPrefix,
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      } else {
        node = parentNode.createChild(element.contentType, {
          filename: element.filename,
          textEncoding: this.mail.textEncoding,
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      }
      if (element.headers) {
        node.addHeader(element.headers);
      }
      if (element.cid) {
        node.setHeader("Content-Id", "<" + element.cid.replace(/[<>]/g, "") + ">");
      }
      if (element.contentTransferEncoding) {
        node.setHeader("Content-Transfer-Encoding", element.contentTransferEncoding);
      } else if (this.mail.encoding && /^text\//i.test(element.contentType)) {
        node.setHeader("Content-Transfer-Encoding", this.mail.encoding);
      }
      if (!/^text\//i.test(element.contentType) || element.contentDisposition) {
        node.setHeader("Content-Disposition", element.contentDisposition || (element.cid && /^image\//i.test(element.contentType) ? "inline" : "attachment"));
      }
      if (typeof element.content === "string" && !["utf8", "usascii", "ascii"].includes(encoding)) {
        element.content = Buffer.from(element.content, encoding);
      }
      if (element.raw) {
        node.setRaw(element.raw);
      } else {
        node.setContent(element.content);
      }
      return node;
    }
    _processDataUrl(element) {
      let parsedDataUri;
      if ((element.path || element.href).match(/^data:/)) {
        parsedDataUri = parseDataURI(element.path || element.href);
      }
      if (!parsedDataUri) {
        return element;
      }
      element.content = parsedDataUri.data;
      element.contentType = element.contentType || parsedDataUri.contentType;
      if ("path" in element) {
        element.path = false;
      }
      if ("href" in element) {
        element.href = false;
      }
      return element;
    }
  }
  module.exports = MailComposer;
});

// node_modules/nodemailer/lib/dkim/message-parser.js
var require_message_parser = __commonJS((exports, module) => {
  var Transform = import.meta.require("stream").Transform;

  class MessageParser extends Transform {
    constructor(options) {
      super(options);
      this.lastBytes = Buffer.alloc(4);
      this.headersParsed = false;
      this.headerBytes = 0;
      this.headerChunks = [];
      this.rawHeaders = false;
      this.bodySize = 0;
    }
    updateLastBytes(data) {
      let lblen = this.lastBytes.length;
      let nblen = Math.min(data.length, lblen);
      for (let i = 0, len = lblen - nblen;i < len; i++) {
        this.lastBytes[i] = this.lastBytes[i + nblen];
      }
      for (let i = 1;i <= nblen; i++) {
        this.lastBytes[lblen - i] = data[data.length - i];
      }
    }
    checkHeaders(data) {
      if (this.headersParsed) {
        return true;
      }
      let lblen = this.lastBytes.length;
      let headerPos = 0;
      this.curLinePos = 0;
      for (let i = 0, len = this.lastBytes.length + data.length;i < len; i++) {
        let chr;
        if (i < lblen) {
          chr = this.lastBytes[i];
        } else {
          chr = data[i - lblen];
        }
        if (chr === 10 && i) {
          let pr1 = i - 1 < lblen ? this.lastBytes[i - 1] : data[i - 1 - lblen];
          let pr2 = i > 1 ? i - 2 < lblen ? this.lastBytes[i - 2] : data[i - 2 - lblen] : false;
          if (pr1 === 10) {
            this.headersParsed = true;
            headerPos = i - lblen + 1;
            this.headerBytes += headerPos;
            break;
          } else if (pr1 === 13 && pr2 === 10) {
            this.headersParsed = true;
            headerPos = i - lblen + 1;
            this.headerBytes += headerPos;
            break;
          }
        }
      }
      if (this.headersParsed) {
        this.headerChunks.push(data.slice(0, headerPos));
        this.rawHeaders = Buffer.concat(this.headerChunks, this.headerBytes);
        this.headerChunks = null;
        this.emit("headers", this.parseHeaders());
        if (data.length - 1 > headerPos) {
          let chunk = data.slice(headerPos);
          this.bodySize += chunk.length;
          setImmediate(() => this.push(chunk));
        }
        return false;
      } else {
        this.headerBytes += data.length;
        this.headerChunks.push(data);
      }
      this.updateLastBytes(data);
      return false;
    }
    _transform(chunk, encoding, callback) {
      if (!chunk || !chunk.length) {
        return callback();
      }
      if (typeof chunk === "string") {
        chunk = Buffer.from(chunk, encoding);
      }
      let headersFound;
      try {
        headersFound = this.checkHeaders(chunk);
      } catch (E) {
        return callback(E);
      }
      if (headersFound) {
        this.bodySize += chunk.length;
        this.push(chunk);
      }
      setImmediate(callback);
    }
    _flush(callback) {
      if (this.headerChunks) {
        let chunk = Buffer.concat(this.headerChunks, this.headerBytes);
        this.bodySize += chunk.length;
        this.push(chunk);
        this.headerChunks = null;
      }
      callback();
    }
    parseHeaders() {
      let lines = (this.rawHeaders || "").toString().split(/\r?\n/);
      for (let i = lines.length - 1;i > 0; i--) {
        if (/^\s/.test(lines[i])) {
          lines[i - 1] += "\n" + lines[i];
          lines.splice(i, 1);
        }
      }
      return lines.filter((line) => line.trim()).map((line) => ({
        key: line.substr(0, line.indexOf(":")).trim().toLowerCase(),
        line
      }));
    }
  }
  module.exports = MessageParser;
});

// node_modules/nodemailer/lib/dkim/relaxed-body.js
var require_relaxed_body = __commonJS((exports, module) => {
  var Transform = import.meta.require("stream").Transform;
  var crypto3 = import.meta.require("crypto");

  class RelaxedBody extends Transform {
    constructor(options) {
      super();
      options = options || {};
      this.chunkBuffer = [];
      this.chunkBufferLen = 0;
      this.bodyHash = crypto3.createHash(options.hashAlgo || "sha1");
      this.remainder = "";
      this.byteLength = 0;
      this.debug = options.debug;
      this._debugBody = options.debug ? [] : false;
    }
    updateHash(chunk) {
      let bodyStr;
      let nextRemainder = "";
      let state = "file";
      for (let i = chunk.length - 1;i >= 0; i--) {
        let c = chunk[i];
        if (state === "file" && (c === 10 || c === 13)) {
        } else if (state === "file" && (c === 9 || c === 32)) {
          state = "line";
        } else if (state === "line" && (c === 9 || c === 32)) {
        } else if (state === "file" || state === "line") {
          state = "body";
          if (i === chunk.length - 1) {
            break;
          }
        }
        if (i === 0) {
          if (state === "file" && (!this.remainder || /[\r\n]$/.test(this.remainder)) || state === "line" && (!this.remainder || /[ \t]$/.test(this.remainder))) {
            this.remainder += chunk.toString("binary");
            return;
          } else if (state === "line" || state === "file") {
            nextRemainder = chunk.toString("binary");
            chunk = false;
            break;
          }
        }
        if (state !== "body") {
          continue;
        }
        nextRemainder = chunk.slice(i + 1).toString("binary");
        chunk = chunk.slice(0, i + 1);
        break;
      }
      let needsFixing = !!this.remainder;
      if (chunk && !needsFixing) {
        for (let i = 0, len = chunk.length;i < len; i++) {
          if (i && chunk[i] === 10 && chunk[i - 1] !== 13) {
            needsFixing = true;
            break;
          } else if (i && chunk[i] === 13 && chunk[i - 1] === 32) {
            needsFixing = true;
            break;
          } else if (i && chunk[i] === 32 && chunk[i - 1] === 32) {
            needsFixing = true;
            break;
          } else if (chunk[i] === 9) {
            needsFixing = true;
            break;
          }
        }
      }
      if (needsFixing) {
        bodyStr = this.remainder + (chunk ? chunk.toString("binary") : "");
        this.remainder = nextRemainder;
        bodyStr = bodyStr.replace(/\r?\n/g, "\n").replace(/[ \t]*$/gm, "").replace(/[ \t]+/gm, " ").replace(/\n/g, "\r\n");
        chunk = Buffer.from(bodyStr, "binary");
      } else if (nextRemainder) {
        this.remainder = nextRemainder;
      }
      if (this.debug) {
        this._debugBody.push(chunk);
      }
      this.bodyHash.update(chunk);
    }
    _transform(chunk, encoding, callback) {
      if (!chunk || !chunk.length) {
        return callback();
      }
      if (typeof chunk === "string") {
        chunk = Buffer.from(chunk, encoding);
      }
      this.updateHash(chunk);
      this.byteLength += chunk.length;
      this.push(chunk);
      callback();
    }
    _flush(callback) {
      if (/[\r\n]$/.test(this.remainder) && this.byteLength > 2) {
        this.bodyHash.update(Buffer.from("\r\n"));
      }
      if (!this.byteLength) {
        this.push(Buffer.from("\r\n"));
      }
      this.emit("hash", this.bodyHash.digest("base64"), this.debug ? Buffer.concat(this._debugBody) : false);
      callback();
    }
  }
  module.exports = RelaxedBody;
});

// node_modules/nodemailer/lib/dkim/sign.js
var require_sign = __commonJS((exports, module) => {
  function generateDKIMHeader(domainName, keySelector, fieldNames, hashAlgo, bodyHash) {
    let dkim = [
      "v=1",
      "a=rsa-" + hashAlgo,
      "c=relaxed/relaxed",
      "d=" + punycode.toASCII(domainName),
      "q=dns/txt",
      "s=" + keySelector,
      "bh=" + bodyHash,
      "h=" + fieldNames
    ].join("; ");
    return mimeFuncs.foldLines("DKIM-Signature: " + dkim, 76) + ";\r\n b=";
  }
  function relaxedHeaders(headers, fieldNames, skipFields) {
    let includedFields = new Set;
    let skip = new Set;
    let headerFields = new Map;
    (skipFields || "").toLowerCase().split(":").forEach((field) => {
      skip.add(field.trim());
    });
    (fieldNames || "").toLowerCase().split(":").filter((field) => !skip.has(field.trim())).forEach((field) => {
      includedFields.add(field.trim());
    });
    for (let i = headers.length - 1;i >= 0; i--) {
      let line = headers[i];
      if (includedFields.has(line.key) && !headerFields.has(line.key)) {
        headerFields.set(line.key, relaxedHeaderLine(line.line));
      }
    }
    let headersList = [];
    let fields = [];
    includedFields.forEach((field) => {
      if (headerFields.has(field)) {
        fields.push(field);
        headersList.push(field + ":" + headerFields.get(field));
      }
    });
    return {
      headers: headersList.join("\r\n") + "\r\n",
      fieldNames: fields.join(":")
    };
  }
  function relaxedHeaderLine(line) {
    return line.substr(line.indexOf(":") + 1).replace(/\r?\n/g, "").replace(/\s+/g, " ").trim();
  }
  var punycode = require_punycode2();
  var mimeFuncs = require_mime_funcs();
  var crypto3 = import.meta.require("crypto");
  module.exports = (headers, hashAlgo, bodyHash, options) => {
    options = options || {};
    let defaultFieldNames = "From:Sender:Reply-To:Subject:Date:Message-ID:To:" + "Cc:MIME-Version:Content-Type:Content-Transfer-Encoding:Content-ID:" + "Content-Description:Resent-Date:Resent-From:Resent-Sender:" + "Resent-To:Resent-Cc:Resent-Message-ID:In-Reply-To:References:" + "List-Id:List-Help:List-Unsubscribe:List-Subscribe:List-Post:" + "List-Owner:List-Archive";
    let fieldNames = options.headerFieldNames || defaultFieldNames;
    let canonicalizedHeaderData = relaxedHeaders(headers, fieldNames, options.skipFields);
    let dkimHeader = generateDKIMHeader(options.domainName, options.keySelector, canonicalizedHeaderData.fieldNames, hashAlgo, bodyHash);
    let signer, signature;
    canonicalizedHeaderData.headers += "dkim-signature:" + relaxedHeaderLine(dkimHeader);
    signer = crypto3.createSign(("rsa-" + hashAlgo).toUpperCase());
    signer.update(canonicalizedHeaderData.headers);
    try {
      signature = signer.sign(options.privateKey, "base64");
    } catch (E) {
      return false;
    }
    return dkimHeader + signature.replace(/(^.{73}|.{75}(?!\r?\n|\r))/g, "$&\r\n ").trim();
  };
  module.exports.relaxedHeaders = relaxedHeaders;
});

// node_modules/nodemailer/lib/dkim/index.js
var require_dkim = __commonJS((exports, module) => {
  var MessageParser = require_message_parser();
  var RelaxedBody = require_relaxed_body();
  var sign = require_sign();
  var PassThrough = import.meta.require("stream").PassThrough;
  var fs = import.meta.require("fs");
  var path = import.meta.require("path");
  var crypto3 = import.meta.require("crypto");
  var DKIM_ALGO = "sha256";
  var MAX_MESSAGE_SIZE = 128 * 1024;

  class DKIMSigner {
    constructor(options, keys, input, output) {
      this.options = options || {};
      this.keys = keys;
      this.cacheTreshold = Number(this.options.cacheTreshold) || MAX_MESSAGE_SIZE;
      this.hashAlgo = this.options.hashAlgo || DKIM_ALGO;
      this.cacheDir = this.options.cacheDir || false;
      this.chunks = [];
      this.chunklen = 0;
      this.readPos = 0;
      this.cachePath = this.cacheDir ? path.join(this.cacheDir, "message." + Date.now() + "-" + crypto3.randomBytes(14).toString("hex")) : false;
      this.cache = false;
      this.headers = false;
      this.bodyHash = false;
      this.parser = false;
      this.relaxedBody = false;
      this.input = input;
      this.output = output;
      this.output.usingCache = false;
      this.hasErrored = false;
      this.input.on("error", (err) => {
        this.hasErrored = true;
        this.cleanup();
        output.emit("error", err);
      });
    }
    cleanup() {
      if (!this.cache || !this.cachePath) {
        return;
      }
      fs.unlink(this.cachePath, () => false);
    }
    createReadCache() {
      this.cache = fs.createReadStream(this.cachePath);
      this.cache.once("error", (err) => {
        this.cleanup();
        this.output.emit("error", err);
      });
      this.cache.once("close", () => {
        this.cleanup();
      });
      this.cache.pipe(this.output);
    }
    sendNextChunk() {
      if (this.hasErrored) {
        return;
      }
      if (this.readPos >= this.chunks.length) {
        if (!this.cache) {
          return this.output.end();
        }
        return this.createReadCache();
      }
      let chunk = this.chunks[this.readPos++];
      if (this.output.write(chunk) === false) {
        return this.output.once("drain", () => {
          this.sendNextChunk();
        });
      }
      setImmediate(() => this.sendNextChunk());
    }
    sendSignedOutput() {
      let keyPos = 0;
      let signNextKey = () => {
        if (keyPos >= this.keys.length) {
          this.output.write(this.parser.rawHeaders);
          return setImmediate(() => this.sendNextChunk());
        }
        let key = this.keys[keyPos++];
        let dkimField = sign(this.headers, this.hashAlgo, this.bodyHash, {
          domainName: key.domainName,
          keySelector: key.keySelector,
          privateKey: key.privateKey,
          headerFieldNames: this.options.headerFieldNames,
          skipFields: this.options.skipFields
        });
        if (dkimField) {
          this.output.write(Buffer.from(dkimField + "\r\n"));
        }
        return setImmediate(signNextKey);
      };
      if (this.bodyHash && this.headers) {
        return signNextKey();
      }
      this.output.write(this.parser.rawHeaders);
      this.sendNextChunk();
    }
    createWriteCache() {
      this.output.usingCache = true;
      this.cache = fs.createWriteStream(this.cachePath);
      this.cache.once("error", (err) => {
        this.cleanup();
        this.relaxedBody.unpipe(this.cache);
        this.relaxedBody.on("readable", () => {
          while (this.relaxedBody.read() !== null) {
          }
        });
        this.hasErrored = true;
        this.output.emit("error", err);
      });
      this.cache.once("close", () => {
        this.sendSignedOutput();
      });
      this.relaxedBody.removeAllListeners("readable");
      this.relaxedBody.pipe(this.cache);
    }
    signStream() {
      this.parser = new MessageParser;
      this.relaxedBody = new RelaxedBody({
        hashAlgo: this.hashAlgo
      });
      this.parser.on("headers", (value) => {
        this.headers = value;
      });
      this.relaxedBody.on("hash", (value) => {
        this.bodyHash = value;
      });
      this.relaxedBody.on("readable", () => {
        let chunk;
        if (this.cache) {
          return;
        }
        while ((chunk = this.relaxedBody.read()) !== null) {
          this.chunks.push(chunk);
          this.chunklen += chunk.length;
          if (this.chunklen >= this.cacheTreshold && this.cachePath) {
            return this.createWriteCache();
          }
        }
      });
      this.relaxedBody.on("end", () => {
        if (this.cache) {
          return;
        }
        this.sendSignedOutput();
      });
      this.parser.pipe(this.relaxedBody);
      setImmediate(() => this.input.pipe(this.parser));
    }
  }

  class DKIM {
    constructor(options) {
      this.options = options || {};
      this.keys = [].concat(this.options.keys || {
        domainName: options.domainName,
        keySelector: options.keySelector,
        privateKey: options.privateKey
      });
    }
    sign(input, extraOptions) {
      let output = new PassThrough;
      let inputStream = input;
      let writeValue = false;
      if (Buffer.isBuffer(input)) {
        writeValue = input;
        inputStream = new PassThrough;
      } else if (typeof input === "string") {
        writeValue = Buffer.from(input);
        inputStream = new PassThrough;
      }
      let options = this.options;
      if (extraOptions && Object.keys(extraOptions).length) {
        options = {};
        Object.keys(this.options || {}).forEach((key) => {
          options[key] = this.options[key];
        });
        Object.keys(extraOptions || {}).forEach((key) => {
          if (!(key in options)) {
            options[key] = extraOptions[key];
          }
        });
      }
      let signer = new DKIMSigner(options, this.keys, inputStream, output);
      setImmediate(() => {
        signer.signStream();
        if (writeValue) {
          setImmediate(() => {
            inputStream.end(writeValue);
          });
        }
      });
      return output;
    }
  }
  module.exports = DKIM;
});

// node_modules/nodemailer/lib/smtp-connection/http-proxy-client.js
var require_http_proxy_client = __commonJS((exports, module) => {
  function httpProxyClient(proxyUrl, destinationPort, destinationHost, callback) {
    let proxy = urllib.parse(proxyUrl);
    let options;
    let connect;
    let socket;
    options = {
      host: proxy.hostname,
      port: Number(proxy.port) ? Number(proxy.port) : proxy.protocol === "https:" ? 443 : 80
    };
    if (proxy.protocol === "https:") {
      options.rejectUnauthorized = false;
      connect = tls.connect.bind(tls);
    } else {
      connect = net.connect.bind(net);
    }
    let finished = false;
    let tempSocketErr = (err) => {
      if (finished) {
        return;
      }
      finished = true;
      try {
        socket.destroy();
      } catch (E) {
      }
      callback(err);
    };
    let timeoutErr = () => {
      let err = new Error("Proxy socket timed out");
      err.code = "ETIMEDOUT";
      tempSocketErr(err);
    };
    socket = connect(options, () => {
      if (finished) {
        return;
      }
      let reqHeaders = {
        Host: destinationHost + ":" + destinationPort,
        Connection: "close"
      };
      if (proxy.auth) {
        reqHeaders["Proxy-Authorization"] = "Basic " + Buffer.from(proxy.auth).toString("base64");
      }
      socket.write("CONNECT " + destinationHost + ":" + destinationPort + " HTTP/1.1\r\n" + Object.keys(reqHeaders).map((key) => key + ": " + reqHeaders[key]).join("\r\n") + "\r\n\r\n");
      let headers = "";
      let onSocketData = (chunk) => {
        let match;
        let remainder;
        if (finished) {
          return;
        }
        headers += chunk.toString("binary");
        if (match = headers.match(/\r\n\r\n/)) {
          socket.removeListener("data", onSocketData);
          remainder = headers.substr(match.index + match[0].length);
          headers = headers.substr(0, match.index);
          if (remainder) {
            socket.unshift(Buffer.from(remainder, "binary"));
          }
          finished = true;
          match = headers.match(/^HTTP\/\d+\.\d+ (\d+)/i);
          if (!match || (match[1] || "").charAt(0) !== "2") {
            try {
              socket.destroy();
            } catch (E) {
            }
            return callback(new Error("Invalid response from proxy" + (match && ": " + match[1] || "")));
          }
          socket.removeListener("error", tempSocketErr);
          socket.removeListener("timeout", timeoutErr);
          socket.setTimeout(0);
          return callback(null, socket);
        }
      };
      socket.on("data", onSocketData);
    });
    socket.setTimeout(httpProxyClient.timeout || 30 * 1000);
    socket.on("timeout", timeoutErr);
    socket.once("error", tempSocketErr);
  }
  var net = import.meta.require("net");
  var tls = import.meta.require("tls");
  var urllib = import.meta.require("url");
  module.exports = httpProxyClient;
});

// node_modules/nodemailer/lib/mailer/mail-message.js
var require_mail_message = __commonJS((exports, module) => {
  var shared = require_shared2();
  var MimeNode = require_mime_node();
  var mimeFuncs = require_mime_funcs();

  class MailMessage {
    constructor(mailer, data) {
      this.mailer = mailer;
      this.data = {};
      this.message = null;
      data = data || {};
      let options = mailer.options || {};
      let defaults = mailer._defaults || {};
      Object.keys(data).forEach((key) => {
        this.data[key] = data[key];
      });
      this.data.headers = this.data.headers || {};
      Object.keys(defaults).forEach((key) => {
        if (!(key in this.data)) {
          this.data[key] = defaults[key];
        } else if (key === "headers") {
          Object.keys(defaults.headers).forEach((key2) => {
            if (!(key2 in this.data.headers)) {
              this.data.headers[key2] = defaults.headers[key2];
            }
          });
        }
      });
      ["disableFileAccess", "disableUrlAccess", "normalizeHeaderKey"].forEach((key) => {
        if (key in options) {
          this.data[key] = options[key];
        }
      });
    }
    resolveContent(...args) {
      return shared.resolveContent(...args);
    }
    resolveAll(callback) {
      let keys = [
        [this.data, "html"],
        [this.data, "text"],
        [this.data, "watchHtml"],
        [this.data, "amp"],
        [this.data, "icalEvent"]
      ];
      if (this.data.alternatives && this.data.alternatives.length) {
        this.data.alternatives.forEach((alternative, i) => {
          keys.push([this.data.alternatives, i]);
        });
      }
      if (this.data.attachments && this.data.attachments.length) {
        this.data.attachments.forEach((attachment, i) => {
          if (!attachment.filename) {
            attachment.filename = (attachment.path || attachment.href || "").split("/").pop().split("?").shift() || "attachment-" + (i + 1);
            if (attachment.filename.indexOf(".") < 0) {
              attachment.filename += "." + mimeFuncs.detectExtension(attachment.contentType);
            }
          }
          if (!attachment.contentType) {
            attachment.contentType = mimeFuncs.detectMimeType(attachment.filename || attachment.path || attachment.href || "bin");
          }
          keys.push([this.data.attachments, i]);
        });
      }
      let mimeNode = new MimeNode;
      let addressKeys = ["from", "to", "cc", "bcc", "sender", "replyTo"];
      addressKeys.forEach((address) => {
        let value;
        if (this.message) {
          value = [].concat(mimeNode._parseAddresses(this.message.getHeader(address === "replyTo" ? "reply-to" : address)) || []);
        } else if (this.data[address]) {
          value = [].concat(mimeNode._parseAddresses(this.data[address]) || []);
        }
        if (value && value.length) {
          this.data[address] = value;
        } else if (address in this.data) {
          this.data[address] = null;
        }
      });
      let singleKeys = ["from", "sender"];
      singleKeys.forEach((address) => {
        if (this.data[address]) {
          this.data[address] = this.data[address].shift();
        }
      });
      let pos = 0;
      let resolveNext = () => {
        if (pos >= keys.length) {
          return callback(null, this.data);
        }
        let args = keys[pos++];
        if (!args[0] || !args[0][args[1]]) {
          return resolveNext();
        }
        shared.resolveContent(...args, (err, value) => {
          if (err) {
            return callback(err);
          }
          let node = {
            content: value
          };
          if (args[0][args[1]] && typeof args[0][args[1]] === "object" && !Buffer.isBuffer(args[0][args[1]])) {
            Object.keys(args[0][args[1]]).forEach((key) => {
              if (!(key in node) && !["content", "path", "href", "raw"].includes(key)) {
                node[key] = args[0][args[1]][key];
              }
            });
          }
          args[0][args[1]] = node;
          resolveNext();
        });
      };
      setImmediate(() => resolveNext());
    }
    normalize(callback) {
      let envelope = this.data.envelope || this.message.getEnvelope();
      let messageId = this.message.messageId();
      this.resolveAll((err, data) => {
        if (err) {
          return callback(err);
        }
        data.envelope = envelope;
        data.messageId = messageId;
        ["html", "text", "watchHtml", "amp"].forEach((key) => {
          if (data[key] && data[key].content) {
            if (typeof data[key].content === "string") {
              data[key] = data[key].content;
            } else if (Buffer.isBuffer(data[key].content)) {
              data[key] = data[key].content.toString();
            }
          }
        });
        if (data.icalEvent && Buffer.isBuffer(data.icalEvent.content)) {
          data.icalEvent.content = data.icalEvent.content.toString("base64");
          data.icalEvent.encoding = "base64";
        }
        if (data.alternatives && data.alternatives.length) {
          data.alternatives.forEach((alternative) => {
            if (alternative && alternative.content && Buffer.isBuffer(alternative.content)) {
              alternative.content = alternative.content.toString("base64");
              alternative.encoding = "base64";
            }
          });
        }
        if (data.attachments && data.attachments.length) {
          data.attachments.forEach((attachment) => {
            if (attachment && attachment.content && Buffer.isBuffer(attachment.content)) {
              attachment.content = attachment.content.toString("base64");
              attachment.encoding = "base64";
            }
          });
        }
        data.normalizedHeaders = {};
        Object.keys(data.headers || {}).forEach((key) => {
          let value = [].concat(data.headers[key] || []).shift();
          value = value && value.value || value;
          if (value) {
            if (["references", "in-reply-to", "message-id", "content-id"].includes(key)) {
              value = this.message._encodeHeaderValue(key, value);
            }
            data.normalizedHeaders[key] = value;
          }
        });
        if (data.list && typeof data.list === "object") {
          let listHeaders = this._getListHeaders(data.list);
          listHeaders.forEach((entry) => {
            data.normalizedHeaders[entry.key] = entry.value.map((val) => val && val.value || val).join(", ");
          });
        }
        if (data.references) {
          data.normalizedHeaders.references = this.message._encodeHeaderValue("references", data.references);
        }
        if (data.inReplyTo) {
          data.normalizedHeaders["in-reply-to"] = this.message._encodeHeaderValue("in-reply-to", data.inReplyTo);
        }
        return callback(null, data);
      });
    }
    setMailerHeader() {
      if (!this.message || !this.data.xMailer) {
        return;
      }
      this.message.setHeader("X-Mailer", this.data.xMailer);
    }
    setPriorityHeaders() {
      if (!this.message || !this.data.priority) {
        return;
      }
      switch ((this.data.priority || "").toString().toLowerCase()) {
        case "high":
          this.message.setHeader("X-Priority", "1 (Highest)");
          this.message.setHeader("X-MSMail-Priority", "High");
          this.message.setHeader("Importance", "High");
          break;
        case "low":
          this.message.setHeader("X-Priority", "5 (Lowest)");
          this.message.setHeader("X-MSMail-Priority", "Low");
          this.message.setHeader("Importance", "Low");
          break;
        default:
      }
    }
    setListHeaders() {
      if (!this.message || !this.data.list || typeof this.data.list !== "object") {
        return;
      }
      if (this.data.list && typeof this.data.list === "object") {
        this._getListHeaders(this.data.list).forEach((listHeader) => {
          listHeader.value.forEach((value) => {
            this.message.addHeader(listHeader.key, value);
          });
        });
      }
    }
    _getListHeaders(listData) {
      return Object.keys(listData).map((key) => ({
        key: "list-" + key.toLowerCase().trim(),
        value: [].concat(listData[key] || []).map((value) => ({
          prepared: true,
          foldLines: true,
          value: [].concat(value || []).map((value2) => {
            if (typeof value2 === "string") {
              value2 = {
                url: value2
              };
            }
            if (value2 && value2.url) {
              if (key.toLowerCase().trim() === "id") {
                let comment2 = value2.comment || "";
                if (mimeFuncs.isPlainText(comment2)) {
                  comment2 = '"' + comment2 + '"';
                } else {
                  comment2 = mimeFuncs.encodeWord(comment2);
                }
                return (value2.comment ? comment2 + " " : "") + this._formatListUrl(value2.url).replace(/^<[^:]+\/{,2}/, "");
              }
              let comment = value2.comment || "";
              if (!mimeFuncs.isPlainText(comment)) {
                comment = mimeFuncs.encodeWord(comment);
              }
              return this._formatListUrl(value2.url) + (value2.comment ? " (" + comment + ")" : "");
            }
            return "";
          }).filter((value2) => value2).join(", ")
        }))
      }));
    }
    _formatListUrl(url) {
      url = url.replace(/[\s<]+|[\s>]+/g, "");
      if (/^(https?|mailto|ftp):/.test(url)) {
        return "<" + url + ">";
      }
      if (/^[^@]+@[^@]+$/.test(url)) {
        return "<mailto:" + url + ">";
      }
      return "<http://" + url + ">";
    }
  }
  module.exports = MailMessage;
});

// node_modules/nodemailer/lib/mailer/index.js
var require_mailer = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var shared = require_shared2();
  var mimeTypes = require_mime_types();
  var MailComposer = require_mail_composer();
  var DKIM = require_dkim();
  var httpProxyClient = require_http_proxy_client();
  var util = import.meta.require("util");
  var urllib = import.meta.require("url");
  var packageData = require_package4();
  var MailMessage = require_mail_message();
  var net = import.meta.require("net");
  var dns = import.meta.require("dns");
  var crypto3 = import.meta.require("crypto");

  class Mail extends EventEmitter {
    constructor(transporter, options, defaults) {
      super();
      this.options = options || {};
      this._defaults = defaults || {};
      this._defaultPlugins = {
        compile: [(...args) => this._convertDataImages(...args)],
        stream: []
      };
      this._userPlugins = {
        compile: [],
        stream: []
      };
      this.meta = new Map;
      this.dkim = this.options.dkim ? new DKIM(this.options.dkim) : false;
      this.transporter = transporter;
      this.transporter.mailer = this;
      this.logger = shared.getLogger(this.options, {
        component: this.options.component || "mail"
      });
      this.logger.debug({
        tnx: "create"
      }, "Creating transport: %s", this.getVersionString());
      if (typeof this.transporter.on === "function") {
        this.transporter.on("log", (log2) => {
          this.logger.debug({
            tnx: "transport"
          }, "%s: %s", log2.type, log2.message);
        });
        this.transporter.on("error", (err) => {
          this.logger.error({
            err,
            tnx: "transport"
          }, "Transport Error: %s", err.message);
          this.emit("error", err);
        });
        this.transporter.on("idle", (...args) => {
          this.emit("idle", ...args);
        });
      }
      ["close", "isIdle", "verify"].forEach((method) => {
        this[method] = (...args) => {
          if (typeof this.transporter[method] === "function") {
            if (method === "verify" && typeof this.getSocket === "function") {
              this.transporter.getSocket = this.getSocket;
              this.getSocket = false;
            }
            return this.transporter[method](...args);
          } else {
            this.logger.warn({
              tnx: "transport",
              methodName: method
            }, "Non existing method %s called for transport", method);
            return false;
          }
        };
      });
      if (this.options.proxy && typeof this.options.proxy === "string") {
        this.setupProxy(this.options.proxy);
      }
    }
    use(step, plugin) {
      step = (step || "").toString();
      if (!this._userPlugins.hasOwnProperty(step)) {
        this._userPlugins[step] = [plugin];
      } else {
        this._userPlugins[step].push(plugin);
      }
      return this;
    }
    sendMail(data, callback = null) {
      let promise;
      if (!callback) {
        promise = new Promise((resolve, reject) => {
          callback = shared.callbackPromise(resolve, reject);
        });
      }
      if (typeof this.getSocket === "function") {
        this.transporter.getSocket = this.getSocket;
        this.getSocket = false;
      }
      let mail = new MailMessage(this, data);
      this.logger.debug({
        tnx: "transport",
        name: this.transporter.name,
        version: this.transporter.version,
        action: "send"
      }, "Sending mail using %s/%s", this.transporter.name, this.transporter.version);
      this._processPlugins("compile", mail, (err) => {
        if (err) {
          this.logger.error({
            err,
            tnx: "plugin",
            action: "compile"
          }, "PluginCompile Error: %s", err.message);
          return callback(err);
        }
        mail.message = new MailComposer(mail.data).compile();
        mail.setMailerHeader();
        mail.setPriorityHeaders();
        mail.setListHeaders();
        this._processPlugins("stream", mail, (err2) => {
          if (err2) {
            this.logger.error({
              err: err2,
              tnx: "plugin",
              action: "stream"
            }, "PluginStream Error: %s", err2.message);
            return callback(err2);
          }
          if (mail.data.dkim || this.dkim) {
            mail.message.processFunc((input) => {
              let dkim = mail.data.dkim ? new DKIM(mail.data.dkim) : this.dkim;
              this.logger.debug({
                tnx: "DKIM",
                messageId: mail.message.messageId(),
                dkimDomains: dkim.keys.map((key) => key.keySelector + "." + key.domainName).join(", ")
              }, "Signing outgoing message with %s keys", dkim.keys.length);
              return dkim.sign(input, mail.data._dkim);
            });
          }
          this.transporter.send(mail, (...args) => {
            if (args[0]) {
              this.logger.error({
                err: args[0],
                tnx: "transport",
                action: "send"
              }, "Send Error: %s", args[0].message);
            }
            callback(...args);
          });
        });
      });
      return promise;
    }
    getVersionString() {
      return util.format("%s (%s; +%s; %s/%s)", packageData.name, packageData.version, packageData.homepage, this.transporter.name, this.transporter.version);
    }
    _processPlugins(step, mail, callback) {
      step = (step || "").toString();
      if (!this._userPlugins.hasOwnProperty(step)) {
        return callback();
      }
      let userPlugins = this._userPlugins[step] || [];
      let defaultPlugins = this._defaultPlugins[step] || [];
      if (userPlugins.length) {
        this.logger.debug({
          tnx: "transaction",
          pluginCount: userPlugins.length,
          step
        }, "Using %s plugins for %s", userPlugins.length, step);
      }
      if (userPlugins.length + defaultPlugins.length === 0) {
        return callback();
      }
      let pos = 0;
      let block = "default";
      let processPlugins = () => {
        let curplugins = block === "default" ? defaultPlugins : userPlugins;
        if (pos >= curplugins.length) {
          if (block === "default" && userPlugins.length) {
            block = "user";
            pos = 0;
            curplugins = userPlugins;
          } else {
            return callback();
          }
        }
        let plugin = curplugins[pos++];
        plugin(mail, (err) => {
          if (err) {
            return callback(err);
          }
          processPlugins();
        });
      };
      processPlugins();
    }
    setupProxy(proxyUrl) {
      let proxy = urllib.parse(proxyUrl);
      this.getSocket = (options, callback) => {
        let protocol = proxy.protocol.replace(/:$/, "").toLowerCase();
        if (this.meta.has("proxy_handler_" + protocol)) {
          return this.meta.get("proxy_handler_" + protocol)(proxy, options, callback);
        }
        switch (protocol) {
          case "http":
          case "https":
            httpProxyClient(proxy.href, options.port, options.host, (err, socket) => {
              if (err) {
                return callback(err);
              }
              return callback(null, {
                connection: socket
              });
            });
            return;
          case "socks":
          case "socks5":
          case "socks4":
          case "socks4a": {
            if (!this.meta.has("proxy_socks_module")) {
              return callback(new Error("Socks module not loaded"));
            }
            let connect = (ipaddress) => {
              let proxyV2 = !!this.meta.get("proxy_socks_module").SocksClient;
              let socksClient = proxyV2 ? this.meta.get("proxy_socks_module").SocksClient : this.meta.get("proxy_socks_module");
              let proxyType = Number(proxy.protocol.replace(/\D/g, "")) || 5;
              let connectionOpts = {
                proxy: {
                  ipaddress,
                  port: Number(proxy.port),
                  type: proxyType
                },
                [proxyV2 ? "destination" : "target"]: {
                  host: options.host,
                  port: options.port
                },
                command: "connect"
              };
              if (proxy.auth) {
                let username = decodeURIComponent(proxy.auth.split(":").shift());
                let password = decodeURIComponent(proxy.auth.split(":").pop());
                if (proxyV2) {
                  connectionOpts.proxy.userId = username;
                  connectionOpts.proxy.password = password;
                } else if (proxyType === 4) {
                  connectionOpts.userid = username;
                } else {
                  connectionOpts.authentication = {
                    username,
                    password
                  };
                }
              }
              socksClient.createConnection(connectionOpts, (err, info) => {
                if (err) {
                  return callback(err);
                }
                return callback(null, {
                  connection: info.socket || info
                });
              });
            };
            if (net.isIP(proxy.hostname)) {
              return connect(proxy.hostname);
            }
            return dns.resolve(proxy.hostname, (err, address) => {
              if (err) {
                return callback(err);
              }
              connect(Array.isArray(address) ? address[0] : address);
            });
          }
        }
        callback(new Error("Unknown proxy configuration"));
      };
    }
    _convertDataImages(mail, callback) {
      if (!this.options.attachDataUrls && !mail.data.attachDataUrls || !mail.data.html) {
        return callback();
      }
      mail.resolveContent(mail.data, "html", (err, html) => {
        if (err) {
          return callback(err);
        }
        let cidCounter = 0;
        html = (html || "").toString().replace(/(<img\b[^<>]{0,1024} src\s{0,20}=[\s"']{0,20})(data:([^;]+);[^"'>\s]+)/gi, (match, prefix, dataUri, mimeType) => {
          let cid = crypto3.randomBytes(10).toString("hex") + "@localhost";
          if (!mail.data.attachments) {
            mail.data.attachments = [];
          }
          if (!Array.isArray(mail.data.attachments)) {
            mail.data.attachments = [].concat(mail.data.attachments || []);
          }
          mail.data.attachments.push({
            path: dataUri,
            cid,
            filename: "image-" + ++cidCounter + "." + mimeTypes.detectExtension(mimeType)
          });
          return prefix + "cid:" + cid;
        });
        mail.data.html = html;
        callback();
      });
    }
    set(key, value) {
      return this.meta.set(key, value);
    }
    get(key) {
      return this.meta.get(key);
    }
  }
  module.exports = Mail;
});

// node_modules/nodemailer/lib/smtp-connection/data-stream.js
var require_data_stream = __commonJS((exports, module) => {
  var stream = import.meta.require("stream");
  var Transform = stream.Transform;

  class DataStream extends Transform {
    constructor(options) {
      super(options);
      this.options = options || {};
      this._curLine = "";
      this.inByteCount = 0;
      this.outByteCount = 0;
      this.lastByte = false;
    }
    _transform(chunk, encoding, done) {
      let chunks = [];
      let chunklen = 0;
      let i, len, lastPos = 0;
      let buf;
      if (!chunk || !chunk.length) {
        return done();
      }
      if (typeof chunk === "string") {
        chunk = Buffer.from(chunk);
      }
      this.inByteCount += chunk.length;
      for (i = 0, len = chunk.length;i < len; i++) {
        if (chunk[i] === 46) {
          if (i && chunk[i - 1] === 10 || !i && (!this.lastByte || this.lastByte === 10)) {
            buf = chunk.slice(lastPos, i + 1);
            chunks.push(buf);
            chunks.push(Buffer.from("."));
            chunklen += buf.length + 1;
            lastPos = i + 1;
          }
        } else if (chunk[i] === 10) {
          if (i && chunk[i - 1] !== 13 || !i && this.lastByte !== 13) {
            if (i > lastPos) {
              buf = chunk.slice(lastPos, i);
              chunks.push(buf);
              chunklen += buf.length + 2;
            } else {
              chunklen += 2;
            }
            chunks.push(Buffer.from("\r\n"));
            lastPos = i + 1;
          }
        }
      }
      if (chunklen) {
        if (lastPos < chunk.length) {
          buf = chunk.slice(lastPos);
          chunks.push(buf);
          chunklen += buf.length;
        }
        this.outByteCount += chunklen;
        this.push(Buffer.concat(chunks, chunklen));
      } else {
        this.outByteCount += chunk.length;
        this.push(chunk);
      }
      this.lastByte = chunk[chunk.length - 1];
      done();
    }
    _flush(done) {
      let buf;
      if (this.lastByte === 10) {
        buf = Buffer.from(".\r\n");
      } else if (this.lastByte === 13) {
        buf = Buffer.from("\n.\r\n");
      } else {
        buf = Buffer.from("\r\n.\r\n");
      }
      this.outByteCount += buf.length;
      this.push(buf);
      done();
    }
  }
  module.exports = DataStream;
});

// node_modules/nodemailer/lib/smtp-connection/index.js
var require_smtp_connection = __commonJS((exports, module) => {
  var packageInfo = require_package4();
  var EventEmitter = import.meta.require("events").EventEmitter;
  var net = import.meta.require("net");
  var tls = import.meta.require("tls");
  var os = import.meta.require("os");
  var crypto3 = import.meta.require("crypto");
  var DataStream = require_data_stream();
  var PassThrough = import.meta.require("stream").PassThrough;
  var shared = require_shared2();
  var CONNECTION_TIMEOUT = 2 * 60 * 1000;
  var SOCKET_TIMEOUT = 10 * 60 * 1000;
  var GREETING_TIMEOUT = 30 * 1000;
  var DNS_TIMEOUT = 30 * 1000;

  class SMTPConnection extends EventEmitter {
    constructor(options) {
      super(options);
      this.id = crypto3.randomBytes(8).toString("base64").replace(/\W/g, "");
      this.stage = "init";
      this.options = options || {};
      this.secureConnection = !!this.options.secure;
      this.alreadySecured = !!this.options.secured;
      this.port = Number(this.options.port) || (this.secureConnection ? 465 : 587);
      this.host = this.options.host || "localhost";
      this.servername = this.options.servername ? this.options.servername : !net.isIP(this.host) ? this.host : false;
      this.allowInternalNetworkInterfaces = this.options.allowInternalNetworkInterfaces || false;
      if (typeof this.options.secure === "undefined" && this.port === 465) {
        this.secureConnection = true;
      }
      this.name = this.options.name || this._getHostname();
      this.logger = shared.getLogger(this.options, {
        component: this.options.component || "smtp-connection",
        sid: this.id
      });
      this.customAuth = new Map;
      Object.keys(this.options.customAuth || {}).forEach((key) => {
        let mapKey = (key || "").toString().trim().toUpperCase();
        if (!mapKey) {
          return;
        }
        this.customAuth.set(mapKey, this.options.customAuth[key]);
      });
      this.version = packageInfo.version;
      this.authenticated = false;
      this.destroyed = false;
      this.secure = !!this.secureConnection;
      this._remainder = "";
      this._responseQueue = [];
      this.lastServerResponse = false;
      this._socket = false;
      this._supportedAuth = [];
      this.allowsAuth = false;
      this._envelope = false;
      this._supportedExtensions = [];
      this._maxAllowedSize = 0;
      this._responseActions = [];
      this._recipientQueue = [];
      this._greetingTimeout = false;
      this._connectionTimeout = false;
      this._destroyed = false;
      this._closing = false;
      this._onSocketData = (chunk) => this._onData(chunk);
      this._onSocketError = (error) => this._onError(error, "ESOCKET", false, "CONN");
      this._onSocketClose = () => this._onClose();
      this._onSocketEnd = () => this._onEnd();
      this._onSocketTimeout = () => this._onTimeout();
    }
    connect(connectCallback) {
      if (typeof connectCallback === "function") {
        this.once("connect", () => {
          this.logger.debug({
            tnx: "smtp"
          }, "SMTP handshake finished");
          connectCallback();
        });
        const isDestroyedMessage = this._isDestroyedMessage("connect");
        if (isDestroyedMessage) {
          return connectCallback(this._formatError(isDestroyedMessage, "ECONNECTION", false, "CONN"));
        }
      }
      let opts = {
        port: this.port,
        host: this.host,
        allowInternalNetworkInterfaces: this.allowInternalNetworkInterfaces,
        timeout: this.options.dnsTimeout || DNS_TIMEOUT
      };
      if (this.options.localAddress) {
        opts.localAddress = this.options.localAddress;
      }
      let setupConnectionHandlers = () => {
        this._connectionTimeout = setTimeout(() => {
          this._onError("Connection timeout", "ETIMEDOUT", false, "CONN");
        }, this.options.connectionTimeout || CONNECTION_TIMEOUT);
        this._socket.on("error", this._onSocketError);
      };
      if (this.options.connection) {
        this._socket = this.options.connection;
        setupConnectionHandlers();
        if (this.secureConnection && !this.alreadySecured) {
          setImmediate(() => this._upgradeConnection((err) => {
            if (err) {
              this._onError(new Error("Error initiating TLS - " + (err.message || err)), "ETLS", false, "CONN");
              return;
            }
            this._onConnect();
          }));
        } else {
          setImmediate(() => this._onConnect());
        }
        return;
      } else if (this.options.socket) {
        this._socket = this.options.socket;
        return shared.resolveHostname(opts, (err, resolved) => {
          if (err) {
            return setImmediate(() => this._onError(err, "EDNS", false, "CONN"));
          }
          this.logger.debug({
            tnx: "dns",
            source: opts.host,
            resolved: resolved.host,
            cached: !!resolved.cached
          }, "Resolved %s as %s [cache %s]", opts.host, resolved.host, resolved.cached ? "hit" : "miss");
          Object.keys(resolved).forEach((key) => {
            if (key.charAt(0) !== "_" && resolved[key]) {
              opts[key] = resolved[key];
            }
          });
          try {
            this._socket.connect(this.port, this.host, () => {
              this._socket.setKeepAlive(true);
              this._onConnect();
            });
            setupConnectionHandlers();
          } catch (E) {
            return setImmediate(() => this._onError(E, "ECONNECTION", false, "CONN"));
          }
        });
      } else if (this.secureConnection) {
        if (this.options.tls) {
          Object.keys(this.options.tls).forEach((key) => {
            opts[key] = this.options.tls[key];
          });
        }
        if (this.servername && !opts.servername) {
          opts.servername = this.servername;
        }
        return shared.resolveHostname(opts, (err, resolved) => {
          if (err) {
            return setImmediate(() => this._onError(err, "EDNS", false, "CONN"));
          }
          this.logger.debug({
            tnx: "dns",
            source: opts.host,
            resolved: resolved.host,
            cached: !!resolved.cached
          }, "Resolved %s as %s [cache %s]", opts.host, resolved.host, resolved.cached ? "hit" : "miss");
          Object.keys(resolved).forEach((key) => {
            if (key.charAt(0) !== "_" && resolved[key]) {
              opts[key] = resolved[key];
            }
          });
          try {
            this._socket = tls.connect(opts, () => {
              this._socket.setKeepAlive(true);
              this._onConnect();
            });
            setupConnectionHandlers();
          } catch (E) {
            return setImmediate(() => this._onError(E, "ECONNECTION", false, "CONN"));
          }
        });
      } else {
        return shared.resolveHostname(opts, (err, resolved) => {
          if (err) {
            return setImmediate(() => this._onError(err, "EDNS", false, "CONN"));
          }
          this.logger.debug({
            tnx: "dns",
            source: opts.host,
            resolved: resolved.host,
            cached: !!resolved.cached
          }, "Resolved %s as %s [cache %s]", opts.host, resolved.host, resolved.cached ? "hit" : "miss");
          Object.keys(resolved).forEach((key) => {
            if (key.charAt(0) !== "_" && resolved[key]) {
              opts[key] = resolved[key];
            }
          });
          try {
            this._socket = net.connect(opts, () => {
              this._socket.setKeepAlive(true);
              this._onConnect();
            });
            setupConnectionHandlers();
          } catch (E) {
            return setImmediate(() => this._onError(E, "ECONNECTION", false, "CONN"));
          }
        });
      }
    }
    quit() {
      this._sendCommand("QUIT");
      this._responseActions.push(this.close);
    }
    close() {
      clearTimeout(this._connectionTimeout);
      clearTimeout(this._greetingTimeout);
      this._responseActions = [];
      if (this._closing) {
        return;
      }
      this._closing = true;
      let closeMethod = "end";
      if (this.stage === "init") {
        closeMethod = "destroy";
      }
      this.logger.debug({
        tnx: "smtp"
      }, 'Closing connection to the server using "%s"', closeMethod);
      let socket = this._socket && this._socket.socket || this._socket;
      if (socket && !socket.destroyed) {
        try {
          this._socket[closeMethod]();
        } catch (E) {
        }
      }
      this._destroy();
    }
    login(authData, callback) {
      const isDestroyedMessage = this._isDestroyedMessage("login");
      if (isDestroyedMessage) {
        return callback(this._formatError(isDestroyedMessage, "ECONNECTION", false, "API"));
      }
      this._auth = authData || {};
      this._authMethod = (this._auth.method || "").toString().trim().toUpperCase() || false;
      if (!this._authMethod && this._auth.oauth2 && !this._auth.credentials) {
        this._authMethod = "XOAUTH2";
      } else if (!this._authMethod || this._authMethod === "XOAUTH2" && !this._auth.oauth2) {
        this._authMethod = (this._supportedAuth[0] || "PLAIN").toUpperCase().trim();
      }
      if (this._authMethod !== "XOAUTH2" && (!this._auth.credentials || !this._auth.credentials.user || !this._auth.credentials.pass)) {
        if (this._auth.user && this._auth.pass || this.customAuth.has(this._authMethod)) {
          this._auth.credentials = {
            user: this._auth.user,
            pass: this._auth.pass,
            options: this._auth.options
          };
        } else {
          return callback(this._formatError('Missing credentials for "' + this._authMethod + '"', "EAUTH", false, "API"));
        }
      }
      if (this.customAuth.has(this._authMethod)) {
        let handler = this.customAuth.get(this._authMethod);
        let lastResponse;
        let returned = false;
        let resolve = () => {
          if (returned) {
            return;
          }
          returned = true;
          this.logger.info({
            tnx: "smtp",
            username: this._auth.user,
            action: "authenticated",
            method: this._authMethod
          }, "User %s authenticated", JSON.stringify(this._auth.user));
          this.authenticated = true;
          callback(null, true);
        };
        let reject = (err) => {
          if (returned) {
            return;
          }
          returned = true;
          callback(this._formatError(err, "EAUTH", lastResponse, "AUTH " + this._authMethod));
        };
        let handlerResponse = handler({
          auth: this._auth,
          method: this._authMethod,
          extensions: [].concat(this._supportedExtensions),
          authMethods: [].concat(this._supportedAuth),
          maxAllowedSize: this._maxAllowedSize || false,
          sendCommand: (cmd, done) => {
            let promise;
            if (!done) {
              promise = new Promise((resolve2, reject2) => {
                done = shared.callbackPromise(resolve2, reject2);
              });
            }
            this._responseActions.push((str) => {
              lastResponse = str;
              let codes = str.match(/^(\d+)(?:\s(\d+\.\d+\.\d+))?\s/);
              let data = {
                command: cmd,
                response: str
              };
              if (codes) {
                data.status = Number(codes[1]) || 0;
                if (codes[2]) {
                  data.code = codes[2];
                }
                data.text = str.substr(codes[0].length);
              } else {
                data.text = str;
                data.status = 0;
              }
              done(null, data);
            });
            setImmediate(() => this._sendCommand(cmd));
            return promise;
          },
          resolve,
          reject
        });
        if (handlerResponse && typeof handlerResponse.catch === "function") {
          handlerResponse.then(resolve).catch(reject);
        }
        return;
      }
      switch (this._authMethod) {
        case "XOAUTH2":
          this._handleXOauth2Token(false, callback);
          return;
        case "LOGIN":
          this._responseActions.push((str) => {
            this._actionAUTH_LOGIN_USER(str, callback);
          });
          this._sendCommand("AUTH LOGIN");
          return;
        case "PLAIN":
          this._responseActions.push((str) => {
            this._actionAUTHComplete(str, callback);
          });
          this._sendCommand("AUTH PLAIN " + Buffer.from("\0" + this._auth.credentials.user + "\0" + this._auth.credentials.pass, "utf-8").toString("base64"), "AUTH PLAIN " + Buffer.from("\0" + this._auth.credentials.user + "\0" + "/* secret */", "utf-8").toString("base64"));
          return;
        case "CRAM-MD5":
          this._responseActions.push((str) => {
            this._actionAUTH_CRAM_MD5(str, callback);
          });
          this._sendCommand("AUTH CRAM-MD5");
          return;
      }
      return callback(this._formatError('Unknown authentication method "' + this._authMethod + '"', "EAUTH", false, "API"));
    }
    send(envelope, message, done) {
      if (!message) {
        return done(this._formatError("Empty message", "EMESSAGE", false, "API"));
      }
      const isDestroyedMessage = this._isDestroyedMessage("send message");
      if (isDestroyedMessage) {
        return done(this._formatError(isDestroyedMessage, "ECONNECTION", false, "API"));
      }
      if (this._maxAllowedSize && envelope.size > this._maxAllowedSize) {
        return setImmediate(() => {
          done(this._formatError("Message size larger than allowed " + this._maxAllowedSize, "EMESSAGE", false, "MAIL FROM"));
        });
      }
      let returned = false;
      let callback = function() {
        if (returned) {
          return;
        }
        returned = true;
        done(...arguments);
      };
      if (typeof message.on === "function") {
        message.on("error", (err) => callback(this._formatError(err, "ESTREAM", false, "API")));
      }
      let startTime = Date.now();
      this._setEnvelope(envelope, (err, info) => {
        if (err) {
          let stream2 = new PassThrough;
          if (typeof message.pipe === "function") {
            message.pipe(stream2);
          } else {
            stream2.write(message);
            stream2.end();
          }
          return callback(err);
        }
        let envelopeTime = Date.now();
        let stream = this._createSendStream((err2, str) => {
          if (err2) {
            return callback(err2);
          }
          info.envelopeTime = envelopeTime - startTime;
          info.messageTime = Date.now() - envelopeTime;
          info.messageSize = stream.outByteCount;
          info.response = str;
          return callback(null, info);
        });
        if (typeof message.pipe === "function") {
          message.pipe(stream);
        } else {
          stream.write(message);
          stream.end();
        }
      });
    }
    reset(callback) {
      this._sendCommand("RSET");
      this._responseActions.push((str) => {
        if (str.charAt(0) !== "2") {
          return callback(this._formatError("Could not reset session state. response=" + str, "EPROTOCOL", str, "RSET"));
        }
        this._envelope = false;
        return callback(null, true);
      });
    }
    _onConnect() {
      clearTimeout(this._connectionTimeout);
      this.logger.info({
        tnx: "network",
        localAddress: this._socket.localAddress,
        localPort: this._socket.localPort,
        remoteAddress: this._socket.remoteAddress,
        remotePort: this._socket.remotePort
      }, "%s established to %s:%s", this.secure ? "Secure connection" : "Connection", this._socket.remoteAddress, this._socket.remotePort);
      if (this._destroyed) {
        this.close();
        return;
      }
      this.stage = "connected";
      this._socket.removeListener("data", this._onSocketData);
      this._socket.removeListener("timeout", this._onSocketTimeout);
      this._socket.removeListener("close", this._onSocketClose);
      this._socket.removeListener("end", this._onSocketEnd);
      this._socket.on("data", this._onSocketData);
      this._socket.once("close", this._onSocketClose);
      this._socket.once("end", this._onSocketEnd);
      this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);
      this._socket.on("timeout", this._onSocketTimeout);
      this._greetingTimeout = setTimeout(() => {
        if (this._socket && !this._destroyed && this._responseActions[0] === this._actionGreeting) {
          this._onError("Greeting never received", "ETIMEDOUT", false, "CONN");
        }
      }, this.options.greetingTimeout || GREETING_TIMEOUT);
      this._responseActions.push(this._actionGreeting);
      this._socket.resume();
    }
    _onData(chunk) {
      if (this._destroyed || !chunk || !chunk.length) {
        return;
      }
      let data = (chunk || "").toString("binary");
      let lines = (this._remainder + data).split(/\r?\n/);
      let lastline;
      this._remainder = lines.pop();
      for (let i = 0, len = lines.length;i < len; i++) {
        if (this._responseQueue.length) {
          lastline = this._responseQueue[this._responseQueue.length - 1];
          if (/^\d+-/.test(lastline.split("\n").pop())) {
            this._responseQueue[this._responseQueue.length - 1] += "\n" + lines[i];
            continue;
          }
        }
        this._responseQueue.push(lines[i]);
      }
      if (this._responseQueue.length) {
        lastline = this._responseQueue[this._responseQueue.length - 1];
        if (/^\d+-/.test(lastline.split("\n").pop())) {
          return;
        }
      }
      this._processResponse();
    }
    _onError(err, type, data, command) {
      clearTimeout(this._connectionTimeout);
      clearTimeout(this._greetingTimeout);
      if (this._destroyed) {
        return;
      }
      err = this._formatError(err, type, data, command);
      this.logger.error(data, err.message);
      this.emit("error", err);
      this.close();
    }
    _formatError(message, type, response, command) {
      let err;
      if (/Error\]$/i.test(Object.prototype.toString.call(message))) {
        err = message;
      } else {
        err = new Error(message);
      }
      if (type && type !== "Error") {
        err.code = type;
      }
      if (response) {
        err.response = response;
        err.message += ": " + response;
      }
      let responseCode = typeof response === "string" && Number((response.match(/^\d+/) || [])[0]) || false;
      if (responseCode) {
        err.responseCode = responseCode;
      }
      if (command) {
        err.command = command;
      }
      return err;
    }
    _onClose() {
      let serverResponse = false;
      if (this._remainder && this._remainder.trim()) {
        if (this.options.debug || this.options.transactionLog) {
          this.logger.debug({
            tnx: "server"
          }, this._remainder.replace(/\r?\n$/, ""));
        }
        this.lastServerResponse = serverResponse = this._remainder.trim();
      }
      this.logger.info({
        tnx: "network"
      }, "Connection closed");
      if (this.upgrading && !this._destroyed) {
        return this._onError(new Error("Connection closed unexpectedly"), "ETLS", serverResponse, "CONN");
      } else if (![this._actionGreeting, this.close].includes(this._responseActions[0]) && !this._destroyed) {
        return this._onError(new Error("Connection closed unexpectedly"), "ECONNECTION", serverResponse, "CONN");
      } else if (/^[45]\d{2}\b/.test(serverResponse)) {
        return this._onError(new Error("Connection closed unexpectedly"), "ECONNECTION", serverResponse, "CONN");
      }
      this._destroy();
    }
    _onEnd() {
      if (this._socket && !this._socket.destroyed) {
        this._socket.destroy();
      }
    }
    _onTimeout() {
      return this._onError(new Error("Timeout"), "ETIMEDOUT", false, "CONN");
    }
    _destroy() {
      if (this._destroyed) {
        return;
      }
      this._destroyed = true;
      this.emit("end");
    }
    _upgradeConnection(callback) {
      this._socket.removeListener("data", this._onSocketData);
      this._socket.removeListener("timeout", this._onSocketTimeout);
      let socketPlain = this._socket;
      let opts = {
        socket: this._socket,
        host: this.host
      };
      Object.keys(this.options.tls || {}).forEach((key) => {
        opts[key] = this.options.tls[key];
      });
      if (this.servername && !opts.servername) {
        opts.servername = this.servername;
      }
      this.upgrading = true;
      try {
        this._socket = tls.connect(opts, () => {
          this.secure = true;
          this.upgrading = false;
          this._socket.on("data", this._onSocketData);
          socketPlain.removeListener("close", this._onSocketClose);
          socketPlain.removeListener("end", this._onSocketEnd);
          return callback(null, true);
        });
      } catch (err) {
        return callback(err);
      }
      this._socket.on("error", this._onSocketError);
      this._socket.once("close", this._onSocketClose);
      this._socket.once("end", this._onSocketEnd);
      this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);
      this._socket.on("timeout", this._onSocketTimeout);
      socketPlain.resume();
    }
    _processResponse() {
      if (!this._responseQueue.length) {
        return false;
      }
      let str = this.lastServerResponse = (this._responseQueue.shift() || "").toString();
      if (/^\d+-/.test(str.split("\n").pop())) {
        return;
      }
      if (this.options.debug || this.options.transactionLog) {
        this.logger.debug({
          tnx: "server"
        }, str.replace(/\r?\n$/, ""));
      }
      if (!str.trim()) {
        setImmediate(() => this._processResponse());
      }
      let action = this._responseActions.shift();
      if (typeof action === "function") {
        action.call(this, str);
        setImmediate(() => this._processResponse());
      } else {
        return this._onError(new Error("Unexpected Response"), "EPROTOCOL", str, "CONN");
      }
    }
    _sendCommand(str, logStr) {
      if (this._destroyed) {
        return;
      }
      if (this._socket.destroyed) {
        return this.close();
      }
      if (this.options.debug || this.options.transactionLog) {
        this.logger.debug({
          tnx: "client"
        }, (logStr || str || "").toString().replace(/\r?\n$/, ""));
      }
      this._socket.write(Buffer.from(str + "\r\n", "utf-8"));
    }
    _setEnvelope(envelope, callback) {
      let args = [];
      let useSmtpUtf8 = false;
      this._envelope = envelope || {};
      this._envelope.from = (this._envelope.from && this._envelope.from.address || this._envelope.from || "").toString().trim();
      this._envelope.to = [].concat(this._envelope.to || []).map((to) => (to && to.address || to || "").toString().trim());
      if (!this._envelope.to.length) {
        return callback(this._formatError("No recipients defined", "EENVELOPE", false, "API"));
      }
      if (this._envelope.from && /[\r\n<>]/.test(this._envelope.from)) {
        return callback(this._formatError("Invalid sender " + JSON.stringify(this._envelope.from), "EENVELOPE", false, "API"));
      }
      if (/[\x80-\uFFFF]/.test(this._envelope.from)) {
        useSmtpUtf8 = true;
      }
      for (let i = 0, len = this._envelope.to.length;i < len; i++) {
        if (!this._envelope.to[i] || /[\r\n<>]/.test(this._envelope.to[i])) {
          return callback(this._formatError("Invalid recipient " + JSON.stringify(this._envelope.to[i]), "EENVELOPE", false, "API"));
        }
        if (/[\x80-\uFFFF]/.test(this._envelope.to[i])) {
          useSmtpUtf8 = true;
        }
      }
      this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));
      this._envelope.rejected = [];
      this._envelope.rejectedErrors = [];
      this._envelope.accepted = [];
      if (this._envelope.dsn) {
        try {
          this._envelope.dsn = this._setDsnEnvelope(this._envelope.dsn);
        } catch (err) {
          return callback(this._formatError("Invalid DSN " + err.message, "EENVELOPE", false, "API"));
        }
      }
      this._responseActions.push((str) => {
        this._actionMAIL(str, callback);
      });
      if (useSmtpUtf8 && this._supportedExtensions.includes("SMTPUTF8")) {
        args.push("SMTPUTF8");
        this._usingSmtpUtf8 = true;
      }
      if (this._envelope.use8BitMime && this._supportedExtensions.includes("8BITMIME")) {
        args.push("BODY=8BITMIME");
        this._using8BitMime = true;
      }
      if (this._envelope.size && this._supportedExtensions.includes("SIZE")) {
        args.push("SIZE=" + this._envelope.size);
      }
      if (this._envelope.dsn && this._supportedExtensions.includes("DSN")) {
        if (this._envelope.dsn.ret) {
          args.push("RET=" + shared.encodeXText(this._envelope.dsn.ret));
        }
        if (this._envelope.dsn.envid) {
          args.push("ENVID=" + shared.encodeXText(this._envelope.dsn.envid));
        }
      }
      this._sendCommand("MAIL FROM:<" + this._envelope.from + ">" + (args.length ? " " + args.join(" ") : ""));
    }
    _setDsnEnvelope(params) {
      let ret = (params.ret || params.return || "").toString().toUpperCase() || null;
      if (ret) {
        switch (ret) {
          case "HDRS":
          case "HEADERS":
            ret = "HDRS";
            break;
          case "FULL":
          case "BODY":
            ret = "FULL";
            break;
        }
      }
      if (ret && !["FULL", "HDRS"].includes(ret)) {
        throw new Error("ret: " + JSON.stringify(ret));
      }
      let envid = (params.envid || params.id || "").toString() || null;
      let notify = params.notify || null;
      if (notify) {
        if (typeof notify === "string") {
          notify = notify.split(",");
        }
        notify = notify.map((n) => n.trim().toUpperCase());
        let validNotify = ["NEVER", "SUCCESS", "FAILURE", "DELAY"];
        let invaliNotify = notify.filter((n) => !validNotify.includes(n));
        if (invaliNotify.length || notify.length > 1 && notify.includes("NEVER")) {
          throw new Error("notify: " + JSON.stringify(notify.join(",")));
        }
        notify = notify.join(",");
      }
      let orcpt = (params.recipient || params.orcpt || "").toString() || null;
      if (orcpt && orcpt.indexOf(";") < 0) {
        orcpt = "rfc822;" + orcpt;
      }
      return {
        ret,
        envid,
        notify,
        orcpt
      };
    }
    _getDsnRcptToArgs() {
      let args = [];
      if (this._envelope.dsn && this._supportedExtensions.includes("DSN")) {
        if (this._envelope.dsn.notify) {
          args.push("NOTIFY=" + shared.encodeXText(this._envelope.dsn.notify));
        }
        if (this._envelope.dsn.orcpt) {
          args.push("ORCPT=" + shared.encodeXText(this._envelope.dsn.orcpt));
        }
      }
      return args.length ? " " + args.join(" ") : "";
    }
    _createSendStream(callback) {
      let dataStream = new DataStream;
      let logStream;
      if (this.options.lmtp) {
        this._envelope.accepted.forEach((recipient, i) => {
          let final = i === this._envelope.accepted.length - 1;
          this._responseActions.push((str) => {
            this._actionLMTPStream(recipient, final, str, callback);
          });
        });
      } else {
        this._responseActions.push((str) => {
          this._actionSMTPStream(str, callback);
        });
      }
      dataStream.pipe(this._socket, {
        end: false
      });
      if (this.options.debug) {
        logStream = new PassThrough;
        logStream.on("readable", () => {
          let chunk;
          while (chunk = logStream.read()) {
            this.logger.debug({
              tnx: "message"
            }, chunk.toString("binary").replace(/\r?\n$/, ""));
          }
        });
        dataStream.pipe(logStream);
      }
      dataStream.once("end", () => {
        this.logger.info({
          tnx: "message",
          inByteCount: dataStream.inByteCount,
          outByteCount: dataStream.outByteCount
        }, "<%s bytes encoded mime message (source size %s bytes)>", dataStream.outByteCount, dataStream.inByteCount);
      });
      return dataStream;
    }
    _actionGreeting(str) {
      clearTimeout(this._greetingTimeout);
      if (str.substr(0, 3) !== "220") {
        this._onError(new Error("Invalid greeting. response=" + str), "EPROTOCOL", str, "CONN");
        return;
      }
      if (this.options.lmtp) {
        this._responseActions.push(this._actionLHLO);
        this._sendCommand("LHLO " + this.name);
      } else {
        this._responseActions.push(this._actionEHLO);
        this._sendCommand("EHLO " + this.name);
      }
    }
    _actionLHLO(str) {
      if (str.charAt(0) !== "2") {
        this._onError(new Error("Invalid LHLO. response=" + str), "EPROTOCOL", str, "LHLO");
        return;
      }
      this._actionEHLO(str);
    }
    _actionEHLO(str) {
      let match;
      if (str.substr(0, 3) === "421") {
        this._onError(new Error("Server terminates connection. response=" + str), "ECONNECTION", str, "EHLO");
        return;
      }
      if (str.charAt(0) !== "2") {
        if (this.options.requireTLS) {
          this._onError(new Error("EHLO failed but HELO does not support required STARTTLS. response=" + str), "ECONNECTION", str, "EHLO");
          return;
        }
        this._responseActions.push(this._actionHELO);
        this._sendCommand("HELO " + this.name);
        return;
      }
      this._ehloLines = str.split(/\r?\n/).map((line) => line.replace(/^\d+[ -]/, "").trim()).filter((line) => line).slice(1);
      if (!this.secure && !this.options.ignoreTLS && (/[ -]STARTTLS\b/im.test(str) || this.options.requireTLS)) {
        this._sendCommand("STARTTLS");
        this._responseActions.push(this._actionSTARTTLS);
        return;
      }
      if (/[ -]SMTPUTF8\b/im.test(str)) {
        this._supportedExtensions.push("SMTPUTF8");
      }
      if (/[ -]DSN\b/im.test(str)) {
        this._supportedExtensions.push("DSN");
      }
      if (/[ -]8BITMIME\b/im.test(str)) {
        this._supportedExtensions.push("8BITMIME");
      }
      if (/[ -]PIPELINING\b/im.test(str)) {
        this._supportedExtensions.push("PIPELINING");
      }
      if (/[ -]AUTH\b/i.test(str)) {
        this.allowsAuth = true;
      }
      if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)PLAIN/i.test(str)) {
        this._supportedAuth.push("PLAIN");
      }
      if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)LOGIN/i.test(str)) {
        this._supportedAuth.push("LOGIN");
      }
      if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)CRAM-MD5/i.test(str)) {
        this._supportedAuth.push("CRAM-MD5");
      }
      if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)XOAUTH2/i.test(str)) {
        this._supportedAuth.push("XOAUTH2");
      }
      if (match = str.match(/[ -]SIZE(?:[ \t]+(\d+))?/im)) {
        this._supportedExtensions.push("SIZE");
        this._maxAllowedSize = Number(match[1]) || 0;
      }
      this.emit("connect");
    }
    _actionHELO(str) {
      if (str.charAt(0) !== "2") {
        this._onError(new Error("Invalid HELO. response=" + str), "EPROTOCOL", str, "HELO");
        return;
      }
      this.allowsAuth = true;
      this.emit("connect");
    }
    _actionSTARTTLS(str) {
      if (str.charAt(0) !== "2") {
        if (this.options.opportunisticTLS) {
          this.logger.info({
            tnx: "smtp"
          }, "Failed STARTTLS upgrade, continuing unencrypted");
          return this.emit("connect");
        }
        this._onError(new Error("Error upgrading connection with STARTTLS"), "ETLS", str, "STARTTLS");
        return;
      }
      this._upgradeConnection((err, secured) => {
        if (err) {
          this._onError(new Error("Error initiating TLS - " + (err.message || err)), "ETLS", false, "STARTTLS");
          return;
        }
        this.logger.info({
          tnx: "smtp"
        }, "Connection upgraded with STARTTLS");
        if (secured) {
          if (this.options.lmtp) {
            this._responseActions.push(this._actionLHLO);
            this._sendCommand("LHLO " + this.name);
          } else {
            this._responseActions.push(this._actionEHLO);
            this._sendCommand("EHLO " + this.name);
          }
        } else {
          this.emit("connect");
        }
      });
    }
    _actionAUTH_LOGIN_USER(str, callback) {
      if (!/^334[ -]/.test(str)) {
        callback(this._formatError('Invalid login sequence while waiting for "334 VXNlcm5hbWU6"', "EAUTH", str, "AUTH LOGIN"));
        return;
      }
      this._responseActions.push((str2) => {
        this._actionAUTH_LOGIN_PASS(str2, callback);
      });
      this._sendCommand(Buffer.from(this._auth.credentials.user + "", "utf-8").toString("base64"));
    }
    _actionAUTH_CRAM_MD5(str, callback) {
      let challengeMatch = str.match(/^334\s+(.+)$/);
      let challengeString = "";
      if (!challengeMatch) {
        return callback(this._formatError("Invalid login sequence while waiting for server challenge string", "EAUTH", str, "AUTH CRAM-MD5"));
      } else {
        challengeString = challengeMatch[1];
      }
      let base64decoded = Buffer.from(challengeString, "base64").toString("ascii"), hmacMD5 = crypto3.createHmac("md5", this._auth.credentials.pass);
      hmacMD5.update(base64decoded);
      let prepended = this._auth.credentials.user + " " + hmacMD5.digest("hex");
      this._responseActions.push((str2) => {
        this._actionAUTH_CRAM_MD5_PASS(str2, callback);
      });
      this._sendCommand(Buffer.from(prepended).toString("base64"), Buffer.from(this._auth.credentials.user + " /* secret */").toString("base64"));
    }
    _actionAUTH_CRAM_MD5_PASS(str, callback) {
      if (!str.match(/^235\s+/)) {
        return callback(this._formatError('Invalid login sequence while waiting for "235"', "EAUTH", str, "AUTH CRAM-MD5"));
      }
      this.logger.info({
        tnx: "smtp",
        username: this._auth.user,
        action: "authenticated",
        method: this._authMethod
      }, "User %s authenticated", JSON.stringify(this._auth.user));
      this.authenticated = true;
      callback(null, true);
    }
    _actionAUTH_LOGIN_PASS(str, callback) {
      if (!/^334[ -]/.test(str)) {
        return callback(this._formatError('Invalid login sequence while waiting for "334 UGFzc3dvcmQ6"', "EAUTH", str, "AUTH LOGIN"));
      }
      this._responseActions.push((str2) => {
        this._actionAUTHComplete(str2, callback);
      });
      this._sendCommand(Buffer.from((this._auth.credentials.pass || "").toString(), "utf-8").toString("base64"), Buffer.from("/* secret */", "utf-8").toString("base64"));
    }
    _actionAUTHComplete(str, isRetry, callback) {
      if (!callback && typeof isRetry === "function") {
        callback = isRetry;
        isRetry = false;
      }
      if (str.substr(0, 3) === "334") {
        this._responseActions.push((str2) => {
          if (isRetry || this._authMethod !== "XOAUTH2") {
            this._actionAUTHComplete(str2, true, callback);
          } else {
            setImmediate(() => this._handleXOauth2Token(true, callback));
          }
        });
        this._sendCommand("");
        return;
      }
      if (str.charAt(0) !== "2") {
        this.logger.info({
          tnx: "smtp",
          username: this._auth.user,
          action: "authfail",
          method: this._authMethod
        }, "User %s failed to authenticate", JSON.stringify(this._auth.user));
        return callback(this._formatError("Invalid login", "EAUTH", str, "AUTH " + this._authMethod));
      }
      this.logger.info({
        tnx: "smtp",
        username: this._auth.user,
        action: "authenticated",
        method: this._authMethod
      }, "User %s authenticated", JSON.stringify(this._auth.user));
      this.authenticated = true;
      callback(null, true);
    }
    _actionMAIL(str, callback) {
      let message, curRecipient;
      if (Number(str.charAt(0)) !== 2) {
        if (this._usingSmtpUtf8 && /^550 /.test(str) && /[\x80-\uFFFF]/.test(this._envelope.from)) {
          message = "Internationalized mailbox name not allowed";
        } else {
          message = "Mail command failed";
        }
        return callback(this._formatError(message, "EENVELOPE", str, "MAIL FROM"));
      }
      if (!this._envelope.rcptQueue.length) {
        return callback(this._formatError("Can't send mail - no recipients defined", "EENVELOPE", false, "API"));
      } else {
        this._recipientQueue = [];
        if (this._supportedExtensions.includes("PIPELINING")) {
          while (this._envelope.rcptQueue.length) {
            curRecipient = this._envelope.rcptQueue.shift();
            this._recipientQueue.push(curRecipient);
            this._responseActions.push((str2) => {
              this._actionRCPT(str2, callback);
            });
            this._sendCommand("RCPT TO:<" + curRecipient + ">" + this._getDsnRcptToArgs());
          }
        } else {
          curRecipient = this._envelope.rcptQueue.shift();
          this._recipientQueue.push(curRecipient);
          this._responseActions.push((str2) => {
            this._actionRCPT(str2, callback);
          });
          this._sendCommand("RCPT TO:<" + curRecipient + ">" + this._getDsnRcptToArgs());
        }
      }
    }
    _actionRCPT(str, callback) {
      let message, err, curRecipient = this._recipientQueue.shift();
      if (Number(str.charAt(0)) !== 2) {
        if (this._usingSmtpUtf8 && /^553 /.test(str) && /[\x80-\uFFFF]/.test(curRecipient)) {
          message = "Internationalized mailbox name not allowed";
        } else {
          message = "Recipient command failed";
        }
        this._envelope.rejected.push(curRecipient);
        err = this._formatError(message, "EENVELOPE", str, "RCPT TO");
        err.recipient = curRecipient;
        this._envelope.rejectedErrors.push(err);
      } else {
        this._envelope.accepted.push(curRecipient);
      }
      if (!this._envelope.rcptQueue.length && !this._recipientQueue.length) {
        if (this._envelope.rejected.length < this._envelope.to.length) {
          this._responseActions.push((str2) => {
            this._actionDATA(str2, callback);
          });
          this._sendCommand("DATA");
        } else {
          err = this._formatError("Can't send mail - all recipients were rejected", "EENVELOPE", str, "RCPT TO");
          err.rejected = this._envelope.rejected;
          err.rejectedErrors = this._envelope.rejectedErrors;
          return callback(err);
        }
      } else if (this._envelope.rcptQueue.length) {
        curRecipient = this._envelope.rcptQueue.shift();
        this._recipientQueue.push(curRecipient);
        this._responseActions.push((str2) => {
          this._actionRCPT(str2, callback);
        });
        this._sendCommand("RCPT TO:<" + curRecipient + ">" + this._getDsnRcptToArgs());
      }
    }
    _actionDATA(str, callback) {
      if (!/^[23]/.test(str)) {
        return callback(this._formatError("Data command failed", "EENVELOPE", str, "DATA"));
      }
      let response = {
        accepted: this._envelope.accepted,
        rejected: this._envelope.rejected
      };
      if (this._ehloLines && this._ehloLines.length) {
        response.ehlo = this._ehloLines;
      }
      if (this._envelope.rejectedErrors.length) {
        response.rejectedErrors = this._envelope.rejectedErrors;
      }
      callback(null, response);
    }
    _actionSMTPStream(str, callback) {
      if (Number(str.charAt(0)) !== 2) {
        return callback(this._formatError("Message failed", "EMESSAGE", str, "DATA"));
      } else {
        return callback(null, str);
      }
    }
    _actionLMTPStream(recipient, final, str, callback) {
      let err;
      if (Number(str.charAt(0)) !== 2) {
        err = this._formatError("Message failed for recipient " + recipient, "EMESSAGE", str, "DATA");
        err.recipient = recipient;
        this._envelope.rejected.push(recipient);
        this._envelope.rejectedErrors.push(err);
        for (let i = 0, len = this._envelope.accepted.length;i < len; i++) {
          if (this._envelope.accepted[i] === recipient) {
            this._envelope.accepted.splice(i, 1);
          }
        }
      }
      if (final) {
        return callback(null, str);
      }
    }
    _handleXOauth2Token(isRetry, callback) {
      this._auth.oauth2.getToken(isRetry, (err, accessToken) => {
        if (err) {
          this.logger.info({
            tnx: "smtp",
            username: this._auth.user,
            action: "authfail",
            method: this._authMethod
          }, "User %s failed to authenticate", JSON.stringify(this._auth.user));
          return callback(this._formatError(err, "EAUTH", false, "AUTH XOAUTH2"));
        }
        this._responseActions.push((str) => {
          this._actionAUTHComplete(str, isRetry, callback);
        });
        this._sendCommand("AUTH XOAUTH2 " + this._auth.oauth2.buildXOAuth2Token(accessToken), "AUTH XOAUTH2 " + this._auth.oauth2.buildXOAuth2Token("/* secret */"));
      });
    }
    _isDestroyedMessage(command) {
      if (this._destroyed) {
        return "Cannot " + command + " - smtp connection is already destroyed.";
      }
      if (this._socket) {
        if (this._socket.destroyed) {
          return "Cannot " + command + " - smtp connection socket is already destroyed.";
        }
        if (!this._socket.writable) {
          return "Cannot " + command + " - smtp connection socket is already half-closed.";
        }
      }
    }
    _getHostname() {
      let defaultHostname;
      try {
        defaultHostname = os.hostname() || "";
      } catch (err) {
        defaultHostname = "localhost";
      }
      if (!defaultHostname || defaultHostname.indexOf(".") < 0) {
        defaultHostname = "[127.0.0.1]";
      }
      if (defaultHostname.match(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/)) {
        defaultHostname = "[" + defaultHostname + "]";
      }
      return defaultHostname;
    }
  }
  module.exports = SMTPConnection;
});

// node_modules/nodemailer/lib/xoauth2/index.js
var require_xoauth2 = __commonJS((exports, module) => {
  var Stream = import.meta.require("stream").Stream;
  var nmfetch = require_fetch();
  var crypto3 = import.meta.require("crypto");
  var shared = require_shared2();

  class XOAuth2 extends Stream {
    constructor(options, logger2) {
      super();
      this.options = options || {};
      if (options && options.serviceClient) {
        if (!options.privateKey || !options.user) {
          setImmediate(() => this.emit("error", new Error('Options "privateKey" and "user" are required for service account!')));
          return;
        }
        let serviceRequestTimeout = Math.min(Math.max(Number(this.options.serviceRequestTimeout) || 0, 0), 3600);
        this.options.serviceRequestTimeout = serviceRequestTimeout || 5 * 60;
      }
      this.logger = shared.getLogger({
        logger: logger2
      }, {
        component: this.options.component || "OAuth2"
      });
      this.provisionCallback = typeof this.options.provisionCallback === "function" ? this.options.provisionCallback : false;
      this.options.accessUrl = this.options.accessUrl || "https://accounts.google.com/o/oauth2/token";
      this.options.customHeaders = this.options.customHeaders || {};
      this.options.customParams = this.options.customParams || {};
      this.accessToken = this.options.accessToken || false;
      if (this.options.expires && Number(this.options.expires)) {
        this.expires = this.options.expires;
      } else {
        let timeout = Math.max(Number(this.options.timeout) || 0, 0);
        this.expires = timeout && Date.now() + timeout * 1000 || 0;
      }
    }
    getToken(renew, callback) {
      if (!renew && this.accessToken && (!this.expires || this.expires > Date.now())) {
        return callback(null, this.accessToken);
      }
      let generateCallback = (...args) => {
        if (args[0]) {
          this.logger.error({
            err: args[0],
            tnx: "OAUTH2",
            user: this.options.user,
            action: "renew"
          }, "Failed generating new Access Token for %s", this.options.user);
        } else {
          this.logger.info({
            tnx: "OAUTH2",
            user: this.options.user,
            action: "renew"
          }, "Generated new Access Token for %s", this.options.user);
        }
        callback(...args);
      };
      if (this.provisionCallback) {
        this.provisionCallback(this.options.user, !!renew, (err, accessToken, expires) => {
          if (!err && accessToken) {
            this.accessToken = accessToken;
            this.expires = expires || 0;
          }
          generateCallback(err, accessToken);
        });
      } else {
        this.generateToken(generateCallback);
      }
    }
    updateToken(accessToken, timeout) {
      this.accessToken = accessToken;
      timeout = Math.max(Number(timeout) || 0, 0);
      this.expires = timeout && Date.now() + timeout * 1000 || 0;
      this.emit("token", {
        user: this.options.user,
        accessToken: accessToken || "",
        expires: this.expires
      });
    }
    generateToken(callback) {
      let urlOptions;
      let loggedUrlOptions;
      if (this.options.serviceClient) {
        let iat = Math.floor(Date.now() / 1000);
        let tokenData = {
          iss: this.options.serviceClient,
          scope: this.options.scope || "https://mail.google.com/",
          sub: this.options.user,
          aud: this.options.accessUrl,
          iat,
          exp: iat + this.options.serviceRequestTimeout
        };
        let token;
        try {
          token = this.jwtSignRS256(tokenData);
        } catch (err) {
          return callback(new Error("Can't generate token. Check your auth options"));
        }
        urlOptions = {
          grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
          assertion: token
        };
        loggedUrlOptions = {
          grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
          assertion: tokenData
        };
      } else {
        if (!this.options.refreshToken) {
          return callback(new Error("Can't create new access token for user"));
        }
        urlOptions = {
          client_id: this.options.clientId || "",
          client_secret: this.options.clientSecret || "",
          refresh_token: this.options.refreshToken,
          grant_type: "refresh_token"
        };
        loggedUrlOptions = {
          client_id: this.options.clientId || "",
          client_secret: (this.options.clientSecret || "").substr(0, 6) + "...",
          refresh_token: (this.options.refreshToken || "").substr(0, 6) + "...",
          grant_type: "refresh_token"
        };
      }
      Object.keys(this.options.customParams).forEach((key) => {
        urlOptions[key] = this.options.customParams[key];
        loggedUrlOptions[key] = this.options.customParams[key];
      });
      this.logger.debug({
        tnx: "OAUTH2",
        user: this.options.user,
        action: "generate"
      }, "Requesting token using: %s", JSON.stringify(loggedUrlOptions));
      this.postRequest(this.options.accessUrl, urlOptions, this.options, (error, body) => {
        let data;
        if (error) {
          return callback(error);
        }
        try {
          data = JSON.parse(body.toString());
        } catch (E) {
          return callback(E);
        }
        if (!data || typeof data !== "object") {
          this.logger.debug({
            tnx: "OAUTH2",
            user: this.options.user,
            action: "post"
          }, "Response: %s", (body || "").toString());
          return callback(new Error("Invalid authentication response"));
        }
        let logData = {};
        Object.keys(data).forEach((key) => {
          if (key !== "access_token") {
            logData[key] = data[key];
          } else {
            logData[key] = (data[key] || "").toString().substr(0, 6) + "...";
          }
        });
        this.logger.debug({
          tnx: "OAUTH2",
          user: this.options.user,
          action: "post"
        }, "Response: %s", JSON.stringify(logData));
        if (data.error) {
          let errorMessage = data.error;
          if (data.error_description) {
            errorMessage += ": " + data.error_description;
          }
          if (data.error_uri) {
            errorMessage += " (" + data.error_uri + ")";
          }
          return callback(new Error(errorMessage));
        }
        if (data.access_token) {
          this.updateToken(data.access_token, data.expires_in);
          return callback(null, this.accessToken);
        }
        return callback(new Error("No access token"));
      });
    }
    buildXOAuth2Token(accessToken) {
      let authData = ["user=" + (this.options.user || ""), "auth=Bearer " + (accessToken || this.accessToken), "", ""];
      return Buffer.from(authData.join("\x01"), "utf-8").toString("base64");
    }
    postRequest(url, payload, params, callback) {
      let returned = false;
      let chunks = [];
      let chunklen = 0;
      let req = nmfetch(url, {
        method: "post",
        headers: params.customHeaders,
        body: payload,
        allowErrorResponse: true
      });
      req.on("readable", () => {
        let chunk;
        while ((chunk = req.read()) !== null) {
          chunks.push(chunk);
          chunklen += chunk.length;
        }
      });
      req.once("error", (err) => {
        if (returned) {
          return;
        }
        returned = true;
        return callback(err);
      });
      req.once("end", () => {
        if (returned) {
          return;
        }
        returned = true;
        return callback(null, Buffer.concat(chunks, chunklen));
      });
    }
    toBase64URL(data) {
      if (typeof data === "string") {
        data = Buffer.from(data);
      }
      return data.toString("base64").replace(/[=]+/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    jwtSignRS256(payload) {
      payload = ['{"alg":"RS256","typ":"JWT"}', JSON.stringify(payload)].map((val) => this.toBase64URL(val)).join(".");
      let signature = crypto3.createSign("RSA-SHA256").update(payload).sign(this.options.privateKey);
      return payload + "." + this.toBase64URL(signature);
    }
  }
  module.exports = XOAuth2;
});

// node_modules/nodemailer/lib/smtp-pool/pool-resource.js
var require_pool_resource = __commonJS((exports, module) => {
  var SMTPConnection = require_smtp_connection();
  var assign = require_shared2().assign;
  var XOAuth2 = require_xoauth2();
  var EventEmitter = import.meta.require("events");

  class PoolResource extends EventEmitter {
    constructor(pool) {
      super();
      this.pool = pool;
      this.options = pool.options;
      this.logger = this.pool.logger;
      if (this.options.auth) {
        switch ((this.options.auth.type || "").toString().toUpperCase()) {
          case "OAUTH2": {
            let oauth2 = new XOAuth2(this.options.auth, this.logger);
            oauth2.provisionCallback = this.pool.mailer && this.pool.mailer.get("oauth2_provision_cb") || oauth2.provisionCallback;
            this.auth = {
              type: "OAUTH2",
              user: this.options.auth.user,
              oauth2,
              method: "XOAUTH2"
            };
            oauth2.on("token", (token) => this.pool.mailer.emit("token", token));
            oauth2.on("error", (err) => this.emit("error", err));
            break;
          }
          default:
            if (!this.options.auth.user && !this.options.auth.pass) {
              break;
            }
            this.auth = {
              type: (this.options.auth.type || "").toString().toUpperCase() || "LOGIN",
              user: this.options.auth.user,
              credentials: {
                user: this.options.auth.user || "",
                pass: this.options.auth.pass,
                options: this.options.auth.options
              },
              method: (this.options.auth.method || "").trim().toUpperCase() || this.options.authMethod || false
            };
        }
      }
      this._connection = false;
      this._connected = false;
      this.messages = 0;
      this.available = true;
    }
    connect(callback) {
      this.pool.getSocket(this.options, (err, socketOptions) => {
        if (err) {
          return callback(err);
        }
        let returned = false;
        let options = this.options;
        if (socketOptions && socketOptions.connection) {
          this.logger.info({
            tnx: "proxy",
            remoteAddress: socketOptions.connection.remoteAddress,
            remotePort: socketOptions.connection.remotePort,
            destHost: options.host || "",
            destPort: options.port || "",
            action: "connected"
          }, "Using proxied socket from %s:%s to %s:%s", socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || "", options.port || "");
          options = assign(false, options);
          Object.keys(socketOptions).forEach((key) => {
            options[key] = socketOptions[key];
          });
        }
        this.connection = new SMTPConnection(options);
        this.connection.once("error", (err2) => {
          this.emit("error", err2);
          if (returned) {
            return;
          }
          returned = true;
          return callback(err2);
        });
        this.connection.once("end", () => {
          this.close();
          if (returned) {
            return;
          }
          returned = true;
          let timer = setTimeout(() => {
            if (returned) {
              return;
            }
            let err2 = new Error("Unexpected socket close");
            if (this.connection && this.connection._socket && this.connection._socket.upgrading) {
              err2.code = "ETLS";
            }
            callback(err2);
          }, 1000);
          try {
            timer.unref();
          } catch (E) {
          }
        });
        this.connection.connect(() => {
          if (returned) {
            return;
          }
          if (this.auth && (this.connection.allowsAuth || options.forceAuth)) {
            this.connection.login(this.auth, (err2) => {
              if (returned) {
                return;
              }
              returned = true;
              if (err2) {
                this.connection.close();
                this.emit("error", err2);
                return callback(err2);
              }
              this._connected = true;
              callback(null, true);
            });
          } else {
            returned = true;
            this._connected = true;
            return callback(null, true);
          }
        });
      });
    }
    send(mail, callback) {
      if (!this._connected) {
        return this.connect((err) => {
          if (err) {
            return callback(err);
          }
          return this.send(mail, callback);
        });
      }
      let envelope = mail.message.getEnvelope();
      let messageId = mail.message.messageId();
      let recipients = [].concat(envelope.to || []);
      if (recipients.length > 3) {
        recipients.push("...and " + recipients.splice(2).length + " more");
      }
      this.logger.info({
        tnx: "send",
        messageId,
        cid: this.id
      }, "Sending message %s using #%s to <%s>", messageId, this.id, recipients.join(", "));
      if (mail.data.dsn) {
        envelope.dsn = mail.data.dsn;
      }
      this.connection.send(envelope, mail.message.createReadStream(), (err, info) => {
        this.messages++;
        if (err) {
          this.connection.close();
          this.emit("error", err);
          return callback(err);
        }
        info.envelope = {
          from: envelope.from,
          to: envelope.to
        };
        info.messageId = messageId;
        setImmediate(() => {
          let err2;
          if (this.messages >= this.options.maxMessages) {
            err2 = new Error("Resource exhausted");
            err2.code = "EMAXLIMIT";
            this.connection.close();
            this.emit("error", err2);
          } else {
            this.pool._checkRateLimit(() => {
              this.available = true;
              this.emit("available");
            });
          }
        });
        callback(null, info);
      });
    }
    close() {
      this._connected = false;
      if (this.auth && this.auth.oauth2) {
        this.auth.oauth2.removeAllListeners();
      }
      if (this.connection) {
        this.connection.close();
      }
      this.emit("close");
    }
  }
  module.exports = PoolResource;
});

// node_modules/nodemailer/lib/well-known/services.json
var require_services = __commonJS((exports, module) => {
  module.exports = {
    "1und1": {
      host: "smtp.1und1.de",
      port: 465,
      secure: true,
      authMethod: "LOGIN"
    },
    Aliyun: {
      domains: ["aliyun.com"],
      host: "smtp.aliyun.com",
      port: 465,
      secure: true
    },
    AOL: {
      domains: ["aol.com"],
      host: "smtp.aol.com",
      port: 587
    },
    Bluewin: {
      host: "smtpauths.bluewin.ch",
      domains: ["bluewin.ch"],
      port: 465
    },
    DebugMail: {
      host: "debugmail.io",
      port: 25
    },
    DynectEmail: {
      aliases: ["Dynect"],
      host: "smtp.dynect.net",
      port: 25
    },
    Ethereal: {
      aliases: ["ethereal.email"],
      host: "smtp.ethereal.email",
      port: 587
    },
    FastMail: {
      domains: ["fastmail.fm"],
      host: "smtp.fastmail.com",
      port: 465,
      secure: true
    },
    "Forward Email": {
      aliases: ["FE", "ForwardEmail"],
      domains: ["forwardemail.net"],
      host: "smtp.forwardemail.net",
      port: 465,
      secure: true
    },
    "Feishu Mail": {
      aliases: ["Feishu", "FeishuMail"],
      domains: ["www.feishu.cn"],
      host: "smtp.feishu.cn",
      port: 465,
      secure: true
    },
    GandiMail: {
      aliases: ["Gandi", "Gandi Mail"],
      host: "mail.gandi.net",
      port: 587
    },
    Gmail: {
      aliases: ["Google Mail"],
      domains: ["gmail.com", "googlemail.com"],
      host: "smtp.gmail.com",
      port: 465,
      secure: true
    },
    Godaddy: {
      host: "smtpout.secureserver.net",
      port: 25
    },
    GodaddyAsia: {
      host: "smtp.asia.secureserver.net",
      port: 25
    },
    GodaddyEurope: {
      host: "smtp.europe.secureserver.net",
      port: 25
    },
    "hot.ee": {
      host: "mail.hot.ee"
    },
    Hotmail: {
      aliases: ["Outlook", "Outlook.com", "Hotmail.com"],
      domains: ["hotmail.com", "outlook.com"],
      host: "smtp-mail.outlook.com",
      port: 587
    },
    iCloud: {
      aliases: ["Me", "Mac"],
      domains: ["me.com", "mac.com"],
      host: "smtp.mail.me.com",
      port: 587
    },
    Infomaniak: {
      host: "mail.infomaniak.com",
      domains: ["ik.me", "ikmail.com", "etik.com"],
      port: 587
    },
    Loopia: {
      host: "mailcluster.loopia.se",
      port: 465
    },
    "mail.ee": {
      host: "smtp.mail.ee"
    },
    "Mail.ru": {
      host: "smtp.mail.ru",
      port: 465,
      secure: true
    },
    "Mailcatch.app": {
      host: "sandbox-smtp.mailcatch.app",
      port: 2525
    },
    Maildev: {
      port: 1025,
      ignoreTLS: true
    },
    Mailgun: {
      host: "smtp.mailgun.org",
      port: 465,
      secure: true
    },
    Mailjet: {
      host: "in.mailjet.com",
      port: 587
    },
    Mailosaur: {
      host: "mailosaur.io",
      port: 25
    },
    Mailtrap: {
      host: "live.smtp.mailtrap.io",
      port: 587
    },
    Mandrill: {
      host: "smtp.mandrillapp.com",
      port: 587
    },
    Naver: {
      host: "smtp.naver.com",
      port: 587
    },
    One: {
      host: "send.one.com",
      port: 465,
      secure: true
    },
    OpenMailBox: {
      aliases: ["OMB", "openmailbox.org"],
      host: "smtp.openmailbox.org",
      port: 465,
      secure: true
    },
    Outlook365: {
      host: "smtp.office365.com",
      port: 587,
      secure: false
    },
    OhMySMTP: {
      host: "smtp.ohmysmtp.com",
      port: 587,
      secure: false
    },
    Postmark: {
      aliases: ["PostmarkApp"],
      host: "smtp.postmarkapp.com",
      port: 2525
    },
    Proton: {
      aliases: ["ProtonMail", "Proton.me", "Protonmail.com", "Protonmail.ch"],
      domains: ["proton.me", "protonmail.com", "pm.me", "protonmail.ch"],
      host: "smtp.protonmail.ch",
      port: 587,
      requireTLS: true
    },
    "qiye.aliyun": {
      host: "smtp.mxhichina.com",
      port: "465",
      secure: true
    },
    QQ: {
      domains: ["qq.com"],
      host: "smtp.qq.com",
      port: 465,
      secure: true
    },
    QQex: {
      aliases: ["QQ Enterprise"],
      domains: ["exmail.qq.com"],
      host: "smtp.exmail.qq.com",
      port: 465,
      secure: true
    },
    SendCloud: {
      host: "smtp.sendcloud.net",
      port: 2525
    },
    SendGrid: {
      host: "smtp.sendgrid.net",
      port: 587
    },
    SendinBlue: {
      aliases: ["Brevo"],
      host: "smtp-relay.brevo.com",
      port: 587
    },
    SendPulse: {
      host: "smtp-pulse.com",
      port: 465,
      secure: true
    },
    SES: {
      host: "email-smtp.us-east-1.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-US-EAST-1": {
      host: "email-smtp.us-east-1.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-US-WEST-2": {
      host: "email-smtp.us-west-2.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-EU-WEST-1": {
      host: "email-smtp.eu-west-1.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-AP-SOUTH-1": {
      host: "email-smtp.ap-south-1.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-AP-NORTHEAST-1": {
      host: "email-smtp.ap-northeast-1.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-AP-NORTHEAST-2": {
      host: "email-smtp.ap-northeast-2.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-AP-NORTHEAST-3": {
      host: "email-smtp.ap-northeast-3.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-AP-SOUTHEAST-1": {
      host: "email-smtp.ap-southeast-1.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-AP-SOUTHEAST-2": {
      host: "email-smtp.ap-southeast-2.amazonaws.com",
      port: 465,
      secure: true
    },
    Seznam: {
      aliases: ["Seznam Email"],
      domains: ["seznam.cz", "email.cz", "post.cz", "spoluzaci.cz"],
      host: "smtp.seznam.cz",
      port: 465,
      secure: true
    },
    Sparkpost: {
      aliases: ["SparkPost", "SparkPost Mail"],
      domains: ["sparkpost.com"],
      host: "smtp.sparkpostmail.com",
      port: 587,
      secure: false
    },
    Tipimail: {
      host: "smtp.tipimail.com",
      port: 587
    },
    Yahoo: {
      domains: ["yahoo.com"],
      host: "smtp.mail.yahoo.com",
      port: 465,
      secure: true
    },
    Yandex: {
      domains: ["yandex.ru"],
      host: "smtp.yandex.ru",
      port: 465,
      secure: true
    },
    Zoho: {
      host: "smtp.zoho.com",
      port: 465,
      secure: true,
      authMethod: "LOGIN"
    },
    "126": {
      host: "smtp.126.com",
      port: 465,
      secure: true
    },
    "163": {
      host: "smtp.163.com",
      port: 465,
      secure: true
    }
  };
});

// node_modules/nodemailer/lib/well-known/index.js
var require_well_known = __commonJS((exports, module) => {
  function normalizeKey(key) {
    return key.replace(/[^a-zA-Z0-9.-]/g, "").toLowerCase();
  }
  function normalizeService(service) {
    let filter = ["domains", "aliases"];
    let response = {};
    Object.keys(service).forEach((key) => {
      if (filter.indexOf(key) < 0) {
        response[key] = service[key];
      }
    });
    return response;
  }
  var services = require_services();
  var normalized = {};
  Object.keys(services).forEach((key) => {
    let service = services[key];
    normalized[normalizeKey(key)] = normalizeService(service);
    [].concat(service.aliases || []).forEach((alias) => {
      normalized[normalizeKey(alias)] = normalizeService(service);
    });
    [].concat(service.domains || []).forEach((domain) => {
      normalized[normalizeKey(domain)] = normalizeService(service);
    });
  });
  module.exports = function(key) {
    key = normalizeKey(key.split("@").pop());
    return normalized[key] || false;
  };
});

// node_modules/nodemailer/lib/smtp-pool/index.js
var require_smtp_pool = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var PoolResource = require_pool_resource();
  var SMTPConnection = require_smtp_connection();
  var wellKnown = require_well_known();
  var shared = require_shared2();
  var packageData = require_package4();

  class SMTPPool extends EventEmitter {
    constructor(options) {
      super();
      options = options || {};
      if (typeof options === "string") {
        options = {
          url: options
        };
      }
      let urlData;
      let service = options.service;
      if (typeof options.getSocket === "function") {
        this.getSocket = options.getSocket;
      }
      if (options.url) {
        urlData = shared.parseConnectionUrl(options.url);
        service = service || urlData.service;
      }
      this.options = shared.assign(false, options, urlData, service && wellKnown(service));
      this.options.maxConnections = this.options.maxConnections || 5;
      this.options.maxMessages = this.options.maxMessages || 100;
      this.logger = shared.getLogger(this.options, {
        component: this.options.component || "smtp-pool"
      });
      let connection = new SMTPConnection(this.options);
      this.name = "SMTP (pool)";
      this.version = packageData.version + "[client:" + connection.version + "]";
      this._rateLimit = {
        counter: 0,
        timeout: null,
        waiting: [],
        checkpoint: false,
        delta: Number(this.options.rateDelta) || 1000,
        limit: Number(this.options.rateLimit) || 0
      };
      this._closed = false;
      this._queue = [];
      this._connections = [];
      this._connectionCounter = 0;
      this.idling = true;
      setImmediate(() => {
        if (this.idling) {
          this.emit("idle");
        }
      });
    }
    getSocket(options, callback) {
      return setImmediate(() => callback(null, false));
    }
    send(mail, callback) {
      if (this._closed) {
        return false;
      }
      this._queue.push({
        mail,
        requeueAttempts: 0,
        callback
      });
      if (this.idling && this._queue.length >= this.options.maxConnections) {
        this.idling = false;
      }
      setImmediate(() => this._processMessages());
      return true;
    }
    close() {
      let connection;
      let len = this._connections.length;
      this._closed = true;
      clearTimeout(this._rateLimit.timeout);
      if (!len && !this._queue.length) {
        return;
      }
      for (let i = len - 1;i >= 0; i--) {
        if (this._connections[i] && this._connections[i].available) {
          connection = this._connections[i];
          connection.close();
          this.logger.info({
            tnx: "connection",
            cid: connection.id,
            action: "removed"
          }, "Connection #%s removed", connection.id);
        }
      }
      if (len && !this._connections.length) {
        this.logger.debug({
          tnx: "connection"
        }, "All connections removed");
      }
      if (!this._queue.length) {
        return;
      }
      let invokeCallbacks = () => {
        if (!this._queue.length) {
          this.logger.debug({
            tnx: "connection"
          }, "Pending queue entries cleared");
          return;
        }
        let entry = this._queue.shift();
        if (entry && typeof entry.callback === "function") {
          try {
            entry.callback(new Error("Connection pool was closed"));
          } catch (E) {
            this.logger.error({
              err: E,
              tnx: "callback",
              cid: connection.id
            }, "Callback error for #%s: %s", connection.id, E.message);
          }
        }
        setImmediate(invokeCallbacks);
      };
      setImmediate(invokeCallbacks);
    }
    _processMessages() {
      let connection;
      let i, len;
      if (this._closed) {
        return;
      }
      if (!this._queue.length) {
        if (!this.idling) {
          this.idling = true;
          this.emit("idle");
        }
        return;
      }
      for (i = 0, len = this._connections.length;i < len; i++) {
        if (this._connections[i].available) {
          connection = this._connections[i];
          break;
        }
      }
      if (!connection && this._connections.length < this.options.maxConnections) {
        connection = this._createConnection();
      }
      if (!connection) {
        this.idling = false;
        return;
      }
      if (!this.idling && this._queue.length < this.options.maxConnections) {
        this.idling = true;
        this.emit("idle");
      }
      let entry = connection.queueEntry = this._queue.shift();
      entry.messageId = (connection.queueEntry.mail.message.getHeader("message-id") || "").replace(/[<>\s]/g, "");
      connection.available = false;
      this.logger.debug({
        tnx: "pool",
        cid: connection.id,
        messageId: entry.messageId,
        action: "assign"
      }, "Assigned message <%s> to #%s (%s)", entry.messageId, connection.id, connection.messages + 1);
      if (this._rateLimit.limit) {
        this._rateLimit.counter++;
        if (!this._rateLimit.checkpoint) {
          this._rateLimit.checkpoint = Date.now();
        }
      }
      connection.send(entry.mail, (err, info) => {
        if (entry === connection.queueEntry) {
          try {
            entry.callback(err, info);
          } catch (E) {
            this.logger.error({
              err: E,
              tnx: "callback",
              cid: connection.id
            }, "Callback error for #%s: %s", connection.id, E.message);
          }
          connection.queueEntry = false;
        }
      });
    }
    _createConnection() {
      let connection = new PoolResource(this);
      connection.id = ++this._connectionCounter;
      this.logger.info({
        tnx: "pool",
        cid: connection.id,
        action: "conection"
      }, "Created new pool resource #%s", connection.id);
      connection.on("available", () => {
        this.logger.debug({
          tnx: "connection",
          cid: connection.id,
          action: "available"
        }, "Connection #%s became available", connection.id);
        if (this._closed) {
          this.close();
        } else {
          this._processMessages();
        }
      });
      connection.once("error", (err) => {
        if (err.code !== "EMAXLIMIT") {
          this.logger.error({
            err,
            tnx: "pool",
            cid: connection.id
          }, "Pool Error for #%s: %s", connection.id, err.message);
        } else {
          this.logger.debug({
            tnx: "pool",
            cid: connection.id,
            action: "maxlimit"
          }, "Max messages limit exchausted for #%s", connection.id);
        }
        if (connection.queueEntry) {
          try {
            connection.queueEntry.callback(err);
          } catch (E) {
            this.logger.error({
              err: E,
              tnx: "callback",
              cid: connection.id
            }, "Callback error for #%s: %s", connection.id, E.message);
          }
          connection.queueEntry = false;
        }
        this._removeConnection(connection);
        this._continueProcessing();
      });
      connection.once("close", () => {
        this.logger.info({
          tnx: "connection",
          cid: connection.id,
          action: "closed"
        }, "Connection #%s was closed", connection.id);
        this._removeConnection(connection);
        if (connection.queueEntry) {
          setTimeout(() => {
            if (connection.queueEntry) {
              if (this._shouldRequeuOnConnectionClose(connection.queueEntry)) {
                this._requeueEntryOnConnectionClose(connection);
              } else {
                this._failDeliveryOnConnectionClose(connection);
              }
            }
            this._continueProcessing();
          }, 50);
        } else {
          this._continueProcessing();
        }
      });
      this._connections.push(connection);
      return connection;
    }
    _shouldRequeuOnConnectionClose(queueEntry) {
      if (this.options.maxRequeues === undefined || this.options.maxRequeues < 0) {
        return true;
      }
      return queueEntry.requeueAttempts < this.options.maxRequeues;
    }
    _failDeliveryOnConnectionClose(connection) {
      if (connection.queueEntry && connection.queueEntry.callback) {
        try {
          connection.queueEntry.callback(new Error("Reached maximum number of retries after connection was closed"));
        } catch (E) {
          this.logger.error({
            err: E,
            tnx: "callback",
            messageId: connection.queueEntry.messageId,
            cid: connection.id
          }, "Callback error for #%s: %s", connection.id, E.message);
        }
        connection.queueEntry = false;
      }
    }
    _requeueEntryOnConnectionClose(connection) {
      connection.queueEntry.requeueAttempts = connection.queueEntry.requeueAttempts + 1;
      this.logger.debug({
        tnx: "pool",
        cid: connection.id,
        messageId: connection.queueEntry.messageId,
        action: "requeue"
      }, "Re-queued message <%s> for #%s. Attempt: #%s", connection.queueEntry.messageId, connection.id, connection.queueEntry.requeueAttempts);
      this._queue.unshift(connection.queueEntry);
      connection.queueEntry = false;
    }
    _continueProcessing() {
      if (this._closed) {
        this.close();
      } else {
        setTimeout(() => this._processMessages(), 100);
      }
    }
    _removeConnection(connection) {
      let index = this._connections.indexOf(connection);
      if (index !== -1) {
        this._connections.splice(index, 1);
      }
    }
    _checkRateLimit(callback) {
      if (!this._rateLimit.limit) {
        return callback();
      }
      let now = Date.now();
      if (this._rateLimit.counter < this._rateLimit.limit) {
        return callback();
      }
      this._rateLimit.waiting.push(callback);
      if (this._rateLimit.checkpoint <= now - this._rateLimit.delta) {
        return this._clearRateLimit();
      } else if (!this._rateLimit.timeout) {
        this._rateLimit.timeout = setTimeout(() => this._clearRateLimit(), this._rateLimit.delta - (now - this._rateLimit.checkpoint));
        this._rateLimit.checkpoint = now;
      }
    }
    _clearRateLimit() {
      clearTimeout(this._rateLimit.timeout);
      this._rateLimit.timeout = null;
      this._rateLimit.counter = 0;
      this._rateLimit.checkpoint = false;
      while (this._rateLimit.waiting.length) {
        let cb = this._rateLimit.waiting.shift();
        setImmediate(cb);
      }
    }
    isIdle() {
      return this.idling;
    }
    verify(callback) {
      let promise;
      if (!callback) {
        promise = new Promise((resolve, reject) => {
          callback = shared.callbackPromise(resolve, reject);
        });
      }
      let auth = new PoolResource(this).auth;
      this.getSocket(this.options, (err, socketOptions) => {
        if (err) {
          return callback(err);
        }
        let options = this.options;
        if (socketOptions && socketOptions.connection) {
          this.logger.info({
            tnx: "proxy",
            remoteAddress: socketOptions.connection.remoteAddress,
            remotePort: socketOptions.connection.remotePort,
            destHost: options.host || "",
            destPort: options.port || "",
            action: "connected"
          }, "Using proxied socket from %s:%s to %s:%s", socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || "", options.port || "");
          options = shared.assign(false, options);
          Object.keys(socketOptions).forEach((key) => {
            options[key] = socketOptions[key];
          });
        }
        let connection = new SMTPConnection(options);
        let returned = false;
        connection.once("error", (err2) => {
          if (returned) {
            return;
          }
          returned = true;
          connection.close();
          return callback(err2);
        });
        connection.once("end", () => {
          if (returned) {
            return;
          }
          returned = true;
          return callback(new Error("Connection closed"));
        });
        let finalize = () => {
          if (returned) {
            return;
          }
          returned = true;
          connection.quit();
          return callback(null, true);
        };
        connection.connect(() => {
          if (returned) {
            return;
          }
          if (auth && (connection.allowsAuth || options.forceAuth)) {
            connection.login(auth, (err2) => {
              if (returned) {
                return;
              }
              if (err2) {
                returned = true;
                connection.close();
                return callback(err2);
              }
              finalize();
            });
          } else if (!auth && connection.allowsAuth && options.forceAuth) {
            let err2 = new Error("Authentication info was not provided");
            err2.code = "NoAuth";
            returned = true;
            connection.close();
            return callback(err2);
          } else {
            finalize();
          }
        });
      });
      return promise;
    }
  }
  module.exports = SMTPPool;
});

// node_modules/nodemailer/lib/smtp-transport/index.js
var require_smtp_transport = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var SMTPConnection = require_smtp_connection();
  var wellKnown = require_well_known();
  var shared = require_shared2();
  var XOAuth2 = require_xoauth2();
  var packageData = require_package4();

  class SMTPTransport extends EventEmitter {
    constructor(options) {
      super();
      options = options || {};
      if (typeof options === "string") {
        options = {
          url: options
        };
      }
      let urlData;
      let service = options.service;
      if (typeof options.getSocket === "function") {
        this.getSocket = options.getSocket;
      }
      if (options.url) {
        urlData = shared.parseConnectionUrl(options.url);
        service = service || urlData.service;
      }
      this.options = shared.assign(false, options, urlData, service && wellKnown(service));
      this.logger = shared.getLogger(this.options, {
        component: this.options.component || "smtp-transport"
      });
      let connection = new SMTPConnection(this.options);
      this.name = "SMTP";
      this.version = packageData.version + "[client:" + connection.version + "]";
      if (this.options.auth) {
        this.auth = this.getAuth({});
      }
    }
    getSocket(options, callback) {
      return setImmediate(() => callback(null, false));
    }
    getAuth(authOpts) {
      if (!authOpts) {
        return this.auth;
      }
      let hasAuth = false;
      let authData = {};
      if (this.options.auth && typeof this.options.auth === "object") {
        Object.keys(this.options.auth).forEach((key) => {
          hasAuth = true;
          authData[key] = this.options.auth[key];
        });
      }
      if (authOpts && typeof authOpts === "object") {
        Object.keys(authOpts).forEach((key) => {
          hasAuth = true;
          authData[key] = authOpts[key];
        });
      }
      if (!hasAuth) {
        return false;
      }
      switch ((authData.type || "").toString().toUpperCase()) {
        case "OAUTH2": {
          if (!authData.service && !authData.user) {
            return false;
          }
          let oauth2 = new XOAuth2(authData, this.logger);
          oauth2.provisionCallback = this.mailer && this.mailer.get("oauth2_provision_cb") || oauth2.provisionCallback;
          oauth2.on("token", (token) => this.mailer.emit("token", token));
          oauth2.on("error", (err) => this.emit("error", err));
          return {
            type: "OAUTH2",
            user: authData.user,
            oauth2,
            method: "XOAUTH2"
          };
        }
        default:
          return {
            type: (authData.type || "").toString().toUpperCase() || "LOGIN",
            user: authData.user,
            credentials: {
              user: authData.user || "",
              pass: authData.pass,
              options: authData.options
            },
            method: (authData.method || "").trim().toUpperCase() || this.options.authMethod || false
          };
      }
    }
    send(mail, callback) {
      this.getSocket(this.options, (err, socketOptions) => {
        if (err) {
          return callback(err);
        }
        let returned = false;
        let options = this.options;
        if (socketOptions && socketOptions.connection) {
          this.logger.info({
            tnx: "proxy",
            remoteAddress: socketOptions.connection.remoteAddress,
            remotePort: socketOptions.connection.remotePort,
            destHost: options.host || "",
            destPort: options.port || "",
            action: "connected"
          }, "Using proxied socket from %s:%s to %s:%s", socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || "", options.port || "");
          options = shared.assign(false, options);
          Object.keys(socketOptions).forEach((key) => {
            options[key] = socketOptions[key];
          });
        }
        let connection = new SMTPConnection(options);
        connection.once("error", (err2) => {
          if (returned) {
            return;
          }
          returned = true;
          connection.close();
          return callback(err2);
        });
        connection.once("end", () => {
          if (returned) {
            return;
          }
          let timer = setTimeout(() => {
            if (returned) {
              return;
            }
            returned = true;
            let err2 = new Error("Unexpected socket close");
            if (connection && connection._socket && connection._socket.upgrading) {
              err2.code = "ETLS";
            }
            callback(err2);
          }, 1000);
          try {
            timer.unref();
          } catch (E) {
          }
        });
        let sendMessage = () => {
          let envelope = mail.message.getEnvelope();
          let messageId = mail.message.messageId();
          let recipients = [].concat(envelope.to || []);
          if (recipients.length > 3) {
            recipients.push("...and " + recipients.splice(2).length + " more");
          }
          if (mail.data.dsn) {
            envelope.dsn = mail.data.dsn;
          }
          this.logger.info({
            tnx: "send",
            messageId
          }, "Sending message %s to <%s>", messageId, recipients.join(", "));
          connection.send(envelope, mail.message.createReadStream(), (err2, info) => {
            returned = true;
            connection.close();
            if (err2) {
              this.logger.error({
                err: err2,
                tnx: "send"
              }, "Send error for %s: %s", messageId, err2.message);
              return callback(err2);
            }
            info.envelope = {
              from: envelope.from,
              to: envelope.to
            };
            info.messageId = messageId;
            try {
              return callback(null, info);
            } catch (E) {
              this.logger.error({
                err: E,
                tnx: "callback"
              }, "Callback error for %s: %s", messageId, E.message);
            }
          });
        };
        connection.connect(() => {
          if (returned) {
            return;
          }
          let auth = this.getAuth(mail.data.auth);
          if (auth && (connection.allowsAuth || options.forceAuth)) {
            connection.login(auth, (err2) => {
              if (auth && auth !== this.auth && auth.oauth2) {
                auth.oauth2.removeAllListeners();
              }
              if (returned) {
                return;
              }
              if (err2) {
                returned = true;
                connection.close();
                return callback(err2);
              }
              sendMessage();
            });
          } else {
            sendMessage();
          }
        });
      });
    }
    verify(callback) {
      let promise;
      if (!callback) {
        promise = new Promise((resolve, reject) => {
          callback = shared.callbackPromise(resolve, reject);
        });
      }
      this.getSocket(this.options, (err, socketOptions) => {
        if (err) {
          return callback(err);
        }
        let options = this.options;
        if (socketOptions && socketOptions.connection) {
          this.logger.info({
            tnx: "proxy",
            remoteAddress: socketOptions.connection.remoteAddress,
            remotePort: socketOptions.connection.remotePort,
            destHost: options.host || "",
            destPort: options.port || "",
            action: "connected"
          }, "Using proxied socket from %s:%s to %s:%s", socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || "", options.port || "");
          options = shared.assign(false, options);
          Object.keys(socketOptions).forEach((key) => {
            options[key] = socketOptions[key];
          });
        }
        let connection = new SMTPConnection(options);
        let returned = false;
        connection.once("error", (err2) => {
          if (returned) {
            return;
          }
          returned = true;
          connection.close();
          return callback(err2);
        });
        connection.once("end", () => {
          if (returned) {
            return;
          }
          returned = true;
          return callback(new Error("Connection closed"));
        });
        let finalize = () => {
          if (returned) {
            return;
          }
          returned = true;
          connection.quit();
          return callback(null, true);
        };
        connection.connect(() => {
          if (returned) {
            return;
          }
          let authData = this.getAuth({});
          if (authData && (connection.allowsAuth || options.forceAuth)) {
            connection.login(authData, (err2) => {
              if (returned) {
                return;
              }
              if (err2) {
                returned = true;
                connection.close();
                return callback(err2);
              }
              finalize();
            });
          } else if (!authData && connection.allowsAuth && options.forceAuth) {
            let err2 = new Error("Authentication info was not provided");
            err2.code = "NoAuth";
            returned = true;
            connection.close();
            return callback(err2);
          } else {
            finalize();
          }
        });
      });
      return promise;
    }
    close() {
      if (this.auth && this.auth.oauth2) {
        this.auth.oauth2.removeAllListeners();
      }
      this.emit("close");
    }
  }
  module.exports = SMTPTransport;
});

// node_modules/nodemailer/lib/sendmail-transport/index.js
var require_sendmail_transport = __commonJS((exports, module) => {
  var spawn = import.meta.require("child_process").spawn;
  var packageData = require_package4();
  var shared = require_shared2();

  class SendmailTransport {
    constructor(options) {
      options = options || {};
      this._spawn = spawn;
      this.options = options || {};
      this.name = "Sendmail";
      this.version = packageData.version;
      this.path = "sendmail";
      this.args = false;
      this.winbreak = false;
      this.logger = shared.getLogger(this.options, {
        component: this.options.component || "sendmail"
      });
      if (options) {
        if (typeof options === "string") {
          this.path = options;
        } else if (typeof options === "object") {
          if (options.path) {
            this.path = options.path;
          }
          if (Array.isArray(options.args)) {
            this.args = options.args;
          }
          this.winbreak = ["win", "windows", "dos", "\r\n"].includes((options.newline || "").toString().toLowerCase());
        }
      }
    }
    send(mail, done) {
      mail.message.keepBcc = true;
      let envelope = mail.data.envelope || mail.message.getEnvelope();
      let messageId = mail.message.messageId();
      let args;
      let sendmail;
      let returned;
      const hasInvalidAddresses = [].concat(envelope.from || []).concat(envelope.to || []).some((addr) => /^-/.test(addr));
      if (hasInvalidAddresses) {
        return done(new Error("Can not send mail. Invalid envelope addresses."));
      }
      if (this.args) {
        args = ["-i"].concat(this.args).concat(envelope.to);
      } else {
        args = ["-i"].concat(envelope.from ? ["-f", envelope.from] : []).concat(envelope.to);
      }
      let callback = (err) => {
        if (returned) {
          return;
        }
        returned = true;
        if (typeof done === "function") {
          if (err) {
            return done(err);
          } else {
            return done(null, {
              envelope: mail.data.envelope || mail.message.getEnvelope(),
              messageId,
              response: "Messages queued for delivery"
            });
          }
        }
      };
      try {
        sendmail = this._spawn(this.path, args);
      } catch (E) {
        this.logger.error({
          err: E,
          tnx: "spawn",
          messageId
        }, "Error occurred while spawning sendmail. %s", E.message);
        return callback(E);
      }
      if (sendmail) {
        sendmail.on("error", (err) => {
          this.logger.error({
            err,
            tnx: "spawn",
            messageId
          }, "Error occurred when sending message %s. %s", messageId, err.message);
          callback(err);
        });
        sendmail.once("exit", (code) => {
          if (!code) {
            return callback();
          }
          let err;
          if (code === 127) {
            err = new Error("Sendmail command not found, process exited with code " + code);
          } else {
            err = new Error("Sendmail exited with code " + code);
          }
          this.logger.error({
            err,
            tnx: "stdin",
            messageId
          }, "Error sending message %s to sendmail. %s", messageId, err.message);
          callback(err);
        });
        sendmail.once("close", callback);
        sendmail.stdin.on("error", (err) => {
          this.logger.error({
            err,
            tnx: "stdin",
            messageId
          }, "Error occurred when piping message %s to sendmail. %s", messageId, err.message);
          callback(err);
        });
        let recipients = [].concat(envelope.to || []);
        if (recipients.length > 3) {
          recipients.push("...and " + recipients.splice(2).length + " more");
        }
        this.logger.info({
          tnx: "send",
          messageId
        }, "Sending message %s to <%s>", messageId, recipients.join(", "));
        let sourceStream = mail.message.createReadStream();
        sourceStream.once("error", (err) => {
          this.logger.error({
            err,
            tnx: "stdin",
            messageId
          }, "Error occurred when generating message %s. %s", messageId, err.message);
          sendmail.kill("SIGINT");
          callback(err);
        });
        sourceStream.pipe(sendmail.stdin);
      } else {
        return callback(new Error("sendmail was not found"));
      }
    }
  }
  module.exports = SendmailTransport;
});

// node_modules/nodemailer/lib/stream-transport/index.js
var require_stream_transport = __commonJS((exports, module) => {
  var packageData = require_package4();
  var shared = require_shared2();

  class StreamTransport {
    constructor(options) {
      options = options || {};
      this.options = options || {};
      this.name = "StreamTransport";
      this.version = packageData.version;
      this.logger = shared.getLogger(this.options, {
        component: this.options.component || "stream-transport"
      });
      this.winbreak = ["win", "windows", "dos", "\r\n"].includes((options.newline || "").toString().toLowerCase());
    }
    send(mail, done) {
      mail.message.keepBcc = true;
      let envelope = mail.data.envelope || mail.message.getEnvelope();
      let messageId = mail.message.messageId();
      let recipients = [].concat(envelope.to || []);
      if (recipients.length > 3) {
        recipients.push("...and " + recipients.splice(2).length + " more");
      }
      this.logger.info({
        tnx: "send",
        messageId
      }, "Sending message %s to <%s> using %s line breaks", messageId, recipients.join(", "), this.winbreak ? "<CR><LF>" : "<LF>");
      setImmediate(() => {
        let stream;
        try {
          stream = mail.message.createReadStream();
        } catch (E) {
          this.logger.error({
            err: E,
            tnx: "send",
            messageId
          }, "Creating send stream failed for %s. %s", messageId, E.message);
          return done(E);
        }
        if (!this.options.buffer) {
          stream.once("error", (err) => {
            this.logger.error({
              err,
              tnx: "send",
              messageId
            }, "Failed creating message for %s. %s", messageId, err.message);
          });
          return done(null, {
            envelope: mail.data.envelope || mail.message.getEnvelope(),
            messageId,
            message: stream
          });
        }
        let chunks = [];
        let chunklen = 0;
        stream.on("readable", () => {
          let chunk;
          while ((chunk = stream.read()) !== null) {
            chunks.push(chunk);
            chunklen += chunk.length;
          }
        });
        stream.once("error", (err) => {
          this.logger.error({
            err,
            tnx: "send",
            messageId
          }, "Failed creating message for %s. %s", messageId, err.message);
          return done(err);
        });
        stream.on("end", () => done(null, {
          envelope: mail.data.envelope || mail.message.getEnvelope(),
          messageId,
          message: Buffer.concat(chunks, chunklen)
        }));
      });
    }
  }
  module.exports = StreamTransport;
});

// node_modules/nodemailer/lib/json-transport/index.js
var require_json_transport = __commonJS((exports, module) => {
  var packageData = require_package4();
  var shared = require_shared2();

  class JSONTransport {
    constructor(options) {
      options = options || {};
      this.options = options || {};
      this.name = "JSONTransport";
      this.version = packageData.version;
      this.logger = shared.getLogger(this.options, {
        component: this.options.component || "json-transport"
      });
    }
    send(mail, done) {
      mail.message.keepBcc = true;
      let envelope = mail.data.envelope || mail.message.getEnvelope();
      let messageId = mail.message.messageId();
      let recipients = [].concat(envelope.to || []);
      if (recipients.length > 3) {
        recipients.push("...and " + recipients.splice(2).length + " more");
      }
      this.logger.info({
        tnx: "send",
        messageId
      }, "Composing JSON structure of %s to <%s>", messageId, recipients.join(", "));
      setImmediate(() => {
        mail.normalize((err, data) => {
          if (err) {
            this.logger.error({
              err,
              tnx: "send",
              messageId
            }, "Failed building JSON structure for %s. %s", messageId, err.message);
            return done(err);
          }
          delete data.envelope;
          delete data.normalizedHeaders;
          return done(null, {
            envelope,
            messageId,
            message: this.options.skipEncoding ? data : JSON.stringify(data)
          });
        });
      });
    }
  }
  module.exports = JSONTransport;
});

// node_modules/nodemailer/lib/ses-transport/index.js
var require_ses_transport = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var packageData = require_package4();
  var shared = require_shared2();
  var LeWindows = require_le_windows();

  class SESTransport extends EventEmitter {
    constructor(options) {
      super();
      options = options || {};
      this.options = options || {};
      this.ses = this.options.SES;
      this.name = "SESTransport";
      this.version = packageData.version;
      this.logger = shared.getLogger(this.options, {
        component: this.options.component || "ses-transport"
      });
      this.maxConnections = Number(this.options.maxConnections) || Infinity;
      this.connections = 0;
      this.sendingRate = Number(this.options.sendingRate) || Infinity;
      this.sendingRateTTL = null;
      this.rateInterval = 1000;
      this.rateMessages = [];
      this.pending = [];
      this.idling = true;
      setImmediate(() => {
        if (this.idling) {
          this.emit("idle");
        }
      });
    }
    send(mail, callback) {
      if (this.connections >= this.maxConnections) {
        this.idling = false;
        return this.pending.push({
          mail,
          callback
        });
      }
      if (!this._checkSendingRate()) {
        this.idling = false;
        return this.pending.push({
          mail,
          callback
        });
      }
      this._send(mail, (...args) => {
        setImmediate(() => callback(...args));
        this._sent();
      });
    }
    _checkRatedQueue() {
      if (this.connections >= this.maxConnections || !this._checkSendingRate()) {
        return;
      }
      if (!this.pending.length) {
        if (!this.idling) {
          this.idling = true;
          this.emit("idle");
        }
        return;
      }
      let next = this.pending.shift();
      this._send(next.mail, (...args) => {
        setImmediate(() => next.callback(...args));
        this._sent();
      });
    }
    _checkSendingRate() {
      clearTimeout(this.sendingRateTTL);
      let now = Date.now();
      let oldest = false;
      for (let i = this.rateMessages.length - 1;i >= 0; i--) {
        if (this.rateMessages[i].ts >= now - this.rateInterval && (!oldest || this.rateMessages[i].ts < oldest)) {
          oldest = this.rateMessages[i].ts;
        }
        if (this.rateMessages[i].ts < now - this.rateInterval && !this.rateMessages[i].pending) {
          this.rateMessages.splice(i, 1);
        }
      }
      if (this.rateMessages.length < this.sendingRate) {
        return true;
      }
      let delay = Math.max(oldest + 1001, now + 20);
      this.sendingRateTTL = setTimeout(() => this._checkRatedQueue(), now - delay);
      try {
        this.sendingRateTTL.unref();
      } catch (E) {
      }
      return false;
    }
    _sent() {
      this.connections--;
      this._checkRatedQueue();
    }
    isIdle() {
      return this.idling;
    }
    _send(mail, callback) {
      let statObject = {
        ts: Date.now(),
        pending: true
      };
      this.connections++;
      this.rateMessages.push(statObject);
      let envelope = mail.data.envelope || mail.message.getEnvelope();
      let messageId = mail.message.messageId();
      let recipients = [].concat(envelope.to || []);
      if (recipients.length > 3) {
        recipients.push("...and " + recipients.splice(2).length + " more");
      }
      this.logger.info({
        tnx: "send",
        messageId
      }, "Sending message %s to <%s>", messageId, recipients.join(", "));
      let getRawMessage = (next) => {
        if (!mail.data._dkim) {
          mail.data._dkim = {};
        }
        if (mail.data._dkim.skipFields && typeof mail.data._dkim.skipFields === "string") {
          mail.data._dkim.skipFields += ":date:message-id";
        } else {
          mail.data._dkim.skipFields = "date:message-id";
        }
        let sourceStream = mail.message.createReadStream();
        let stream = sourceStream.pipe(new LeWindows);
        let chunks = [];
        let chunklen = 0;
        stream.on("readable", () => {
          let chunk;
          while ((chunk = stream.read()) !== null) {
            chunks.push(chunk);
            chunklen += chunk.length;
          }
        });
        sourceStream.once("error", (err) => stream.emit("error", err));
        stream.once("error", (err) => {
          next(err);
        });
        stream.once("end", () => next(null, Buffer.concat(chunks, chunklen)));
      };
      setImmediate(() => getRawMessage((err, raw2) => {
        if (err) {
          this.logger.error({
            err,
            tnx: "send",
            messageId
          }, "Failed creating message for %s. %s", messageId, err.message);
          statObject.pending = false;
          return callback(err);
        }
        let sesMessage = {
          RawMessage: {
            Data: raw2
          },
          Source: envelope.from,
          Destinations: envelope.to
        };
        Object.keys(mail.data.ses || {}).forEach((key) => {
          sesMessage[key] = mail.data.ses[key];
        });
        let ses2 = (this.ses.aws ? this.ses.ses : this.ses) || {};
        let aws = this.ses.aws || {};
        let getRegion = (cb) => {
          if (ses2.config && typeof ses2.config.region === "function") {
            return ses2.config.region().then((region) => cb(null, region)).catch((err2) => cb(err2));
          }
          return cb(null, ses2.config && ses2.config.region || "us-east-1");
        };
        getRegion((err2, region) => {
          if (err2 || !region) {
            region = "us-east-1";
          }
          let sendPromise;
          if (typeof ses2.send === "function" && aws.SendRawEmailCommand) {
            sendPromise = ses2.send(new aws.SendRawEmailCommand(sesMessage));
          } else {
            sendPromise = ses2.sendRawEmail(sesMessage).promise();
          }
          sendPromise.then((data) => {
            if (region === "us-east-1") {
              region = "email";
            }
            statObject.pending = false;
            callback(null, {
              envelope: {
                from: envelope.from,
                to: envelope.to
              },
              messageId: "<" + data.MessageId + (!/@/.test(data.MessageId) ? "@" + region + ".amazonses.com" : "") + ">",
              response: data.MessageId,
              raw: raw2
            });
          }).catch((err3) => {
            this.logger.error({
              err: err3,
              tnx: "send"
            }, "Send error for %s: %s", messageId, err3.message);
            statObject.pending = false;
            callback(err3);
          });
        });
      }));
    }
    verify(callback) {
      let promise;
      let ses2 = (this.ses.aws ? this.ses.ses : this.ses) || {};
      let aws = this.ses.aws || {};
      const sesMessage = {
        RawMessage: {
          Data: "From: invalid@invalid\r\nTo: invalid@invalid\r\n Subject: Invalid\r\n\r\nInvalid"
        },
        Source: "invalid@invalid",
        Destinations: ["invalid@invalid"]
      };
      if (!callback) {
        promise = new Promise((resolve, reject) => {
          callback = shared.callbackPromise(resolve, reject);
        });
      }
      const cb = (err) => {
        if (err && (err.code || err.Code) !== "InvalidParameterValue") {
          return callback(err);
        }
        return callback(null, true);
      };
      if (typeof ses2.send === "function" && aws.SendRawEmailCommand) {
        sesMessage.RawMessage.Data = Buffer.from(sesMessage.RawMessage.Data);
        ses2.send(new aws.SendRawEmailCommand(sesMessage), cb);
      } else {
        ses2.sendRawEmail(sesMessage, cb);
      }
      return promise;
    }
  }
  module.exports = SESTransport;
});

// node_modules/nodemailer/lib/nodemailer.js
var require_nodemailer = __commonJS((exports, module) => {
  var Mailer = require_mailer();
  var shared = require_shared2();
  var SMTPPool = require_smtp_pool();
  var SMTPTransport = require_smtp_transport();
  var SendmailTransport = require_sendmail_transport();
  var StreamTransport = require_stream_transport();
  var JSONTransport = require_json_transport();
  var SESTransport = require_ses_transport();
  var nmfetch = require_fetch();
  var packageData = require_package4();
  var ETHEREAL_API = (process.env.ETHEREAL_API || "https://api.nodemailer.com").replace(/\/+$/, "");
  var ETHEREAL_WEB = (process.env.ETHEREAL_WEB || "https://ethereal.email").replace(/\/+$/, "");
  var ETHEREAL_API_KEY = (process.env.ETHEREAL_API_KEY || "").replace(/\s*/g, "") || null;
  var ETHEREAL_CACHE = ["true", "yes", "y", "1"].includes((process.env.ETHEREAL_CACHE || "yes").toString().trim().toLowerCase());
  var testAccount = false;
  exports.createTransport = function(transporter, defaults) {
    let urlConfig;
    let options;
    let mailer;
    if (typeof transporter === "object" && typeof transporter.send !== "function" || typeof transporter === "string" && /^(smtps?|direct):/i.test(transporter)) {
      if (urlConfig = typeof transporter === "string" ? transporter : transporter.url) {
        options = shared.parseConnectionUrl(urlConfig);
      } else {
        options = transporter;
      }
      if (options.pool) {
        transporter = new SMTPPool(options);
      } else if (options.sendmail) {
        transporter = new SendmailTransport(options);
      } else if (options.streamTransport) {
        transporter = new StreamTransport(options);
      } else if (options.jsonTransport) {
        transporter = new JSONTransport(options);
      } else if (options.SES) {
        transporter = new SESTransport(options);
      } else {
        transporter = new SMTPTransport(options);
      }
    }
    mailer = new Mailer(transporter, options, defaults);
    return mailer;
  };
  exports.createTestAccount = function(apiUrl, callback) {
    let promise;
    if (!callback && typeof apiUrl === "function") {
      callback = apiUrl;
      apiUrl = false;
    }
    if (!callback) {
      promise = new Promise((resolve, reject) => {
        callback = shared.callbackPromise(resolve, reject);
      });
    }
    if (ETHEREAL_CACHE && testAccount) {
      setImmediate(() => callback(null, testAccount));
      return promise;
    }
    apiUrl = apiUrl || ETHEREAL_API;
    let chunks = [];
    let chunklen = 0;
    let requestHeaders = {};
    let requestBody = {
      requestor: packageData.name,
      version: packageData.version
    };
    if (ETHEREAL_API_KEY) {
      requestHeaders.Authorization = "Bearer " + ETHEREAL_API_KEY;
    }
    let req = nmfetch(apiUrl + "/user", {
      contentType: "application/json",
      method: "POST",
      headers: requestHeaders,
      body: Buffer.from(JSON.stringify(requestBody))
    });
    req.on("readable", () => {
      let chunk;
      while ((chunk = req.read()) !== null) {
        chunks.push(chunk);
        chunklen += chunk.length;
      }
    });
    req.once("error", (err) => callback(err));
    req.once("end", () => {
      let res = Buffer.concat(chunks, chunklen);
      let data;
      let err;
      try {
        data = JSON.parse(res.toString());
      } catch (E) {
        err = E;
      }
      if (err) {
        return callback(err);
      }
      if (data.status !== "success" || data.error) {
        return callback(new Error(data.error || "Request failed"));
      }
      delete data.status;
      testAccount = data;
      callback(null, testAccount);
    });
    return promise;
  };
  exports.getTestMessageUrl = function(info) {
    if (!info || !info.response) {
      return false;
    }
    let infoProps = new Map;
    info.response.replace(/\[([^\]]+)\]$/, (m, props) => {
      props.replace(/\b([A-Z0-9]+)=([^\s]+)/g, (m2, key, value) => {
        infoProps.set(key, value);
      });
    });
    if (infoProps.has("STATUS") && infoProps.has("MSGID")) {
      return (testAccount.web || ETHEREAL_WEB) + "/message/" + infoProps.get("MSGID");
    }
    return false;
  };
});

// node_modules/dotenv/package.json
var require_package5 = __commonJS((exports, module) => {
  module.exports = {
    name: "dotenv",
    version: "16.4.7",
    description: "Loads environment variables from .env file",
    main: "lib/main.js",
    types: "lib/main.d.ts",
    exports: {
      ".": {
        types: "./lib/main.d.ts",
        require: "./lib/main.js",
        default: "./lib/main.js"
      },
      "./config": "./config.js",
      "./config.js": "./config.js",
      "./lib/env-options": "./lib/env-options.js",
      "./lib/env-options.js": "./lib/env-options.js",
      "./lib/cli-options": "./lib/cli-options.js",
      "./lib/cli-options.js": "./lib/cli-options.js",
      "./package.json": "./package.json"
    },
    scripts: {
      "dts-check": "tsc --project tests/types/tsconfig.json",
      lint: "standard",
      pretest: "npm run lint && npm run dts-check",
      test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000",
      "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=lcov",
      prerelease: "npm test",
      release: "standard-version"
    },
    repository: {
      type: "git",
      url: "git://github.com/motdotla/dotenv.git"
    },
    funding: "https://dotenvx.com",
    keywords: [
      "dotenv",
      "env",
      ".env",
      "environment",
      "variables",
      "config",
      "settings"
    ],
    readmeFilename: "README.md",
    license: "BSD-2-Clause",
    devDependencies: {
      "@types/node": "^18.11.3",
      decache: "^4.6.2",
      sinon: "^14.0.1",
      standard: "^17.0.0",
      "standard-version": "^9.5.0",
      tap: "^19.2.0",
      typescript: "^4.8.4"
    },
    engines: {
      node: ">=12"
    },
    browser: {
      fs: false
    }
  };
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS((exports, module) => {
  function parse2(src) {
    const obj = {};
    let lines = src.toString();
    lines = lines.replace(/\r\n?/mg, "\n");
    let match;
    while ((match = LINE.exec(lines)) != null) {
      const key = match[1];
      let value = match[2] || "";
      value = value.trim();
      const maybeQuote = value[0];
      value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
      if (maybeQuote === '"') {
        value = value.replace(/\\n/g, "\n");
        value = value.replace(/\\r/g, "\r");
      }
      obj[key] = value;
    }
    return obj;
  }
  function _parseVault(options) {
    const vaultPath = _vaultPath(options);
    const result = DotenvModule.configDotenv({ path: vaultPath });
    if (!result.parsed) {
      const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
      err.code = "MISSING_DATA";
      throw err;
    }
    const keys = _dotenvKey(options).split(",");
    const length = keys.length;
    let decrypted;
    for (let i = 0;i < length; i++) {
      try {
        const key = keys[i].trim();
        const attrs = _instructions(result, key);
        decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
        break;
      } catch (error) {
        if (i + 1 >= length) {
          throw error;
        }
      }
    }
    return DotenvModule.parse(decrypted);
  }
  function _log(message) {
    console.log(`[dotenv@${version}][INFO] ${message}`);
  }
  function _warn(message) {
    console.log(`[dotenv@${version}][WARN] ${message}`);
  }
  function _debug(message) {
    console.log(`[dotenv@${version}][DEBUG] ${message}`);
  }
  function _dotenvKey(options) {
    if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
      return options.DOTENV_KEY;
    }
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
      return process.env.DOTENV_KEY;
    }
    return "";
  }
  function _instructions(result, dotenvKey) {
    let uri;
    try {
      uri = new URL(dotenvKey);
    } catch (error) {
      if (error.code === "ERR_INVALID_URL") {
        const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      throw error;
    }
    const key = uri.password;
    if (!key) {
      const err = new Error("INVALID_DOTENV_KEY: Missing key part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environment = uri.searchParams.get("environment");
    if (!environment) {
      const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
    const ciphertext = result.parsed[environmentKey];
    if (!ciphertext) {
      const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
      err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
      throw err;
    }
    return { ciphertext, key };
  }
  function _vaultPath(options) {
    let possibleVaultPath = null;
    if (options && options.path && options.path.length > 0) {
      if (Array.isArray(options.path)) {
        for (const filepath of options.path) {
          if (fs.existsSync(filepath)) {
            possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
          }
        }
      } else {
        possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
      }
    } else {
      possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
    }
    if (fs.existsSync(possibleVaultPath)) {
      return possibleVaultPath;
    }
    return null;
  }
  function _resolveHome(envPath) {
    return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
  }
  function _configVault(options) {
    _log("Loading env from encrypted .env.vault");
    const parsed = DotenvModule._parseVault(options);
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options);
    return { parsed };
  }
  function configDotenv(options) {
    const dotenvPath = path.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    const debug = Boolean(options && options.debug);
    if (options && options.encoding) {
      encoding = options.encoding;
    } else {
      if (debug) {
        _debug("No encoding is specified. UTF-8 is used by default");
      }
    }
    let optionPaths = [dotenvPath];
    if (options && options.path) {
      if (!Array.isArray(options.path)) {
        optionPaths = [_resolveHome(options.path)];
      } else {
        optionPaths = [];
        for (const filepath of options.path) {
          optionPaths.push(_resolveHome(filepath));
        }
      }
    }
    let lastError;
    const parsedAll = {};
    for (const path2 of optionPaths) {
      try {
        const parsed = DotenvModule.parse(fs.readFileSync(path2, { encoding }));
        DotenvModule.populate(parsedAll, parsed, options);
      } catch (e) {
        if (debug) {
          _debug(`Failed to load ${path2} ${e.message}`);
        }
        lastError = e;
      }
    }
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsedAll, options);
    if (lastError) {
      return { parsed: parsedAll, error: lastError };
    } else {
      return { parsed: parsedAll };
    }
  }
  function config(options) {
    if (_dotenvKey(options).length === 0) {
      return DotenvModule.configDotenv(options);
    }
    const vaultPath = _vaultPath(options);
    if (!vaultPath) {
      _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
      return DotenvModule.configDotenv(options);
    }
    return DotenvModule._configVault(options);
  }
  function decrypt(encrypted, keyStr) {
    const key = Buffer.from(keyStr.slice(-64), "hex");
    let ciphertext = Buffer.from(encrypted, "base64");
    const nonce = ciphertext.subarray(0, 12);
    const authTag = ciphertext.subarray(-16);
    ciphertext = ciphertext.subarray(12, -16);
    try {
      const aesgcm = crypto3.createDecipheriv("aes-256-gcm", key, nonce);
      aesgcm.setAuthTag(authTag);
      return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
    } catch (error) {
      const isRange = error instanceof RangeError;
      const invalidKeyLength = error.message === "Invalid key length";
      const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
      if (isRange || invalidKeyLength) {
        const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      } else if (decryptionFailed) {
        const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
        err.code = "DECRYPTION_FAILED";
        throw err;
      } else {
        throw error;
      }
    }
  }
  function populate(processEnv, parsed, options = {}) {
    const debug = Boolean(options && options.debug);
    const override = Boolean(options && options.override);
    if (typeof parsed !== "object") {
      const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
      err.code = "OBJECT_REQUIRED";
      throw err;
    }
    for (const key of Object.keys(parsed)) {
      if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
        if (override === true) {
          processEnv[key] = parsed[key];
        }
        if (debug) {
          if (override === true) {
            _debug(`"${key}" is already defined and WAS overwritten`);
          } else {
            _debug(`"${key}" is already defined and was NOT overwritten`);
          }
        }
      } else {
        processEnv[key] = parsed[key];
      }
    }
  }
  var fs = import.meta.require("fs");
  var path = import.meta.require("path");
  var os = import.meta.require("os");
  var crypto3 = import.meta.require("crypto");
  var packageJson = require_package5();
  var version = packageJson.version;
  var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
  var DotenvModule = {
    configDotenv,
    _configVault,
    _parseVault,
    config,
    decrypt,
    parse: parse2,
    populate
  };
  exports.configDotenv = DotenvModule.configDotenv;
  exports._configVault = DotenvModule._configVault;
  exports._parseVault = DotenvModule._parseVault;
  exports.config = DotenvModule.config;
  exports.decrypt = DotenvModule.decrypt;
  exports.parse = DotenvModule.parse;
  exports.populate = DotenvModule.populate;
  module.exports = DotenvModule;
});

// node_modules/@hono/node-server/dist/index.mjs
import { createServer as createServerHTTP } from "http";
import { Http2ServerRequest } from "http2";
import { Readable } from "stream";
function writeFromReadableStream(stream, writable) {
  if (stream.locked) {
    throw new TypeError("ReadableStream is locked.");
  } else if (writable.destroyed) {
    stream.cancel();
    return;
  }
  const reader = stream.getReader();
  writable.on("close", cancel);
  writable.on("error", cancel);
  reader.read().then(flow, cancel);
  return reader.closed.finally(() => {
    writable.off("close", cancel);
    writable.off("error", cancel);
  });
  function cancel(error) {
    reader.cancel(error).catch(() => {
    });
    if (error) {
      writable.destroy(error);
    }
  }
  function onDrain() {
    reader.read().then(flow, cancel);
  }
  function flow({ done, value }) {
    try {
      if (done) {
        writable.end();
      } else if (!writable.write(value)) {
        writable.once("drain", onDrain);
      } else {
        return reader.read().then(flow, cancel);
      }
    } catch (e) {
      cancel(e);
    }
  }
}
function getInternalBody(response) {
  if (!stateKey) {
    return;
  }
  if (response instanceof Response2) {
    response = response[getResponseCache]();
  }
  const state = response[stateKey];
  return state && state.body || undefined;
}
import crypto2 from "crypto";
var RequestError = class extends Error {
  static name = "RequestError";
  constructor(message, options) {
    super(message, options);
  }
};
var toRequestError = (e) => {
  if (e instanceof RequestError) {
    return e;
  }
  return new RequestError(e.message, { cause: e });
};
var GlobalRequest = global.Request;
var Request2 = class extends GlobalRequest {
  constructor(input, options) {
    if (typeof input === "object" && getRequestCache in input) {
      input = input[getRequestCache]();
    }
    if (typeof options?.body?.getReader !== "undefined") {
      options.duplex ??= "half";
    }
    super(input, options);
  }
};
var newRequestFromIncoming = (method, url, incoming, abortController) => {
  const headerRecord = [];
  const rawHeaders = incoming.rawHeaders;
  for (let i = 0;i < rawHeaders.length; i += 2) {
    const { [i]: key, [i + 1]: value } = rawHeaders;
    if (key.charCodeAt(0) !== 58) {
      headerRecord.push([key, value]);
    }
  }
  const init = {
    method,
    headers: headerRecord,
    signal: abortController.signal
  };
  if (method === "TRACE") {
    init.method = "GET";
    const req = new Request2(url, init);
    Object.defineProperty(req, "method", {
      get() {
        return "TRACE";
      }
    });
    return req;
  }
  if (!(method === "GET" || method === "HEAD")) {
    if ("rawBody" in incoming && incoming.rawBody instanceof Buffer) {
      init.body = new ReadableStream({
        start(controller) {
          controller.enqueue(incoming.rawBody);
          controller.close();
        }
      });
    } else {
      init.body = Readable.toWeb(incoming);
    }
  }
  return new Request2(url, init);
};
var getRequestCache = Symbol("getRequestCache");
var requestCache = Symbol("requestCache");
var incomingKey = Symbol("incomingKey");
var urlKey = Symbol("urlKey");
var abortControllerKey = Symbol("abortControllerKey");
var getAbortController = Symbol("getAbortController");
var requestPrototype = {
  get method() {
    return this[incomingKey].method || "GET";
  },
  get url() {
    return this[urlKey];
  },
  [getAbortController]() {
    this[getRequestCache]();
    return this[abortControllerKey];
  },
  [getRequestCache]() {
    this[abortControllerKey] ||= new AbortController;
    return this[requestCache] ||= newRequestFromIncoming(this.method, this[urlKey], this[incomingKey], this[abortControllerKey]);
  }
};
[
  "body",
  "bodyUsed",
  "cache",
  "credentials",
  "destination",
  "headers",
  "integrity",
  "mode",
  "redirect",
  "referrer",
  "referrerPolicy",
  "signal",
  "keepalive"
].forEach((k) => {
  Object.defineProperty(requestPrototype, k, {
    get() {
      return this[getRequestCache]()[k];
    }
  });
});
["arrayBuffer", "blob", "clone", "formData", "json", "text"].forEach((k) => {
  Object.defineProperty(requestPrototype, k, {
    value: function() {
      return this[getRequestCache]()[k]();
    }
  });
});
Object.setPrototypeOf(requestPrototype, Request2.prototype);
var newRequest = (incoming, defaultHostname) => {
  const req = Object.create(requestPrototype);
  req[incomingKey] = incoming;
  const host = (incoming instanceof Http2ServerRequest ? incoming.authority : incoming.headers.host) || defaultHostname;
  if (!host) {
    throw new RequestError("Missing host header");
  }
  const url = new URL(`${incoming instanceof Http2ServerRequest || incoming.socket && incoming.socket.encrypted ? "https" : "http"}://${host}${incoming.url}`);
  if (url.hostname.length !== host.length && url.hostname !== host.replace(/:\d+$/, "")) {
    throw new RequestError("Invalid host header");
  }
  req[urlKey] = url.href;
  return req;
};
var buildOutgoingHttpHeaders = (headers) => {
  const res = {};
  if (!(headers instanceof Headers)) {
    headers = new Headers(headers ?? undefined);
  }
  const cookies = [];
  for (const [k, v] of headers) {
    if (k === "set-cookie") {
      cookies.push(v);
    } else {
      res[k] = v;
    }
  }
  if (cookies.length > 0) {
    res["set-cookie"] = cookies;
  }
  res["content-type"] ??= "text/plain; charset=UTF-8";
  return res;
};
var responseCache = Symbol("responseCache");
var getResponseCache = Symbol("getResponseCache");
var cacheKey = Symbol("cache");
var GlobalResponse = global.Response;
var Response2 = class _Response {
  #body;
  #init;
  [getResponseCache]() {
    delete this[cacheKey];
    return this[responseCache] ||= new GlobalResponse(this.#body, this.#init);
  }
  constructor(body, init) {
    this.#body = body;
    if (init instanceof _Response) {
      const cachedGlobalResponse = init[responseCache];
      if (cachedGlobalResponse) {
        this.#init = cachedGlobalResponse;
        this[getResponseCache]();
        return;
      } else {
        this.#init = init.#init;
      }
    } else {
      this.#init = init;
    }
    if (typeof body === "string" || typeof body?.getReader !== "undefined") {
      let headers = init?.headers || { "content-type": "text/plain; charset=UTF-8" };
      if (headers instanceof Headers) {
        headers = buildOutgoingHttpHeaders(headers);
      }
      this[cacheKey] = [init?.status || 200, body, headers];
    }
  }
};
[
  "body",
  "bodyUsed",
  "headers",
  "ok",
  "redirected",
  "status",
  "statusText",
  "trailers",
  "type",
  "url"
].forEach((k) => {
  Object.defineProperty(Response2.prototype, k, {
    get() {
      return this[getResponseCache]()[k];
    }
  });
});
["arrayBuffer", "blob", "clone", "formData", "json", "text"].forEach((k) => {
  Object.defineProperty(Response2.prototype, k, {
    value: function() {
      return this[getResponseCache]()[k]();
    }
  });
});
Object.setPrototypeOf(Response2, GlobalResponse);
Object.setPrototypeOf(Response2.prototype, GlobalResponse.prototype);
var stateKey = Reflect.ownKeys(new GlobalResponse).find((k) => typeof k === "symbol" && k.toString() === "Symbol(state)");
if (!stateKey) {
  console.warn("Failed to find Response internal state key");
}
var X_ALREADY_SENT = "x-hono-already-sent";
var webFetch = global.fetch;
if (typeof global.crypto === "undefined") {
  global.crypto = crypto2;
}
global.fetch = (info, init) => {
  init = {
    compress: false,
    ...init
  };
  return webFetch(info, init);
};
var regBuffer = /^no$/i;
var regContentType = /^(application\/json\b|text\/(?!event-stream\b))/i;
var handleRequestError = () => new Response(null, {
  status: 400
});
var handleFetchError = (e) => new Response(null, {
  status: e instanceof Error && (e.name === "TimeoutError" || e.constructor.name === "TimeoutError") ? 504 : 500
});
var handleResponseError = (e, outgoing) => {
  const err = e instanceof Error ? e : new Error("unknown error", { cause: e });
  if (err.code === "ERR_STREAM_PREMATURE_CLOSE") {
    console.info("The user aborted a request.");
  } else {
    console.error(e);
    if (!outgoing.headersSent) {
      outgoing.writeHead(500, { "Content-Type": "text/plain" });
    }
    outgoing.end(`Error: ${err.message}`);
    outgoing.destroy(err);
  }
};
var responseViaCache = (res, outgoing) => {
  const [status, body, header] = res[cacheKey];
  if (typeof body === "string") {
    header["Content-Length"] = Buffer.byteLength(body);
    outgoing.writeHead(status, header);
    outgoing.end(body);
  } else {
    outgoing.writeHead(status, header);
    return writeFromReadableStream(body, outgoing)?.catch((e) => handleResponseError(e, outgoing));
  }
};
var responseViaResponseObject = async (res, outgoing, options = {}) => {
  if (res instanceof Promise) {
    if (options.errorHandler) {
      try {
        res = await res;
      } catch (err) {
        const errRes = await options.errorHandler(err);
        if (!errRes) {
          return;
        }
        res = errRes;
      }
    } else {
      res = await res.catch(handleFetchError);
    }
  }
  if (cacheKey in res) {
    return responseViaCache(res, outgoing);
  }
  const resHeaderRecord = buildOutgoingHttpHeaders(res.headers);
  const internalBody = getInternalBody(res);
  if (internalBody) {
    const { length, source, stream } = internalBody;
    if (source instanceof Uint8Array && source.byteLength !== length) {
    } else {
      if (length) {
        resHeaderRecord["content-length"] = length;
      }
      outgoing.writeHead(res.status, resHeaderRecord);
      if (typeof source === "string" || source instanceof Uint8Array) {
        outgoing.end(source);
      } else if (source instanceof Blob) {
        outgoing.end(new Uint8Array(await source.arrayBuffer()));
      } else {
        await writeFromReadableStream(stream, outgoing);
      }
      return;
    }
  }
  if (res.body) {
    const {
      "transfer-encoding": transferEncoding,
      "content-encoding": contentEncoding,
      "content-length": contentLength,
      "x-accel-buffering": accelBuffering,
      "content-type": contentType
    } = resHeaderRecord;
    if (transferEncoding || contentEncoding || contentLength || accelBuffering && regBuffer.test(accelBuffering) || !regContentType.test(contentType)) {
      outgoing.writeHead(res.status, resHeaderRecord);
      await writeFromReadableStream(res.body, outgoing);
    } else {
      const buffer = await res.arrayBuffer();
      resHeaderRecord["content-length"] = buffer.byteLength;
      outgoing.writeHead(res.status, resHeaderRecord);
      outgoing.end(new Uint8Array(buffer));
    }
  } else if (resHeaderRecord[X_ALREADY_SENT]) {
  } else {
    outgoing.writeHead(res.status, resHeaderRecord);
    outgoing.end();
  }
};
var getRequestListener = (fetchCallback, options = {}) => {
  if (options.overrideGlobalObjects !== false && global.Request !== Request2) {
    Object.defineProperty(global, "Request", {
      value: Request2
    });
    Object.defineProperty(global, "Response", {
      value: Response2
    });
  }
  return async (incoming, outgoing) => {
    let res, req;
    try {
      req = newRequest(incoming, options.hostname);
      outgoing.on("close", () => {
        const abortController = req[abortControllerKey];
        if (!abortController) {
          return;
        }
        if (incoming.errored) {
          req[abortControllerKey].abort(incoming.errored.toString());
        } else if (!outgoing.writableFinished) {
          req[abortControllerKey].abort("Client connection prematurely closed.");
        }
      });
      res = fetchCallback(req, { incoming, outgoing });
      if (cacheKey in res) {
        return responseViaCache(res, outgoing);
      }
    } catch (e) {
      if (!res) {
        if (options.errorHandler) {
          res = await options.errorHandler(req ? e : toRequestError(e));
          if (!res) {
            return;
          }
        } else if (!req) {
          res = handleRequestError();
        } else {
          res = handleFetchError(e);
        }
      } else {
        return handleResponseError(e, outgoing);
      }
    }
    try {
      return responseViaResponseObject(res, outgoing, options);
    } catch (e) {
      return handleResponseError(e, outgoing);
    }
  };
};
var createAdaptorServer = (options) => {
  const fetchCallback = options.fetch;
  const requestListener = getRequestListener(fetchCallback, {
    hostname: options.hostname,
    overrideGlobalObjects: options.overrideGlobalObjects
  });
  const createServer = options.createServer || createServerHTTP;
  const server = createServer(options.serverOptions || {}, requestListener);
  return server;
};
var serve = (options, listeningListener) => {
  const server = createAdaptorServer(options);
  server.listen(options?.port ?? 3000, options.hostname, () => {
    const serverInfo = server.address();
    listeningListener && listeningListener(serverInfo);
  });
  return server;
};

// node_modules/hono/dist/utils/body.js
async function parseFormData(request, options) {
  const formData = await request.formData();
  if (formData) {
    return convertFormDataToBodyData(formData, options);
  }
  return {};
}
function convertFormDataToBodyData(formData, options) {
  const form = /* @__PURE__ */ Object.create(null);
  formData.forEach((value, key) => {
    const shouldParseAllValues = options.all || key.endsWith("[]");
    if (!shouldParseAllValues) {
      form[key] = value;
    } else {
      handleParsingAllValues(form, key, value);
    }
  });
  if (options.dot) {
    Object.entries(form).forEach(([key, value]) => {
      const shouldParseDotValues = key.includes(".");
      if (shouldParseDotValues) {
        handleParsingNestedValues(form, key, value);
        delete form[key];
      }
    });
  }
  return form;
}
var parseBody = async (request, options = /* @__PURE__ */ Object.create(null)) => {
  const { all = false, dot = false } = options;
  const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;
  const contentType = headers.get("Content-Type");
  if (contentType?.startsWith("multipart/form-data") || contentType?.startsWith("application/x-www-form-urlencoded")) {
    return parseFormData(request, { all, dot });
  }
  return {};
};
var handleParsingAllValues = (form, key, value) => {
  if (form[key] !== undefined) {
    if (Array.isArray(form[key])) {
      form[key].push(value);
    } else {
      form[key] = [form[key], value];
    }
  } else {
    form[key] = value;
  }
};
var handleParsingNestedValues = (form, key, value) => {
  let nestedForm = form;
  const keys = key.split(".");
  keys.forEach((key2, index) => {
    if (index === keys.length - 1) {
      nestedForm[key2] = value;
    } else {
      if (!nestedForm[key2] || typeof nestedForm[key2] !== "object" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) {
        nestedForm[key2] = /* @__PURE__ */ Object.create(null);
      }
      nestedForm = nestedForm[key2];
    }
  });
};

// node_modules/hono/dist/utils/url.js
var splitPath = (path) => {
  const paths = path.split("/");
  if (paths[0] === "") {
    paths.shift();
  }
  return paths;
};
var splitRoutingPath = (routePath) => {
  const { groups, path } = extractGroupsFromPath(routePath);
  const paths = splitPath(path);
  return replaceGroupMarks(paths, groups);
};
var extractGroupsFromPath = (path) => {
  const groups = [];
  path = path.replace(/\{[^}]+\}/g, (match, index) => {
    const mark = `@${index}`;
    groups.push([mark, match]);
    return mark;
  });
  return { groups, path };
};
var replaceGroupMarks = (paths, groups) => {
  for (let i = groups.length - 1;i >= 0; i--) {
    const [mark] = groups[i];
    for (let j = paths.length - 1;j >= 0; j--) {
      if (paths[j].includes(mark)) {
        paths[j] = paths[j].replace(mark, groups[i][1]);
        break;
      }
    }
  }
  return paths;
};
var patternCache = {};
var getPattern = (label, next) => {
  if (label === "*") {
    return "*";
  }
  const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
  if (match) {
    const cacheKey2 = `${label}#${next}`;
    if (!patternCache[cacheKey2]) {
      if (match[2]) {
        patternCache[cacheKey2] = next && next[0] !== ":" && next[0] !== "*" ? [cacheKey2, match[1], new RegExp(`^${match[2]}(?=/${next})`)] : [label, match[1], new RegExp(`^${match[2]}\$`)];
      } else {
        patternCache[cacheKey2] = [label, match[1], true];
      }
    }
    return patternCache[cacheKey2];
  }
  return null;
};
var tryDecode = (str, decoder) => {
  try {
    return decoder(str);
  } catch {
    return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match) => {
      try {
        return decoder(match);
      } catch {
        return match;
      }
    });
  }
};
var tryDecodeURI = (str) => tryDecode(str, decodeURI);
var getPath = (request) => {
  const url = request.url;
  const start = url.indexOf("/", 8);
  let i = start;
  for (;i < url.length; i++) {
    const charCode = url.charCodeAt(i);
    if (charCode === 37) {
      const queryIndex = url.indexOf("?", i);
      const path = url.slice(start, queryIndex === -1 ? undefined : queryIndex);
      return tryDecodeURI(path.includes("%25") ? path.replace(/%25/g, "%2525") : path);
    } else if (charCode === 63) {
      break;
    }
  }
  return url.slice(start, i);
};
var getPathNoStrict = (request) => {
  const result = getPath(request);
  return result.length > 1 && result.at(-1) === "/" ? result.slice(0, -1) : result;
};
var mergePath = (base, sub, ...rest) => {
  if (rest.length) {
    sub = mergePath(sub, ...rest);
  }
  return `${base?.[0] === "/" ? "" : "/"}${base}${sub === "/" ? "" : `${base?.at(-1) === "/" ? "" : "/"}${sub?.[0] === "/" ? sub.slice(1) : sub}`}`;
};
var checkOptionalParameter = (path) => {
  if (!path.match(/\:.+\?$/)) {
    return null;
  }
  const segments = path.split("/");
  const results = [];
  let basePath = "";
  segments.forEach((segment) => {
    if (segment !== "" && !/\:/.test(segment)) {
      basePath += "/" + segment;
    } else if (/\:/.test(segment)) {
      if (/\?/.test(segment)) {
        if (results.length === 0 && basePath === "") {
          results.push("/");
        } else {
          results.push(basePath);
        }
        const optionalSegment = segment.replace("?", "");
        basePath += "/" + optionalSegment;
        results.push(basePath);
      } else {
        basePath += "/" + segment;
      }
    }
  });
  return results.filter((v, i, a) => a.indexOf(v) === i);
};
var _decodeURI = (value) => {
  if (!/[%+]/.test(value)) {
    return value;
  }
  if (value.indexOf("+") !== -1) {
    value = value.replace(/\+/g, " ");
  }
  return value.indexOf("%") !== -1 ? decodeURIComponent_(value) : value;
};
var _getQueryParam = (url, key, multiple) => {
  let encoded;
  if (!multiple && key && !/[%+]/.test(key)) {
    let keyIndex2 = url.indexOf(`?${key}`, 8);
    if (keyIndex2 === -1) {
      keyIndex2 = url.indexOf(`&${key}`, 8);
    }
    while (keyIndex2 !== -1) {
      const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);
      if (trailingKeyCode === 61) {
        const valueIndex = keyIndex2 + key.length + 2;
        const endIndex = url.indexOf("&", valueIndex);
        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? undefined : endIndex));
      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
        return "";
      }
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    encoded = /[%+]/.test(url);
    if (!encoded) {
      return;
    }
  }
  const results = {};
  encoded ??= /[%+]/.test(url);
  let keyIndex = url.indexOf("?", 8);
  while (keyIndex !== -1) {
    const nextKeyIndex = url.indexOf("&", keyIndex + 1);
    let valueIndex = url.indexOf("=", keyIndex);
    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
      valueIndex = -1;
    }
    let name = url.slice(keyIndex + 1, valueIndex === -1 ? nextKeyIndex === -1 ? undefined : nextKeyIndex : valueIndex);
    if (encoded) {
      name = _decodeURI(name);
    }
    keyIndex = nextKeyIndex;
    if (name === "") {
      continue;
    }
    let value;
    if (valueIndex === -1) {
      value = "";
    } else {
      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? undefined : nextKeyIndex);
      if (encoded) {
        value = _decodeURI(value);
      }
    }
    if (multiple) {
      if (!(results[name] && Array.isArray(results[name]))) {
        results[name] = [];
      }
      results[name].push(value);
    } else {
      results[name] ??= value;
    }
  }
  return key ? results[key] : results;
};
var getQueryParam = _getQueryParam;
var getQueryParams = (url, key) => {
  return _getQueryParam(url, key, true);
};
var decodeURIComponent_ = decodeURIComponent;

// node_modules/hono/dist/request.js
var tryDecodeURIComponent = (str) => tryDecode(str, decodeURIComponent_);
var HonoRequest = class {
  raw;
  #validatedData;
  #matchResult;
  routeIndex = 0;
  path;
  bodyCache = {};
  constructor(request, path = "/", matchResult = [[]]) {
    this.raw = request;
    this.path = path;
    this.#matchResult = matchResult;
    this.#validatedData = {};
  }
  param(key) {
    return key ? this.#getDecodedParam(key) : this.#getAllDecodedParams();
  }
  #getDecodedParam(key) {
    const paramKey = this.#matchResult[0][this.routeIndex][1][key];
    const param = this.#getParamValue(paramKey);
    return param ? /\%/.test(param) ? tryDecodeURIComponent(param) : param : undefined;
  }
  #getAllDecodedParams() {
    const decoded = {};
    const keys = Object.keys(this.#matchResult[0][this.routeIndex][1]);
    for (const key of keys) {
      const value = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key]);
      if (value && typeof value === "string") {
        decoded[key] = /\%/.test(value) ? tryDecodeURIComponent(value) : value;
      }
    }
    return decoded;
  }
  #getParamValue(paramKey) {
    return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;
  }
  query(key) {
    return getQueryParam(this.url, key);
  }
  queries(key) {
    return getQueryParams(this.url, key);
  }
  header(name) {
    if (name) {
      return this.raw.headers.get(name) ?? undefined;
    }
    const headerData = {};
    this.raw.headers.forEach((value, key) => {
      headerData[key] = value;
    });
    return headerData;
  }
  async parseBody(options) {
    return this.bodyCache.parsedBody ??= await parseBody(this, options);
  }
  #cachedBody = (key) => {
    const { bodyCache, raw } = this;
    const cachedBody = bodyCache[key];
    if (cachedBody) {
      return cachedBody;
    }
    const anyCachedKey = Object.keys(bodyCache)[0];
    if (anyCachedKey) {
      return bodyCache[anyCachedKey].then((body) => {
        if (anyCachedKey === "json") {
          body = JSON.stringify(body);
        }
        return new Response(body)[key]();
      });
    }
    return bodyCache[key] = raw[key]();
  };
  json() {
    return this.#cachedBody("json");
  }
  text() {
    return this.#cachedBody("text");
  }
  arrayBuffer() {
    return this.#cachedBody("arrayBuffer");
  }
  blob() {
    return this.#cachedBody("blob");
  }
  formData() {
    return this.#cachedBody("formData");
  }
  addValidatedData(target, data) {
    this.#validatedData[target] = data;
  }
  valid(target) {
    return this.#validatedData[target];
  }
  get url() {
    return this.raw.url;
  }
  get method() {
    return this.raw.method;
  }
  get matchedRoutes() {
    return this.#matchResult[0].map(([[, route]]) => route);
  }
  get routePath() {
    return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path;
  }
};

// node_modules/hono/dist/utils/html.js
var HtmlEscapedCallbackPhase = {
  Stringify: 1,
  BeforeStream: 2,
  Stream: 3
};
var raw = (value, callbacks) => {
  const escapedString = new String(value);
  escapedString.isEscaped = true;
  escapedString.callbacks = callbacks;
  return escapedString;
};
var resolveCallback = async (str, phase, preserveCallbacks, context, buffer) => {
  if (typeof str === "object" && !(str instanceof String)) {
    if (!(str instanceof Promise)) {
      str = str.toString();
    }
    if (str instanceof Promise) {
      str = await str;
    }
  }
  const callbacks = str.callbacks;
  if (!callbacks?.length) {
    return Promise.resolve(str);
  }
  if (buffer) {
    buffer[0] += str;
  } else {
    buffer = [str];
  }
  const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context }))).then((res) => Promise.all(res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context, buffer))).then(() => buffer[0]));
  if (preserveCallbacks) {
    return raw(await resStr, callbacks);
  } else {
    return resStr;
  }
};

// node_modules/hono/dist/context.js
var TEXT_PLAIN = "text/plain; charset=UTF-8";
var setHeaders = (headers, map = {}) => {
  for (const key of Object.keys(map)) {
    headers.set(key, map[key]);
  }
  return headers;
};
var Context = class {
  #rawRequest;
  #req;
  env = {};
  #var;
  finalized = false;
  error;
  #status = 200;
  #executionCtx;
  #headers;
  #preparedHeaders;
  #res;
  #isFresh = true;
  #layout;
  #renderer;
  #notFoundHandler;
  #matchResult;
  #path;
  constructor(req, options) {
    this.#rawRequest = req;
    if (options) {
      this.#executionCtx = options.executionCtx;
      this.env = options.env;
      this.#notFoundHandler = options.notFoundHandler;
      this.#path = options.path;
      this.#matchResult = options.matchResult;
    }
  }
  get req() {
    this.#req ??= new HonoRequest(this.#rawRequest, this.#path, this.#matchResult);
    return this.#req;
  }
  get event() {
    if (this.#executionCtx && "respondWith" in this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no FetchEvent");
    }
  }
  get executionCtx() {
    if (this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no ExecutionContext");
    }
  }
  get res() {
    this.#isFresh = false;
    return this.#res ||= new Response("404 Not Found", { status: 404 });
  }
  set res(_res) {
    this.#isFresh = false;
    if (this.#res && _res) {
      try {
        for (const [k, v] of this.#res.headers.entries()) {
          if (k === "content-type") {
            continue;
          }
          if (k === "set-cookie") {
            const cookies = this.#res.headers.getSetCookie();
            _res.headers.delete("set-cookie");
            for (const cookie of cookies) {
              _res.headers.append("set-cookie", cookie);
            }
          } else {
            _res.headers.set(k, v);
          }
        }
      } catch (e) {
        if (e instanceof TypeError && e.message.includes("immutable")) {
          this.res = new Response(_res.body, {
            headers: _res.headers,
            status: _res.status
          });
          return;
        } else {
          throw e;
        }
      }
    }
    this.#res = _res;
    this.finalized = true;
  }
  render = (...args) => {
    this.#renderer ??= (content) => this.html(content);
    return this.#renderer(...args);
  };
  setLayout = (layout) => this.#layout = layout;
  getLayout = () => this.#layout;
  setRenderer = (renderer) => {
    this.#renderer = renderer;
  };
  header = (name, value, options) => {
    if (value === undefined) {
      if (this.#headers) {
        this.#headers.delete(name);
      } else if (this.#preparedHeaders) {
        delete this.#preparedHeaders[name.toLocaleLowerCase()];
      }
      if (this.finalized) {
        this.res.headers.delete(name);
      }
      return;
    }
    if (options?.append) {
      if (!this.#headers) {
        this.#isFresh = false;
        this.#headers = new Headers(this.#preparedHeaders);
        this.#preparedHeaders = {};
      }
      this.#headers.append(name, value);
    } else {
      if (this.#headers) {
        this.#headers.set(name, value);
      } else {
        this.#preparedHeaders ??= {};
        this.#preparedHeaders[name.toLowerCase()] = value;
      }
    }
    if (this.finalized) {
      if (options?.append) {
        this.res.headers.append(name, value);
      } else {
        this.res.headers.set(name, value);
      }
    }
  };
  status = (status) => {
    this.#isFresh = false;
    this.#status = status;
  };
  set = (key, value) => {
    this.#var ??= /* @__PURE__ */ new Map;
    this.#var.set(key, value);
  };
  get = (key) => {
    return this.#var ? this.#var.get(key) : undefined;
  };
  get var() {
    if (!this.#var) {
      return {};
    }
    return Object.fromEntries(this.#var);
  }
  #newResponse(data, arg, headers) {
    if (this.#isFresh && !headers && !arg && this.#status === 200) {
      return new Response(data, {
        headers: this.#preparedHeaders
      });
    }
    if (arg && typeof arg !== "number") {
      const header = new Headers(arg.headers);
      if (this.#headers) {
        this.#headers.forEach((v, k) => {
          if (k === "set-cookie") {
            header.append(k, v);
          } else {
            header.set(k, v);
          }
        });
      }
      const headers2 = setHeaders(header, this.#preparedHeaders);
      return new Response(data, {
        headers: headers2,
        status: arg.status ?? this.#status
      });
    }
    const status = typeof arg === "number" ? arg : this.#status;
    this.#preparedHeaders ??= {};
    this.#headers ??= new Headers;
    setHeaders(this.#headers, this.#preparedHeaders);
    if (this.#res) {
      this.#res.headers.forEach((v, k) => {
        if (k === "set-cookie") {
          this.#headers?.append(k, v);
        } else {
          this.#headers?.set(k, v);
        }
      });
      setHeaders(this.#headers, this.#preparedHeaders);
    }
    headers ??= {};
    for (const [k, v] of Object.entries(headers)) {
      if (typeof v === "string") {
        this.#headers.set(k, v);
      } else {
        this.#headers.delete(k);
        for (const v2 of v) {
          this.#headers.append(k, v2);
        }
      }
    }
    return new Response(data, {
      status,
      headers: this.#headers
    });
  }
  newResponse = (...args) => this.#newResponse(...args);
  body = (data, arg, headers) => {
    return typeof arg === "number" ? this.#newResponse(data, arg, headers) : this.#newResponse(data, arg);
  };
  text = (text, arg, headers) => {
    if (!this.#preparedHeaders) {
      if (this.#isFresh && !headers && !arg) {
        return new Response(text);
      }
      this.#preparedHeaders = {};
    }
    this.#preparedHeaders["content-type"] = TEXT_PLAIN;
    if (typeof arg === "number") {
      return this.#newResponse(text, arg, headers);
    }
    return this.#newResponse(text, arg);
  };
  json = (object, arg, headers) => {
    const body = JSON.stringify(object);
    this.#preparedHeaders ??= {};
    this.#preparedHeaders["content-type"] = "application/json";
    return typeof arg === "number" ? this.#newResponse(body, arg, headers) : this.#newResponse(body, arg);
  };
  html = (html, arg, headers) => {
    this.#preparedHeaders ??= {};
    this.#preparedHeaders["content-type"] = "text/html; charset=UTF-8";
    if (typeof html === "object") {
      return resolveCallback(html, HtmlEscapedCallbackPhase.Stringify, false, {}).then((html2) => {
        return typeof arg === "number" ? this.#newResponse(html2, arg, headers) : this.#newResponse(html2, arg);
      });
    }
    return typeof arg === "number" ? this.#newResponse(html, arg, headers) : this.#newResponse(html, arg);
  };
  redirect = (location, status) => {
    this.#headers ??= new Headers;
    this.#headers.set("Location", String(location));
    return this.newResponse(null, status ?? 302);
  };
  notFound = () => {
    this.#notFoundHandler ??= () => new Response;
    return this.#notFoundHandler(this);
  };
};

// node_modules/hono/dist/compose.js
var compose = (middleware, onError, onNotFound) => {
  return (context, next) => {
    let index = -1;
    const isContext = context instanceof Context;
    return dispatch(0);
    async function dispatch(i) {
      if (i <= index) {
        throw new Error("next() called multiple times");
      }
      index = i;
      let res;
      let isError = false;
      let handler;
      if (middleware[i]) {
        handler = middleware[i][0][0];
        if (isContext) {
          context.req.routeIndex = i;
        }
      } else {
        handler = i === middleware.length && next || undefined;
      }
      if (!handler) {
        if (isContext && context.finalized === false && onNotFound) {
          res = await onNotFound(context);
        }
      } else {
        try {
          res = await handler(context, () => {
            return dispatch(i + 1);
          });
        } catch (err) {
          if (err instanceof Error && isContext && onError) {
            context.error = err;
            res = await onError(err, context);
            isError = true;
          } else {
            throw err;
          }
        }
      }
      if (res && (context.finalized === false || isError)) {
        context.res = res;
      }
      return context;
    }
  };
};

// node_modules/hono/dist/router.js
var METHOD_NAME_ALL = "ALL";
var METHOD_NAME_ALL_LOWERCASE = "all";
var METHODS = ["get", "post", "put", "delete", "options", "patch"];
var MESSAGE_MATCHER_IS_ALREADY_BUILT = "Can not add a route since the matcher is already built.";
var UnsupportedPathError = class extends Error {
};

// node_modules/hono/dist/utils/constants.js
var COMPOSED_HANDLER = "__COMPOSED_HANDLER";

// node_modules/hono/dist/hono-base.js
var notFoundHandler = (c) => {
  return c.text("404 Not Found", 404);
};
var errorHandler = (err, c) => {
  if ("getResponse" in err) {
    return err.getResponse();
  }
  console.error(err);
  return c.text("Internal Server Error", 500);
};
var Hono = class {
  get;
  post;
  put;
  delete;
  options;
  patch;
  all;
  on;
  use;
  router;
  getPath;
  _basePath = "/";
  #path = "/";
  routes = [];
  constructor(options = {}) {
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
    allMethods.forEach((method) => {
      this[method] = (args1, ...args) => {
        if (typeof args1 === "string") {
          this.#path = args1;
        } else {
          this.#addRoute(method, this.#path, args1);
        }
        args.forEach((handler) => {
          this.#addRoute(method, this.#path, handler);
        });
        return this;
      };
    });
    this.on = (method, path, ...handlers) => {
      for (const p of [path].flat()) {
        this.#path = p;
        for (const m of [method].flat()) {
          handlers.map((handler) => {
            this.#addRoute(m.toUpperCase(), this.#path, handler);
          });
        }
      }
      return this;
    };
    this.use = (arg1, ...handlers) => {
      if (typeof arg1 === "string") {
        this.#path = arg1;
      } else {
        this.#path = "*";
        handlers.unshift(arg1);
      }
      handlers.forEach((handler) => {
        this.#addRoute(METHOD_NAME_ALL, this.#path, handler);
      });
      return this;
    };
    const strict = options.strict ?? true;
    delete options.strict;
    Object.assign(this, options);
    this.getPath = strict ? options.getPath ?? getPath : getPathNoStrict;
  }
  #clone() {
    const clone = new Hono({
      router: this.router,
      getPath: this.getPath
    });
    clone.routes = this.routes;
    return clone;
  }
  #notFoundHandler = notFoundHandler;
  errorHandler = errorHandler;
  route(path, app) {
    const subApp = this.basePath(path);
    app.routes.map((r) => {
      let handler;
      if (app.errorHandler === errorHandler) {
        handler = r.handler;
      } else {
        handler = async (c, next) => (await compose([], app.errorHandler)(c, () => r.handler(c, next))).res;
        handler[COMPOSED_HANDLER] = r.handler;
      }
      subApp.#addRoute(r.method, r.path, handler);
    });
    return this;
  }
  basePath(path) {
    const subApp = this.#clone();
    subApp._basePath = mergePath(this._basePath, path);
    return subApp;
  }
  onError = (handler) => {
    this.errorHandler = handler;
    return this;
  };
  notFound = (handler) => {
    this.#notFoundHandler = handler;
    return this;
  };
  mount(path, applicationHandler, options) {
    let replaceRequest;
    let optionHandler;
    if (options) {
      if (typeof options === "function") {
        optionHandler = options;
      } else {
        optionHandler = options.optionHandler;
        replaceRequest = options.replaceRequest;
      }
    }
    const getOptions = optionHandler ? (c) => {
      const options2 = optionHandler(c);
      return Array.isArray(options2) ? options2 : [options2];
    } : (c) => {
      let executionContext = undefined;
      try {
        executionContext = c.executionCtx;
      } catch {
      }
      return [c.env, executionContext];
    };
    replaceRequest ||= (() => {
      const mergedPath = mergePath(this._basePath, path);
      const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
      return (request) => {
        const url = new URL(request.url);
        url.pathname = url.pathname.slice(pathPrefixLength) || "/";
        return new Request(url, request);
      };
    })();
    const handler = async (c, next) => {
      const res = await applicationHandler(replaceRequest(c.req.raw), ...getOptions(c));
      if (res) {
        return res;
      }
      await next();
    };
    this.#addRoute(METHOD_NAME_ALL, mergePath(path, "*"), handler);
    return this;
  }
  #addRoute(method, path, handler) {
    method = method.toUpperCase();
    path = mergePath(this._basePath, path);
    const r = { path, method, handler };
    this.router.add(method, path, [handler, r]);
    this.routes.push(r);
  }
  #handleError(err, c) {
    if (err instanceof Error) {
      return this.errorHandler(err, c);
    }
    throw err;
  }
  #dispatch(request, executionCtx, env, method) {
    if (method === "HEAD") {
      return (async () => new Response(null, await this.#dispatch(request, executionCtx, env, "GET")))();
    }
    const path = this.getPath(request, { env });
    const matchResult = this.router.match(method, path);
    const c = new Context(request, {
      path,
      matchResult,
      env,
      executionCtx,
      notFoundHandler: this.#notFoundHandler
    });
    if (matchResult[0].length === 1) {
      let res;
      try {
        res = matchResult[0][0][0][0](c, async () => {
          c.res = await this.#notFoundHandler(c);
        });
      } catch (err) {
        return this.#handleError(err, c);
      }
      return res instanceof Promise ? res.then((resolved) => resolved || (c.finalized ? c.res : this.#notFoundHandler(c))).catch((err) => this.#handleError(err, c)) : res ?? this.#notFoundHandler(c);
    }
    const composed = compose(matchResult[0], this.errorHandler, this.#notFoundHandler);
    return (async () => {
      try {
        const context = await composed(c);
        if (!context.finalized) {
          throw new Error("Context is not finalized. Did you forget to return a Response object or `await next()`?");
        }
        return context.res;
      } catch (err) {
        return this.#handleError(err, c);
      }
    })();
  }
  fetch = (request, ...rest) => {
    return this.#dispatch(request, rest[1], rest[0], request.method);
  };
  request = (input, requestInit, Env, executionCtx) => {
    if (input instanceof Request) {
      return this.fetch(requestInit ? new Request(input, requestInit) : input, Env, executionCtx);
    }
    input = input.toString();
    return this.fetch(new Request(/^https?:\/\//.test(input) ? input : `http://localhost${mergePath("/", input)}`, requestInit), Env, executionCtx);
  };
  fire = () => {
    addEventListener("fetch", (event) => {
      event.respondWith(this.#dispatch(event.request, event, undefined, event.request.method));
    });
  };
};

// node_modules/hono/dist/router/reg-exp-router/node.js
function compareKey(a, b) {
  if (a.length === 1) {
    return b.length === 1 ? a < b ? -1 : 1 : -1;
  }
  if (b.length === 1) {
    return 1;
  }
  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {
    return 1;
  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {
    return -1;
  }
  if (a === LABEL_REG_EXP_STR) {
    return 1;
  } else if (b === LABEL_REG_EXP_STR) {
    return -1;
  }
  return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;
}
var LABEL_REG_EXP_STR = "[^/]+";
var ONLY_WILDCARD_REG_EXP_STR = ".*";
var TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
var PATH_ERROR = Symbol();
var regExpMetaChars = new Set(".\\+*[^]$()");
var Node = class {
  #index;
  #varIndex;
  #children = /* @__PURE__ */ Object.create(null);
  insert(tokens, index, paramMap, context, pathErrorCheckOnly) {
    if (tokens.length === 0) {
      if (this.#index !== undefined) {
        throw PATH_ERROR;
      }
      if (pathErrorCheckOnly) {
        return;
      }
      this.#index = index;
      return;
    }
    const [token, ...restTokens] = tokens;
    const pattern = token === "*" ? restTokens.length === 0 ? ["", "", ONLY_WILDCARD_REG_EXP_STR] : ["", "", LABEL_REG_EXP_STR] : token === "/*" ? ["", "", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    let node;
    if (pattern) {
      const name = pattern[1];
      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;
      if (name && pattern[2]) {
        regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:");
        if (/\((?!\?:)/.test(regexpStr)) {
          throw PATH_ERROR;
        }
      }
      node = this.#children[regexpStr];
      if (!node) {
        if (Object.keys(this.#children).some((k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR)) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[regexpStr] = new Node;
        if (name !== "") {
          node.#varIndex = context.varIndex++;
        }
      }
      if (!pathErrorCheckOnly && name !== "") {
        paramMap.push([name, node.#varIndex]);
      }
    } else {
      node = this.#children[token];
      if (!node) {
        if (Object.keys(this.#children).some((k) => k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR)) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[token] = new Node;
      }
    }
    node.insert(restTokens, index, paramMap, context, pathErrorCheckOnly);
  }
  buildRegExpStr() {
    const childKeys = Object.keys(this.#children).sort(compareKey);
    const strList = childKeys.map((k) => {
      const c = this.#children[k];
      return (typeof c.#varIndex === "number" ? `(${k})@${c.#varIndex}` : regExpMetaChars.has(k) ? `\\${k}` : k) + c.buildRegExpStr();
    });
    if (typeof this.#index === "number") {
      strList.unshift(`#${this.#index}`);
    }
    if (strList.length === 0) {
      return "";
    }
    if (strList.length === 1) {
      return strList[0];
    }
    return "(?:" + strList.join("|") + ")";
  }
};

// node_modules/hono/dist/router/reg-exp-router/trie.js
var Trie = class {
  #context = { varIndex: 0 };
  #root = new Node;
  insert(path, index, pathErrorCheckOnly) {
    const paramAssoc = [];
    const groups = [];
    for (let i = 0;; ) {
      let replaced = false;
      path = path.replace(/\{[^}]+\}/g, (m) => {
        const mark = `@\\${i}`;
        groups[i] = [mark, m];
        i++;
        replaced = true;
        return mark;
      });
      if (!replaced) {
        break;
      }
    }
    const tokens = path.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
    for (let i = groups.length - 1;i >= 0; i--) {
      const [mark] = groups[i];
      for (let j = tokens.length - 1;j >= 0; j--) {
        if (tokens[j].indexOf(mark) !== -1) {
          tokens[j] = tokens[j].replace(mark, groups[i][1]);
          break;
        }
      }
    }
    this.#root.insert(tokens, index, paramAssoc, this.#context, pathErrorCheckOnly);
    return paramAssoc;
  }
  buildRegExp() {
    let regexp = this.#root.buildRegExpStr();
    if (regexp === "") {
      return [/^$/, [], []];
    }
    let captureIndex = 0;
    const indexReplacementMap = [];
    const paramReplacementMap = [];
    regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_, handlerIndex, paramIndex) => {
      if (handlerIndex !== undefined) {
        indexReplacementMap[++captureIndex] = Number(handlerIndex);
        return "$()";
      }
      if (paramIndex !== undefined) {
        paramReplacementMap[Number(paramIndex)] = ++captureIndex;
        return "";
      }
      return "";
    });
    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];
  }
};

// node_modules/hono/dist/router/reg-exp-router/router.js
function buildWildcardRegExp(path) {
  return wildcardRegExpCache[path] ??= new RegExp(path === "*" ? "" : `^${path.replace(/\/\*$|([.\\+*[^\]$()])/g, (_, metaChar) => metaChar ? `\\${metaChar}` : "(?:|/.*)")}\$`);
}
function clearWildcardRegExpCache() {
  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
}
function buildMatcherFromPreprocessedRoutes(routes) {
  const trie = new Trie;
  const handlerData = [];
  if (routes.length === 0) {
    return nullMatcher;
  }
  const routesWithStaticPathFlag = routes.map((route) => [!/\*|\/:/.test(route[0]), ...route]).sort(([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length);
  const staticMap = /* @__PURE__ */ Object.create(null);
  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length;i < len; i++) {
    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];
    if (pathErrorCheckOnly) {
      staticMap[path] = [handlers.map(([h]) => [h, /* @__PURE__ */ Object.create(null)]), emptyParam];
    } else {
      j++;
    }
    let paramAssoc;
    try {
      paramAssoc = trie.insert(path, j, pathErrorCheckOnly);
    } catch (e) {
      throw e === PATH_ERROR ? new UnsupportedPathError(path) : e;
    }
    if (pathErrorCheckOnly) {
      continue;
    }
    handlerData[j] = handlers.map(([h, paramCount]) => {
      const paramIndexMap = /* @__PURE__ */ Object.create(null);
      paramCount -= 1;
      for (;paramCount >= 0; paramCount--) {
        const [key, value] = paramAssoc[paramCount];
        paramIndexMap[key] = value;
      }
      return [h, paramIndexMap];
    });
  }
  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
  for (let i = 0, len = handlerData.length;i < len; i++) {
    for (let j = 0, len2 = handlerData[i].length;j < len2; j++) {
      const map = handlerData[i][j]?.[1];
      if (!map) {
        continue;
      }
      const keys = Object.keys(map);
      for (let k = 0, len3 = keys.length;k < len3; k++) {
        map[keys[k]] = paramReplacementMap[map[keys[k]]];
      }
    }
  }
  const handlerMap = [];
  for (const i in indexReplacementMap) {
    handlerMap[i] = handlerData[indexReplacementMap[i]];
  }
  return [regexp, handlerMap, staticMap];
}
function findMiddleware(middleware, path) {
  if (!middleware) {
    return;
  }
  for (const k of Object.keys(middleware).sort((a, b) => b.length - a.length)) {
    if (buildWildcardRegExp(k).test(path)) {
      return [...middleware[k]];
    }
  }
  return;
}
var emptyParam = [];
var nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];
var wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
var RegExpRouter = class {
  name = "RegExpRouter";
  #middleware;
  #routes;
  constructor() {
    this.#middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
    this.#routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
  }
  add(method, path, handler) {
    const middleware = this.#middleware;
    const routes = this.#routes;
    if (!middleware || !routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    if (!middleware[method]) {
      [middleware, routes].forEach((handlerMap) => {
        handlerMap[method] = /* @__PURE__ */ Object.create(null);
        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p) => {
          handlerMap[method][p] = [...handlerMap[METHOD_NAME_ALL][p]];
        });
      });
    }
    if (path === "/*") {
      path = "*";
    }
    const paramCount = (path.match(/\/:/g) || []).length;
    if (/\*$/.test(path)) {
      const re = buildWildcardRegExp(path);
      if (method === METHOD_NAME_ALL) {
        Object.keys(middleware).forEach((m) => {
          middleware[m][path] ||= findMiddleware(middleware[m], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
        });
      } else {
        middleware[method][path] ||= findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
      }
      Object.keys(middleware).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(middleware[m]).forEach((p) => {
            re.test(p) && middleware[m][p].push([handler, paramCount]);
          });
        }
      });
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(routes[m]).forEach((p) => re.test(p) && routes[m][p].push([handler, paramCount]));
        }
      });
      return;
    }
    const paths = checkOptionalParameter(path) || [path];
    for (let i = 0, len = paths.length;i < len; i++) {
      const path2 = paths[i];
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          routes[m][path2] ||= [
            ...findMiddleware(middleware[m], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || []
          ];
          routes[m][path2].push([handler, paramCount - len + i + 1]);
        }
      });
    }
  }
  match(method, path) {
    clearWildcardRegExpCache();
    const matchers = this.#buildAllMatchers();
    this.match = (method2, path2) => {
      const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];
      const staticMatch = matcher[2][path2];
      if (staticMatch) {
        return staticMatch;
      }
      const match = path2.match(matcher[0]);
      if (!match) {
        return [[], emptyParam];
      }
      const index = match.indexOf("", 1);
      return [matcher[1][index], match];
    };
    return this.match(method, path);
  }
  #buildAllMatchers() {
    const matchers = /* @__PURE__ */ Object.create(null);
    Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((method) => {
      matchers[method] ||= this.#buildMatcher(method);
    });
    this.#middleware = this.#routes = undefined;
    return matchers;
  }
  #buildMatcher(method) {
    const routes = [];
    let hasOwnRoute = method === METHOD_NAME_ALL;
    [this.#middleware, this.#routes].forEach((r) => {
      const ownRoute = r[method] ? Object.keys(r[method]).map((path) => [path, r[method][path]]) : [];
      if (ownRoute.length !== 0) {
        hasOwnRoute ||= true;
        routes.push(...ownRoute);
      } else if (method !== METHOD_NAME_ALL) {
        routes.push(...Object.keys(r[METHOD_NAME_ALL]).map((path) => [path, r[METHOD_NAME_ALL][path]]));
      }
    });
    if (!hasOwnRoute) {
      return null;
    } else {
      return buildMatcherFromPreprocessedRoutes(routes);
    }
  }
};

// node_modules/hono/dist/router/smart-router/router.js
var SmartRouter = class {
  name = "SmartRouter";
  #routers = [];
  #routes = [];
  constructor(init) {
    this.#routers = init.routers;
  }
  add(method, path, handler) {
    if (!this.#routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    this.#routes.push([method, path, handler]);
  }
  match(method, path) {
    if (!this.#routes) {
      throw new Error("Fatal error");
    }
    const routers = this.#routers;
    const routes = this.#routes;
    const len = routers.length;
    let i = 0;
    let res;
    for (;i < len; i++) {
      const router = routers[i];
      try {
        for (let i2 = 0, len2 = routes.length;i2 < len2; i2++) {
          router.add(...routes[i2]);
        }
        res = router.match(method, path);
      } catch (e) {
        if (e instanceof UnsupportedPathError) {
          continue;
        }
        throw e;
      }
      this.match = router.match.bind(router);
      this.#routers = [router];
      this.#routes = undefined;
      break;
    }
    if (i === len) {
      throw new Error("Fatal error");
    }
    this.name = `SmartRouter + ${this.activeRouter.name}`;
    return res;
  }
  get activeRouter() {
    if (this.#routes || this.#routers.length !== 1) {
      throw new Error("No active router has been determined yet.");
    }
    return this.#routers[0];
  }
};

// node_modules/hono/dist/router/trie-router/node.js
var emptyParams = /* @__PURE__ */ Object.create(null);
var Node2 = class {
  #methods;
  #children;
  #patterns;
  #order = 0;
  #params = emptyParams;
  constructor(method, handler, children) {
    this.#children = children || /* @__PURE__ */ Object.create(null);
    this.#methods = [];
    if (method && handler) {
      const m = /* @__PURE__ */ Object.create(null);
      m[method] = { handler, possibleKeys: [], score: 0 };
      this.#methods = [m];
    }
    this.#patterns = [];
  }
  insert(method, path, handler) {
    this.#order = ++this.#order;
    let curNode = this;
    const parts = splitRoutingPath(path);
    const possibleKeys = [];
    for (let i = 0, len = parts.length;i < len; i++) {
      const p = parts[i];
      const nextP = parts[i + 1];
      const pattern = getPattern(p, nextP);
      const key = Array.isArray(pattern) ? pattern[0] : p;
      if (Object.keys(curNode.#children).includes(key)) {
        curNode = curNode.#children[key];
        const pattern2 = getPattern(p, nextP);
        if (pattern2) {
          possibleKeys.push(pattern2[1]);
        }
        continue;
      }
      curNode.#children[key] = new Node2;
      if (pattern) {
        curNode.#patterns.push(pattern);
        possibleKeys.push(pattern[1]);
      }
      curNode = curNode.#children[key];
    }
    const m = /* @__PURE__ */ Object.create(null);
    const handlerSet = {
      handler,
      possibleKeys: possibleKeys.filter((v, i, a) => a.indexOf(v) === i),
      score: this.#order
    };
    m[method] = handlerSet;
    curNode.#methods.push(m);
    return curNode;
  }
  #getHandlerSets(node, method, nodeParams, params) {
    const handlerSets = [];
    for (let i = 0, len = node.#methods.length;i < len; i++) {
      const m = node.#methods[i];
      const handlerSet = m[method] || m[METHOD_NAME_ALL];
      const processedSet = {};
      if (handlerSet !== undefined) {
        handlerSet.params = /* @__PURE__ */ Object.create(null);
        handlerSets.push(handlerSet);
        if (nodeParams !== emptyParams || params && params !== emptyParams) {
          for (let i2 = 0, len2 = handlerSet.possibleKeys.length;i2 < len2; i2++) {
            const key = handlerSet.possibleKeys[i2];
            const processed = processedSet[handlerSet.score];
            handlerSet.params[key] = params?.[key] && !processed ? params[key] : nodeParams[key] ?? params?.[key];
            processedSet[handlerSet.score] = true;
          }
        }
      }
    }
    return handlerSets;
  }
  search(method, path) {
    const handlerSets = [];
    this.#params = emptyParams;
    const curNode = this;
    let curNodes = [curNode];
    const parts = splitPath(path);
    const curNodesQueue = [];
    for (let i = 0, len = parts.length;i < len; i++) {
      const part = parts[i];
      const isLast = i === len - 1;
      const tempNodes = [];
      for (let j = 0, len2 = curNodes.length;j < len2; j++) {
        const node = curNodes[j];
        const nextNode = node.#children[part];
        if (nextNode) {
          nextNode.#params = node.#params;
          if (isLast) {
            if (nextNode.#children["*"]) {
              handlerSets.push(...this.#getHandlerSets(nextNode.#children["*"], method, node.#params));
            }
            handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params));
          } else {
            tempNodes.push(nextNode);
          }
        }
        for (let k = 0, len3 = node.#patterns.length;k < len3; k++) {
          const pattern = node.#patterns[k];
          const params = node.#params === emptyParams ? {} : { ...node.#params };
          if (pattern === "*") {
            const astNode = node.#children["*"];
            if (astNode) {
              handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params));
              astNode.#params = params;
              tempNodes.push(astNode);
            }
            continue;
          }
          if (part === "") {
            continue;
          }
          const [key, name, matcher] = pattern;
          const child = node.#children[key];
          const restPathString = parts.slice(i).join("/");
          if (matcher instanceof RegExp) {
            const m = matcher.exec(restPathString);
            if (m) {
              params[name] = m[0];
              handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params));
              if (Object.keys(child.#children).length) {
                child.#params = params;
                const componentCount = m[0].match(/\//)?.length ?? 0;
                const targetCurNodes = curNodesQueue[componentCount] ||= [];
                targetCurNodes.push(child);
              }
              continue;
            }
          }
          if (matcher === true || matcher.test(part)) {
            params[name] = part;
            if (isLast) {
              handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params));
              if (child.#children["*"]) {
                handlerSets.push(...this.#getHandlerSets(child.#children["*"], method, params, node.#params));
              }
            } else {
              child.#params = params;
              tempNodes.push(child);
            }
          }
        }
      }
      curNodes = tempNodes.concat(curNodesQueue.shift() ?? []);
    }
    if (handlerSets.length > 1) {
      handlerSets.sort((a, b) => {
        return a.score - b.score;
      });
    }
    return [handlerSets.map(({ handler, params }) => [handler, params])];
  }
};

// node_modules/hono/dist/router/trie-router/router.js
var TrieRouter = class {
  name = "TrieRouter";
  #node;
  constructor() {
    this.#node = new Node2;
  }
  add(method, path, handler) {
    const results = checkOptionalParameter(path);
    if (results) {
      for (let i = 0, len = results.length;i < len; i++) {
        this.#node.insert(method, results[i], handler);
      }
      return;
    }
    this.#node.insert(method, path, handler);
  }
  match(method, path) {
    return this.#node.search(method, path);
  }
};

// node_modules/hono/dist/hono.js
var Hono2 = class extends Hono {
  constructor(options = {}) {
    super(options);
    this.router = options.router ?? new SmartRouter({
      routers: [new RegExpRouter, new TrieRouter]
    });
  }
};

// node_modules/hono/dist/middleware/cors/index.js
var cors = (options) => {
  const defaults = {
    origin: "*",
    allowMethods: ["GET", "HEAD", "PUT", "POST", "DELETE", "PATCH"],
    allowHeaders: [],
    exposeHeaders: []
  };
  const opts = {
    ...defaults,
    ...options
  };
  const findAllowOrigin = ((optsOrigin) => {
    if (typeof optsOrigin === "string") {
      if (optsOrigin === "*") {
        return () => optsOrigin;
      } else {
        return (origin) => optsOrigin === origin ? origin : null;
      }
    } else if (typeof optsOrigin === "function") {
      return optsOrigin;
    } else {
      return (origin) => optsOrigin.includes(origin) ? origin : null;
    }
  })(opts.origin);
  return async function cors2(c, next) {
    function set(key, value) {
      c.res.headers.set(key, value);
    }
    const allowOrigin = findAllowOrigin(c.req.header("origin") || "", c);
    if (allowOrigin) {
      set("Access-Control-Allow-Origin", allowOrigin);
    }
    if (opts.origin !== "*") {
      const existingVary = c.req.header("Vary");
      if (existingVary) {
        set("Vary", existingVary);
      } else {
        set("Vary", "Origin");
      }
    }
    if (opts.credentials) {
      set("Access-Control-Allow-Credentials", "true");
    }
    if (opts.exposeHeaders?.length) {
      set("Access-Control-Expose-Headers", opts.exposeHeaders.join(","));
    }
    if (c.req.method === "OPTIONS") {
      if (opts.maxAge != null) {
        set("Access-Control-Max-Age", opts.maxAge.toString());
      }
      if (opts.allowMethods?.length) {
        set("Access-Control-Allow-Methods", opts.allowMethods.join(","));
      }
      let headers = opts.allowHeaders;
      if (!headers?.length) {
        const requestHeaders = c.req.header("Access-Control-Request-Headers");
        if (requestHeaders) {
          headers = requestHeaders.split(/\s*,\s*/);
        }
      }
      if (headers?.length) {
        set("Access-Control-Allow-Headers", headers.join(","));
        c.res.headers.append("Vary", "Access-Control-Request-Headers");
      }
      c.res.headers.delete("Content-Length");
      c.res.headers.delete("Content-Type");
      return new Response(null, {
        headers: c.res.headers,
        status: 204,
        statusText: "No Content"
      });
    }
    await next();
  };
};

// node_modules/hono/dist/utils/color.js
function getColorEnabled() {
  const { process: process2, Deno: Deno2 } = globalThis;
  const isNoColor = typeof Deno2?.noColor === "boolean" ? Deno2.noColor : process2 !== undefined ? "NO_COLOR" in process2?.env : false;
  return !isNoColor;
}

// node_modules/hono/dist/middleware/logger/index.js
function log(fn, prefix, method, path, status = 0, elapsed) {
  const out = prefix === "<--" ? `${prefix} ${method} ${path}` : `${prefix} ${method} ${path} ${colorStatus(status)} ${elapsed}`;
  fn(out);
}
var humanize = (times) => {
  const [delimiter, separator] = [",", "."];
  const orderTimes = times.map((v) => v.replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1" + delimiter));
  return orderTimes.join(separator);
};
var time = (start) => {
  const delta = Date.now() - start;
  return humanize([delta < 1000 ? delta + "ms" : Math.round(delta / 1000) + "s"]);
};
var colorStatus = (status) => {
  const colorEnabled = getColorEnabled();
  if (colorEnabled) {
    switch (status / 100 | 0) {
      case 5:
        return `\x1B[31m${status}\x1B[0m`;
      case 4:
        return `\x1B[33m${status}\x1B[0m`;
      case 3:
        return `\x1B[36m${status}\x1B[0m`;
      case 2:
        return `\x1B[32m${status}\x1B[0m`;
    }
  }
  return `${status}`;
};
var logger = (fn = console.log) => {
  return async function logger2(c, next) {
    const { method, url } = c.req;
    const path = url.slice(url.indexOf("/", 8));
    log(fn, "<--", method, path);
    const start = Date.now();
    await next();
    log(fn, "-->", method, path, c.res.status, time(start));
  };
};

// node_modules/hono/dist/middleware/powered-by/index.js
var poweredBy = (options) => {
  return async function poweredBy2(c, next) {
    await next();
    c.res.headers.set("X-Powered-By", options?.serverName ?? "Hono");
  };
};

// node_modules/hono/dist/utils/encode.js
var decodeBase64Url = (str) => {
  return decodeBase64(str.replace(/_|-/g, (m) => ({ _: "/", "-": "+" })[m] ?? m));
};
var encodeBase64Url = (buf) => encodeBase64(buf).replace(/\/|\+/g, (m) => ({ "/": "_", "+": "-" })[m] ?? m);
var encodeBase64 = (buf) => {
  let binary = "";
  const bytes = new Uint8Array(buf);
  for (let i = 0, len = bytes.length;i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
};
var decodeBase64 = (str) => {
  const binary = atob(str);
  const bytes = new Uint8Array(new ArrayBuffer(binary.length));
  const half = binary.length / 2;
  for (let i = 0, j = binary.length - 1;i <= half; i++, j--) {
    bytes[i] = binary.charCodeAt(i);
    bytes[j] = binary.charCodeAt(j);
  }
  return bytes;
};

// node_modules/hono/dist/middleware/secure-headers/secure-headers.js
function getFilteredHeaders(options) {
  return Object.entries(HEADERS_MAP).filter(([key]) => options[key]).map(([key, defaultValue]) => {
    const overrideValue = options[key];
    return typeof overrideValue === "string" ? [defaultValue[0], overrideValue] : defaultValue;
  });
}
function getCSPDirectives(contentSecurityPolicy) {
  const callbacks = [];
  const resultValues = [];
  for (const [directive, value] of Object.entries(contentSecurityPolicy)) {
    const valueArray = Array.isArray(value) ? value : [value];
    valueArray.forEach((value2, i) => {
      if (typeof value2 === "function") {
        const index = i * 2 + 2 + resultValues.length;
        callbacks.push((ctx, values) => {
          values[index] = value2(ctx, directive);
        });
      }
    });
    resultValues.push(directive.replace(/[A-Z]+(?![a-z])|[A-Z]/g, (match, offset) => offset ? "-" + match.toLowerCase() : match.toLowerCase()), ...valueArray.flatMap((value2) => [" ", value2]), "; ");
  }
  resultValues.pop();
  return callbacks.length === 0 ? [undefined, resultValues.join("")] : [
    (ctx, headersToSet) => headersToSet.map((values) => {
      if (values[0] === "Content-Security-Policy" || values[0] === "Content-Security-Policy-Report-Only") {
        const clone = values[1].slice();
        callbacks.forEach((cb) => {
          cb(ctx, clone);
        });
        return [values[0], clone.join("")];
      } else {
        return values;
      }
    }),
    resultValues
  ];
}
function getPermissionsPolicyDirectives(policy) {
  return Object.entries(policy).map(([directive, value]) => {
    const kebabDirective = camelToKebab(directive);
    if (typeof value === "boolean") {
      return `${kebabDirective}=${value ? "*" : "none"}`;
    }
    if (Array.isArray(value)) {
      if (value.length === 0) {
        return `${kebabDirective}=()`;
      }
      if (value.length === 1 && (value[0] === "*" || value[0] === "none")) {
        return `${kebabDirective}=${value[0]}`;
      }
      const allowlist = value.map((item) => ["self", "src"].includes(item) ? item : `"${item}"`);
      return `${kebabDirective}=(${allowlist.join(" ")})`;
    }
    return "";
  }).filter(Boolean).join(", ");
}
function camelToKebab(str) {
  return str.replace(/([a-z\d])([A-Z])/g, "$1-$2").toLowerCase();
}
function getReportingEndpoints(reportingEndpoints = []) {
  return reportingEndpoints.map((endpoint) => `${endpoint.name}="${endpoint.url}"`).join(", ");
}
function getReportToOptions(reportTo = []) {
  return reportTo.map((option) => JSON.stringify(option)).join(", ");
}
function setHeaders2(ctx, headersToSet) {
  headersToSet.forEach(([header, value]) => {
    ctx.res.headers.set(header, value);
  });
}
var HEADERS_MAP = {
  crossOriginEmbedderPolicy: ["Cross-Origin-Embedder-Policy", "require-corp"],
  crossOriginResourcePolicy: ["Cross-Origin-Resource-Policy", "same-origin"],
  crossOriginOpenerPolicy: ["Cross-Origin-Opener-Policy", "same-origin"],
  originAgentCluster: ["Origin-Agent-Cluster", "?1"],
  referrerPolicy: ["Referrer-Policy", "no-referrer"],
  strictTransportSecurity: ["Strict-Transport-Security", "max-age=15552000; includeSubDomains"],
  xContentTypeOptions: ["X-Content-Type-Options", "nosniff"],
  xDnsPrefetchControl: ["X-DNS-Prefetch-Control", "off"],
  xDownloadOptions: ["X-Download-Options", "noopen"],
  xFrameOptions: ["X-Frame-Options", "SAMEORIGIN"],
  xPermittedCrossDomainPolicies: ["X-Permitted-Cross-Domain-Policies", "none"],
  xXssProtection: ["X-XSS-Protection", "0"]
};
var DEFAULT_OPTIONS = {
  crossOriginEmbedderPolicy: false,
  crossOriginResourcePolicy: true,
  crossOriginOpenerPolicy: true,
  originAgentCluster: true,
  referrerPolicy: true,
  strictTransportSecurity: true,
  xContentTypeOptions: true,
  xDnsPrefetchControl: true,
  xDownloadOptions: true,
  xFrameOptions: true,
  xPermittedCrossDomainPolicies: true,
  xXssProtection: true,
  removePoweredBy: true,
  permissionsPolicy: {}
};
var secureHeaders = (customOptions) => {
  const options = { ...DEFAULT_OPTIONS, ...customOptions };
  const headersToSet = getFilteredHeaders(options);
  const callbacks = [];
  if (options.contentSecurityPolicy) {
    const [callback, value] = getCSPDirectives(options.contentSecurityPolicy);
    if (callback) {
      callbacks.push(callback);
    }
    headersToSet.push(["Content-Security-Policy", value]);
  }
  if (options.contentSecurityPolicyReportOnly) {
    const [callback, value] = getCSPDirectives(options.contentSecurityPolicyReportOnly);
    if (callback) {
      callbacks.push(callback);
    }
    headersToSet.push(["Content-Security-Policy-Report-Only", value]);
  }
  if (options.permissionsPolicy && Object.keys(options.permissionsPolicy).length > 0) {
    headersToSet.push([
      "Permissions-Policy",
      getPermissionsPolicyDirectives(options.permissionsPolicy)
    ]);
  }
  if (options.reportingEndpoints) {
    headersToSet.push(["Reporting-Endpoints", getReportingEndpoints(options.reportingEndpoints)]);
  }
  if (options.reportTo) {
    headersToSet.push(["Report-To", getReportToOptions(options.reportTo)]);
  }
  return async function secureHeaders2(ctx, next) {
    const headersToSetForReq = callbacks.length === 0 ? headersToSet : callbacks.reduce((acc, cb) => cb(ctx, acc), headersToSet);
    await next();
    setHeaders2(ctx, headersToSetForReq);
    if (options?.removePoweredBy) {
      ctx.res.headers.delete("X-Powered-By");
    }
  };
};

// node_modules/hono/dist/utils/compress.js
var COMPRESSIBLE_CONTENT_TYPE_REGEX = /^\s*(?:text\/(?!event-stream(?:[;\s]|$))[^;\s]+|application\/(?:javascript|json|xml|xml-dtd|ecmascript|dart|postscript|rtf|tar|toml|vnd\.dart|vnd\.ms-fontobject|vnd\.ms-opentype|wasm|x-httpd-php|x-javascript|x-ns-proxy-autoconfig|x-sh|x-tar|x-virtualbox-hdd|x-virtualbox-ova|x-virtualbox-ovf|x-virtualbox-vbox|x-virtualbox-vdi|x-virtualbox-vhd|x-virtualbox-vmdk|x-www-form-urlencoded)|font\/(?:otf|ttf)|image\/(?:bmp|vnd\.adobe\.photoshop|vnd\.microsoft\.icon|vnd\.ms-dds|x-icon|x-ms-bmp)|message\/rfc822|model\/gltf-binary|x-shader\/x-fragment|x-shader\/x-vertex|[^;\s]+?\+(?:json|text|xml|yaml))(?:[;\s]|$)/i;

// node_modules/hono/dist/middleware/compress/index.js
var ENCODING_TYPES = ["gzip", "deflate"];
var cacheControlNoTransformRegExp = /(?:^|,)\s*?no-transform\s*?(?:,|$)/i;
var compress = (options) => {
  const threshold = options?.threshold ?? 1024;
  return async function compress2(ctx, next) {
    await next();
    const contentLength = ctx.res.headers.get("Content-Length");
    if (ctx.res.headers.has("Content-Encoding") || ctx.req.method === "HEAD" || contentLength && Number(contentLength) < threshold || !shouldCompress(ctx.res) || !shouldTransform(ctx.res)) {
      return;
    }
    const accepted = ctx.req.header("Accept-Encoding");
    const encoding = options?.encoding ?? ENCODING_TYPES.find((encoding2) => accepted?.includes(encoding2));
    if (!encoding || !ctx.res.body) {
      return;
    }
    const stream = new CompressionStream(encoding);
    ctx.res = new Response(ctx.res.body.pipeThrough(stream), ctx.res);
    ctx.res.headers.delete("Content-Length");
    ctx.res.headers.set("Content-Encoding", encoding);
  };
};
var shouldCompress = (res) => {
  const type = res.headers.get("Content-Type");
  return type && COMPRESSIBLE_CONTENT_TYPE_REGEX.test(type);
};
var shouldTransform = (res) => {
  const cacheControl = res.headers.get("Cache-Control");
  return !cacheControl || !cacheControlNoTransformRegExp.test(cacheControl);
};

// src/app.ts
var import_cloudinary2 = __toESM(require_cloudinary(), 1);

// node_modules/hono/dist/http-exception.js
var HTTPException = class extends Error {
  res;
  status;
  constructor(status = 500, options) {
    super(options?.message, { cause: options?.cause });
    this.res = options?.res;
    this.status = status;
  }
  getResponse() {
    if (this.res) {
      const newResponse = new Response(this.res.body, {
        status: this.status,
        headers: this.res.headers
      });
      return newResponse;
    }
    return new Response(this.message, {
      status: this.status
    });
  }
};

// src/utils/index.ts
var import_lodash = __toESM(require_lodash(), 1);
var getInfoData = ({ fields, data }) => {
  if (!Array.isArray(fields) || fields.length === 0) {
    throw new Error("fields ph\u1EA3i l\xE0 m\u1ED9t m\u1EA3ng v\xE0 kh\xF4ng \u0111\u01B0\u1EE3c r\u1ED7ng!");
  }
  if (Array.isArray(data)) {
    return data.map((item) => import_lodash.default.pick(item, fields));
  }
  return import_lodash.default.pick(data, fields);
};

// src/models/user.model.ts
var import_mongoose = __toESM(require_mongoose2(), 1);
var DOCUMENT_NAME = "user";
var COLLECTION_NAME = "users";
var userSchema = new import_mongoose.Schema({
  username: { type: String, unique: true, required: true },
  email: { type: String, unique: true, required: true },
  password_hash: { type: String, required: false },
  role: { type: String, enum: ["user", "admin"], default: "user" },
  topic_id: { type: import_mongoose.Schema.Types.ObjectId, ref: "topic", required: false },
  streak: { type: Number, default: 0 },
  streak_max: { type: Number, default: 0 },
  streak_start: { type: Date, default: null },
  is_delete: { type: Boolean, default: false }
}, {
  collection: COLLECTION_NAME,
  timestamps: true
});
var UserModel = import_mongoose.model(DOCUMENT_NAME, userSchema);
var user_model_default = UserModel;

// src/services/user.service.ts
var import_mongoose11 = __toESM(require_mongoose2(), 1);

// src/models/topic.model.ts
var import_mongoose2 = __toESM(require_mongoose2(), 1);
var DOCUMENT_NAME2 = "topic";
var COLLECTION_NAME2 = "topics";
var topicSchema = new import_mongoose2.Schema({
  name: { type: String, unique: true, required: true },
  description: { type: String, default: "" },
  image: { type: String },
  isDelete: { type: Boolean, default: false }
}, {
  collection: COLLECTION_NAME2,
  timestamps: true
});
var TopicModel = import_mongoose2.model(DOCUMENT_NAME2, topicSchema);
var topic_model_default = TopicModel;

// src/utils/upload.ultil.ts
var import_cloudinary = __toESM(require_cloudinary(), 1);
var uploadFileImg = async (file, folderName, options = {}) => {
  try {
    const transformation = [
      { quality: "auto" },
      { fetch_format: "auto" }
    ];
    const uploadResponse = await import_cloudinary.v2.uploader.upload(file, {
      folder: folderName,
      transformation
    }).catch((err) => {
      console.log(err);
      throw new HTTPException(500, { message: "Upload file th\u1EA5t b\u1EA1i" });
    });
    return uploadResponse;
  } catch (err) {
    console.error(err);
    throw new HTTPException(500, { message: "Upload file th\u1EA5t b\u1EA1i" });
  }
};

// src/services/topic.service.ts
var import_is_base64 = __toESM(require_is_base64(), 1);
var TopicService = {
  createOrUpdate: async (_id, name, description, image) => {
    let imageUrl = image;
    if (image && import_is_base64.default(image, { allowMime: true })) {
      const res = await uploadFileImg(image, "goat-topic");
      imageUrl = res.url;
    }
    let updatedTopic = null;
    if (!_id) {
      updatedTopic = await topic_model_default.create({
        name,
        description,
        image: imageUrl
      });
    } else {
      updatedTopic = await topic_model_default.findOneAndUpdate({ _id }, { name, description, image: imageUrl }, { upsert: true, new: true });
    }
    return updatedTopic;
  },
  getById: async (topic_id) => {
    const topic = await topic_model_default.findOne({ _id: topic_id, isDelete: false }).lean();
    if (!topic)
      throw new HTTPException(404, { message: "Topic not found" });
    return getInfoData({ fields: ["_id", "name", "description", "image"], data: topic });
  },
  getAll: async () => {
    const topics = await topic_model_default.find({ isDelete: false });
    return topics;
  },
  deleteById: async (topic_id) => {
    const topic = await topic_model_default.findOne({ _id: topic_id, isDelete: false });
    if (!topic)
      throw new HTTPException(404, { message: "Ch\u1EE7 \u0111\u1EC1 kh\xF4ng t\u1ED3n t\u1EA1i" });
    topic.isDelete = true;
    return await topic.save();
  }
};

// src/models/user_progress.model.ts
var import_mongoose3 = __toESM(require_mongoose2(), 1);
var DOCUMENT_NAME3 = "user_progress";
var COLLECTION_NAME3 = "user_progresses";
var userProgressSchema = new import_mongoose3.Schema({
  user_id: { type: import_mongoose3.Schema.Types.ObjectId, ref: "user", required: true },
  progress_id: { type: import_mongoose3.Schema.Types.ObjectId, ref: "progress", required: true },
  lesson_id: { type: import_mongoose3.Schema.Types.ObjectId, ref: "lesson", default: null },
  topic_id: { type: import_mongoose3.Schema.Types.ObjectId, ref: "topic", required: true },
  status: { type: String, enum: ["in_progress", "completed"], default: "in_progress" },
  score: { type: Number, default: 0 },
  detail: [{
    exercise_id: { type: String },
    question: { type: String },
    correct_answer: { type: import_mongoose3.Schema.Types.Mixed },
    user_answer: { type: import_mongoose3.Schema.Types.Mixed },
    correct: { type: Boolean }
  }]
}, {
  collection: COLLECTION_NAME3,
  timestamps: true
});
var UserProgressModel = import_mongoose3.model(DOCUMENT_NAME3, userProgressSchema);
var user_progress_model_default = UserProgressModel;

// src/services/user_progress.service.ts
var UserProgressService = {
  processDB: async ({
    user_id,
    progress_id,
    lesson_id,
    topic_id,
    status,
    score,
    detail,
    _id
  }) => {
    let newUserProgress = null;
    if (!_id) {
      newUserProgress = await user_progress_model_default.create({
        user_id,
        progress_id,
        lesson_id,
        status,
        score,
        detail,
        topic_id
      });
    } else {
      newUserProgress = await user_progress_model_default.findOneAndUpdate({ _id }, { user_id, progress_id, lesson_id, status, score, detail, topic_id }, { upsert: true, new: true });
    }
    return (await newUserProgress.populate("lesson_id")).populate("progress_id");
  },
  getByUserTopicAndStatus: async (user_id, progress_id) => {
    const result = await user_progress_model_default.findOne({
      user_id,
      progress_id,
      status: "in_progress"
    }).populate({
      path: "lesson_id",
      select: "_id title description order exercises vocabularies min_score"
    }).populate("progress_id").lean();
    return result;
  },
  getAllByUserAndTopic: async (user_id, topic_id) => {
    const result = await user_progress_model_default.find({
      user_id,
      topic_id
    }).lean();
    return result;
  }
};

// src/models/lesson.model.ts
var import_mongoose4 = __toESM(require_mongoose2(), 1);
var DOCUMENT_NAME4 = "lesson";
var COLLECTION_NAME4 = "lessons";
var lessonSchema = new import_mongoose4.Schema({
  title: { type: String, required: true },
  description: { type: String, default: "" },
  order: { type: Number, required: true },
  exercises: [{ type: import_mongoose4.Schema.Types.ObjectId, ref: "exercise", default: [] }],
  vocabularies: [{ type: import_mongoose4.Schema.Types.ObjectId, ref: "vocabulary", default: [] }],
  min_score: { type: Number, min: 0, default: 0 },
  progress_id: { type: import_mongoose4.Schema.Types.ObjectId, ref: "progress" },
  status: { type: String, enum: ["publish", "draft"], default: "publish" },
  is_delete: { type: Boolean, default: false }
}, {
  collection: COLLECTION_NAME4,
  timestamps: true
});
var LessonModel = import_mongoose4.model(DOCUMENT_NAME4, lessonSchema);
var lesson_model_default = LessonModel;

// src/models/exercise.model.ts
var import_mongoose5 = __toESM(require_mongoose2(), 1);
var DOCUMENT_NAME5 = "exercise";
var COLLECTION_NAME5 = "exercises";
var exerciseSchema = new import_mongoose5.Schema({
  type: { type: import_mongoose5.Schema.Types.ObjectId, ref: "exercise_type", required: true },
  level: { type: import_mongoose5.Schema.Types.ObjectId, ref: "exercise_level", required: true },
  question: { type: String, required: true },
  options: { type: import_mongoose5.Schema.Types.Mixed },
  multiple_correct: { type: Boolean, default: false },
  correct_answer: { type: import_mongoose5.Schema.Types.Mixed, required: true },
  audio: { type: String },
  explain_answer: { type: String },
  explain_answer_vn: { type: String }
}, {
  collection: COLLECTION_NAME5,
  timestamps: true
});
var ExerciseModel = import_mongoose5.model(DOCUMENT_NAME5, exerciseSchema);
var exercise_model_default = ExerciseModel;

// src/services/exercise.service.ts
var import_mongoose6 = __toESM(require_mongoose2(), 1);
var ExerciseService = {
  createOrUpdate: async ({
    _id,
    type,
    level,
    question,
    options,
    multiple_correct,
    correct_answer,
    audio,
    explain_answer,
    explain_answer_vn
  }) => {
    const isCreate = import_mongoose6.Types.ObjectId.isValid(_id) ? false : true;
    const newId = isCreate ? undefined : _id;
    const exercise = await exercise_model_default.findById(newId);
    if (exercise) {
      return await exercise_model_default.findByIdAndUpdate(newId, { type, level, question, options, multiple_correct, correct_answer, audio, explain_answer, explain_answer_vn }, { new: true });
    } else {
      const newExercise = new exercise_model_default({
        type,
        level,
        question,
        options,
        multiple_correct,
        correct_answer,
        audio,
        explain_answer,
        explain_answer_vn
      });
      return await newExercise.save();
    }
  },
  getById: async (exercise_id) => {
    const exercise = await exercise_model_default.findById(exercise_id).populate("type").populate("level").lean();
    if (!exercise)
      throw new HTTPException(404, { message: "Kh\xF4ng t\xECm th\u1EA5y b\xE0i t\u1EADp" });
    return exercise;
  }
};

// src/models/vocabulary.model.ts
var import_mongoose7 = __toESM(require_mongoose2(), 1);
var DOCUMENT_NAME6 = "vocabulary";
var COLLECTION_NAME6 = "vocabularies";
var vocabularySchema = new import_mongoose7.Schema({
  word: { type: String, required: true, trim: true },
  meaning: { type: String, required: true },
  phonetic: { type: String },
  vietnamese: { type: String },
  type: [{
    type: String,
    enum: ["noun", "verb", "adjective", "adverb", "preposition", "conjunction", "pronoun", "determiner"],
    required: true
  }],
  topic_id: { type: import_mongoose7.Schema.Types.ObjectId, ref: "topic" },
  examples: [{
    sentence: { type: String, required: true },
    translation: { type: String }
  }],
  audio: {
    uk: { type: String },
    us: { type: String }
  },
  is_delete: { type: Boolean, default: false }
}, {
  collection: COLLECTION_NAME6,
  timestamps: true
});
var VocabularyModel = import_mongoose7.model(DOCUMENT_NAME6, vocabularySchema);
var vocabulary_model_default = VocabularyModel;

// src/services/vocabulary.service.ts
var VoCabularyService = {
  createOrUpdate: async (_id, word, meaning, phonetic, type, topic_id, examples, audio, vietnamese) => {
    let updatedVocabulary;
    if (!_id) {
      updatedVocabulary = await vocabulary_model_default.create({
        word,
        meaning,
        type,
        topic_id,
        examples,
        audio,
        phonetic,
        vietnamese
      });
    } else {
      updatedVocabulary = await vocabulary_model_default.findOneAndUpdate({ _id }, { word, meaning, type, topic_id, examples, audio, phonetic, vietnamese }, { upsert: true, new: true });
    }
    return getInfoData({ data: updatedVocabulary, fields: ["_id", "word", "meaning", "type", "phonetic", "topic_id", "examples", "audio", "vietnamese"] });
  },
  getById: async (vocabulary_id) => {
    const vocabulary = await vocabulary_model_default.findById(vocabulary_id).lean();
    if (!vocabulary)
      throw new HTTPException(404, { message: "Kh\xF4ng t\xECm th\u1EA5y t\u1EEB v\u1EF1ng" });
    return getInfoData({ data: vocabulary, fields: ["_id", "word", "meaning", "type", "phonetic", "topic_id", "examples", "audio", "vietnamese"] });
  },
  getAll: async (page = 1, limit = 10, search = "") => {
    const query = { is_delete: false };
    if (search) {
      query.$or = [
        { word: { $regex: search, $options: "i" } },
        { meaning: { $regex: search, $options: "i" } }
      ];
    }
    const vocabularies = await vocabulary_model_default.find(query).skip((page - 1) * limit).limit(limit).lean();
    const totalRecords = await vocabulary_model_default.countDocuments(query);
    const totalPages = Math.ceil(totalRecords / limit);
    return {
      vocabularies: vocabularies.map((vocabulary) => getInfoData({ data: vocabulary, fields: ["_id", "word", "meaning", "type", "phonetic", "topic_id", "examples", "audio", "vietnamese"] })),
      pagination: {
        currentPage: page,
        totalPages,
        totalRecords
      }
    };
  },
  deleteById: async (vocabulary_id) => {
    const vocabulary = await vocabulary_model_default.findById(vocabulary_id);
    if (!vocabulary)
      throw new HTTPException(404, { message: "Kh\xF4ng t\xECm th\u1EA5y t\u1EEB v\u1EF1ng" });
    vocabulary.is_delete = true;
    await vocabulary.save();
    return getInfoData({ data: vocabulary, fields: ["_id", "word", "meaning", "type", "phonetic", "topic_id", "examples", "audio", "vietnamese"] });
  },
  getAllByTopic: async (topic_id, page, limit, search, sort) => {
    const topic = await TopicService.getById(topic_id);
    const query = { topic_id, is_delete: false };
    if (search) {
      query.$or = [
        { word: { $regex: search, $options: "i" } },
        { meaning: { $regex: search, $options: "i" } }
      ];
    }
    let sortOptions = { createdAt: -1 };
    if (sort) {
      sortOptions = sort.split(",").reduce((acc, item) => {
        const [key, value] = item.split(":");
        acc[key] = value === "desc" ? -1 : 1;
        return acc;
      }, {});
    }
    const vocabularies = await vocabulary_model_default.find(query).skip((page - 1) * limit).limit(limit).populate("topic_id").sort(sortOptions).lean();
    const totalRecords = await vocabulary_model_default.countDocuments(query);
    const totalPages = Math.ceil(totalRecords / limit);
    return {
      vocabularies: vocabularies.map((vocabulary) => getInfoData({
        data: vocabulary,
        fields: ["_id", "word", "meaning", "type", "phonetic", "topic_id", "examples", "audio", "vietnamese"]
      })),
      topic: getInfoData({ data: topic, fields: ["_id", "name", "description"] }),
      pagination: {
        currentPage: page,
        totalPages,
        totalRecords
      }
    };
  }
};

// src/services/lesson.service.ts
var import_mongoose9 = __toESM(require_mongoose2(), 1);

// src/models/progress.model.ts
var import_mongoose8 = __toESM(require_mongoose2(), 1);
var DOCUMENT_NAME7 = "progress";
var COLLECTION_NAME7 = "progresses";
var progressSchema = new import_mongoose8.Schema({
  name: { type: String, required: true },
  description: { type: String, default: "" },
  icon: { type: String, default: "" },
  order: { type: Number, required: true },
  topic_id: { type: import_mongoose8.Schema.Types.ObjectId, ref: "topic", required: true },
  is_delete: { type: Boolean, default: false }
}, {
  collection: COLLECTION_NAME7,
  timestamps: true
});
var ProgressModel = import_mongoose8.model(DOCUMENT_NAME7, progressSchema);
var progress_model_default = ProgressModel;

// src/services/progress.service.ts
var ProgressService = {
  createOrUpdate: async (_id, name, description, topic_id, icon, order) => {
    if (!_id) {
      const checkProgress = await progress_model_default.findOne({ is_delete: false, topic_id, name: { $regex: name, $options: "i" } });
      if (checkProgress)
        throw new HTTPException(404, { message: "L\u1ED9 tr\xECnh \u0111\xE3 t\u1ED3n t\u1EA1i" });
    }
    let updatedProgress;
    if (!_id) {
      updatedProgress = await progress_model_default.create({
        name,
        description,
        icon,
        order,
        topic_id
      });
    } else {
      updatedProgress = await progress_model_default.findOneAndUpdate({ _id }, { name, description, icon, order, topic_id }, { upsert: true, new: true });
    }
    return updatedProgress;
  },
  getAllByTopic: async (topic_id) => {
    const progresses = await progress_model_default.find({ topic_id, is_delete: false }).populate("topic_id").sort({ order: 1 }).lean();
    if (!progresses.length)
      return [];
    const progressesWithLessons = await Promise.all(progresses.map(async (progress) => {
      const lessons = await LessonService.getByProgressId(progress._id.toString());
      return {
        _id: progress._id,
        name: progress.name,
        description: progress.description,
        icon: progress.icon,
        order: progress.order,
        topic_id: progress.topic_id,
        lessons
      };
    }));
    return progressesWithLessons;
  },
  getFirstByTopic: async (topic_id) => {
    const progress = await progress_model_default.findOne({
      topic_id,
      is_delete: false
    }).sort({ createdAt: 1 }).lean();
    if (!progress)
      throw new HTTPException(404, { message: "Kh\xF4ng t\xECm th\u1EA5y l\u1ED9 tr\xECnh" });
    return progress;
  },
  getByTopicIdAndOrder: async (topic_id, order) => {
    const progress = await progress_model_default.findOne({ topic_id, order, is_delete: false }).lean();
    if (!progress)
      throw new HTTPException(404, { message: "Kh\xF4ng t\xECm th\u1EA5y l\u1ED9 tr\xECnh" });
    return progress;
  },
  getAll: async (page = 1, limit = 10, search = "") => {
    const query = { is_delete: false };
    if (search) {
      query.$or = [
        { name: { $regex: search, $options: "i" } },
        { description: { $regex: search, $options: "i" } },
        { topic_id: { $in: await topic_model_default.find({ name: { $regex: search, $options: "i" } }).distinct("_id") } }
      ];
    }
    const skip = (page - 1) * limit;
    const progresses = await progress_model_default.find(query).populate({
      path: "topic_id",
      select: "name description"
    }).skip(skip).limit(limit).sort({ createdAt: -1 });
    const totalRecords = await progress_model_default.countDocuments(query);
    const totalPages = Math.ceil(totalRecords / limit);
    return {
      progresses,
      pagination: {
        currentPage: page,
        totalPages,
        totalRecords
      }
    };
  },
  deleteById: async (progress_id) => {
    const progress = await progress_model_default.findOne({ _id: progress_id, is_delete: false });
    if (!progress)
      throw new HTTPException(404, { message: "L\u1ED9 tr\xECnh kh\xF4ng t\u1ED3n t\u1EA1i" });
    progress.is_delete = true;
    return await progress.save();
  },
  getById: async (progress_id) => {
    const progress = await progress_model_default.findOne({ _id: progress_id, is_delete: false });
    if (!progress)
      throw new HTTPException(404, { message: "L\u1ED9 tr\xECnh kh\xF4ng t\u1ED3n t\u1EA1i" });
    return progress;
  },
  getNextByTopic: async (topic_id, progress_id) => {
    const progress = await progress_model_default.findOne({ _id: progress_id, is_delete: false });
    if (!progress)
      throw new HTTPException(404, { message: "L\u1ED9 tr\xECnh kh\xF4ng t\u1ED3n t\u1EA1i" });
    const nextProgress = await progress_model_default.findOne({ topic_id, order: { $gt: progress.order }, is_delete: false }).sort({ order: 1 });
    if (!nextProgress)
      throw new HTTPException(404, { message: "Kh\xF4ng t\xECm th\u1EA5y l\u1ED9 tr\xECnh k\u1EBF ti\u1EBFp" });
    return nextProgress;
  }
};

// src/services/lesson.service.ts
var LessonService = {
  createOrUpdate: async (_id, title, description, order, exercises, vocabularies, progress_id, status) => {
    if (!["publish", "draft"].includes(status)) {
      throw new HTTPException(400, { message: "Tr\u1EA1ng th\xE1i kh\xF4ng h\u1EE3p l\u1EC7" });
    }
    const processExercises = async () => {
      return Promise.all(exercises.map(async (exercise) => {
        const newExercise = await ExerciseService.createOrUpdate(exercise);
        if (!newExercise)
          throw new HTTPException(400, { message: "Kh\xF4ng th\u1EC3 t\u1EA1o ho\u1EB7c c\u1EADp nh\u1EADt b\xE0i t\u1EADp" });
        return newExercise._id;
      }));
    };
    const [newExercises] = await Promise.all([processExercises()]);
    const updateData = { title, description, order, exercises: newExercises, vocabularies, progress_id, status };
    const lesson = await lesson_model_default.findByIdAndUpdate(_id || new import_mongoose9.Types.ObjectId, updateData, { new: true, upsert: true });
    return lesson;
  },
  getById: async (lesson_id) => {
    const lesson = await lesson_model_default.findById(lesson_id).lean();
    if (!lesson)
      throw new HTTPException(404, { message: "Kh\xF4ng t\xECm th\u1EA5y b\xE0i h\u1ECDc" });
    return lesson;
  },
  getDetail: async (lesson_id) => {
    const lesson = await lesson_model_default.findById(lesson_id).lean();
    if (!lesson)
      throw new HTTPException(404, { message: "Kh\xF4ng t\xECm th\u1EA5y b\xE0i h\u1ECDc" });
    const exercisesPromise = await Promise.all(lesson.exercises.map(async (exercise_id) => {
      const exercise = await ExerciseService.getById(exercise_id);
      return getInfoData({
        data: exercise,
        fields: [
          "_id",
          "type",
          "level",
          "question",
          "options",
          "multiple_correct",
          "correct_answer",
          "audio",
          "explain_answer",
          "explain_answer_vn"
        ]
      });
    }));
    const vocabulariesPromise = await Promise.all(lesson.vocabularies.map(async (vocabulary_id) => {
      const vocabulary = await VoCabularyService.getById(vocabulary_id);
      return vocabulary;
    }));
    const progress = await ProgressService.getById(lesson.progress_id);
    const topic = await TopicService.getById(progress.topic_id);
    return {
      ...getInfoData({ data: lesson, fields: ["_id", "title", "description", "order", "progress_id", "exercises", "vocabularies", "status"] }),
      exercises: exercisesPromise,
      progress,
      vocabularies: vocabulariesPromise,
      topic
    };
  },
  getFirstByProgress: async (progress_id) => {
    const lesson = await lesson_model_default.findOne({ progress_id, is_delete: false }).sort({ createdAt: 1 }).lean();
    return lesson;
  },
  getByProgressId: async (progress_id) => {
    const lessons = await lesson_model_default.find({ progress_id, is_delete: false }).sort({ createdAt: 1 }).lean();
    return lessons;
  },
  getAll: async (page = 1, limit = 10, search = "") => {
    const query = { is_delete: false };
    if (search) {
      query.$or = [
        { title: { $regex: search, $options: "i" } },
        { description: { $regex: search, $options: "i" } }
      ];
    }
    const skip = (page - 1) * limit;
    const lessons = await lesson_model_default.find(query).skip(skip).limit(limit).sort({ createdAt: -1 });
    const totalRecords = await lesson_model_default.countDocuments(query);
    const totalPages = Math.ceil(totalRecords / limit);
    return {
      lessons,
      pagination: {
        currentPage: page,
        totalPages,
        totalRecords
      }
    };
  },
  deleteLesson: async (lesson_id) => {
    const lesson = await lesson_model_default.findByIdAndUpdate(lesson_id, { is_delete: true }, { new: true });
    if (!lesson)
      throw new HTTPException(404, { message: "Kh\xF4ng t\xECm th\u1EA5y b\xE0i h\u1ECDc" });
    return lesson;
  }
};

// src/services/user.service.ts
var import_lodash2 = __toESM(require_lodash(), 1);

// src/models/user_topic.model.ts
var import_mongoose10 = __toESM(require_mongoose2(), 1);
var DOCUMENT_NAME8 = "user_topic";
var COLLECTION_NAME8 = "user_topics";
var userTopicSchema = new import_mongoose10.Schema({
  user_id: { type: import_mongoose10.Schema.Types.ObjectId, ref: "user" },
  topic_id: { type: import_mongoose10.Schema.Types.ObjectId, ref: "topic" }
}, {
  collection: COLLECTION_NAME8,
  timestamps: true
});
var UserTopicModel = import_mongoose10.model(DOCUMENT_NAME8, userTopicSchema);
var user_topic_model_default = UserTopicModel;

// src/services/user_topic.service.ts
var UserTopicService = {
  processDB: async ({
    user_id,
    topic_id,
    _id
  }) => {
    let updatedUserTopic = null;
    if (!_id) {
      updatedUserTopic = await user_topic_model_default.create({
        user_id,
        topic_id
      });
    } else {
      updatedUserTopic = await user_topic_model_default.findOneAndUpdate({ _id }, { user_id, topic_id }, { upsert: true, new: true });
    }
    return updatedUserTopic;
  },
  getByUser: async (user_id) => {
    const result = await user_topic_model_default.find({ user_id }).lean();
    return result;
  }
};

// node_modules/bcryptjs/index.js
import nodeCrypto from "crypto";
function randomBytes(len) {
  try {
    return crypto.getRandomValues(new Uint8Array(len));
  } catch {
  }
  try {
    return nodeCrypto.randomBytes(len);
  } catch {
  }
  if (!randomFallback) {
    throw Error("Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative");
  }
  return randomFallback(len);
}
function setRandomFallback(random) {
  randomFallback = random;
}
function genSaltSync(rounds, seed_length) {
  rounds = rounds || GENSALT_DEFAULT_LOG2_ROUNDS;
  if (typeof rounds !== "number")
    throw Error("Illegal arguments: " + typeof rounds + ", " + typeof seed_length);
  if (rounds < 4)
    rounds = 4;
  else if (rounds > 31)
    rounds = 31;
  var salt = [];
  salt.push("$2b$");
  if (rounds < 10)
    salt.push("0");
  salt.push(rounds.toString());
  salt.push("$");
  salt.push(base64_encode(randomBytes(BCRYPT_SALT_LEN), BCRYPT_SALT_LEN));
  return salt.join("");
}
function genSalt(rounds, seed_length, callback) {
  if (typeof seed_length === "function")
    callback = seed_length, seed_length = undefined;
  if (typeof rounds === "function")
    callback = rounds, rounds = undefined;
  if (typeof rounds === "undefined")
    rounds = GENSALT_DEFAULT_LOG2_ROUNDS;
  else if (typeof rounds !== "number")
    throw Error("illegal arguments: " + typeof rounds);
  function _async(callback2) {
    nextTick(function() {
      try {
        callback2(null, genSaltSync(rounds));
      } catch (err) {
        callback2(err);
      }
    });
  }
  if (callback) {
    if (typeof callback !== "function")
      throw Error("Illegal callback: " + typeof callback);
    _async(callback);
  } else
    return new Promise(function(resolve, reject) {
      _async(function(err, res) {
        if (err) {
          reject(err);
          return;
        }
        resolve(res);
      });
    });
}
function hashSync(password, salt) {
  if (typeof salt === "undefined")
    salt = GENSALT_DEFAULT_LOG2_ROUNDS;
  if (typeof salt === "number")
    salt = genSaltSync(salt);
  if (typeof password !== "string" || typeof salt !== "string")
    throw Error("Illegal arguments: " + typeof password + ", " + typeof salt);
  return _hash(password, salt);
}
function hash(password, salt, callback, progressCallback) {
  function _async(callback2) {
    if (typeof password === "string" && typeof salt === "number")
      genSalt(salt, function(err, salt2) {
        _hash(password, salt2, callback2, progressCallback);
      });
    else if (typeof password === "string" && typeof salt === "string")
      _hash(password, salt, callback2, progressCallback);
    else
      nextTick(callback2.bind(this, Error("Illegal arguments: " + typeof password + ", " + typeof salt)));
  }
  if (callback) {
    if (typeof callback !== "function")
      throw Error("Illegal callback: " + typeof callback);
    _async(callback);
  } else
    return new Promise(function(resolve, reject) {
      _async(function(err, res) {
        if (err) {
          reject(err);
          return;
        }
        resolve(res);
      });
    });
}
function safeStringCompare(known, unknown) {
  var diff = known.length ^ unknown.length;
  for (var i = 0;i < known.length; ++i) {
    diff |= known.charCodeAt(i) ^ unknown.charCodeAt(i);
  }
  return diff === 0;
}
function compareSync(password, hash2) {
  if (typeof password !== "string" || typeof hash2 !== "string")
    throw Error("Illegal arguments: " + typeof password + ", " + typeof hash2);
  if (hash2.length !== 60)
    return false;
  return safeStringCompare(hashSync(password, hash2.substring(0, hash2.length - 31)), hash2);
}
function compare(password, hashValue, callback, progressCallback) {
  function _async(callback2) {
    if (typeof password !== "string" || typeof hashValue !== "string") {
      nextTick(callback2.bind(this, Error("Illegal arguments: " + typeof password + ", " + typeof hashValue)));
      return;
    }
    if (hashValue.length !== 60) {
      nextTick(callback2.bind(this, null, false));
      return;
    }
    hash(password, hashValue.substring(0, 29), function(err, comp) {
      if (err)
        callback2(err);
      else
        callback2(null, safeStringCompare(comp, hashValue));
    }, progressCallback);
  }
  if (callback) {
    if (typeof callback !== "function")
      throw Error("Illegal callback: " + typeof callback);
    _async(callback);
  } else
    return new Promise(function(resolve, reject) {
      _async(function(err, res) {
        if (err) {
          reject(err);
          return;
        }
        resolve(res);
      });
    });
}
function getRounds(hash2) {
  if (typeof hash2 !== "string")
    throw Error("Illegal arguments: " + typeof hash2);
  return parseInt(hash2.split("$")[2], 10);
}
function getSalt(hash2) {
  if (typeof hash2 !== "string")
    throw Error("Illegal arguments: " + typeof hash2);
  if (hash2.length !== 60)
    throw Error("Illegal hash length: " + hash2.length + " != 60");
  return hash2.substring(0, 29);
}
function truncates(password) {
  if (typeof password !== "string")
    throw Error("Illegal arguments: " + typeof password);
  return utf8Length(password) > 72;
}
function utf8Length(string) {
  var len = 0, c = 0;
  for (var i = 0;i < string.length; ++i) {
    c = string.charCodeAt(i);
    if (c < 128)
      len += 1;
    else if (c < 2048)
      len += 2;
    else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
      ++i;
      len += 4;
    } else
      len += 3;
  }
  return len;
}
function utf8Array(string) {
  var offset = 0, c1, c2;
  var buffer = new Array(utf8Length(string));
  for (var i = 0, k = string.length;i < k; ++i) {
    c1 = string.charCodeAt(i);
    if (c1 < 128) {
      buffer[offset++] = c1;
    } else if (c1 < 2048) {
      buffer[offset++] = c1 >> 6 | 192;
      buffer[offset++] = c1 & 63 | 128;
    } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
      c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
      ++i;
      buffer[offset++] = c1 >> 18 | 240;
      buffer[offset++] = c1 >> 12 & 63 | 128;
      buffer[offset++] = c1 >> 6 & 63 | 128;
      buffer[offset++] = c1 & 63 | 128;
    } else {
      buffer[offset++] = c1 >> 12 | 224;
      buffer[offset++] = c1 >> 6 & 63 | 128;
      buffer[offset++] = c1 & 63 | 128;
    }
  }
  return buffer;
}
function base64_encode(b, len) {
  var off = 0, rs2 = [], c1, c2;
  if (len <= 0 || len > b.length)
    throw Error("Illegal len: " + len);
  while (off < len) {
    c1 = b[off++] & 255;
    rs2.push(BASE64_CODE[c1 >> 2 & 63]);
    c1 = (c1 & 3) << 4;
    if (off >= len) {
      rs2.push(BASE64_CODE[c1 & 63]);
      break;
    }
    c2 = b[off++] & 255;
    c1 |= c2 >> 4 & 15;
    rs2.push(BASE64_CODE[c1 & 63]);
    c1 = (c2 & 15) << 2;
    if (off >= len) {
      rs2.push(BASE64_CODE[c1 & 63]);
      break;
    }
    c2 = b[off++] & 255;
    c1 |= c2 >> 6 & 3;
    rs2.push(BASE64_CODE[c1 & 63]);
    rs2.push(BASE64_CODE[c2 & 63]);
  }
  return rs2.join("");
}
function base64_decode(s, len) {
  var off = 0, slen = s.length, olen = 0, rs2 = [], c1, c2, c3, c4, o, code;
  if (len <= 0)
    throw Error("Illegal len: " + len);
  while (off < slen - 1 && olen < len) {
    code = s.charCodeAt(off++);
    c1 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    code = s.charCodeAt(off++);
    c2 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    if (c1 == -1 || c2 == -1)
      break;
    o = c1 << 2 >>> 0;
    o |= (c2 & 48) >> 4;
    rs2.push(String.fromCharCode(o));
    if (++olen >= len || off >= slen)
      break;
    code = s.charCodeAt(off++);
    c3 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    if (c3 == -1)
      break;
    o = (c2 & 15) << 4 >>> 0;
    o |= (c3 & 60) >> 2;
    rs2.push(String.fromCharCode(o));
    if (++olen >= len || off >= slen)
      break;
    code = s.charCodeAt(off++);
    c4 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    o = (c3 & 3) << 6 >>> 0;
    o |= c4;
    rs2.push(String.fromCharCode(o));
    ++olen;
  }
  var res = [];
  for (off = 0;off < olen; off++)
    res.push(rs2[off].charCodeAt(0));
  return res;
}
function _encipher(lr, off, P, S) {
  var n, l = lr[off], r = lr[off + 1];
  l ^= P[0];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[1];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[2];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[3];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[4];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[5];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[6];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[7];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[8];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[9];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[10];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[11];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[12];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[13];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[14];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[15];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[16];
  lr[off] = r ^ P[BLOWFISH_NUM_ROUNDS + 1];
  lr[off + 1] = l;
  return lr;
}
function _streamtoword(data, offp) {
  for (var i = 0, word = 0;i < 4; ++i)
    word = word << 8 | data[offp] & 255, offp = (offp + 1) % data.length;
  return { key: word, offp };
}
function _key(key, P, S) {
  var offset = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
  for (var i = 0;i < plen; i++)
    sw = _streamtoword(key, offset), offset = sw.offp, P[i] = P[i] ^ sw.key;
  for (i = 0;i < plen; i += 2)
    lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
  for (i = 0;i < slen; i += 2)
    lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
}
function _ekskey(data, key, P, S) {
  var offp = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
  for (var i = 0;i < plen; i++)
    sw = _streamtoword(key, offp), offp = sw.offp, P[i] = P[i] ^ sw.key;
  offp = 0;
  for (i = 0;i < plen; i += 2)
    sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
  for (i = 0;i < slen; i += 2)
    sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
}
function _crypt(b, salt, rounds, callback, progressCallback) {
  var cdata = C_ORIG.slice(), clen = cdata.length, err;
  if (rounds < 4 || rounds > 31) {
    err = Error("Illegal number of rounds (4-31): " + rounds);
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else
      throw err;
  }
  if (salt.length !== BCRYPT_SALT_LEN) {
    err = Error("Illegal salt length: " + salt.length + " != " + BCRYPT_SALT_LEN);
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else
      throw err;
  }
  rounds = 1 << rounds >>> 0;
  var P, S, i = 0, j;
  if (typeof Int32Array === "function") {
    P = new Int32Array(P_ORIG);
    S = new Int32Array(S_ORIG);
  } else {
    P = P_ORIG.slice();
    S = S_ORIG.slice();
  }
  _ekskey(salt, b, P, S);
  function next() {
    if (progressCallback)
      progressCallback(i / rounds);
    if (i < rounds) {
      var start = Date.now();
      for (;i < rounds; ) {
        i = i + 1;
        _key(b, P, S);
        _key(salt, P, S);
        if (Date.now() - start > MAX_EXECUTION_TIME)
          break;
      }
    } else {
      for (i = 0;i < 64; i++)
        for (j = 0;j < clen >> 1; j++)
          _encipher(cdata, j << 1, P, S);
      var ret = [];
      for (i = 0;i < clen; i++)
        ret.push((cdata[i] >> 24 & 255) >>> 0), ret.push((cdata[i] >> 16 & 255) >>> 0), ret.push((cdata[i] >> 8 & 255) >>> 0), ret.push((cdata[i] & 255) >>> 0);
      if (callback) {
        callback(null, ret);
        return;
      } else
        return ret;
    }
    if (callback)
      nextTick(next);
  }
  if (typeof callback !== "undefined") {
    next();
  } else {
    var res;
    while (true)
      if (typeof (res = next()) !== "undefined")
        return res || [];
  }
}
function _hash(password, salt, callback, progressCallback) {
  var err;
  if (typeof password !== "string" || typeof salt !== "string") {
    err = Error("Invalid string / salt: Not a string");
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else
      throw err;
  }
  var minor, offset;
  if (salt.charAt(0) !== "$" || salt.charAt(1) !== "2") {
    err = Error("Invalid salt version: " + salt.substring(0, 2));
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else
      throw err;
  }
  if (salt.charAt(2) === "$")
    minor = String.fromCharCode(0), offset = 3;
  else {
    minor = salt.charAt(2);
    if (minor !== "a" && minor !== "b" && minor !== "y" || salt.charAt(3) !== "$") {
      err = Error("Invalid salt revision: " + salt.substring(2, 4));
      if (callback) {
        nextTick(callback.bind(this, err));
        return;
      } else
        throw err;
    }
    offset = 4;
  }
  if (salt.charAt(offset + 2) > "$") {
    err = Error("Missing salt rounds");
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else
      throw err;
  }
  var r1 = parseInt(salt.substring(offset, offset + 1), 10) * 10, r2 = parseInt(salt.substring(offset + 1, offset + 2), 10), rounds = r1 + r2, real_salt = salt.substring(offset + 3, offset + 25);
  password += minor >= "a" ? "\0" : "";
  var passwordb = utf8Array(password), saltb = base64_decode(real_salt, BCRYPT_SALT_LEN);
  function finish(bytes) {
    var res = [];
    res.push("$2");
    if (minor >= "a")
      res.push(minor);
    res.push("$");
    if (rounds < 10)
      res.push("0");
    res.push(rounds.toString());
    res.push("$");
    res.push(base64_encode(saltb, saltb.length));
    res.push(base64_encode(bytes, C_ORIG.length * 4 - 1));
    return res.join("");
  }
  if (typeof callback == "undefined")
    return finish(_crypt(passwordb, saltb, rounds));
  else {
    _crypt(passwordb, saltb, rounds, function(err2, bytes) {
      if (err2)
        callback(err2, null);
      else
        callback(null, finish(bytes));
    }, progressCallback);
  }
}
function encodeBase642(bytes, length) {
  return base64_encode(bytes, length);
}
function decodeBase642(string, length) {
  return base64_decode(string, length);
}
var randomFallback = null;
randomFallback = null;
var nextTick = typeof process !== "undefined" && process && typeof process.nextTick === "function" ? typeof setImmediate === "function" ? setImmediate : process.nextTick : setTimeout;
var BASE64_CODE = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split("");
var BASE64_INDEX = [
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  62,
  63,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  -1,
  -1,
  -1,
  -1,
  -1
];
var BCRYPT_SALT_LEN = 16;
var GENSALT_DEFAULT_LOG2_ROUNDS = 10;
var BLOWFISH_NUM_ROUNDS = 16;
var MAX_EXECUTION_TIME = 100;
var P_ORIG = [
  608135816,
  2242054355,
  320440878,
  57701188,
  2752067618,
  698298832,
  137296536,
  3964562569,
  1160258022,
  953160567,
  3193202383,
  887688300,
  3232508343,
  3380367581,
  1065670069,
  3041331479,
  2450970073,
  2306472731
];
var S_ORIG = [
  3509652390,
  2564797868,
  805139163,
  3491422135,
  3101798381,
  1780907670,
  3128725573,
  4046225305,
  614570311,
  3012652279,
  134345442,
  2240740374,
  1667834072,
  1901547113,
  2757295779,
  4103290238,
  227898511,
  1921955416,
  1904987480,
  2182433518,
  2069144605,
  3260701109,
  2620446009,
  720527379,
  3318853667,
  677414384,
  3393288472,
  3101374703,
  2390351024,
  1614419982,
  1822297739,
  2954791486,
  3608508353,
  3174124327,
  2024746970,
  1432378464,
  3864339955,
  2857741204,
  1464375394,
  1676153920,
  1439316330,
  715854006,
  3033291828,
  289532110,
  2706671279,
  2087905683,
  3018724369,
  1668267050,
  732546397,
  1947742710,
  3462151702,
  2609353502,
  2950085171,
  1814351708,
  2050118529,
  680887927,
  999245976,
  1800124847,
  3300911131,
  1713906067,
  1641548236,
  4213287313,
  1216130144,
  1575780402,
  4018429277,
  3917837745,
  3693486850,
  3949271944,
  596196993,
  3549867205,
  258830323,
  2213823033,
  772490370,
  2760122372,
  1774776394,
  2652871518,
  566650946,
  4142492826,
  1728879713,
  2882767088,
  1783734482,
  3629395816,
  2517608232,
  2874225571,
  1861159788,
  326777828,
  3124490320,
  2130389656,
  2716951837,
  967770486,
  1724537150,
  2185432712,
  2364442137,
  1164943284,
  2105845187,
  998989502,
  3765401048,
  2244026483,
  1075463327,
  1455516326,
  1322494562,
  910128902,
  469688178,
  1117454909,
  936433444,
  3490320968,
  3675253459,
  1240580251,
  122909385,
  2157517691,
  634681816,
  4142456567,
  3825094682,
  3061402683,
  2540495037,
  79693498,
  3249098678,
  1084186820,
  1583128258,
  426386531,
  1761308591,
  1047286709,
  322548459,
  995290223,
  1845252383,
  2603652396,
  3431023940,
  2942221577,
  3202600964,
  3727903485,
  1712269319,
  422464435,
  3234572375,
  1170764815,
  3523960633,
  3117677531,
  1434042557,
  442511882,
  3600875718,
  1076654713,
  1738483198,
  4213154764,
  2393238008,
  3677496056,
  1014306527,
  4251020053,
  793779912,
  2902807211,
  842905082,
  4246964064,
  1395751752,
  1040244610,
  2656851899,
  3396308128,
  445077038,
  3742853595,
  3577915638,
  679411651,
  2892444358,
  2354009459,
  1767581616,
  3150600392,
  3791627101,
  3102740896,
  284835224,
  4246832056,
  1258075500,
  768725851,
  2589189241,
  3069724005,
  3532540348,
  1274779536,
  3789419226,
  2764799539,
  1660621633,
  3471099624,
  4011903706,
  913787905,
  3497959166,
  737222580,
  2514213453,
  2928710040,
  3937242737,
  1804850592,
  3499020752,
  2949064160,
  2386320175,
  2390070455,
  2415321851,
  4061277028,
  2290661394,
  2416832540,
  1336762016,
  1754252060,
  3520065937,
  3014181293,
  791618072,
  3188594551,
  3933548030,
  2332172193,
  3852520463,
  3043980520,
  413987798,
  3465142937,
  3030929376,
  4245938359,
  2093235073,
  3534596313,
  375366246,
  2157278981,
  2479649556,
  555357303,
  3870105701,
  2008414854,
  3344188149,
  4221384143,
  3956125452,
  2067696032,
  3594591187,
  2921233993,
  2428461,
  544322398,
  577241275,
  1471733935,
  610547355,
  4027169054,
  1432588573,
  1507829418,
  2025931657,
  3646575487,
  545086370,
  48609733,
  2200306550,
  1653985193,
  298326376,
  1316178497,
  3007786442,
  2064951626,
  458293330,
  2589141269,
  3591329599,
  3164325604,
  727753846,
  2179363840,
  146436021,
  1461446943,
  4069977195,
  705550613,
  3059967265,
  3887724982,
  4281599278,
  3313849956,
  1404054877,
  2845806497,
  146425753,
  1854211946,
  1266315497,
  3048417604,
  3681880366,
  3289982499,
  2909710000,
  1235738493,
  2632868024,
  2414719590,
  3970600049,
  1771706367,
  1449415276,
  3266420449,
  422970021,
  1963543593,
  2690192192,
  3826793022,
  1062508698,
  1531092325,
  1804592342,
  2583117782,
  2714934279,
  4024971509,
  1294809318,
  4028980673,
  1289560198,
  2221992742,
  1669523910,
  35572830,
  157838143,
  1052438473,
  1016535060,
  1802137761,
  1753167236,
  1386275462,
  3080475397,
  2857371447,
  1040679964,
  2145300060,
  2390574316,
  1461121720,
  2956646967,
  4031777805,
  4028374788,
  33600511,
  2920084762,
  1018524850,
  629373528,
  3691585981,
  3515945977,
  2091462646,
  2486323059,
  586499841,
  988145025,
  935516892,
  3367335476,
  2599673255,
  2839830854,
  265290510,
  3972581182,
  2759138881,
  3795373465,
  1005194799,
  847297441,
  406762289,
  1314163512,
  1332590856,
  1866599683,
  4127851711,
  750260880,
  613907577,
  1450815602,
  3165620655,
  3734664991,
  3650291728,
  3012275730,
  3704569646,
  1427272223,
  778793252,
  1343938022,
  2676280711,
  2052605720,
  1946737175,
  3164576444,
  3914038668,
  3967478842,
  3682934266,
  1661551462,
  3294938066,
  4011595847,
  840292616,
  3712170807,
  616741398,
  312560963,
  711312465,
  1351876610,
  322626781,
  1910503582,
  271666773,
  2175563734,
  1594956187,
  70604529,
  3617834859,
  1007753275,
  1495573769,
  4069517037,
  2549218298,
  2663038764,
  504708206,
  2263041392,
  3941167025,
  2249088522,
  1514023603,
  1998579484,
  1312622330,
  694541497,
  2582060303,
  2151582166,
  1382467621,
  776784248,
  2618340202,
  3323268794,
  2497899128,
  2784771155,
  503983604,
  4076293799,
  907881277,
  423175695,
  432175456,
  1378068232,
  4145222326,
  3954048622,
  3938656102,
  3820766613,
  2793130115,
  2977904593,
  26017576,
  3274890735,
  3194772133,
  1700274565,
  1756076034,
  4006520079,
  3677328699,
  720338349,
  1533947780,
  354530856,
  688349552,
  3973924725,
  1637815568,
  332179504,
  3949051286,
  53804574,
  2852348879,
  3044236432,
  1282449977,
  3583942155,
  3416972820,
  4006381244,
  1617046695,
  2628476075,
  3002303598,
  1686838959,
  431878346,
  2686675385,
  1700445008,
  1080580658,
  1009431731,
  832498133,
  3223435511,
  2605976345,
  2271191193,
  2516031870,
  1648197032,
  4164389018,
  2548247927,
  300782431,
  375919233,
  238389289,
  3353747414,
  2531188641,
  2019080857,
  1475708069,
  455242339,
  2609103871,
  448939670,
  3451063019,
  1395535956,
  2413381860,
  1841049896,
  1491858159,
  885456874,
  4264095073,
  4001119347,
  1565136089,
  3898914787,
  1108368660,
  540939232,
  1173283510,
  2745871338,
  3681308437,
  4207628240,
  3343053890,
  4016749493,
  1699691293,
  1103962373,
  3625875870,
  2256883143,
  3830138730,
  1031889488,
  3479347698,
  1535977030,
  4236805024,
  3251091107,
  2132092099,
  1774941330,
  1199868427,
  1452454533,
  157007616,
  2904115357,
  342012276,
  595725824,
  1480756522,
  206960106,
  497939518,
  591360097,
  863170706,
  2375253569,
  3596610801,
  1814182875,
  2094937945,
  3421402208,
  1082520231,
  3463918190,
  2785509508,
  435703966,
  3908032597,
  1641649973,
  2842273706,
  3305899714,
  1510255612,
  2148256476,
  2655287854,
  3276092548,
  4258621189,
  236887753,
  3681803219,
  274041037,
  1734335097,
  3815195456,
  3317970021,
  1899903192,
  1026095262,
  4050517792,
  356393447,
  2410691914,
  3873677099,
  3682840055,
  3913112168,
  2491498743,
  4132185628,
  2489919796,
  1091903735,
  1979897079,
  3170134830,
  3567386728,
  3557303409,
  857797738,
  1136121015,
  1342202287,
  507115054,
  2535736646,
  337727348,
  3213592640,
  1301675037,
  2528481711,
  1895095763,
  1721773893,
  3216771564,
  62756741,
  2142006736,
  835421444,
  2531993523,
  1442658625,
  3659876326,
  2882144922,
  676362277,
  1392781812,
  170690266,
  3921047035,
  1759253602,
  3611846912,
  1745797284,
  664899054,
  1329594018,
  3901205900,
  3045908486,
  2062866102,
  2865634940,
  3543621612,
  3464012697,
  1080764994,
  553557557,
  3656615353,
  3996768171,
  991055499,
  499776247,
  1265440854,
  648242737,
  3940784050,
  980351604,
  3713745714,
  1749149687,
  3396870395,
  4211799374,
  3640570775,
  1161844396,
  3125318951,
  1431517754,
  545492359,
  4268468663,
  3499529547,
  1437099964,
  2702547544,
  3433638243,
  2581715763,
  2787789398,
  1060185593,
  1593081372,
  2418618748,
  4260947970,
  69676912,
  2159744348,
  86519011,
  2512459080,
  3838209314,
  1220612927,
  3339683548,
  133810670,
  1090789135,
  1078426020,
  1569222167,
  845107691,
  3583754449,
  4072456591,
  1091646820,
  628848692,
  1613405280,
  3757631651,
  526609435,
  236106946,
  48312990,
  2942717905,
  3402727701,
  1797494240,
  859738849,
  992217954,
  4005476642,
  2243076622,
  3870952857,
  3732016268,
  765654824,
  3490871365,
  2511836413,
  1685915746,
  3888969200,
  1414112111,
  2273134842,
  3281911079,
  4080962846,
  172450625,
  2569994100,
  980381355,
  4109958455,
  2819808352,
  2716589560,
  2568741196,
  3681446669,
  3329971472,
  1835478071,
  660984891,
  3704678404,
  4045999559,
  3422617507,
  3040415634,
  1762651403,
  1719377915,
  3470491036,
  2693910283,
  3642056355,
  3138596744,
  1364962596,
  2073328063,
  1983633131,
  926494387,
  3423689081,
  2150032023,
  4096667949,
  1749200295,
  3328846651,
  309677260,
  2016342300,
  1779581495,
  3079819751,
  111262694,
  1274766160,
  443224088,
  298511866,
  1025883608,
  3806446537,
  1145181785,
  168956806,
  3641502830,
  3584813610,
  1689216846,
  3666258015,
  3200248200,
  1692713982,
  2646376535,
  4042768518,
  1618508792,
  1610833997,
  3523052358,
  4130873264,
  2001055236,
  3610705100,
  2202168115,
  4028541809,
  2961195399,
  1006657119,
  2006996926,
  3186142756,
  1430667929,
  3210227297,
  1314452623,
  4074634658,
  4101304120,
  2273951170,
  1399257539,
  3367210612,
  3027628629,
  1190975929,
  2062231137,
  2333990788,
  2221543033,
  2438960610,
  1181637006,
  548689776,
  2362791313,
  3372408396,
  3104550113,
  3145860560,
  296247880,
  1970579870,
  3078560182,
  3769228297,
  1714227617,
  3291629107,
  3898220290,
  166772364,
  1251581989,
  493813264,
  448347421,
  195405023,
  2709975567,
  677966185,
  3703036547,
  1463355134,
  2715995803,
  1338867538,
  1343315457,
  2802222074,
  2684532164,
  233230375,
  2599980071,
  2000651841,
  3277868038,
  1638401717,
  4028070440,
  3237316320,
  6314154,
  819756386,
  300326615,
  590932579,
  1405279636,
  3267499572,
  3150704214,
  2428286686,
  3959192993,
  3461946742,
  1862657033,
  1266418056,
  963775037,
  2089974820,
  2263052895,
  1917689273,
  448879540,
  3550394620,
  3981727096,
  150775221,
  3627908307,
  1303187396,
  508620638,
  2975983352,
  2726630617,
  1817252668,
  1876281319,
  1457606340,
  908771278,
  3720792119,
  3617206836,
  2455994898,
  1729034894,
  1080033504,
  976866871,
  3556439503,
  2881648439,
  1522871579,
  1555064734,
  1336096578,
  3548522304,
  2579274686,
  3574697629,
  3205460757,
  3593280638,
  3338716283,
  3079412587,
  564236357,
  2993598910,
  1781952180,
  1464380207,
  3163844217,
  3332601554,
  1699332808,
  1393555694,
  1183702653,
  3581086237,
  1288719814,
  691649499,
  2847557200,
  2895455976,
  3193889540,
  2717570544,
  1781354906,
  1676643554,
  2592534050,
  3230253752,
  1126444790,
  2770207658,
  2633158820,
  2210423226,
  2615765581,
  2414155088,
  3127139286,
  673620729,
  2805611233,
  1269405062,
  4015350505,
  3341807571,
  4149409754,
  1057255273,
  2012875353,
  2162469141,
  2276492801,
  2601117357,
  993977747,
  3918593370,
  2654263191,
  753973209,
  36408145,
  2530585658,
  25011837,
  3520020182,
  2088578344,
  530523599,
  2918365339,
  1524020338,
  1518925132,
  3760827505,
  3759777254,
  1202760957,
  3985898139,
  3906192525,
  674977740,
  4174734889,
  2031300136,
  2019492241,
  3983892565,
  4153806404,
  3822280332,
  352677332,
  2297720250,
  60907813,
  90501309,
  3286998549,
  1016092578,
  2535922412,
  2839152426,
  457141659,
  509813237,
  4120667899,
  652014361,
  1966332200,
  2975202805,
  55981186,
  2327461051,
  676427537,
  3255491064,
  2882294119,
  3433927263,
  1307055953,
  942726286,
  933058658,
  2468411793,
  3933900994,
  4215176142,
  1361170020,
  2001714738,
  2830558078,
  3274259782,
  1222529897,
  1679025792,
  2729314320,
  3714953764,
  1770335741,
  151462246,
  3013232138,
  1682292957,
  1483529935,
  471910574,
  1539241949,
  458788160,
  3436315007,
  1807016891,
  3718408830,
  978976581,
  1043663428,
  3165965781,
  1927990952,
  4200891579,
  2372276910,
  3208408903,
  3533431907,
  1412390302,
  2931980059,
  4132332400,
  1947078029,
  3881505623,
  4168226417,
  2941484381,
  1077988104,
  1320477388,
  886195818,
  18198404,
  3786409000,
  2509781533,
  112762804,
  3463356488,
  1866414978,
  891333506,
  18488651,
  661792760,
  1628790961,
  3885187036,
  3141171499,
  876946877,
  2693282273,
  1372485963,
  791857591,
  2686433993,
  3759982718,
  3167212022,
  3472953795,
  2716379847,
  445679433,
  3561995674,
  3504004811,
  3574258232,
  54117162,
  3331405415,
  2381918588,
  3769707343,
  4154350007,
  1140177722,
  4074052095,
  668550556,
  3214352940,
  367459370,
  261225585,
  2610173221,
  4209349473,
  3468074219,
  3265815641,
  314222801,
  3066103646,
  3808782860,
  282218597,
  3406013506,
  3773591054,
  379116347,
  1285071038,
  846784868,
  2669647154,
  3771962079,
  3550491691,
  2305946142,
  453669953,
  1268987020,
  3317592352,
  3279303384,
  3744833421,
  2610507566,
  3859509063,
  266596637,
  3847019092,
  517658769,
  3462560207,
  3443424879,
  370717030,
  4247526661,
  2224018117,
  4143653529,
  4112773975,
  2788324899,
  2477274417,
  1456262402,
  2901442914,
  1517677493,
  1846949527,
  2295493580,
  3734397586,
  2176403920,
  1280348187,
  1908823572,
  3871786941,
  846861322,
  1172426758,
  3287448474,
  3383383037,
  1655181056,
  3139813346,
  901632758,
  1897031941,
  2986607138,
  3066810236,
  3447102507,
  1393639104,
  373351379,
  950779232,
  625454576,
  3124240540,
  4148612726,
  2007998917,
  544563296,
  2244738638,
  2330496472,
  2058025392,
  1291430526,
  424198748,
  50039436,
  29584100,
  3605783033,
  2429876329,
  2791104160,
  1057563949,
  3255363231,
  3075367218,
  3463963227,
  1469046755,
  985887462
];
var C_ORIG = [
  1332899944,
  1700884034,
  1701343084,
  1684370003,
  1668446532,
  1869963892
];
var bcryptjs_default = {
  setRandomFallback,
  genSaltSync,
  genSalt,
  hashSync,
  hash,
  compareSync,
  compare,
  getRounds,
  getSalt,
  truncates,
  encodeBase64: encodeBase642,
  decodeBase64: decodeBase642
};

// src/services/auth.service.ts
var import_nodemailer = __toESM(require_nodemailer(), 1);

// node_modules/hono/dist/utils/jwt/jwa.js
var AlgorithmTypes = /* @__PURE__ */ ((AlgorithmTypes2) => {
  AlgorithmTypes2["HS256"] = "HS256";
  AlgorithmTypes2["HS384"] = "HS384";
  AlgorithmTypes2["HS512"] = "HS512";
  AlgorithmTypes2["RS256"] = "RS256";
  AlgorithmTypes2["RS384"] = "RS384";
  AlgorithmTypes2["RS512"] = "RS512";
  AlgorithmTypes2["PS256"] = "PS256";
  AlgorithmTypes2["PS384"] = "PS384";
  AlgorithmTypes2["PS512"] = "PS512";
  AlgorithmTypes2["ES256"] = "ES256";
  AlgorithmTypes2["ES384"] = "ES384";
  AlgorithmTypes2["ES512"] = "ES512";
  AlgorithmTypes2["EdDSA"] = "EdDSA";
  return AlgorithmTypes2;
})(AlgorithmTypes || {});

// node_modules/hono/dist/helper/adapter/index.js
var knownUserAgents = {
  deno: "Deno",
  bun: "Bun",
  workerd: "Cloudflare-Workers",
  node: "Node.js"
};
var getRuntimeKey = () => {
  const global2 = globalThis;
  const userAgentSupported = typeof navigator !== "undefined" && typeof navigator.userAgent === "string";
  if (userAgentSupported) {
    for (const [runtimeKey, userAgent] of Object.entries(knownUserAgents)) {
      if (checkUserAgentEquals(userAgent)) {
        return runtimeKey;
      }
    }
  }
  if (typeof global2?.EdgeRuntime === "string") {
    return "edge-light";
  }
  if (global2?.fastly !== undefined) {
    return "fastly";
  }
  if (global2?.process?.release?.name === "node") {
    return "node";
  }
  return "other";
};
var checkUserAgentEquals = (platform) => {
  const userAgent = navigator.userAgent;
  return userAgent.startsWith(platform);
};

// node_modules/hono/dist/utils/jwt/types.js
var JwtAlgorithmNotImplemented = class extends Error {
  constructor(alg) {
    super(`${alg} is not an implemented algorithm`);
    this.name = "JwtAlgorithmNotImplemented";
  }
};
var JwtTokenInvalid = class extends Error {
  constructor(token) {
    super(`invalid JWT token: ${token}`);
    this.name = "JwtTokenInvalid";
  }
};
var JwtTokenNotBefore = class extends Error {
  constructor(token) {
    super(`token (${token}) is being used before it's valid`);
    this.name = "JwtTokenNotBefore";
  }
};
var JwtTokenExpired = class extends Error {
  constructor(token) {
    super(`token (${token}) expired`);
    this.name = "JwtTokenExpired";
  }
};
var JwtTokenIssuedAt = class extends Error {
  constructor(currentTimestamp, iat) {
    super(`Incorrect "iat" claim must be a older than "${currentTimestamp}" (iat: "${iat}")`);
    this.name = "JwtTokenIssuedAt";
  }
};
var JwtHeaderInvalid = class extends Error {
  constructor(header) {
    super(`jwt header is invalid: ${JSON.stringify(header)}`);
    this.name = "JwtHeaderInvalid";
  }
};
var JwtHeaderRequiresKid = class extends Error {
  constructor(header) {
    super(`required "kid" in jwt header: ${JSON.stringify(header)}`);
    this.name = "JwtHeaderRequiresKid";
  }
};
var JwtTokenSignatureMismatched = class extends Error {
  constructor(token) {
    super(`token(${token}) signature mismatched`);
    this.name = "JwtTokenSignatureMismatched";
  }
};
var CryptoKeyUsage = /* @__PURE__ */ ((CryptoKeyUsage2) => {
  CryptoKeyUsage2["Encrypt"] = "encrypt";
  CryptoKeyUsage2["Decrypt"] = "decrypt";
  CryptoKeyUsage2["Sign"] = "sign";
  CryptoKeyUsage2["Verify"] = "verify";
  CryptoKeyUsage2["DeriveKey"] = "deriveKey";
  CryptoKeyUsage2["DeriveBits"] = "deriveBits";
  CryptoKeyUsage2["WrapKey"] = "wrapKey";
  CryptoKeyUsage2["UnwrapKey"] = "unwrapKey";
  return CryptoKeyUsage2;
})(CryptoKeyUsage || {});

// node_modules/hono/dist/utils/jwt/utf8.js
var utf8Encoder = new TextEncoder;
var utf8Decoder = new TextDecoder;

// node_modules/hono/dist/utils/jwt/jws.js
async function signing(privateKey, alg, data) {
  const algorithm = getKeyAlgorithm(alg);
  const cryptoKey = await importPrivateKey(privateKey, algorithm);
  return await crypto.subtle.sign(algorithm, cryptoKey, data);
}
async function verifying(publicKey, alg, signature, data) {
  const algorithm = getKeyAlgorithm(alg);
  const cryptoKey = await importPublicKey(publicKey, algorithm);
  return await crypto.subtle.verify(algorithm, cryptoKey, signature, data);
}
function pemToBinary(pem) {
  return decodeBase64(pem.replace(/-+(BEGIN|END).*/g, "").replace(/\s/g, ""));
}
async function importPrivateKey(key, alg) {
  if (!crypto.subtle || !crypto.subtle.importKey) {
    throw new Error("`crypto.subtle.importKey` is undefined. JWT auth middleware requires it.");
  }
  if (isCryptoKey(key)) {
    if (key.type !== "private" && key.type !== "secret") {
      throw new Error(`unexpected key type: CryptoKey.type is ${key.type}, expected private or secret`);
    }
    return key;
  }
  const usages = [CryptoKeyUsage.Sign];
  if (typeof key === "object") {
    return await crypto.subtle.importKey("jwk", key, alg, false, usages);
  }
  if (key.includes("PRIVATE")) {
    return await crypto.subtle.importKey("pkcs8", pemToBinary(key), alg, false, usages);
  }
  return await crypto.subtle.importKey("raw", utf8Encoder.encode(key), alg, false, usages);
}
async function importPublicKey(key, alg) {
  if (!crypto.subtle || !crypto.subtle.importKey) {
    throw new Error("`crypto.subtle.importKey` is undefined. JWT auth middleware requires it.");
  }
  if (isCryptoKey(key)) {
    if (key.type === "public" || key.type === "secret") {
      return key;
    }
    key = await exportPublicJwkFrom(key);
  }
  if (typeof key === "string" && key.includes("PRIVATE")) {
    const privateKey = await crypto.subtle.importKey("pkcs8", pemToBinary(key), alg, true, [
      CryptoKeyUsage.Sign
    ]);
    key = await exportPublicJwkFrom(privateKey);
  }
  const usages = [CryptoKeyUsage.Verify];
  if (typeof key === "object") {
    return await crypto.subtle.importKey("jwk", key, alg, false, usages);
  }
  if (key.includes("PUBLIC")) {
    return await crypto.subtle.importKey("spki", pemToBinary(key), alg, false, usages);
  }
  return await crypto.subtle.importKey("raw", utf8Encoder.encode(key), alg, false, usages);
}
async function exportPublicJwkFrom(privateKey) {
  if (privateKey.type !== "private") {
    throw new Error(`unexpected key type: ${privateKey.type}`);
  }
  if (!privateKey.extractable) {
    throw new Error("unexpected private key is unextractable");
  }
  const jwk = await crypto.subtle.exportKey("jwk", privateKey);
  const { kty } = jwk;
  const { alg, e, n } = jwk;
  const { crv, x, y } = jwk;
  return { kty, alg, e, n, crv, x, y, key_ops: [CryptoKeyUsage.Verify] };
}
function getKeyAlgorithm(name) {
  switch (name) {
    case "HS256":
      return {
        name: "HMAC",
        hash: {
          name: "SHA-256"
        }
      };
    case "HS384":
      return {
        name: "HMAC",
        hash: {
          name: "SHA-384"
        }
      };
    case "HS512":
      return {
        name: "HMAC",
        hash: {
          name: "SHA-512"
        }
      };
    case "RS256":
      return {
        name: "RSASSA-PKCS1-v1_5",
        hash: {
          name: "SHA-256"
        }
      };
    case "RS384":
      return {
        name: "RSASSA-PKCS1-v1_5",
        hash: {
          name: "SHA-384"
        }
      };
    case "RS512":
      return {
        name: "RSASSA-PKCS1-v1_5",
        hash: {
          name: "SHA-512"
        }
      };
    case "PS256":
      return {
        name: "RSA-PSS",
        hash: {
          name: "SHA-256"
        },
        saltLength: 32
      };
    case "PS384":
      return {
        name: "RSA-PSS",
        hash: {
          name: "SHA-384"
        },
        saltLength: 48
      };
    case "PS512":
      return {
        name: "RSA-PSS",
        hash: {
          name: "SHA-512"
        },
        saltLength: 64
      };
    case "ES256":
      return {
        name: "ECDSA",
        hash: {
          name: "SHA-256"
        },
        namedCurve: "P-256"
      };
    case "ES384":
      return {
        name: "ECDSA",
        hash: {
          name: "SHA-384"
        },
        namedCurve: "P-384"
      };
    case "ES512":
      return {
        name: "ECDSA",
        hash: {
          name: "SHA-512"
        },
        namedCurve: "P-521"
      };
    case "EdDSA":
      return {
        name: "Ed25519",
        namedCurve: "Ed25519"
      };
    default:
      throw new JwtAlgorithmNotImplemented(name);
  }
}
function isCryptoKey(key) {
  const runtime = getRuntimeKey();
  if (runtime === "node" && !!crypto.webcrypto) {
    return key instanceof crypto.webcrypto.CryptoKey;
  }
  return key instanceof CryptoKey;
}

// node_modules/hono/dist/utils/jwt/jwt.js
function isTokenHeader(obj) {
  if (typeof obj === "object" && obj !== null) {
    const objWithAlg = obj;
    return "alg" in objWithAlg && Object.values(AlgorithmTypes).includes(objWithAlg.alg) && (!("typ" in objWithAlg) || objWithAlg.typ === "JWT");
  }
  return false;
}
var encodeJwtPart = (part) => encodeBase64Url(utf8Encoder.encode(JSON.stringify(part))).replace(/=/g, "");
var encodeSignaturePart = (buf) => encodeBase64Url(buf).replace(/=/g, "");
var decodeJwtPart = (part) => JSON.parse(utf8Decoder.decode(decodeBase64Url(part)));
var sign = async (payload, privateKey, alg = "HS256") => {
  const encodedPayload = encodeJwtPart(payload);
  let encodedHeader;
  if (typeof privateKey === "object" && "alg" in privateKey) {
    alg = privateKey.alg;
    encodedHeader = encodeJwtPart({ alg, typ: "JWT", kid: privateKey.kid });
  } else {
    encodedHeader = encodeJwtPart({ alg, typ: "JWT" });
  }
  const partialToken = `${encodedHeader}.${encodedPayload}`;
  const signaturePart = await signing(privateKey, alg, utf8Encoder.encode(partialToken));
  const signature = encodeSignaturePart(signaturePart);
  return `${partialToken}.${signature}`;
};
var verify = async (token, publicKey, alg = "HS256") => {
  const tokenParts = token.split(".");
  if (tokenParts.length !== 3) {
    throw new JwtTokenInvalid(token);
  }
  const { header, payload } = decode(token);
  if (!isTokenHeader(header)) {
    throw new JwtHeaderInvalid(header);
  }
  const now = Date.now() / 1000 | 0;
  if (payload.nbf && payload.nbf > now) {
    throw new JwtTokenNotBefore(token);
  }
  if (payload.exp && payload.exp <= now) {
    throw new JwtTokenExpired(token);
  }
  if (payload.iat && now < payload.iat) {
    throw new JwtTokenIssuedAt(now, payload.iat);
  }
  const headerPayload = token.substring(0, token.lastIndexOf("."));
  const verified = await verifying(publicKey, alg, decodeBase64Url(tokenParts[2]), utf8Encoder.encode(headerPayload));
  if (!verified) {
    throw new JwtTokenSignatureMismatched(token);
  }
  return payload;
};
var verifyFromJwks = async (token, options, init) => {
  const header = decodeHeader(token);
  if (!isTokenHeader(header)) {
    throw new JwtHeaderInvalid(header);
  }
  if (!header.kid) {
    throw new JwtHeaderRequiresKid(header);
  }
  let keys = typeof options.keys === "function" ? await options.keys() : options.keys;
  if (options.jwks_uri) {
    const response = await fetch(options.jwks_uri, init);
    if (!response.ok) {
      throw new Error(`failed to fetch JWKS from ${options.jwks_uri}`);
    }
    const data = await response.json();
    if (!data.keys) {
      throw new Error('invalid JWKS response. "keys" field is missing');
    }
    if (!Array.isArray(data.keys)) {
      throw new Error('invalid JWKS response. "keys" field is not an array');
    }
    if (keys) {
      keys.push(...data.keys);
    } else {
      keys = data.keys;
    }
  } else if (!keys) {
    throw new Error('verifyFromJwks requires options for either "keys" or "jwks_uri" or both');
  }
  const matchingKey = keys.find((key) => key.kid === header.kid);
  if (!matchingKey) {
    throw new JwtTokenInvalid(token);
  }
  return await verify(token, matchingKey, matchingKey.alg);
};
var decode = (token) => {
  try {
    const [h, p] = token.split(".");
    const header = decodeJwtPart(h);
    const payload = decodeJwtPart(p);
    return {
      header,
      payload
    };
  } catch {
    throw new JwtTokenInvalid(token);
  }
};
var decodeHeader = (token) => {
  try {
    const [h] = token.split(".");
    return decodeJwtPart(h);
  } catch {
    throw new JwtTokenInvalid(token);
  }
};

// node_modules/hono/dist/utils/jwt/index.js
var Jwt = { sign, verify, decode, verifyFromJwks };

// node_modules/hono/dist/middleware/jwt/jwt.js
var verify2 = Jwt.verify;
var decode2 = Jwt.decode;
var sign2 = Jwt.sign;

// src/utils/auth.util.ts
var import_dotenv = __toESM(require_main(), 1);
import_dotenv.default.config();
var SECRET_KEY = "GOATENGLISHAPI";
var EXPIRES_IN_SECONDS = 60 * 60 * 24;
var generateToken = async (user) => {
  if (!SECRET_KEY)
    return null;
  return await sign2({ userId: user._id, role: user.role, exp: Math.floor(Date.now() / 1000) + EXPIRES_IN_SECONDS }, SECRET_KEY);
};
var verifyToken = async (token) => {
  try {
    if (!SECRET_KEY)
      return null;
    return await verify2(token, SECRET_KEY);
  } catch (error) {
    return null;
  }
};

// src/services/auth.service.ts
var otpStore = new Map;
var AuthService = {
  register: async (username, email, password, otpCode, topic_id) => {
    const existingUser = await user_model_default.findOne({ username, is_delete: false });
    if (existingUser) {
      throw new HTTPException(409, { message: `Username \u0111\xE3 \u0111\u01B0\u1EE3c s\u1EED d\u1EE5ng!` });
    }
    const isValid = await AuthService.verifyOTP(email, otpCode);
    if (!isValid)
      throw new HTTPException(400, { message: "M\xE3 OTP kh\xF4ng h\u1EE3p l\u1EC7 ho\u1EB7c \u0111\xE3 h\u1EBFt h\u1EA1n!" });
    const hashedPassword = await bcryptjs_default.hash(password, 10);
    const newUser = new user_model_default({
      username,
      email,
      password_hash: hashedPassword,
      topic_id: topic_id || null
    });
    const savedUser = await newUser.save();
    if (topic_id) {
      const firstProgress = await ProgressService.getFirstByTopic(topic_id);
      const lessons = await LessonService.getByProgressId(firstProgress._id);
      if (lessons) {
        const lesson = lessons[0];
        await UserProgressService.processDB({
          user_id: savedUser._id.toString(),
          status: "in_progress",
          score: 0,
          lesson_id: lesson._id.toString(),
          progress_id: firstProgress._id.toString(),
          topic_id,
          _id: undefined,
          detail: []
        });
      }
    }
    return;
  },
  login: async (username, password) => {
    const user = await user_model_default.findOne({ username, is_delete: false });
    if (!user)
      throw new Error("Username ho\u1EB7c m\u1EADt kh\u1EA9u kh\xF4ng \u0111\xFAng!");
    const isMatch = await bcryptjs_default.compare(password, user.password_hash);
    if (!isMatch)
      throw new Error("Username ho\u1EB7c m\u1EADt kh\u1EA9u kh\xF4ng \u0111\xFAng!");
    const token = await generateToken({
      _id: user._id,
      role: user.role
    });
    return { token };
  },
  getOTP: async ({ emailTo }) => {
    const existingUser = await user_model_default.findOne({ email: emailTo, is_delete: false });
    if (existingUser) {
      throw new HTTPException(409, { message: `Email \u0111\xE3 \u0111\u01B0\u1EE3c s\u1EED d\u1EE5ng!` });
    }
    const otpCode = Math.floor(1e5 + Math.random() * 900000).toString();
    const expiresAt = Date.now() + 5 * 60 * 1000;
    otpStore.set(emailTo, { otp: otpCode, expiresAt });
    await AuthService.sendOTPMail({ emailTo, otpCode });
  },
  verifyOTP: async (email, otpCode, otpStoreInput) => {
    console.log(otpStoreInput);
    if (otpStoreInput)
      otpStore = otpStoreInput;
    const otpData = otpStore.get(email);
    if (!otpData)
      return false;
    if (otpData.expiresAt < Date.now()) {
      otpStore.delete(email);
      return false;
    }
    if (otpData.otp !== otpCode)
      return false;
    otpStore.delete(email);
    return true;
  },
  sendOTPMail: async ({ subject, emailTo, otpCode }) => {
    if (false) {
    }
    const transport = import_nodemailer.default.createTransport({
      host: "smtp.gmail.com",
      port: Number("587") || 587,
      secure: false,
      auth: {
        user: "20210864@eaut.edu.vn",
        pass: "mzau bcpn dsrg myco"
      }
    });
    transport.verify((error, success) => {
      if (error) {
        console.error("Mail server connection failed:", error);
      } else {
        console.log("Mail server is ready to send messages");
      }
    });
    var mailOptions = {
      from: "20210864@eaut.edu.vn",
      to: emailTo,
      subject,
      html: `<!DOCTYPE html>
                <html lang="vi">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>M\xE3 OTP c\u1EE7a b\u1EA1n</title>
                    <style>
                        body {
                            font-family: Arial, sans-serif;
                            background-color: #f4f4f4;
                            margin: 0;
                            padding: 0;
                        }
                        .email-container {
                            max-width: 600px;
                            margin: auto;
                            background-color: #ffffff;
                            padding: 20px;
                            border-radius: 5px;
                            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);
                        }
                        .header {
                            background-color: #4CAF50;
                            padding: 15px;
                            text-align: center;
                            color: #ffffff;
                            font-size: 20px;
                            border-radius: 5px 5px 0 0;
                        }
                        .content {
                            padding: 20px;
                            color: #333333;
                            line-height: 1.6;
                            text-align: center;
                        }
                        .otp-code {
                            font-size: 24px;
                            color: #4CAF50;
                            font-weight: bold;
                            margin: 20px 0;
                        }
                        .footer {
                            text-align: center;
                            padding: 10px;
                            font-size: 12px;
                            color: #777777;
                        }
                    </style>
                </head>
                <body>
                    <div class="email-container">
                        <div class="header">
                            X\xE1c minh t\xE0i kho\u1EA3n c\u1EE7a b\u1EA1n
                        </div>
                        <div class="content">
                            <p>Ch\xE0o b\u1EA1n,</p>
                            <p>C\u1EA3m \u01A1n b\u1EA1n \u0111\xE3 s\u1EED d\u1EE5ng d\u1ECBch v\u1EE5 c\u1EE7a ch\xFAng t\xF4i! \u0110\u1EC3 x\xE1c th\u1EF1c t\xE0i kho\u1EA3n, vui l\xF2ng nh\u1EADp m\xE3 OTP d\u01B0\u1EDBi \u0111\xE2y:</p>
                            <div class="otp-code">${otpCode}</div>
                            <p>M\xE3 OTP n\xE0y s\u1EBD h\u1EBFt h\u1EA1n sau 5 ph\xFAt. Vui l\xF2ng kh\xF4ng chia s\u1EBB m\xE3 n\xE0y v\u1EDBi b\u1EA5t k\u1EF3 ai \u0111\u1EC3 b\u1EA3o m\u1EADt t\xE0i kho\u1EA3n c\u1EE7a b\u1EA1n.</p>
                        </div>
                        <div class="footer">
                            <p>Email h\u1ED7 tr\u1EE3: 20210864@eaut.edu.vn</p>
                            <p>\u0110i\u1EC7n tho\u1EA1i: 0342404775</p>
                        </div>
                    </div>
                </body>
            </html>`
    };
    let info = await transport.sendMail(mailOptions);
    if (!info.response)
      throw new HTTPException(401, { message: "G\u1EEDi email th\u1EA5t b\u1EA1i" });
    console.log(`\u2705 Email \u0111\xE3 g\u1EEDi th\xE0nh c\xF4ng: ${info.messageId} - OTP: ${otpCode}`);
  },
  getOTPForgotPassword: async ({ emailTo }) => {
    const existingUser = await user_model_default.findOne({ email: emailTo, is_delete: false });
    if (!existingUser) {
      throw new HTTPException(409, { message: `Email kh\xF4ng t\u1ED3n t\u1EA1i!` });
    }
    const otpCode = Math.floor(1e5 + Math.random() * 900000).toString();
    const expiresAt = Date.now() + 5 * 60 * 1000;
    otpStore.set(emailTo, { otp: otpCode, expiresAt });
    await AuthService.sendOTPMail({ emailTo, otpCode });
  },
  verifyOTPForgotPassword: async (email, otpCode) => {
    const otpData = otpStore.get(email);
    if (!otpData)
      return false;
    if (otpData.expiresAt < Date.now()) {
      otpStore.delete(email);
      return false;
    }
    if (otpData.otp !== otpCode)
      return false;
    otpStore.delete(email);
    return true;
  },
  resetPassword: async (email, password) => {
    const existingUser = await user_model_default.findOne({ email, is_delete: false });
    if (!existingUser) {
      throw new HTTPException(409, { message: `Email kh\xF4ng t\u1ED3n t\u1EA1i!` });
    }
    const hashedPassword = await bcryptjs_default.hash(password, 10);
    await user_model_default.updateOne({ email }, { password_hash: hashedPassword });
    return true;
  }
};

// src/services/user.service.ts
var otpStore2 = new Map;
var UserService = {
  createOrUpdate: async (_id, username, email, role) => {
    let updatedUser;
    if (!_id) {
      updatedUser = await user_model_default.create({
        username,
        email,
        role
      });
    } else {
      updatedUser = await user_model_default.findOneAndUpdate({ _id }, { username, email, role }, { upsert: true, new: true });
    }
    return updatedUser;
  },
  getAll: async () => {
    const users = await user_model_default.find({ is_delete: false }).lean();
    return getInfoData({ fields: ["_id", "username", "email", "topic_id", "role"], data: users });
  },
  getById: async (user_id) => {
    const user = await user_model_default.findById(user_id).lean();
    if (!user)
      throw new HTTPException(404, { message: "User not found" });
    return getInfoData({ fields: ["_id", "username", "email", "topic_id", "role"], data: user });
  },
  getInfo: async (user_id) => {
    const user = await user_model_default.findOne({ _id: user_id, is_delete: false }).lean();
    if (!user)
      throw new HTTPException(404, { message: "User not found" });
    let score = 0;
    let topic = null;
    if (user.topic_id) {
      topic = await TopicService.getById(user.topic_id?.toString());
      const userProgresses = await UserProgressService.getAllByUserAndTopic(user._id?.toString(), user.topic_id?.toString());
      score = import_lodash2.default.sumBy(userProgresses, "score");
    }
    return {
      user: getInfoData({ fields: ["_id", "username", "email", "topic_id", "streak", "streak_max", "streak_start"], data: user }),
      topic,
      score
    };
  },
  changeTopic: async (user_id, topic_id, type) => {
    const user = await user_model_default.findById(user_id);
    if (!user)
      throw new HTTPException(404, { message: "User not found" });
    user.topic_id = new import_mongoose11.Types.ObjectId(topic_id);
    await user.save();
    if (type === "start") {
      const newUserTopic = await UserTopicService.processDB({ user_id, topic_id });
      const newUserProgress = await UserProgressService.processDB({
        user_id,
        status: "in_progress",
        score: 0,
        lesson_id: null,
        progress_id: null,
        topic_id
      });
      return { user: getInfoData({ fields: ["_id", "username", "email", "topic_id"], data: user }), newUserTopic, newUserProgress };
    }
    return getInfoData({ fields: ["_id", "username", "email", "topic_id"], data: user });
  },
  getTopicsLearned: async (user_id) => {
    const topicsLearned = await UserTopicService.getByUser(user_id);
    return topicsLearned;
  },
  getLessonCurrent: async (user_id, topic_id) => {
    const userProgress = await user_progress_model_default.findOne({ user_id, topic_id, status: "in_progress" }).populate("lesson_id").populate("progress_id").lean();
    if (!userProgress) {
      const firstProgress = await ProgressService.getFirstByTopic(topic_id);
      const lesson = await LessonService.getFirstByProgress(firstProgress._id.toString());
      const newUserProgress = await UserProgressService.processDB({
        user_id,
        status: "in_progress",
        score: 0,
        lesson_id: lesson._id.toString(),
        progress_id: firstProgress._id.toString(),
        topic_id
      });
      return newUserProgress;
    }
    return userProgress;
  },
  submitLesson: async ({ user_id, lesson_id, topic_id, progress_id, status = "completed", score = 50, detail }) => {
    const userProgress = await user_progress_model_default.findOne({ user_id, lesson_id, topic_id, progress_id });
    if (!userProgress)
      throw new HTTPException(404, { message: "Kh\xF4ng t\xECm th\u1EA5y b\xE0i h\u1ECDc" });
    const today = new Date;
    today.setHours(0, 0, 0, 0);
    const checkTodayProgress = await user_progress_model_default.findOne({
      user_id,
      status: "completed",
      createdAt: { $gte: today }
    });
    if (!checkTodayProgress) {
      await user_model_default.findByIdAndUpdate(user_id, {
        $inc: { streak: 1 },
        $set: { streak_start: new Date }
      });
      const updatedUser = await user_model_default.findById(user_id);
      if (updatedUser.streak > (updatedUser.streak_max || 0)) {
        updatedUser.streak_max = updatedUser.streak;
        await updatedUser.save();
      }
    }
    const result = await UserProgressService.processDB({
      user_id,
      lesson_id,
      topic_id,
      progress_id,
      status,
      score,
      detail,
      _id: userProgress?._id?.toString()
    });
    if (!result)
      throw new HTTPException(400, { message: "Kh\xF4ng th\u1EC3 c\u1EADp nh\u1EADt b\xE0i h\u1ECDc" });
    const lessonsProgress = await LessonService.getByProgressId(progress_id);
    const lessonIndex = lessonsProgress.findIndex((lesson) => lesson._id.toString() === lesson_id);
    const nextLesson = lessonsProgress[lessonIndex + 1];
    if (nextLesson) {
      await UserProgressService.processDB({
        user_id,
        status: "in_progress",
        score: 0,
        lesson_id: nextLesson._id.toString(),
        progress_id,
        topic_id
      });
    } else {
      const nextProgress = await ProgressService.getNextByTopic(topic_id, progress_id);
      if (nextProgress) {
        const firstLesson = await LessonService.getFirstByProgress(nextProgress._id.toString());
        if (!firstLesson)
          throw new HTTPException(404, { message: "Kh\xF4ng t\xECm th\u1EA5y b\xE0i h\u1ECDc" });
        await UserProgressService.processDB({
          user_id,
          status: "in_progress",
          score: 0,
          lesson_id: firstLesson._id.toString(),
          progress_id: nextProgress._id.toString(),
          topic_id
        });
      }
    }
    return null;
  },
  deleteById: async (user_id) => {
    const user = await user_model_default.findOne({ _id: user_id, is_delete: false });
    if (!user)
      throw new HTTPException(404, { message: "Ng\u01B0\u1EDDi d\xF9ng kh\xF4ng t\u1ED3n t\u1EA1i" });
    user.is_delete = true;
    return await user.save();
  },
  getOldMistake: async (user_id, topic_id) => {
    const userProgresses = await UserProgressService.getAllByUserAndTopic(user_id, topic_id);
    let oldMistakes = [];
    await Promise.all(userProgresses.map(async (progress) => {
      if (progress.detail) {
        await Promise.all(progress.detail.map(async (item) => {
          if (item.correct === false) {
            const exercise = await ExerciseService.getById(item.exercise_id);
            oldMistakes.push({ ...item, exercise });
          }
        }));
      }
    }));
    return oldMistakes;
  },
  updateInfor: async (user_id, username, email, otpCode) => {
    const userEmail = await user_model_default.findOne({ email, is_delete: false });
    if (userEmail && userEmail?._id?.toString() !== user_id) {
      throw new HTTPException(400, { message: "Email \u0111\xE3 t\u1ED3n t\u1EA1i" });
    }
    const userUsername = await user_model_default.findOne({ username, is_delete: false });
    if (userUsername && userUsername?._id?.toString() !== user_id) {
      throw new HTTPException(400, { message: "T\xEAn \u0111\u0103ng nh\u1EADp \u0111\xE3 t\u1ED3n t\u1EA1i" });
    }
    const userUpdate = await user_model_default.findById(user_id);
    if (!userUpdate)
      throw new HTTPException(404, { message: "Ng\u01B0\u1EDDi d\xF9ng kh\xF4ng t\u1ED3n t\u1EA1i" });
    if (otpCode) {
      const isValid = await AuthService.verifyOTP(email, otpCode, otpStore2);
      if (!isValid)
        throw new HTTPException(400, { message: "M\xE3 OTP kh\xF4ng h\u1EE3p l\u1EC7 ho\u1EB7c \u0111\xE3 h\u1EBFt h\u1EA1n!" });
      userUpdate.username = username;
      userUpdate.email = email;
      await userUpdate.save();
      return {
        status: 200,
        message: "C\u1EADp nh\u1EADt th\xF4ng tin th\xE0nh c\xF4ng",
        data: getInfoData({ fields: ["_id", "username", "email"], data: userUpdate })
      };
    }
    otpCode = Math.floor(1e5 + Math.random() * 900000).toString();
    const expiresAt = Date.now() + 5 * 60 * 1000;
    otpStore2.set(email, { otp: otpCode, expiresAt });
    await AuthService.sendOTPMail({ emailTo: email, otpCode });
    return {
      status: 200,
      message: "M\xE3 OTP \u0111\xE3 \u0111\u01B0\u1EE3c g\u1EEDi \u0111\u1EBFn email c\u1EE7a b\u1EA1n. Vui l\xF2ng ki\u1EC3m tra email \u0111\u1EC3 x\xE1c nh\u1EADn thay \u0111\u1ED5i.",
      otpCode: true
    };
  },
  changePassword: async (user_id, oldPassword, newPassword) => {
    const user = await user_model_default.findById(user_id);
    if (!user)
      throw new HTTPException(404, { message: "Ng\u01B0\u1EDDi d\xF9ng kh\xF4ng t\u1ED3n t\u1EA1i" });
    const isMatch = await bcryptjs_default.compare(oldPassword, user.password_hash);
    if (!isMatch)
      throw new HTTPException(400, { message: "M\u1EADt kh\u1EA9u c\u0169 kh\xF4ng \u0111\xFAng" });
    if (oldPassword === newPassword)
      throw new HTTPException(400, { message: "M\u1EADt kh\u1EA9u m\u1EDBi kh\xF4ng \u0111\u01B0\u1EE3c gi\u1ED1ng m\u1EADt kh\u1EA9u c\u0169" });
    const hashedPassword = await bcryptjs_default.hash(newPassword, 10);
    user.password_hash = hashedPassword;
    await user.save();
    return getInfoData({ fields: ["_id", "username", "email"], data: user });
  },
  deleteAccount: async (user_id, password) => {
    const user = await user_model_default.findById(user_id);
    if (!user)
      throw new HTTPException(404, { message: "Ng\u01B0\u1EDDi d\xF9ng kh\xF4ng t\u1ED3n t\u1EA1i" });
    const isMatch = await bcryptjs_default.compare(password, user.password_hash);
    if (!isMatch)
      throw new HTTPException(400, { message: "M\u1EADt kh\u1EA9u kh\xF4ng \u0111\xFAng" });
    user.is_delete = true;
    return await user.save();
  },
  checkStreak: async (user_id) => {
    const user = await user_model_default.findById(user_id).lean();
    if (!user)
      throw new HTTPException(404, { message: "Ng\u01B0\u1EDDi d\xF9ng kh\xF4ng t\u1ED3n t\u1EA1i" });
    if (!user.streak_start) {
      return {
        status: 200,
        message: "Ch\u01B0a c\xF3 streak n\xE0o",
        streak: 0,
        reset_streak: false
      };
    }
    const yesterday = new Date;
    yesterday.setDate(yesterday.getDate() - 1);
    yesterday.setHours(0, 0, 0, 0);
    const today = new Date;
    today.setHours(0, 0, 0, 0);
    const checkTodayProgress = await user_progress_model_default.findOne({
      user_id: user._id,
      status: "completed",
      createdAt: { $gte: today }
    });
    if (checkTodayProgress) {
      return {
        status: 200,
        message: "Ng\u01B0\u1EDDi d\xF9ng \u0111\xE3 h\u1ECDc b\xE0i h\xF4m nay",
        streak: user.streak,
        reset_streak: false
      };
    }
    const checkYesterdayProgress = await user_progress_model_default.findOne({
      user_id: user._id,
      status: "completed",
      createdAt: { $gte: yesterday, $lt: today }
    });
    if (!checkYesterdayProgress) {
      const result = await user_model_default.findByIdAndUpdate(user_id, { $set: { streak: 0 } });
      return {
        status: 200,
        message: "Kh\xF4ng c\xF3 b\xE0i h\u1ECDc n\xE0o v\xE0o ng\xE0y h\xF4m qua, streak \u0111\xE3 \u0111\u01B0\u1EE3c reset v\u1EC1 0",
        streak: 0,
        result,
        reset_streak: true
      };
    }
    return {
      status: 200,
      message: "Ki\u1EC3m tra streak th\xE0nh c\xF4ng",
      streak: user.streak,
      reset_streak: false
    };
  }
};

// src/controllers/user.controller.ts
var UserController = {
  createOrUpdate: async (c) => {
    const { _id, username, email, role } = await c.req.json();
    const result = await UserService.createOrUpdate(_id, username, email, role || "user");
    return c.json({ message: "Th\u1EF1c hi\u1EC7n th\xE0nh c\xF4ng", data: result }, 200);
  },
  getAll: async (c, next) => {
    const users = await UserService.getAll();
    return c.json({ message: "Success", data: users }, 200);
  },
  getById: async (c, next) => {
    const { user_id } = c.req.param();
    const user = c.get("user");
    const foundUser = await UserService.getById(user_id || user.userId);
    return c.json({ message: "Success", data: foundUser }, 200);
  },
  getInfo: async (c, next) => {
    const user = c.get("user");
    const foundUser = await UserService.getInfo(user.userId);
    return c.json({ message: "Success", data: foundUser }, 200);
  },
  changeTopic: async (c, next) => {
    const { topic_id, type } = await c.req.json();
    const user = c.get("user");
    const result = await UserService.changeTopic(user.userId, topic_id, type);
    return c.json({ message: "Success", data: result }, 200);
  },
  getTopicsLearned: async (c, next) => {
    const user = c.get("user");
    const topics = await UserService.getTopicsLearned(user.userId);
    return c.json({ message: "Success", data: topics }, 200);
  },
  getLessonCurrent: async (c, next) => {
    const user = c.get("user");
    const { topic_id } = c.req.param();
    const lesson = await UserService.getLessonCurrent(user.userId, topic_id);
    return c.json({ message: "L\u1EA5y b\xE0i h\u1ECDc hi\u1EC7n t\u1EA1i th\xE0nh c\xF4ng", data: lesson }, 200);
  },
  submitLesson: async (c, next) => {
    const user = c.get("user");
    const { data } = await c.req.json();
    const result = await UserService.submitLesson({
      user_id: user.userId,
      ...data
    });
    return c.json({ message: "Ho\xE0n th\xE0nh b\xE0i h\u1ECDc th\xE0nh c\xF4ng", data: result }, 200);
  },
  deleteById: async (c) => {
    const { user_id } = c.req.param();
    const result = await UserService.deleteById(user_id);
    return c.json({ message: "X\xF3a ng\u01B0\u1EDDi d\xF9ng th\xE0nh c\xF4ng", data: result }, 200);
  },
  getOldMistake: async (c) => {
    const { user_id, topic_id } = c.req.param();
    const result = await UserService.getOldMistake(user_id, topic_id);
    return c.json({ message: "L\u1EA5y l\u1ED7i c\u0169 th\xE0nh c\xF4ng", data: result }, 200);
  },
  updateInfor: async (c) => {
    const { username, email, otpCode } = await c.req.json();
    console.log("update infor", username, email, otpCode);
    const user = c.get("user");
    const result = await UserService.updateInfor(user.userId, username, email, otpCode);
    return c.json(result, 200);
  },
  changePassword: async (c) => {
    const { oldPassword, newPassword } = await c.req.json();
    const user = c.get("user");
    const result = await UserService.changePassword(user.userId, oldPassword, newPassword);
    return c.json({ message: "Thay \u0111\u1ED5i m\u1EADt kh\u1EA9u th\xE0nh c\xF4ng", data: result, status: 200 }, 200);
  },
  deleteAccount: async (c) => {
    const { password } = await c.req.json();
    const user = c.get("user");
    const result = await UserService.deleteAccount(user.userId, password);
    return c.json({ message: "X\xF3a t\xE0i kho\u1EA3n th\xE0nh c\xF4ng", data: result, status: 200 }, 200);
  },
  checkStreak: async (c) => {
    const user = c.get("user");
    const result = await UserService.checkStreak(user.userId);
    return c.json({ ...result }, 200);
  }
};

// src/utils/async_handler.util.ts
var asyncHandler = (fn) => {
  return async (c, next) => {
    try {
      return await fn(c, next);
    } catch (error) {
      console.error(error);
      let statusCode = 500;
      let errorMessage = "L\u1ED7i h\u1EC7 th\u1ED1ng!";
      if (error instanceof HTTPException) {
        statusCode = error.status;
        errorMessage = error.message;
      } else if (error instanceof Error) {
        errorMessage = error.message;
      }
      return c.json({ status: statusCode, message: errorMessage });
    }
  };
};

// src/middlewares/auth.middleware.ts
var authenticate = async (c, next) => {
  const token = c.req.header("Authorization")?.split(" ")[1];
  if (!token)
    return c.json({ message: "B\u1EA1n ch\u01B0a \u0111\u0103ng nh\u1EADp!" }, 401);
  const decoded = await verifyToken(token);
  if (!decoded)
    return c.json({ message: "Token kh\xF4ng h\u1EE3p l\u1EC7!" }, 401);
  const user = await user_model_default.findOne({ _id: decoded.userId, is_delete: false });
  if (!user)
    return c.json({ message: "Ng\u01B0\u1EDDi d\xF9ng kh\xF4ng t\u1ED3n t\u1EA1i!" }, 401);
  c.set("user", decoded);
  await next();
};
var authorizeAdmin = async (c, next) => {
  const user = c.get("user");
  if (user.role !== "admin") {
    return c.json({ message: "B\u1EA1n kh\xF4ng c\xF3 quy\u1EC1n truy c\u1EADp!" }, 403);
  }
  await next();
};

// node_modules/zod/lib/index.mjs
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === errorMap ? undefined : errorMap
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap, invalid_type_error, required_error, description } = params;
  if (errorMap && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap)
    return { errorMap, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== undefined ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== undefined ? message : required_error) !== null && _a !== undefined ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== undefined ? message : invalid_type_error) !== null && _b !== undefined ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}\$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}\$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt2, alg) {
  if (!jwtRegex.test(jwt2))
    return false;
  try {
    const [header] = jwt2.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a2, _b2;
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== undefined ? _a2 : fatal) !== null && _b2 !== undefined ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== undefined ? _a : fatal) !== null && _b !== undefined ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_3, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== undefined) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === undefined ? undefined : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache;
var _ZodNativeEnum_cache;

class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};

class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === undefined ? undefined : params.async) !== null && _a !== undefined ? _a : false,
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === undefined ? undefined : err.message) === null || _a === undefined ? undefined : _a.toLowerCase()) === null || _b === undefined ? undefined : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap,
        async: true
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+\$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}\$`);

class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
      offset: (_a = options === null || options === undefined ? undefined : options.offset) !== null && _a !== undefined ? _a : false,
      local: (_b = options === null || options === undefined ? undefined : options.local) !== null && _b !== undefined ? _b : false,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === undefined ? undefined : options.position,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};

class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};

class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === undefined ? undefined : _b.call(_a, issue, ctx).message) !== null && _c !== undefined ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== undefined ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [undefined, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};

class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = new Map;
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}

class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};

class ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, undefined);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
_ZodEnum_cache = new WeakMap;
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, undefined);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
_ZodNativeEnum_cache = new WeakMap;
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};

class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}

class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  enum: enumType,
  function: functionType,
  instanceof: instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  null: nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  undefined: undefinedType,
  union: unionType,
  unknown: unknownType,
  void: voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// src/validators/auth.validator.ts
var registerSchema = z.object({
  username: z.string().min(3, "T\xEAn ng\u01B0\u1EDDi d\xF9ng ph\u1EA3i c\xF3 \xEDt nh\u1EA5t 3 k\xFD t\u1EF1"),
  email: z.string().email("Email kh\xF4ng h\u1EE3p l\u1EC7"),
  password: z.string().min(6, "M\u1EADt kh\u1EA9u ph\u1EA3i c\xF3 \xEDt nh\u1EA5t 6 k\xFD t\u1EF1"),
  confirm_password: z.string().min(6, "X\xE1c nh\u1EADn m\u1EADt kh\u1EA9u ph\u1EA3i c\xF3 \xEDt nh\u1EA5t 6 k\xFD t\u1EF1"),
  otp_code: z.string().length(6, "M\xE3 OTP ph\u1EA3i c\xF3 \u0111\xFAng 6 ch\u1EEF s\u1ED1"),
  topic_id: z.string().optional()
}).refine((data) => data.password === data.confirm_password, {
  message: "M\u1EADt kh\u1EA9u x\xE1c nh\u1EADn kh\xF4ng kh\u1EDBp",
  path: ["confirm_password"]
});
var loginSchema = z.object({
  username: z.string().min(2, "Username kh\xF4ng \u0111\u01B0\u1EE3c tr\u1ED1ng!"),
  password: z.string().min(2, "Password kh\xF4ng \u0111\u01B0\u1EE3c tr\u1ED1ng!")
});
var emailSchema = z.object({
  email: z.string().email("Email kh\xF4ng h\u1EE3p l\u1EC7")
});

// src/middlewares/validate.middleware.ts
var validate = (schema) => {
  return async (c, next) => {
    try {
      const body = await c.req.json();
      schema.parse(body);
      await next();
    } catch (error) {
      if (error instanceof ZodError) {
        return c.json({
          message: "D\u1EEF li\u1EC7u kh\xF4ng h\u1EE3p l\u1EC7!",
          errors: error.errors.map((err) => ({
            field: err.path.join("."),
            message: err.message
          }))
        }, 400);
      }
      return c.json({ message: "L\u1ED7i h\u1EC7 th\u1ED1ng!" }, 500);
    }
  };
};

// src/routes/user.route.ts
var app = new Hono2;
app.post("/", authenticate, authorizeAdmin, validate(emailSchema), asyncHandler(UserController.createOrUpdate));
app.get("/", authenticate, authorizeAdmin, asyncHandler(UserController.getAll));
app.get("/get-info", authenticate, asyncHandler(UserController.getInfo));
app.post("/change-topic", authenticate, asyncHandler(UserController.changeTopic));
app.get("/get-topics-learned", authenticate, asyncHandler(UserController.getTopicsLearned));
app.get("/get-lesson-current/:topic_id", authenticate, asyncHandler(UserController.getLessonCurrent));
app.post("/submit-lesson", authenticate, asyncHandler(UserController.submitLesson));
app.get("/:user_id", authenticate, authorizeAdmin, asyncHandler(UserController.getById));
app.delete("/:user_id", authenticate, authorizeAdmin, asyncHandler(UserController.deleteById));
app.get("/get-old-mistake/:user_id/:topic_id", authenticate, asyncHandler(UserController.getOldMistake));
app.post("/update-infor", authenticate, asyncHandler(UserController.updateInfor));
app.post("/change-password", authenticate, asyncHandler(UserController.changePassword));
app.post("/delete-account", authenticate, asyncHandler(UserController.deleteAccount));
app.post("/check-streak", authenticate, asyncHandler(UserController.checkStreak));
var user_route_default = app;

// src/controllers/auth.controller.ts
var AuthController = {
  register: async (c) => {
    const { username, email, password, otp_code, topic } = await c.req.json();
    const newUser = await AuthService.register(username, email, password, otp_code, topic);
    return c.json({ status: 201, message: "\u0110\u0103ng k\xFD th\xE0nh c\xF4ng!", data: newUser }, 201);
  },
  login: async (c) => {
    const { username, password } = await c.req.json();
    const data = await AuthService.login(username, password);
    return c.json({ status: 200, message: `\u0110\u0103ng nh\u1EADp th\xE0nh c\xF4ng!`, data }, 200);
  },
  sendOTP: async (c) => {
    const { email } = await c.req.json();
    await AuthService.getOTP({
      emailTo: email
    });
    return c.json({ status: 200, message: "M\xE3 OTP \u0111\xE3 \u0111\u01B0\u1EE3c g\u1EEDi!" }, 200);
  },
  sendOTPForgotPassword: async (c) => {
    const { email } = await c.req.json();
    await AuthService.getOTPForgotPassword({
      emailTo: email
    });
    return c.json({ status: 200, message: "M\xE3 OTP \u0111\xE3 \u0111\u01B0\u1EE3c g\u1EEDi!" }, 200);
  },
  verifyOTPForgotPassword: async (c) => {
    const { email, otp } = await c.req.json();
    const isValid2 = await AuthService.verifyOTPForgotPassword(email, otp);
    if (!isValid2)
      return c.json({ status: 400, message: "M\xE3 OTP kh\xF4ng h\u1EE3p l\u1EC7 ho\u1EB7c \u0111\xE3 h\u1EBFt h\u1EA1n!" }, 400);
    return c.json({ status: 200, message: "M\xE3 OTP h\u1EE3p l\u1EC7!" }, 200);
  },
  resetPassword: async (c) => {
    const { email, password } = await c.req.json();
    const isReset = await AuthService.resetPassword(email, password);
    if (!isReset)
      return c.json({ status: 400, message: "M\u1EADt kh\u1EA9u kh\xF4ng h\u1EE3p l\u1EC7!" }, 400);
    return c.json({ status: 200, message: "\u0110\u1EB7t l\u1EA1i m\u1EADt kh\u1EA9u th\xE0nh c\xF4ng!" }, 200);
  }
};

// src/routes/auth.route.ts
var app2 = new Hono2;
app2.post("/register", validate(registerSchema), asyncHandler(AuthController.register));
app2.post("/login", validate(loginSchema), asyncHandler(AuthController.login));
app2.post("/send-otp", validate(emailSchema), asyncHandler(AuthController.sendOTP));
app2.post("/send-otp-forgot-password", validate(emailSchema), asyncHandler(AuthController.sendOTPForgotPassword));
app2.post("/verify-otp-forgot-password", validate(emailSchema), asyncHandler(AuthController.verifyOTPForgotPassword));
app2.post("/reset-password", validate(emailSchema), asyncHandler(AuthController.resetPassword));
var auth_route_default = app2;

// src/controllers/topic.controller.ts
var TopicController = {
  createOrUpdate: async (c) => {
    const { _id, name, description, image } = await c.req.json();
    const result = await TopicService.createOrUpdate(_id, name, description, image);
    return c.json({ message: "Th\u1EF1c hi\u1EC7n th\xE0nh c\xF4ng", data: result }, 200);
  },
  getAll: async (c) => {
    const topics = await TopicService.getAll();
    return c.json({ message: "Success", data: topics }, 200);
  },
  getById: async (c) => {
    const { topic_id } = c.req.param();
    const topic = await TopicService.getById(topic_id);
    return c.json({ message: "Success", data: topic }, 200);
  },
  deleteById: async (c) => {
    const { topic_id } = c.req.param();
    const result = await TopicService.deleteById(topic_id);
    return c.json({ message: "X\xF3a ch\u1EE7 \u0111\u1EC1 th\xE0nh c\xF4ng", data: result }, 200);
  }
};

// src/routes/topic.route.ts
var app3 = new Hono2;
app3.post("/", authenticate, authorizeAdmin, asyncHandler(TopicController.createOrUpdate));
app3.get("/", asyncHandler(TopicController.getAll));
app3.get("/:topic_id", authenticate, authorizeAdmin, asyncHandler(TopicController.getById));
app3.delete("/:topic_id", authenticate, authorizeAdmin, asyncHandler(TopicController.deleteById));
var topic_route_default = app3;

// src/controllers/progress.controller.ts
var ProgressController = {
  createOrUpdate: async (c, next) => {
    const { _id, name, description, icon, order, topic_id } = await c.req.json();
    const result = await ProgressService.createOrUpdate(_id, name, description, topic_id, icon, order);
    return c.json({ message: "Th\u1EF1c hi\u1EC7n th\xE0nh c\xF4ng", data: result }, 200);
  },
  getAllByTopic: async (c, next) => {
    const { topic_id } = c.req.param();
    const progresses = await ProgressService.getAllByTopic(topic_id);
    return c.json({ message: "L\u1EA5y danh s\xE1ch progress th\xE0nh c\xF4ng", data: progresses }, 200);
  },
  getAll: async (c, next) => {
    const page = Number(c.req.query("page")) || 1;
    const limit = Number(c.req.query("limit")) || 10;
    const search = c.req.query("search") || "";
    const progresses = await ProgressService.getAll(page, limit, search);
    return c.json({ message: "L\u1EA5y danh s\xE1ch progress th\xE0nh c\xF4ng", data: progresses }, 200);
  },
  deleteById: async (c, next) => {
    const { progress_id } = c.req.param();
    const result = await ProgressService.deleteById(progress_id);
    return c.json({ message: "X\xF3a l\u1ED9 tr\xECnh th\xE0nh c\xF4ng", data: result }, 200);
  },
  getById: async (c, next) => {
    const { progress_id } = c.req.param();
    const result = await ProgressService.getById(progress_id);
    return c.json({ message: "Success", data: result }, 200);
  }
};

// src/routes/progress.route.ts
var app4 = new Hono2;
app4.get("/", asyncHandler(ProgressController.getAll));
app4.post("/", authenticate, authorizeAdmin, asyncHandler(ProgressController.createOrUpdate));
app4.get("/:progress_id", asyncHandler(ProgressController.getById));
app4.get("/topic/:topic_id", asyncHandler(ProgressController.getAllByTopic));
app4.delete("/:progress_id", authenticate, authorizeAdmin, asyncHandler(ProgressController.deleteById));
var progress_route_default = app4;

// src/controllers/lesson.controller.ts
var LessonController = {
  createOrUpdate: async (c, next) => {
    const { _id, title, description, order, exercises, vocabularies, progress_id, status } = await c.req.json();
    const result = await LessonService.createOrUpdate(_id, title, description, order, exercises, vocabularies, progress_id, status);
    return c.json({ message: "Th\u1EF1c hi\u1EC7n th\xE0nh c\xF4ng", data: result }, 200);
  },
  getDetail: async (c, next) => {
    const { lesson_id } = c.req.param();
    const result = await LessonService.getDetail(lesson_id);
    return c.json({ message: "L\u1EA5y chi ti\u1EBFt b\xE0i h\u1ECDc th\xE0nh c\xF4ng", data: result }, 200);
  },
  getAll: async (c, next) => {
    const page = Number(c.req.query("page")) || 1;
    const limit = Number(c.req.query("limit")) || 10;
    const search = c.req.query("search") || "";
    const lessons = await LessonService.getAll(page, limit, search);
    return c.json({ message: "L\u1EA5y danh s\xE1ch progress th\xE0nh c\xF4ng", data: lessons }, 200);
  },
  deleteLesson: async (c, next) => {
    const { lesson_id } = c.req.param();
    const result = await LessonService.deleteLesson(lesson_id);
    return c.json({ message: "X\xF3a b\xE0i h\u1ECDc th\xE0nh c\xF4ng", data: result }, 200);
  }
};

// src/routes/lesson.route.ts
var app5 = new Hono2;
app5.get("/ping", (c) => c.text("PING LESSON API"));
app5.get("/", asyncHandler(LessonController.getAll));
app5.post("/", authenticate, authorizeAdmin, asyncHandler(LessonController.createOrUpdate));
app5.get("/:lesson_id", asyncHandler(LessonController.getDetail));
app5.delete("/:lesson_id", authenticate, authorizeAdmin, asyncHandler(LessonController.deleteLesson));
var OPENROUTER_API_KEY = "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";
app5.post("/generate", async (c) => {
  try {
    const { prompt } = await c.req.json();
    if (!prompt) {
      return c.json({ error: "Missing prompt" }, 400);
    }
    const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${OPENROUTER_API_KEY}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: "mistralai/mistral-7b-instruct",
        messages: [{ role: "user", content: prompt }],
        max_tokens: 100
      })
    });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`OpenRouter API error: ${errorText}`);
    }
    const data = await response.json();
    return c.json(data);
  } catch (error) {
    console.error("L\u1ED7i khi g\u1ECDi OpenRouter:", error);
    return c.json({ error: "L\u1ED7i khi g\u1ECDi OpenRouter API" }, 500);
  }
});
var lesson_route_default = app5;

// src/models/exercise_level.model.ts
var import_mongoose12 = __toESM(require_mongoose2(), 1);
var DOCUMENT_NAME9 = "exercise_level";
var COLLECTION_NAME9 = "exercise_levels";
var exerciseLevelSchema = new import_mongoose12.Schema({
  ma_muc: { type: String, require: true },
  ten_muc: { type: String, require: true }
}, {
  collection: COLLECTION_NAME9,
  timestamps: true
});
var ExerciseLevelModel = import_mongoose12.model(DOCUMENT_NAME9, exerciseLevelSchema);
var exercise_level_model_default = ExerciseLevelModel;

// src/services/exercise_level.service.ts
var ExerciseLevelService = {
  create: async (ma_muc, ten_muc) => {
    const newItem = new exercise_level_model_default({
      ma_muc,
      ten_muc
    });
    return await newItem.save();
  },
  getById: async (id) => {
    const data = await exercise_level_model_default.findById(id).lean();
    if (!data)
      throw new HTTPException(404, { message: "Kh\xF4ng t\xECm th\u1EA5y c\u1EA5p \u0111\u1ED9 b\xE0i t\u1EADp" });
    return {
      level_id: data._id,
      level_ma_muc: data.ma_muc,
      level_ten_muc: data.ten_muc
    };
  },
  getAll: async () => {
    const data = await exercise_level_model_default.find().lean();
    return data;
  }
};

// src/controllers/exercise_level.controller.ts
var ExerciseLevelController = {
  create: async (c, next) => {
    const { ma_muc, ten_muc } = await c.req.json();
    const result = await ExerciseLevelService.create(ma_muc, ten_muc);
    return c.json({ message: "T\u1EA1o m\u1EDBi c\u1EA5p \u0111\u1ED9 b\xE0i t\u1EADp th\xE0nh c\xF4ng", data: result }, 201);
  },
  getAll: async (c, next) => {
    const result = await ExerciseLevelService.getAll();
    return c.json({ message: "L\u1EA5y danh s\xE1ch c\u1EA5p \u0111\u1ED9 b\xE0i t\u1EADp th\xE0nh c\xF4ng", data: result }, 200);
  }
};

// src/routes/exercise_level.route.ts
var app6 = new Hono2;
app6.get("/ping", (c) => c.text("PING ExerciseLevel API"));
app6.post("/", authenticate, authorizeAdmin, asyncHandler(ExerciseLevelController.create));
app6.get("/", asyncHandler(ExerciseLevelController.getAll));
var exercise_level_route_default = app6;

// src/models/exercise_type.model.ts
var import_mongoose13 = __toESM(require_mongoose2(), 1);
var DOCUMENT_NAME10 = "exercise_type";
var COLLECTION_NAME10 = "exercise_types";
var exerciseTypeSchema = new import_mongoose13.Schema({
  ma_muc: { type: String, require: true },
  ten_muc: { type: String, require: true }
}, {
  collection: COLLECTION_NAME10,
  timestamps: true
});
var ExerciseTypeModel = import_mongoose13.model(DOCUMENT_NAME10, exerciseTypeSchema);
var exercise_type_model_default = ExerciseTypeModel;

// src/services/exercise_type.service.ts
var ExerciseTypeService = {
  create: async (ma_muc, ten_muc) => {
    const newItem = new exercise_type_model_default({
      ma_muc,
      ten_muc
    });
    return await newItem.save();
  },
  getById: async (id) => {
    const data = await exercise_type_model_default.findById(id).lean();
    if (!data)
      throw new HTTPException(404, { message: "Kh\xF4ng t\xECm th\u1EA5y lo\u1EA1i b\xE0i t\u1EADp" });
    return {
      type_id: data._id,
      type_ma_muc: data.ma_muc,
      type_ten_muc: data.ten_muc
    };
  },
  getAll: async () => {
    const data = await exercise_type_model_default.find().lean();
    return data;
  }
};

// src/controllers/exercise_type.controller.ts
var ExerciseTypeController = {
  create: async (c, next) => {
    const { ma_muc, ten_muc } = await c.req.json();
    const result = await ExerciseTypeService.create(ma_muc, ten_muc);
    return c.json({ message: "T\u1EA1o m\u1EDBi lo\u1EA1i b\xE0i t\u1EADp th\xE0nh c\xF4ng", data: result }, 201);
  },
  getAll: async (c, next) => {
    const result = await ExerciseTypeService.getAll();
    return c.json({ message: "L\u1EA5y danh s\xE1ch lo\u1EA1i b\xE0i t\u1EADp th\xE0nh c\xF4ng", data: result }, 200);
  }
};

// src/routes/exercise_type.route.ts
var app7 = new Hono2;
app7.get("/ping", (c) => c.text("PING ExerciseType API"));
app7.post("/", authenticate, authorizeAdmin, asyncHandler(ExerciseTypeController.create));
app7.get("/", asyncHandler(ExerciseTypeController.getAll));
var exercise_type_route_default = app7;

// src/controllers/exercise.controller.ts
var ExerciseController = {
  create: async (c, next) => {
    const {
      type,
      level,
      question,
      options,
      multiple_correct,
      _id,
      correct_answer,
      audio,
      explain_answer,
      explain_answer_vn
    } = await c.req.json();
    const result = await ExerciseService.createOrUpdate({
      _id,
      type,
      level,
      question,
      options,
      multiple_correct,
      correct_answer,
      audio,
      explain_answer,
      explain_answer_vn
    });
    return c.json({ message: "T\u1EA1o m\u1EDBi b\xE0i t\u1EADp th\xE0nh c\xF4ng", data: result }, 201);
  }
};

// src/routes/exercise.route.ts
async function fetchOpenRouter(prompt, retryCount = 3) {
  try {
    const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${OPENROUTER_API_KEY2}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: "meta-llama/llama-3.1-8b-instruct:free",
        messages: [{ role: "user", content: prompt }],
        response_format: { type: "json_object" }
      })
    });
    if (response.status === 429 && retryCount > 0) {
      console.warn("Rate limit exceeded. Retrying in 2s...");
      await new Promise((res) => setTimeout(res, 2000));
      return fetchOpenRouter(prompt, retryCount - 1);
    }
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`OpenRouter API error: ${errorText}`);
    }
    const data = await response.json();
    if (data && data.choices?.[0]?.finish_reason === "stop") {
      const messageContent = extractJSON(data.choices[0].message.content);
      return { data, messageContent };
    }
  } catch (error) {
    console.error("L\u1ED7i khi g\u1ECDi OpenRouter:", error);
    throw error;
  }
}
function extractJSON(responseText) {
  const match = responseText.match(/\{[\s\S]*\}/);
  if (match) {
    try {
      return JSON.parse(match[0]);
    } catch (error) {
      console.error("L\u1ED7i ph\xE2n t\xEDch JSON:", error);
    }
  }
  return null;
}
var app8 = new Hono2;
var OPENROUTER_API_KEY2 = "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";
app8.get("/ping", (c) => c.text("PING Exercise API"));
app8.post("/", authenticate, authorizeAdmin, asyncHandler(ExerciseController.create));
app8.post("/generate-exercise", async (c) => {
  try {
    const { type, word } = await c.req.json();
    if (!type || !word) {
      return c.json({ error: "Thi\u1EBFu type ho\u1EB7c word" }, 400);
    }
    let prompt = "";
    switch (type) {
      case "fill_blank":
        prompt = `T\u1EA1o b\xE0i t\u1EADp \u0111i\u1EC1n v\xE0o ch\u1ED7 tr\u1ED1ng v\u1EDBi t\u1EEB '${word}', \u0111\u1EC3 h\u1ECDc ti\u1EBFng Anh. Tr\u1EA3 v\u1EC1 JSON h\u1EE3p l\u1EC7, kh\xF4ng k\xE8m b\u1EA5t k\u1EF3 v\u0103n b\u1EA3n n\xE0o kh\xE1c:
                    {
                    "type": "fill_blank",
                    "question": "C\xE2u c\xF3 ch\u1EE9a t\u1EEB c\u1EA7n \u0111i\u1EC1n...",
                    "answer": "T\u1EEB c\u1EA7n \u0111i\u1EC1n"
                    }`;
        break;
      case "mcq":
        prompt = `
                    Create a multiple choice test on English vocabulary in the field of information technology.
                    - Vocabulary: "${word}"
                    - Question: "Choose the correct meaning of the word '${word}'"
                    - The answer is the closest meaning to the vocabulary, not written in sentences or paragraphs. For example: "computer" -> "computer", "value" -> "value".
                    - There are 4 answers in Vietnamese or English, and only 1 answer is correct.
                    - If the vocabulary is in English, the answer will be the Vietnamese meaning and vice versa.
                    - Returns valid JSON, without any other text:
                    {
                    "type": "mcq",
                    "word": "${word}",
                    "question": "Choose the correct meaning of the word '${word}'",
                    "options": ["Incorrect meaning 1", "Incorrect meaning 2", "Incorrect meaning 3", "Correct answer"],
                    "answer": "Correct answer"
                    }
                `;
        break;
      case "sentence_order":
        prompt = `T\u1EA1o b\xE0i t\u1EADp s\u1EAFp x\u1EBFp t\u1EEB th\xE0nh c\xE2u ho\xE0n ch\u1EC9nh c\xF3 ch\u1EE9a t\u1EEB '${word}', \u0111\u1EC3 h\u1ECDc ti\u1EBFng Anh. Tr\u1EA3 v\u1EC1 JSON h\u1EE3p l\u1EC7, kh\xF4ng k\xE8m b\u1EA5t k\u1EF3 v\u0103n b\u1EA3n n\xE0o kh\xE1c:
                    {
                    "type": "sentence_order",
                    "words": ["T\u1EEB 1", "T\u1EEB 2", "T\u1EEB 3", "T\u1EEB 4", "..."],
                    "answer": "C\xE2u ho\xE0n ch\u1EC9nh"
                    }`;
        break;
      case "match_meaning":
        prompt = `T\u1EA1o b\xE0i t\u1EADp gh\xE9p ngh\u0129a, y\xEAu c\u1EA7u ng\u01B0\u1EDDi Vi\u1EC7t n\u1ED1i t\u1EEB '${word}' v\u1EDBi ngh\u0129a \u0111\xFAng. Tr\u1EA3 v\u1EC1 JSON h\u1EE3p l\u1EC7, kh\xF4ng k\xE8m b\u1EA5t k\u1EF3 v\u0103n b\u1EA3n n\xE0o kh\xE1c:
                    {
                    "type": "match_meaning",
                    "word": "${word}",
                    "options": ["Ngh\u0129a sai 1", "Ngh\u0129a sai 2", "Ngh\u0129a sai 3", "Ngh\u0129a \u0111\xFAng"],
                    "answer": "Ngh\u0129a \u0111\xFAng"
                    }`;
        break;
      case "listen_fill":
        prompt = `T\u1EA1o b\xE0i t\u1EADp nghe v\xE0 \u0111i\u1EC1n t\u1EEB v\xE0o ch\u1ED7 tr\u1ED1ng c\xF3 ch\u1EE9a t\u1EEB '${word}', \u0111\u1EC3 h\u1ECDc ti\u1EBFng Anh. Tr\u1EA3 v\u1EC1 JSON h\u1EE3p l\u1EC7, kh\xF4ng k\xE8m b\u1EA5t k\u1EF3 v\u0103n b\u1EA3n n\xE0o kh\xE1c:
                    {
                    "type": "listen_fill",
                    "audio": "URL c\u1EE7a file \xE2m thanh",
                    "question": "C\xE2u c\xF3 t\u1EEB c\u1EA7n \u0111i\u1EC1n v\xE0o ch\u1ED7 tr\u1ED1ng...",
                    "answer": "T\u1EEB c\u1EA7n \u0111i\u1EC1n"
                    }`;
        break;
      default:
        return c.json({ error: "Lo\u1EA1i b\xE0i t\u1EADp kh\xF4ng h\u1EE3p l\u1EC7" }, 400);
    }
    const result = await fetchOpenRouter(prompt);
    return c.json(result);
  } catch (error) {
    return c.json({ error: "L\u1ED7i khi t\u1EA1o b\xE0i t\u1EADp" }, 500);
  }
});
var exercise_route_default = app8;

// src/controllers/vocabulary.controller.ts
var VocabularyController = {
  createOrUpdate: async (c, next) => {
    const { _id, word, meaning, phonetic, type, topic_id, examples, audio, vietnamese } = await c.req.json();
    const result = await VoCabularyService.createOrUpdate(_id, word, meaning, phonetic, type, topic_id, examples, audio, vietnamese);
    return c.json({ message: "Th\u1EF1c hi\u1EC7n th\xE0nh c\xF4ng", data: result }, 200);
  },
  getAll: async (c, next) => {
    const page = Number(c.req.query("page")) || 1;
    const limit = Number(c.req.query("limit")) || 10;
    const search = c.req.query("search") || "";
    const result = await VoCabularyService.getAll(page, limit, search);
    return c.json({ message: "L\u1EA5y danh s\xE1ch t\u1EEB v\u1EF1ng th\xE0nh c\xF4ng", data: result }, 200);
  },
  getById: async (c, next) => {
    const { vocabulary_id } = c.req.param();
    const result = await VoCabularyService.getById(vocabulary_id);
    return c.json({ message: "L\u1EA5y th\xF4ng tin t\u1EEB v\u1EF1ng th\xE0nh c\xF4ng", data: result }, 200);
  },
  deleteById: async (c, next) => {
    const { vocabulary_id } = c.req.param();
    const result = await VoCabularyService.deleteById(vocabulary_id);
    return c.json({ message: "X\xF3a t\u1EEB v\u1EF1ng th\xE0nh c\xF4ng", data: result }, 200);
  },
  getAllByTopic: async (c, next) => {
    const { topic_id } = c.req.param();
    const { page, limit, search, sort } = c.req.query();
    const result = await VoCabularyService.getAllByTopic(topic_id, Number(page) || 1, Number(limit) || 10, search, sort);
    return c.json({ message: "L\u1EA5y danh s\xE1ch t\u1EEB v\u1EF1ng theo ch\u1EE7 \u0111\u1EC1 th\xE0nh c\xF4ng", data: result }, 200);
  }
};

// src/routes/vocabulary.route.ts
var app9 = new Hono2;
app9.post("/", authenticate, authorizeAdmin, asyncHandler(VocabularyController.createOrUpdate));
app9.get("/", authenticate, asyncHandler(VocabularyController.getAll));
app9.get("/:vocabulary_id", authenticate, asyncHandler(VocabularyController.getById));
app9.delete("/:vocabulary_id", authenticate, authorizeAdmin, asyncHandler(VocabularyController.deleteById));
app9.get("/topic/:topic_id", authenticate, asyncHandler(VocabularyController.getAllByTopic));
var vocabulary_route_default = app9;

// src/services/admin.service.ts
var AdminService = {
  getData: async () => {
    const countUser = await user_model_default.countDocuments({ is_delete: false });
    const countLesson = await lesson_model_default.countDocuments({ is_delete: false });
    const countTopic = await topic_model_default.countDocuments({ isDelete: false });
    const countVocabulary = await vocabulary_model_default.countDocuments({ is_delete: false });
    const lessons = await lesson_model_default.find({ is_delete: false }).populate({
      path: "progress_id",
      select: "topic_id",
      populate: {
        path: "topic_id",
        select: "name"
      }
    }).sort({ createdAt: -1 }).limit(10).lean();
    const users = await user_model_default.find({ is_delete: false }).sort({ createdAt: -1 }).limit(10);
    return {
      countUser,
      countLesson,
      countTopic,
      countVocabulary,
      lessons: getInfoData({ data: lessons, fields: ["_id", "title", "status", "progress_id"] }),
      users: getInfoData({ data: users, fields: ["_id", "username", "email", "role"] })
    };
  },
  getReport: async () => {
    const totalUsers = (await user_progress_model_default.distinct("user_id")).length;
    const totalLessons = (await user_progress_model_default.distinct("lesson_id")).length;
    const completedLessons = await user_progress_model_default.countDocuments({ status: "completed" });
    const inProgressLessons = await user_progress_model_default.countDocuments({ status: "in_progress" });
    const completionRate = {
      completed: completedLessons,
      inProgress: inProgressLessons
    };
    const avgScoreData = await user_progress_model_default.aggregate([
      { $group: { _id: null, avgScore: { $avg: "$score" } } }
    ]);
    const avgScore = avgScoreData.length > 0 ? avgScoreData[0].avgScore : 0;
    const topLessons = await user_progress_model_default.aggregate([
      {
        $group: {
          _id: "$lesson_id",
          count: { $sum: 1 }
        }
      },
      { $sort: { count: -1 } },
      { $limit: 10 },
      {
        $lookup: {
          from: "lessons",
          localField: "_id",
          foreignField: "_id",
          as: "lessonInfo"
        }
      },
      {
        $unwind: "$lessonInfo"
      },
      {
        $project: {
          _id: 1,
          count: 1,
          title: "$lessonInfo.title",
          progress_id: "$lessonInfo.progress_id"
        }
      }
    ]);
    return {
      totalUsers,
      totalLessons,
      completionRate,
      avgScore,
      topLessons
    };
  }
};

// src/controllers/admin.controller.ts
var AdminController = {
  getData: async (c, next) => {
    const user = c.get("user");
    const data = await AdminService.getData();
    return c.json({ message: "L\u1EA5y d\u1EEF li\u1EC7u th\xE0nh c\xF4ng", data }, 200);
  },
  getReport: async (c, next) => {
    const user = c.get("user");
    const data = await AdminService.getReport();
    return c.json({ message: "L\u1EA5y d\u1EEF li\u1EC7u th\xE0nh c\xF4ng", data }, 200);
  }
};

// src/routes/admin.route.ts
var app10 = new Hono2;
app10.get("/dashboard", authenticate, authorizeAdmin, asyncHandler(AdminController.getData));
app10.get("/report", authenticate, authorizeAdmin, asyncHandler(AdminController.getReport));
var admin_route_default = app10;

// src/routes/index.ts
var app11 = new Hono2;
app11.route("/auth", auth_route_default);
app11.route("/user", user_route_default);
app11.route("/topic", topic_route_default);
app11.route("/progress", progress_route_default);
app11.route("/lesson", lesson_route_default);
app11.route("/exercise", exercise_route_default);
app11.route("/exercise-level", exercise_level_route_default);
app11.route("/exercise-type", exercise_type_route_default);
app11.route("/vocabulary", vocabulary_route_default);
app11.route("/admin", admin_route_default);
app11.post("/text-to-speech", async (c) => {
  const { text, lang } = await c.req.json();
  if (!text)
    return c.json({ error: "Missing text input" }, 400);
  const googleTTSUrl = `https://translate.google.com/translate_tts?ie=UTF-8&tl=${lang || "en"}&client=tw-ob&q=${encodeURIComponent(text)}`;
  const response = await fetch(googleTTSUrl, {
    headers: {
      "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)"
    }
  });
  if (!response.ok) {
    return c.json({ error: `Google TTS API error: ${response.status}` }, 500);
  }
  const audioBuffer = await response.arrayBuffer();
  return new Response(audioBuffer, {
    headers: { "Content-Type": "audio/mpeg" }
  });
});
var routes_default = app11;

// src/db/mongo.ts
var import_mongoose14 = __toESM(require_mongoose2(), 1);
var import_dotenv2 = __toESM(require_main(), 1);
import_dotenv2.default.config();
var connectString = "mongodb://localhost:27017/goat-english";

class Database {
  static instance = null;
  connection = null;
  constructor() {
    this.connect();
  }
  async connect() {
    if (!connectString)
      throw new HTTPException(500, { message: "Connecting to MongoDB error" });
    console.log(`\uD83D\uDD17 Connecting to: ${connectString}`);
    if (true) {
      import_mongoose14.default.set("debug", true);
      import_mongoose14.default.set("debug", { color: true });
    }
    try {
      const db = await import_mongoose14.default.connect(connectString, {
        maxPoolSize: 50
      });
      this.connection = db.connection;
      console.log(`\u2705 Connected to MongoDB successfully`);
    } catch (err) {
      console.error(`\u274C Error connecting to MongoDB:`, err);
    }
  }
  static getInstance() {
    if (!Database.instance) {
      Database.instance = new Database;
    }
    return Database.instance;
  }
  getConnection() {
    return this.connection;
  }
}
var instanceMongoDb = Database.getInstance();
var mongo_default = instanceMongoDb;

// src/app.ts
var app12 = new Hono2;
app12.get("/", (c) => {
  return c.text("Hello from Hono on Vercel!");
});
app12.use("*", poweredBy());
app12.use("*", logger());
app12.use("*", secureHeaders());
app12.use("*", compress());
app12.use("*", cors());
mongo_default.getConnection();
app12.route("/api", routes_default);
import_cloudinary2.v2.config({
  cloud_name: "dm0czde4x",
  api_key: "549139983968566",
  api_secret: "4WO2sOPEJMrW91K0KVEFJXO2VFE",
  secure: true
});
var app_default = app12;

// src/server.ts
var port = 3000;
console.log(`Server is running on http://localhost:${port}`);
serve({
  fetch: app_default.fetch,
  port
});
